// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: injective/exchange/v1beta1/tx.proto
#ifndef GRPC_injective_2fexchange_2fv1beta1_2ftx_2eproto__INCLUDED
#define GRPC_injective_2fexchange_2fv1beta1_2ftx_2eproto__INCLUDED

#include "injective/exchange/v1beta1/tx.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace injective {
namespace exchange {
namespace v1beta1 {

// Msg defines the exchange Msg service.
class Msg final {
 public:
  static constexpr char const* service_full_name() {
    return "injective.exchange.v1beta1.Msg";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Deposit defines a method for transferring coins from the sender's bank
    // balance into the subaccount's exchange deposits
    virtual ::grpc::Status Deposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::injective::exchange::v1beta1::MsgDepositResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgDepositResponse>> AsyncDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgDepositResponse>>(AsyncDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgDepositResponse>> PrepareAsyncDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgDepositResponse>>(PrepareAsyncDepositRaw(context, request, cq));
    }
    // Withdraw defines a method for withdrawing coins from a subaccount's
    // deposits to the user's bank balance
    virtual ::grpc::Status Withdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::injective::exchange::v1beta1::MsgWithdrawResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgWithdrawResponse>> AsyncWithdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgWithdrawResponse>>(AsyncWithdrawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgWithdrawResponse>> PrepareAsyncWithdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgWithdrawResponse>>(PrepareAsyncWithdrawRaw(context, request, cq));
    }
    // InstantSpotMarketLaunch defines method for creating a spot market by paying
    // listing fee without governance
    virtual ::grpc::Status InstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>> AsyncInstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>>(AsyncInstantSpotMarketLaunchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>> PrepareAsyncInstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>>(PrepareAsyncInstantSpotMarketLaunchRaw(context, request, cq));
    }
    // InstantPerpetualMarketLaunch defines a method for creating a new perpetual
    // futures market by paying listing fee without governance
    virtual ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>> AsyncInstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>>(AsyncInstantPerpetualMarketLaunchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>> PrepareAsyncInstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>>(PrepareAsyncInstantPerpetualMarketLaunchRaw(context, request, cq));
    }
    // InstantExpiryFuturesMarketLaunch defines a method for creating a new expiry
    // futures market by paying listing fee without governance
    virtual ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>> AsyncInstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>>(AsyncInstantExpiryFuturesMarketLaunchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>> PrepareAsyncInstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>>(PrepareAsyncInstantExpiryFuturesMarketLaunchRaw(context, request, cq));
    }
    // CreateSpotLimitOrder defines a method for creating a new spot limit order.
    virtual ::grpc::Status CreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>> AsyncCreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>>(AsyncCreateSpotLimitOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>> PrepareAsyncCreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>>(PrepareAsyncCreateSpotLimitOrderRaw(context, request, cq));
    }
    // BatchCreateSpotLimitOrder defines a method for creating a new batch of spot
    // limit orders.
    virtual ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>> AsyncBatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>>(AsyncBatchCreateSpotLimitOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>> PrepareAsyncBatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>>(PrepareAsyncBatchCreateSpotLimitOrdersRaw(context, request, cq));
    }
    // CreateSpotMarketOrder defines a method for creating a new spot market
    // order.
    virtual ::grpc::Status CreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>> AsyncCreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>>(AsyncCreateSpotMarketOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>> PrepareAsyncCreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>>(PrepareAsyncCreateSpotMarketOrderRaw(context, request, cq));
    }
    // MsgCancelSpotOrder defines a method for cancelling a spot order.
    virtual ::grpc::Status CancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>> AsyncCancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>>(AsyncCancelSpotOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>> PrepareAsyncCancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>>(PrepareAsyncCancelSpotOrderRaw(context, request, cq));
    }
    // BatchCancelSpotOrders defines a method for cancelling a batch of spot
    // orders in a given market.
    virtual ::grpc::Status BatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>> AsyncBatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>>(AsyncBatchCancelSpotOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>> PrepareAsyncBatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>>(PrepareAsyncBatchCancelSpotOrdersRaw(context, request, cq));
    }
    // BatchUpdateOrders defines a method for updating a batch of orders.
    virtual ::grpc::Status BatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>> AsyncBatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>>(AsyncBatchUpdateOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>> PrepareAsyncBatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>>(PrepareAsyncBatchUpdateOrdersRaw(context, request, cq));
    }
    // PrivilegedExecuteContract defines a method for executing a Cosmwasm
    // contract from the exchange module with privileged capabilities.
    virtual ::grpc::Status PrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>> AsyncPrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>>(AsyncPrivilegedExecuteContractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>> PrepareAsyncPrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>>(PrepareAsyncPrivilegedExecuteContractRaw(context, request, cq));
    }
    // CreateDerivativeLimitOrder defines a method for creating a new derivative
    // limit order.
    virtual ::grpc::Status CreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>> AsyncCreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>>(AsyncCreateDerivativeLimitOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>> PrepareAsyncCreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>>(PrepareAsyncCreateDerivativeLimitOrderRaw(context, request, cq));
    }
    // BatchCreateDerivativeLimitOrders defines a method for creating a new batch
    // of derivative limit orders.
    virtual ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>> AsyncBatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>>(AsyncBatchCreateDerivativeLimitOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>> PrepareAsyncBatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>>(PrepareAsyncBatchCreateDerivativeLimitOrdersRaw(context, request, cq));
    }
    // MsgCreateDerivativeLimitOrder defines a method for creating a new
    // derivative market order.
    virtual ::grpc::Status CreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>> AsyncCreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>>(AsyncCreateDerivativeMarketOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>> PrepareAsyncCreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>>(PrepareAsyncCreateDerivativeMarketOrderRaw(context, request, cq));
    }
    // MsgCancelDerivativeOrder defines a method for cancelling a derivative
    // order.
    virtual ::grpc::Status CancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>> AsyncCancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>>(AsyncCancelDerivativeOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>> PrepareAsyncCancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>>(PrepareAsyncCancelDerivativeOrderRaw(context, request, cq));
    }
    // MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of
    // derivative limit orders.
    virtual ::grpc::Status BatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>> AsyncBatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>>(AsyncBatchCancelDerivativeOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>> PrepareAsyncBatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>>(PrepareAsyncBatchCancelDerivativeOrdersRaw(context, request, cq));
    }
    // InstantBinaryOptionsMarketLaunch defines method for creating a binary
    // options market by paying listing fee without governance
    virtual ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>> AsyncInstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>>(AsyncInstantBinaryOptionsMarketLaunchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>> PrepareAsyncInstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>>(PrepareAsyncInstantBinaryOptionsMarketLaunchRaw(context, request, cq));
    }
    // CreateBinaryOptionsLimitOrder defines a method for creating a new binary
    // options limit order.
    virtual ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>> AsyncCreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>>(AsyncCreateBinaryOptionsLimitOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>> PrepareAsyncCreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>>(PrepareAsyncCreateBinaryOptionsLimitOrderRaw(context, request, cq));
    }
    // CreateBinaryOptionsMarketOrder defines a method for creating a new binary
    // options market order.
    virtual ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>> AsyncCreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>>(AsyncCreateBinaryOptionsMarketOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>> PrepareAsyncCreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>>(PrepareAsyncCreateBinaryOptionsMarketOrderRaw(context, request, cq));
    }
    // MsgCancelBinaryOptionsOrder defines a method for cancelling a binary
    // options order.
    virtual ::grpc::Status CancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>> AsyncCancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>>(AsyncCancelBinaryOptionsOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>> PrepareAsyncCancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>>(PrepareAsyncCancelBinaryOptionsOrderRaw(context, request, cq));
    }
    // BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of
    // binary options limit orders.
    virtual ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>> AsyncBatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>>(AsyncBatchCancelBinaryOptionsOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>> PrepareAsyncBatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>>(PrepareAsyncBatchCancelBinaryOptionsOrdersRaw(context, request, cq));
    }
    // SubaccountTransfer defines a method for transfer between subaccounts
    virtual ::grpc::Status SubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>> AsyncSubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>>(AsyncSubaccountTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>> PrepareAsyncSubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>>(PrepareAsyncSubaccountTransferRaw(context, request, cq));
    }
    // ExternalTransfer defines a method for transfer between external accounts
    virtual ::grpc::Status ExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::injective::exchange::v1beta1::MsgExternalTransferResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgExternalTransferResponse>> AsyncExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgExternalTransferResponse>>(AsyncExternalTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgExternalTransferResponse>> PrepareAsyncExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgExternalTransferResponse>>(PrepareAsyncExternalTransferRaw(context, request, cq));
    }
    // LiquidatePosition defines a method for liquidating a position
    virtual ::grpc::Status LiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>> AsyncLiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>>(AsyncLiquidatePositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>> PrepareAsyncLiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>>(PrepareAsyncLiquidatePositionRaw(context, request, cq));
    }
    // IncreasePositionMargin defines a method for increasing margin of a position
    virtual ::grpc::Status IncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>> AsyncIncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>>(AsyncIncreasePositionMarginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>> PrepareAsyncIncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>>(PrepareAsyncIncreasePositionMarginRaw(context, request, cq));
    }
    // RewardsOptOut defines a method for opting out of rewards
    virtual ::grpc::Status RewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>> AsyncRewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>>(AsyncRewardsOptOutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>> PrepareAsyncRewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>>(PrepareAsyncRewardsOptOutRaw(context, request, cq));
    }
    // AdminUpdateBinaryOptionsMarket defines method for updating a binary options
    // market by admin
    virtual ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>> AsyncAdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>>(AsyncAdminUpdateBinaryOptionsMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>> PrepareAsyncAdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>>(PrepareAsyncAdminUpdateBinaryOptionsMarketRaw(context, request, cq));
    }
    //
    virtual ::grpc::Status ReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>> AsyncReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>>(AsyncReclaimLockedFundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>> PrepareAsyncReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>>(PrepareAsyncReclaimLockedFundsRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>> AsyncUpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>>(AsyncUpdateParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>> PrepareAsyncUpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>>(PrepareAsyncUpdateParamsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Deposit defines a method for transferring coins from the sender's bank
      // balance into the subaccount's exchange deposits
      virtual void Deposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit* request, ::injective::exchange::v1beta1::MsgDepositResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Deposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit* request, ::injective::exchange::v1beta1::MsgDepositResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Withdraw defines a method for withdrawing coins from a subaccount's
      // deposits to the user's bank balance
      virtual void Withdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw* request, ::injective::exchange::v1beta1::MsgWithdrawResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Withdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw* request, ::injective::exchange::v1beta1::MsgWithdrawResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // InstantSpotMarketLaunch defines method for creating a spot market by paying
      // listing fee without governance
      virtual void InstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // InstantPerpetualMarketLaunch defines a method for creating a new perpetual
      // futures market by paying listing fee without governance
      virtual void InstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // InstantExpiryFuturesMarketLaunch defines a method for creating a new expiry
      // futures market by paying listing fee without governance
      virtual void InstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // CreateSpotLimitOrder defines a method for creating a new spot limit order.
      virtual void CreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // BatchCreateSpotLimitOrder defines a method for creating a new batch of spot
      // limit orders.
      virtual void BatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // CreateSpotMarketOrder defines a method for creating a new spot market
      // order.
      virtual void CreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // MsgCancelSpotOrder defines a method for cancelling a spot order.
      virtual void CancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* request, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* request, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // BatchCancelSpotOrders defines a method for cancelling a batch of spot
      // orders in a given market.
      virtual void BatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // BatchUpdateOrders defines a method for updating a batch of orders.
      virtual void BatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* request, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* request, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // PrivilegedExecuteContract defines a method for executing a Cosmwasm
      // contract from the exchange module with privileged capabilities.
      virtual void PrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* request, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* request, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // CreateDerivativeLimitOrder defines a method for creating a new derivative
      // limit order.
      virtual void CreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // BatchCreateDerivativeLimitOrders defines a method for creating a new batch
      // of derivative limit orders.
      virtual void BatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // MsgCreateDerivativeLimitOrder defines a method for creating a new
      // derivative market order.
      virtual void CreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // MsgCancelDerivativeOrder defines a method for cancelling a derivative
      // order.
      virtual void CancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* request, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* request, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of
      // derivative limit orders.
      virtual void BatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // InstantBinaryOptionsMarketLaunch defines method for creating a binary
      // options market by paying listing fee without governance
      virtual void InstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // CreateBinaryOptionsLimitOrder defines a method for creating a new binary
      // options limit order.
      virtual void CreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // CreateBinaryOptionsMarketOrder defines a method for creating a new binary
      // options market order.
      virtual void CreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // MsgCancelBinaryOptionsOrder defines a method for cancelling a binary
      // options order.
      virtual void CancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* request, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* request, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of
      // binary options limit orders.
      virtual void BatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // SubaccountTransfer defines a method for transfer between subaccounts
      virtual void SubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* request, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* request, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ExternalTransfer defines a method for transfer between external accounts
      virtual void ExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer* request, ::injective::exchange::v1beta1::MsgExternalTransferResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer* request, ::injective::exchange::v1beta1::MsgExternalTransferResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // LiquidatePosition defines a method for liquidating a position
      virtual void LiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition* request, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition* request, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // IncreasePositionMargin defines a method for increasing margin of a position
      virtual void IncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* request, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* request, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RewardsOptOut defines a method for opting out of rewards
      virtual void RewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut* request, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut* request, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // AdminUpdateBinaryOptionsMarket defines method for updating a binary options
      // market by admin
      virtual void AdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* request, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* request, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      virtual void ReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* request, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* request, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams* request, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams* request, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgDepositResponse>* AsyncDepositRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgDepositResponse>* PrepareAsyncDepositRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgWithdrawResponse>* AsyncWithdrawRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgWithdrawResponse>* PrepareAsyncWithdrawRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>* AsyncInstantSpotMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>* PrepareAsyncInstantSpotMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>* AsyncInstantPerpetualMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>* PrepareAsyncInstantPerpetualMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>* AsyncInstantExpiryFuturesMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>* PrepareAsyncInstantExpiryFuturesMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>* AsyncCreateSpotLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>* PrepareAsyncCreateSpotLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>* AsyncBatchCreateSpotLimitOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>* PrepareAsyncBatchCreateSpotLimitOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>* AsyncCreateSpotMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>* PrepareAsyncCreateSpotMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>* AsyncCancelSpotOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>* PrepareAsyncCancelSpotOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>* AsyncBatchCancelSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>* PrepareAsyncBatchCancelSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>* AsyncBatchUpdateOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>* PrepareAsyncBatchUpdateOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>* AsyncPrivilegedExecuteContractRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>* PrepareAsyncPrivilegedExecuteContractRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>* AsyncCreateDerivativeLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>* PrepareAsyncCreateDerivativeLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>* AsyncBatchCreateDerivativeLimitOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>* PrepareAsyncBatchCreateDerivativeLimitOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>* AsyncCreateDerivativeMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>* PrepareAsyncCreateDerivativeMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>* AsyncCancelDerivativeOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>* PrepareAsyncCancelDerivativeOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>* AsyncBatchCancelDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>* PrepareAsyncBatchCancelDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>* AsyncInstantBinaryOptionsMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>* PrepareAsyncInstantBinaryOptionsMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>* AsyncCreateBinaryOptionsLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>* PrepareAsyncCreateBinaryOptionsLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>* AsyncCreateBinaryOptionsMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>* PrepareAsyncCreateBinaryOptionsMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>* AsyncCancelBinaryOptionsOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>* PrepareAsyncCancelBinaryOptionsOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>* AsyncBatchCancelBinaryOptionsOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>* PrepareAsyncBatchCancelBinaryOptionsOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>* AsyncSubaccountTransferRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>* PrepareAsyncSubaccountTransferRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgExternalTransferResponse>* AsyncExternalTransferRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgExternalTransferResponse>* PrepareAsyncExternalTransferRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>* AsyncLiquidatePositionRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>* PrepareAsyncLiquidatePositionRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>* AsyncIncreasePositionMarginRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>* PrepareAsyncIncreasePositionMarginRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>* AsyncRewardsOptOutRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>* PrepareAsyncRewardsOptOutRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>* AsyncAdminUpdateBinaryOptionsMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>* PrepareAsyncAdminUpdateBinaryOptionsMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>* AsyncReclaimLockedFundsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>* PrepareAsyncReclaimLockedFundsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>* AsyncUpdateParamsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>* PrepareAsyncUpdateParamsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Deposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::injective::exchange::v1beta1::MsgDepositResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgDepositResponse>> AsyncDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgDepositResponse>>(AsyncDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgDepositResponse>> PrepareAsyncDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgDepositResponse>>(PrepareAsyncDepositRaw(context, request, cq));
    }
    ::grpc::Status Withdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::injective::exchange::v1beta1::MsgWithdrawResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgWithdrawResponse>> AsyncWithdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgWithdrawResponse>>(AsyncWithdrawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgWithdrawResponse>> PrepareAsyncWithdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgWithdrawResponse>>(PrepareAsyncWithdrawRaw(context, request, cq));
    }
    ::grpc::Status InstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>> AsyncInstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>>(AsyncInstantSpotMarketLaunchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>> PrepareAsyncInstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>>(PrepareAsyncInstantSpotMarketLaunchRaw(context, request, cq));
    }
    ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>> AsyncInstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>>(AsyncInstantPerpetualMarketLaunchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>> PrepareAsyncInstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>>(PrepareAsyncInstantPerpetualMarketLaunchRaw(context, request, cq));
    }
    ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>> AsyncInstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>>(AsyncInstantExpiryFuturesMarketLaunchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>> PrepareAsyncInstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>>(PrepareAsyncInstantExpiryFuturesMarketLaunchRaw(context, request, cq));
    }
    ::grpc::Status CreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>> AsyncCreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>>(AsyncCreateSpotLimitOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>> PrepareAsyncCreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>>(PrepareAsyncCreateSpotLimitOrderRaw(context, request, cq));
    }
    ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>> AsyncBatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>>(AsyncBatchCreateSpotLimitOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>> PrepareAsyncBatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>>(PrepareAsyncBatchCreateSpotLimitOrdersRaw(context, request, cq));
    }
    ::grpc::Status CreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>> AsyncCreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>>(AsyncCreateSpotMarketOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>> PrepareAsyncCreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>>(PrepareAsyncCreateSpotMarketOrderRaw(context, request, cq));
    }
    ::grpc::Status CancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>> AsyncCancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>>(AsyncCancelSpotOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>> PrepareAsyncCancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>>(PrepareAsyncCancelSpotOrderRaw(context, request, cq));
    }
    ::grpc::Status BatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>> AsyncBatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>>(AsyncBatchCancelSpotOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>> PrepareAsyncBatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>>(PrepareAsyncBatchCancelSpotOrdersRaw(context, request, cq));
    }
    ::grpc::Status BatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>> AsyncBatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>>(AsyncBatchUpdateOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>> PrepareAsyncBatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>>(PrepareAsyncBatchUpdateOrdersRaw(context, request, cq));
    }
    ::grpc::Status PrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>> AsyncPrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>>(AsyncPrivilegedExecuteContractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>> PrepareAsyncPrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>>(PrepareAsyncPrivilegedExecuteContractRaw(context, request, cq));
    }
    ::grpc::Status CreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>> AsyncCreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>>(AsyncCreateDerivativeLimitOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>> PrepareAsyncCreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>>(PrepareAsyncCreateDerivativeLimitOrderRaw(context, request, cq));
    }
    ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>> AsyncBatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>>(AsyncBatchCreateDerivativeLimitOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>> PrepareAsyncBatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>>(PrepareAsyncBatchCreateDerivativeLimitOrdersRaw(context, request, cq));
    }
    ::grpc::Status CreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>> AsyncCreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>>(AsyncCreateDerivativeMarketOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>> PrepareAsyncCreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>>(PrepareAsyncCreateDerivativeMarketOrderRaw(context, request, cq));
    }
    ::grpc::Status CancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>> AsyncCancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>>(AsyncCancelDerivativeOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>> PrepareAsyncCancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>>(PrepareAsyncCancelDerivativeOrderRaw(context, request, cq));
    }
    ::grpc::Status BatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>> AsyncBatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>>(AsyncBatchCancelDerivativeOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>> PrepareAsyncBatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>>(PrepareAsyncBatchCancelDerivativeOrdersRaw(context, request, cq));
    }
    ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>> AsyncInstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>>(AsyncInstantBinaryOptionsMarketLaunchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>> PrepareAsyncInstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>>(PrepareAsyncInstantBinaryOptionsMarketLaunchRaw(context, request, cq));
    }
    ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>> AsyncCreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>>(AsyncCreateBinaryOptionsLimitOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>> PrepareAsyncCreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>>(PrepareAsyncCreateBinaryOptionsLimitOrderRaw(context, request, cq));
    }
    ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>> AsyncCreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>>(AsyncCreateBinaryOptionsMarketOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>> PrepareAsyncCreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>>(PrepareAsyncCreateBinaryOptionsMarketOrderRaw(context, request, cq));
    }
    ::grpc::Status CancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>> AsyncCancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>>(AsyncCancelBinaryOptionsOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>> PrepareAsyncCancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>>(PrepareAsyncCancelBinaryOptionsOrderRaw(context, request, cq));
    }
    ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>> AsyncBatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>>(AsyncBatchCancelBinaryOptionsOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>> PrepareAsyncBatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>>(PrepareAsyncBatchCancelBinaryOptionsOrdersRaw(context, request, cq));
    }
    ::grpc::Status SubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>> AsyncSubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>>(AsyncSubaccountTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>> PrepareAsyncSubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>>(PrepareAsyncSubaccountTransferRaw(context, request, cq));
    }
    ::grpc::Status ExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::injective::exchange::v1beta1::MsgExternalTransferResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgExternalTransferResponse>> AsyncExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgExternalTransferResponse>>(AsyncExternalTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgExternalTransferResponse>> PrepareAsyncExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgExternalTransferResponse>>(PrepareAsyncExternalTransferRaw(context, request, cq));
    }
    ::grpc::Status LiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>> AsyncLiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>>(AsyncLiquidatePositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>> PrepareAsyncLiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>>(PrepareAsyncLiquidatePositionRaw(context, request, cq));
    }
    ::grpc::Status IncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>> AsyncIncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>>(AsyncIncreasePositionMarginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>> PrepareAsyncIncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>>(PrepareAsyncIncreasePositionMarginRaw(context, request, cq));
    }
    ::grpc::Status RewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>> AsyncRewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>>(AsyncRewardsOptOutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>> PrepareAsyncRewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>>(PrepareAsyncRewardsOptOutRaw(context, request, cq));
    }
    ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>> AsyncAdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>>(AsyncAdminUpdateBinaryOptionsMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>> PrepareAsyncAdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>>(PrepareAsyncAdminUpdateBinaryOptionsMarketRaw(context, request, cq));
    }
    ::grpc::Status ReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>> AsyncReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>>(AsyncReclaimLockedFundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>> PrepareAsyncReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>>(PrepareAsyncReclaimLockedFundsRaw(context, request, cq));
    }
    ::grpc::Status UpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>> AsyncUpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>>(AsyncUpdateParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>> PrepareAsyncUpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>>(PrepareAsyncUpdateParamsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Deposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit* request, ::injective::exchange::v1beta1::MsgDepositResponse* response, std::function<void(::grpc::Status)>) override;
      void Deposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit* request, ::injective::exchange::v1beta1::MsgDepositResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Withdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw* request, ::injective::exchange::v1beta1::MsgWithdrawResponse* response, std::function<void(::grpc::Status)>) override;
      void Withdraw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw* request, ::injective::exchange::v1beta1::MsgWithdrawResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* response, std::function<void(::grpc::Status)>) override;
      void InstantSpotMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* response, std::function<void(::grpc::Status)>) override;
      void InstantPerpetualMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* response, std::function<void(::grpc::Status)>) override;
      void InstantExpiryFuturesMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateSpotLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchCreateSpotLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateSpotMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* request, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CancelSpotOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* request, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchCancelSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* request, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchUpdateOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* request, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* request, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* response, std::function<void(::grpc::Status)>) override;
      void PrivilegedExecuteContract(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* request, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateDerivativeLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchCreateDerivativeLimitOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateDerivativeMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* request, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CancelDerivativeOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* request, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchCancelDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* response, std::function<void(::grpc::Status)>) override;
      void InstantBinaryOptionsMarketLaunch(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateBinaryOptionsLimitOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateBinaryOptionsMarketOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* request, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* response, std::function<void(::grpc::Status)>) override;
      void CancelBinaryOptionsOrder(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* request, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchCancelBinaryOptionsOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* request, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* request, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer* request, ::injective::exchange::v1beta1::MsgExternalTransferResponse* response, std::function<void(::grpc::Status)>) override;
      void ExternalTransfer(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer* request, ::injective::exchange::v1beta1::MsgExternalTransferResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition* request, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* response, std::function<void(::grpc::Status)>) override;
      void LiquidatePosition(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition* request, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* request, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* response, std::function<void(::grpc::Status)>) override;
      void IncreasePositionMargin(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* request, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut* request, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* response, std::function<void(::grpc::Status)>) override;
      void RewardsOptOut(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut* request, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* request, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* response, std::function<void(::grpc::Status)>) override;
      void AdminUpdateBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* request, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* request, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* response, std::function<void(::grpc::Status)>) override;
      void ReclaimLockedFunds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* request, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams* request, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams* request, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgDepositResponse>* AsyncDepositRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgDepositResponse>* PrepareAsyncDepositRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgDeposit& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgWithdrawResponse>* AsyncWithdrawRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgWithdrawResponse>* PrepareAsyncWithdrawRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgWithdraw& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>* AsyncInstantSpotMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>* PrepareAsyncInstantSpotMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>* AsyncInstantPerpetualMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>* PrepareAsyncInstantPerpetualMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>* AsyncInstantExpiryFuturesMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>* PrepareAsyncInstantExpiryFuturesMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>* AsyncCreateSpotLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>* PrepareAsyncCreateSpotLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>* AsyncBatchCreateSpotLimitOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>* PrepareAsyncBatchCreateSpotLimitOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>* AsyncCreateSpotMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>* PrepareAsyncCreateSpotMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>* AsyncCancelSpotOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>* PrepareAsyncCancelSpotOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>* AsyncBatchCancelSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>* PrepareAsyncBatchCancelSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>* AsyncBatchUpdateOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>* PrepareAsyncBatchUpdateOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>* AsyncPrivilegedExecuteContractRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>* PrepareAsyncPrivilegedExecuteContractRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>* AsyncCreateDerivativeLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>* PrepareAsyncCreateDerivativeLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>* AsyncBatchCreateDerivativeLimitOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>* PrepareAsyncBatchCreateDerivativeLimitOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>* AsyncCreateDerivativeMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>* PrepareAsyncCreateDerivativeMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>* AsyncCancelDerivativeOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>* PrepareAsyncCancelDerivativeOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>* AsyncBatchCancelDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>* PrepareAsyncBatchCancelDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>* AsyncInstantBinaryOptionsMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>* PrepareAsyncInstantBinaryOptionsMarketLaunchRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>* AsyncCreateBinaryOptionsLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>* PrepareAsyncCreateBinaryOptionsLimitOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>* AsyncCreateBinaryOptionsMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>* PrepareAsyncCreateBinaryOptionsMarketOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>* AsyncCancelBinaryOptionsOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>* PrepareAsyncCancelBinaryOptionsOrderRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>* AsyncBatchCancelBinaryOptionsOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>* PrepareAsyncBatchCancelBinaryOptionsOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>* AsyncSubaccountTransferRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>* PrepareAsyncSubaccountTransferRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgExternalTransferResponse>* AsyncExternalTransferRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgExternalTransferResponse>* PrepareAsyncExternalTransferRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>* AsyncLiquidatePositionRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>* PrepareAsyncLiquidatePositionRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>* AsyncIncreasePositionMarginRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>* PrepareAsyncIncreasePositionMarginRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>* AsyncRewardsOptOutRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>* PrepareAsyncRewardsOptOutRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>* AsyncAdminUpdateBinaryOptionsMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>* PrepareAsyncAdminUpdateBinaryOptionsMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>* AsyncReclaimLockedFundsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>* PrepareAsyncReclaimLockedFundsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>* AsyncUpdateParamsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>* PrepareAsyncUpdateParamsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Deposit_;
    const ::grpc::internal::RpcMethod rpcmethod_Withdraw_;
    const ::grpc::internal::RpcMethod rpcmethod_InstantSpotMarketLaunch_;
    const ::grpc::internal::RpcMethod rpcmethod_InstantPerpetualMarketLaunch_;
    const ::grpc::internal::RpcMethod rpcmethod_InstantExpiryFuturesMarketLaunch_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateSpotLimitOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchCreateSpotLimitOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateSpotMarketOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelSpotOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchCancelSpotOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchUpdateOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_PrivilegedExecuteContract_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateDerivativeLimitOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchCreateDerivativeLimitOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateDerivativeMarketOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelDerivativeOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchCancelDerivativeOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_InstantBinaryOptionsMarketLaunch_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateBinaryOptionsLimitOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateBinaryOptionsMarketOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelBinaryOptionsOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchCancelBinaryOptionsOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountTransfer_;
    const ::grpc::internal::RpcMethod rpcmethod_ExternalTransfer_;
    const ::grpc::internal::RpcMethod rpcmethod_LiquidatePosition_;
    const ::grpc::internal::RpcMethod rpcmethod_IncreasePositionMargin_;
    const ::grpc::internal::RpcMethod rpcmethod_RewardsOptOut_;
    const ::grpc::internal::RpcMethod rpcmethod_AdminUpdateBinaryOptionsMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_ReclaimLockedFunds_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateParams_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Deposit defines a method for transferring coins from the sender's bank
    // balance into the subaccount's exchange deposits
    virtual ::grpc::Status Deposit(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgDeposit* request, ::injective::exchange::v1beta1::MsgDepositResponse* response);
    // Withdraw defines a method for withdrawing coins from a subaccount's
    // deposits to the user's bank balance
    virtual ::grpc::Status Withdraw(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgWithdraw* request, ::injective::exchange::v1beta1::MsgWithdrawResponse* response);
    // InstantSpotMarketLaunch defines method for creating a spot market by paying
    // listing fee without governance
    virtual ::grpc::Status InstantSpotMarketLaunch(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* response);
    // InstantPerpetualMarketLaunch defines a method for creating a new perpetual
    // futures market by paying listing fee without governance
    virtual ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* response);
    // InstantExpiryFuturesMarketLaunch defines a method for creating a new expiry
    // futures market by paying listing fee without governance
    virtual ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* response);
    // CreateSpotLimitOrder defines a method for creating a new spot limit order.
    virtual ::grpc::Status CreateSpotLimitOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* response);
    // BatchCreateSpotLimitOrder defines a method for creating a new batch of spot
    // limit orders.
    virtual ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* response);
    // CreateSpotMarketOrder defines a method for creating a new spot market
    // order.
    virtual ::grpc::Status CreateSpotMarketOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* response);
    // MsgCancelSpotOrder defines a method for cancelling a spot order.
    virtual ::grpc::Status CancelSpotOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* request, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* response);
    // BatchCancelSpotOrders defines a method for cancelling a batch of spot
    // orders in a given market.
    virtual ::grpc::Status BatchCancelSpotOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* response);
    // BatchUpdateOrders defines a method for updating a batch of orders.
    virtual ::grpc::Status BatchUpdateOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* request, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* response);
    // PrivilegedExecuteContract defines a method for executing a Cosmwasm
    // contract from the exchange module with privileged capabilities.
    virtual ::grpc::Status PrivilegedExecuteContract(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* request, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* response);
    // CreateDerivativeLimitOrder defines a method for creating a new derivative
    // limit order.
    virtual ::grpc::Status CreateDerivativeLimitOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* response);
    // BatchCreateDerivativeLimitOrders defines a method for creating a new batch
    // of derivative limit orders.
    virtual ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* response);
    // MsgCreateDerivativeLimitOrder defines a method for creating a new
    // derivative market order.
    virtual ::grpc::Status CreateDerivativeMarketOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* response);
    // MsgCancelDerivativeOrder defines a method for cancelling a derivative
    // order.
    virtual ::grpc::Status CancelDerivativeOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* request, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* response);
    // MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of
    // derivative limit orders.
    virtual ::grpc::Status BatchCancelDerivativeOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* response);
    // InstantBinaryOptionsMarketLaunch defines method for creating a binary
    // options market by paying listing fee without governance
    virtual ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* response);
    // CreateBinaryOptionsLimitOrder defines a method for creating a new binary
    // options limit order.
    virtual ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* response);
    // CreateBinaryOptionsMarketOrder defines a method for creating a new binary
    // options market order.
    virtual ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* response);
    // MsgCancelBinaryOptionsOrder defines a method for cancelling a binary
    // options order.
    virtual ::grpc::Status CancelBinaryOptionsOrder(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* request, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* response);
    // BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of
    // binary options limit orders.
    virtual ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* response);
    // SubaccountTransfer defines a method for transfer between subaccounts
    virtual ::grpc::Status SubaccountTransfer(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* request, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* response);
    // ExternalTransfer defines a method for transfer between external accounts
    virtual ::grpc::Status ExternalTransfer(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer* request, ::injective::exchange::v1beta1::MsgExternalTransferResponse* response);
    // LiquidatePosition defines a method for liquidating a position
    virtual ::grpc::Status LiquidatePosition(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition* request, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* response);
    // IncreasePositionMargin defines a method for increasing margin of a position
    virtual ::grpc::Status IncreasePositionMargin(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* request, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* response);
    // RewardsOptOut defines a method for opting out of rewards
    virtual ::grpc::Status RewardsOptOut(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut* request, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* response);
    // AdminUpdateBinaryOptionsMarket defines method for updating a binary options
    // market by admin
    virtual ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* request, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* response);
    //
    virtual ::grpc::Status ReclaimLockedFunds(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* request, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* response);
    virtual ::grpc::Status UpdateParams(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams* request, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Deposit() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgDeposit* /*request*/, ::injective::exchange::v1beta1::MsgDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeposit(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgDeposit* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgDepositResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Withdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Withdraw() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Withdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdraw(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgWithdraw* /*request*/, ::injective::exchange::v1beta1::MsgWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWithdraw(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgWithdraw* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgWithdrawResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InstantSpotMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InstantSpotMarketLaunch() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_InstantSpotMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantSpotMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantSpotMarketLaunch(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InstantPerpetualMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InstantPerpetualMarketLaunch() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_InstantPerpetualMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantPerpetualMarketLaunch(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InstantExpiryFuturesMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InstantExpiryFuturesMarketLaunch() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_InstantExpiryFuturesMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantExpiryFuturesMarketLaunch(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateSpotLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateSpotLimitOrder() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_CreateSpotLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSpotLimitOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchCreateSpotLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchCreateSpotLimitOrders() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_BatchCreateSpotLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCreateSpotLimitOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateSpotMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateSpotMarketOrder() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_CreateSpotMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSpotMarketOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelSpotOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelSpotOrder() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_CancelSpotOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSpotOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelSpotOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCancelSpotOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchCancelSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchCancelSpotOrders() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_BatchCancelSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCancelSpotOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchUpdateOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchUpdateOrders() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_BatchUpdateOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchUpdateOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgBatchUpdateOrders* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PrivilegedExecuteContract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrivilegedExecuteContract() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_PrivilegedExecuteContract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrivilegedExecuteContract(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* /*request*/, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrivilegedExecuteContract(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateDerivativeLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateDerivativeLimitOrder() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_CreateDerivativeLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateDerivativeLimitOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchCreateDerivativeLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchCreateDerivativeLimitOrders() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_BatchCreateDerivativeLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCreateDerivativeLimitOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateDerivativeMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateDerivativeMarketOrder() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_CreateDerivativeMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateDerivativeMarketOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelDerivativeOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelDerivativeOrder() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_CancelDerivativeOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelDerivativeOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelDerivativeOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchCancelDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchCancelDerivativeOrders() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_BatchCancelDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCancelDerivativeOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InstantBinaryOptionsMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InstantBinaryOptionsMarketLaunch() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_InstantBinaryOptionsMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantBinaryOptionsMarketLaunch(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateBinaryOptionsLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateBinaryOptionsLimitOrder() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_CreateBinaryOptionsLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateBinaryOptionsLimitOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateBinaryOptionsMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateBinaryOptionsMarketOrder() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_CreateBinaryOptionsMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateBinaryOptionsMarketOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelBinaryOptionsOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelBinaryOptionsOrder() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_CancelBinaryOptionsOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelBinaryOptionsOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelBinaryOptionsOrder(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchCancelBinaryOptionsOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchCancelBinaryOptionsOrders() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_BatchCancelBinaryOptionsOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCancelBinaryOptionsOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountTransfer() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_SubaccountTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* /*request*/, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountTransfer(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgSubaccountTransfer* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExternalTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExternalTransfer() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_ExternalTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExternalTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgExternalTransfer* /*request*/, ::injective::exchange::v1beta1::MsgExternalTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExternalTransfer(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgExternalTransfer* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgExternalTransferResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LiquidatePosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LiquidatePosition() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_LiquidatePosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidatePosition(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgLiquidatePosition* /*request*/, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLiquidatePosition(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgLiquidatePosition* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IncreasePositionMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IncreasePositionMargin() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_IncreasePositionMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IncreasePositionMargin(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* /*request*/, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIncreasePositionMargin(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgIncreasePositionMargin* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RewardsOptOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RewardsOptOut() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_RewardsOptOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RewardsOptOut(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgRewardsOptOut* /*request*/, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRewardsOptOut(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgRewardsOptOut* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AdminUpdateBinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AdminUpdateBinaryOptionsMarket() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_AdminUpdateBinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* /*request*/, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAdminUpdateBinaryOptionsMarket(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReclaimLockedFunds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReclaimLockedFunds() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_ReclaimLockedFunds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReclaimLockedFunds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* /*request*/, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReclaimLockedFunds(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgReclaimLockedFunds* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateParams() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_UpdateParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgUpdateParams* /*request*/, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateParams(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MsgUpdateParams* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MsgUpdateParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Deposit<WithAsyncMethod_Withdraw<WithAsyncMethod_InstantSpotMarketLaunch<WithAsyncMethod_InstantPerpetualMarketLaunch<WithAsyncMethod_InstantExpiryFuturesMarketLaunch<WithAsyncMethod_CreateSpotLimitOrder<WithAsyncMethod_BatchCreateSpotLimitOrders<WithAsyncMethod_CreateSpotMarketOrder<WithAsyncMethod_CancelSpotOrder<WithAsyncMethod_BatchCancelSpotOrders<WithAsyncMethod_BatchUpdateOrders<WithAsyncMethod_PrivilegedExecuteContract<WithAsyncMethod_CreateDerivativeLimitOrder<WithAsyncMethod_BatchCreateDerivativeLimitOrders<WithAsyncMethod_CreateDerivativeMarketOrder<WithAsyncMethod_CancelDerivativeOrder<WithAsyncMethod_BatchCancelDerivativeOrders<WithAsyncMethod_InstantBinaryOptionsMarketLaunch<WithAsyncMethod_CreateBinaryOptionsLimitOrder<WithAsyncMethod_CreateBinaryOptionsMarketOrder<WithAsyncMethod_CancelBinaryOptionsOrder<WithAsyncMethod_BatchCancelBinaryOptionsOrders<WithAsyncMethod_SubaccountTransfer<WithAsyncMethod_ExternalTransfer<WithAsyncMethod_LiquidatePosition<WithAsyncMethod_IncreasePositionMargin<WithAsyncMethod_RewardsOptOut<WithAsyncMethod_AdminUpdateBinaryOptionsMarket<WithAsyncMethod_ReclaimLockedFunds<WithAsyncMethod_UpdateParams<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Deposit() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgDeposit, ::injective::exchange::v1beta1::MsgDepositResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgDeposit* request, ::injective::exchange::v1beta1::MsgDepositResponse* response) { return this->Deposit(context, request, response); }));}
    void SetMessageAllocatorFor_Deposit(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgDeposit, ::injective::exchange::v1beta1::MsgDepositResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgDeposit, ::injective::exchange::v1beta1::MsgDepositResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgDeposit* /*request*/, ::injective::exchange::v1beta1::MsgDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Deposit(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgDeposit* /*request*/, ::injective::exchange::v1beta1::MsgDepositResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Withdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Withdraw() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgWithdraw, ::injective::exchange::v1beta1::MsgWithdrawResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgWithdraw* request, ::injective::exchange::v1beta1::MsgWithdrawResponse* response) { return this->Withdraw(context, request, response); }));}
    void SetMessageAllocatorFor_Withdraw(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgWithdraw, ::injective::exchange::v1beta1::MsgWithdrawResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgWithdraw, ::injective::exchange::v1beta1::MsgWithdrawResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Withdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdraw(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgWithdraw* /*request*/, ::injective::exchange::v1beta1::MsgWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Withdraw(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgWithdraw* /*request*/, ::injective::exchange::v1beta1::MsgWithdrawResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InstantSpotMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InstantSpotMarketLaunch() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* response) { return this->InstantSpotMarketLaunch(context, request, response); }));}
    void SetMessageAllocatorFor_InstantSpotMarketLaunch(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InstantSpotMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantSpotMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InstantSpotMarketLaunch(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InstantPerpetualMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InstantPerpetualMarketLaunch() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* response) { return this->InstantPerpetualMarketLaunch(context, request, response); }));}
    void SetMessageAllocatorFor_InstantPerpetualMarketLaunch(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InstantPerpetualMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InstantPerpetualMarketLaunch(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InstantExpiryFuturesMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InstantExpiryFuturesMarketLaunch() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* response) { return this->InstantExpiryFuturesMarketLaunch(context, request, response); }));}
    void SetMessageAllocatorFor_InstantExpiryFuturesMarketLaunch(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InstantExpiryFuturesMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InstantExpiryFuturesMarketLaunch(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateSpotLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateSpotLimitOrder() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* response) { return this->CreateSpotLimitOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CreateSpotLimitOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateSpotLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateSpotLimitOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchCreateSpotLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchCreateSpotLimitOrders() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* response) { return this->BatchCreateSpotLimitOrders(context, request, response); }));}
    void SetMessageAllocatorFor_BatchCreateSpotLimitOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchCreateSpotLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCreateSpotLimitOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateSpotMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateSpotMarketOrder() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* response) { return this->CreateSpotMarketOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CreateSpotMarketOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateSpotMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateSpotMarketOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CancelSpotOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CancelSpotOrder() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCancelSpotOrder, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* request, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* response) { return this->CancelSpotOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CancelSpotOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCancelSpotOrder, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCancelSpotOrder, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CancelSpotOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSpotOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelSpotOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchCancelSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchCancelSpotOrders() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* response) { return this->BatchCancelSpotOrders(context, request, response); }));}
    void SetMessageAllocatorFor_BatchCancelSpotOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchCancelSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCancelSpotOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchUpdateOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchUpdateOrders() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchUpdateOrders, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* request, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* response) { return this->BatchUpdateOrders(context, request, response); }));}
    void SetMessageAllocatorFor_BatchUpdateOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgBatchUpdateOrders, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchUpdateOrders, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchUpdateOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchUpdateOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PrivilegedExecuteContract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PrivilegedExecuteContract() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* request, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* response) { return this->PrivilegedExecuteContract(context, request, response); }));}
    void SetMessageAllocatorFor_PrivilegedExecuteContract(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PrivilegedExecuteContract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrivilegedExecuteContract(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* /*request*/, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PrivilegedExecuteContract(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* /*request*/, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateDerivativeLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateDerivativeLimitOrder() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* response) { return this->CreateDerivativeLimitOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CreateDerivativeLimitOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateDerivativeLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateDerivativeLimitOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchCreateDerivativeLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchCreateDerivativeLimitOrders() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* request, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* response) { return this->BatchCreateDerivativeLimitOrders(context, request, response); }));}
    void SetMessageAllocatorFor_BatchCreateDerivativeLimitOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchCreateDerivativeLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCreateDerivativeLimitOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateDerivativeMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateDerivativeMarketOrder() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* response) { return this->CreateDerivativeMarketOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CreateDerivativeMarketOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateDerivativeMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateDerivativeMarketOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CancelDerivativeOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CancelDerivativeOrder() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCancelDerivativeOrder, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* request, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* response) { return this->CancelDerivativeOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CancelDerivativeOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCancelDerivativeOrder, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCancelDerivativeOrder, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CancelDerivativeOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelDerivativeOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelDerivativeOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchCancelDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchCancelDerivativeOrders() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* response) { return this->BatchCancelDerivativeOrders(context, request, response); }));}
    void SetMessageAllocatorFor_BatchCancelDerivativeOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchCancelDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCancelDerivativeOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InstantBinaryOptionsMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InstantBinaryOptionsMarketLaunch() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* request, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* response) { return this->InstantBinaryOptionsMarketLaunch(context, request, response); }));}
    void SetMessageAllocatorFor_InstantBinaryOptionsMarketLaunch(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InstantBinaryOptionsMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InstantBinaryOptionsMarketLaunch(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateBinaryOptionsLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateBinaryOptionsLimitOrder() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* response) { return this->CreateBinaryOptionsLimitOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CreateBinaryOptionsLimitOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateBinaryOptionsLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateBinaryOptionsLimitOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateBinaryOptionsMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateBinaryOptionsMarketOrder() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* request, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* response) { return this->CreateBinaryOptionsMarketOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CreateBinaryOptionsMarketOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateBinaryOptionsMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateBinaryOptionsMarketOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CancelBinaryOptionsOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CancelBinaryOptionsOrder() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* request, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* response) { return this->CancelBinaryOptionsOrder(context, request, response); }));}
    void SetMessageAllocatorFor_CancelBinaryOptionsOrder(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CancelBinaryOptionsOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelBinaryOptionsOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelBinaryOptionsOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchCancelBinaryOptionsOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchCancelBinaryOptionsOrders() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* request, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* response) { return this->BatchCancelBinaryOptionsOrders(context, request, response); }));}
    void SetMessageAllocatorFor_BatchCancelBinaryOptionsOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchCancelBinaryOptionsOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCancelBinaryOptionsOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountTransfer() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgSubaccountTransfer, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* request, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* response) { return this->SubaccountTransfer(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountTransfer(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgSubaccountTransfer, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgSubaccountTransfer, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* /*request*/, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* /*request*/, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExternalTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExternalTransfer() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgExternalTransfer, ::injective::exchange::v1beta1::MsgExternalTransferResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgExternalTransfer* request, ::injective::exchange::v1beta1::MsgExternalTransferResponse* response) { return this->ExternalTransfer(context, request, response); }));}
    void SetMessageAllocatorFor_ExternalTransfer(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgExternalTransfer, ::injective::exchange::v1beta1::MsgExternalTransferResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgExternalTransfer, ::injective::exchange::v1beta1::MsgExternalTransferResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExternalTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExternalTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgExternalTransfer* /*request*/, ::injective::exchange::v1beta1::MsgExternalTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExternalTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgExternalTransfer* /*request*/, ::injective::exchange::v1beta1::MsgExternalTransferResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LiquidatePosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LiquidatePosition() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgLiquidatePosition, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgLiquidatePosition* request, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* response) { return this->LiquidatePosition(context, request, response); }));}
    void SetMessageAllocatorFor_LiquidatePosition(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgLiquidatePosition, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgLiquidatePosition, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LiquidatePosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidatePosition(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgLiquidatePosition* /*request*/, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LiquidatePosition(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgLiquidatePosition* /*request*/, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IncreasePositionMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IncreasePositionMargin() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgIncreasePositionMargin, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* request, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* response) { return this->IncreasePositionMargin(context, request, response); }));}
    void SetMessageAllocatorFor_IncreasePositionMargin(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgIncreasePositionMargin, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgIncreasePositionMargin, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IncreasePositionMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IncreasePositionMargin(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* /*request*/, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IncreasePositionMargin(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* /*request*/, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RewardsOptOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RewardsOptOut() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgRewardsOptOut, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgRewardsOptOut* request, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* response) { return this->RewardsOptOut(context, request, response); }));}
    void SetMessageAllocatorFor_RewardsOptOut(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgRewardsOptOut, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgRewardsOptOut, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RewardsOptOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RewardsOptOut(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgRewardsOptOut* /*request*/, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RewardsOptOut(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgRewardsOptOut* /*request*/, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AdminUpdateBinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AdminUpdateBinaryOptionsMarket() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* request, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* response) { return this->AdminUpdateBinaryOptionsMarket(context, request, response); }));}
    void SetMessageAllocatorFor_AdminUpdateBinaryOptionsMarket(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AdminUpdateBinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* /*request*/, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AdminUpdateBinaryOptionsMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* /*request*/, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReclaimLockedFunds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReclaimLockedFunds() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgReclaimLockedFunds, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* request, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* response) { return this->ReclaimLockedFunds(context, request, response); }));}
    void SetMessageAllocatorFor_ReclaimLockedFunds(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgReclaimLockedFunds, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgReclaimLockedFunds, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReclaimLockedFunds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReclaimLockedFunds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* /*request*/, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReclaimLockedFunds(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* /*request*/, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateParams() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgUpdateParams, ::injective::exchange::v1beta1::MsgUpdateParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MsgUpdateParams* request, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* response) { return this->UpdateParams(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateParams(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MsgUpdateParams, ::injective::exchange::v1beta1::MsgUpdateParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MsgUpdateParams, ::injective::exchange::v1beta1::MsgUpdateParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgUpdateParams* /*request*/, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateParams(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgUpdateParams* /*request*/, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Deposit<WithCallbackMethod_Withdraw<WithCallbackMethod_InstantSpotMarketLaunch<WithCallbackMethod_InstantPerpetualMarketLaunch<WithCallbackMethod_InstantExpiryFuturesMarketLaunch<WithCallbackMethod_CreateSpotLimitOrder<WithCallbackMethod_BatchCreateSpotLimitOrders<WithCallbackMethod_CreateSpotMarketOrder<WithCallbackMethod_CancelSpotOrder<WithCallbackMethod_BatchCancelSpotOrders<WithCallbackMethod_BatchUpdateOrders<WithCallbackMethod_PrivilegedExecuteContract<WithCallbackMethod_CreateDerivativeLimitOrder<WithCallbackMethod_BatchCreateDerivativeLimitOrders<WithCallbackMethod_CreateDerivativeMarketOrder<WithCallbackMethod_CancelDerivativeOrder<WithCallbackMethod_BatchCancelDerivativeOrders<WithCallbackMethod_InstantBinaryOptionsMarketLaunch<WithCallbackMethod_CreateBinaryOptionsLimitOrder<WithCallbackMethod_CreateBinaryOptionsMarketOrder<WithCallbackMethod_CancelBinaryOptionsOrder<WithCallbackMethod_BatchCancelBinaryOptionsOrders<WithCallbackMethod_SubaccountTransfer<WithCallbackMethod_ExternalTransfer<WithCallbackMethod_LiquidatePosition<WithCallbackMethod_IncreasePositionMargin<WithCallbackMethod_RewardsOptOut<WithCallbackMethod_AdminUpdateBinaryOptionsMarket<WithCallbackMethod_ReclaimLockedFunds<WithCallbackMethod_UpdateParams<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Deposit() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgDeposit* /*request*/, ::injective::exchange::v1beta1::MsgDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Withdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Withdraw() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Withdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdraw(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgWithdraw* /*request*/, ::injective::exchange::v1beta1::MsgWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InstantSpotMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InstantSpotMarketLaunch() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_InstantSpotMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantSpotMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InstantPerpetualMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InstantPerpetualMarketLaunch() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_InstantPerpetualMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InstantExpiryFuturesMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InstantExpiryFuturesMarketLaunch() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_InstantExpiryFuturesMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateSpotLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateSpotLimitOrder() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_CreateSpotLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchCreateSpotLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchCreateSpotLimitOrders() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_BatchCreateSpotLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateSpotMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateSpotMarketOrder() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_CreateSpotMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelSpotOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelSpotOrder() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_CancelSpotOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSpotOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchCancelSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchCancelSpotOrders() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_BatchCancelSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchUpdateOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchUpdateOrders() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_BatchUpdateOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PrivilegedExecuteContract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrivilegedExecuteContract() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_PrivilegedExecuteContract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrivilegedExecuteContract(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* /*request*/, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateDerivativeLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateDerivativeLimitOrder() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_CreateDerivativeLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchCreateDerivativeLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchCreateDerivativeLimitOrders() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_BatchCreateDerivativeLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateDerivativeMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateDerivativeMarketOrder() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_CreateDerivativeMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelDerivativeOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelDerivativeOrder() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_CancelDerivativeOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelDerivativeOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchCancelDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchCancelDerivativeOrders() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_BatchCancelDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InstantBinaryOptionsMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InstantBinaryOptionsMarketLaunch() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_InstantBinaryOptionsMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateBinaryOptionsLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateBinaryOptionsLimitOrder() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_CreateBinaryOptionsLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateBinaryOptionsMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateBinaryOptionsMarketOrder() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_CreateBinaryOptionsMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelBinaryOptionsOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelBinaryOptionsOrder() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_CancelBinaryOptionsOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelBinaryOptionsOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchCancelBinaryOptionsOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchCancelBinaryOptionsOrders() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_BatchCancelBinaryOptionsOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountTransfer() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_SubaccountTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* /*request*/, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExternalTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExternalTransfer() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_ExternalTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExternalTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgExternalTransfer* /*request*/, ::injective::exchange::v1beta1::MsgExternalTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LiquidatePosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LiquidatePosition() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_LiquidatePosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidatePosition(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgLiquidatePosition* /*request*/, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IncreasePositionMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IncreasePositionMargin() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_IncreasePositionMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IncreasePositionMargin(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* /*request*/, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RewardsOptOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RewardsOptOut() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_RewardsOptOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RewardsOptOut(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgRewardsOptOut* /*request*/, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AdminUpdateBinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AdminUpdateBinaryOptionsMarket() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_AdminUpdateBinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* /*request*/, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReclaimLockedFunds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReclaimLockedFunds() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_ReclaimLockedFunds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReclaimLockedFunds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* /*request*/, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateParams() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_UpdateParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgUpdateParams* /*request*/, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Deposit() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgDeposit* /*request*/, ::injective::exchange::v1beta1::MsgDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeposit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Withdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Withdraw() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Withdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdraw(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgWithdraw* /*request*/, ::injective::exchange::v1beta1::MsgWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWithdraw(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InstantSpotMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InstantSpotMarketLaunch() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_InstantSpotMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantSpotMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantSpotMarketLaunch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InstantPerpetualMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InstantPerpetualMarketLaunch() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_InstantPerpetualMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantPerpetualMarketLaunch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InstantExpiryFuturesMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InstantExpiryFuturesMarketLaunch() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_InstantExpiryFuturesMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantExpiryFuturesMarketLaunch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateSpotLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateSpotLimitOrder() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_CreateSpotLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSpotLimitOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchCreateSpotLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchCreateSpotLimitOrders() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_BatchCreateSpotLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCreateSpotLimitOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateSpotMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateSpotMarketOrder() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_CreateSpotMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSpotMarketOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelSpotOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelSpotOrder() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_CancelSpotOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSpotOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelSpotOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchCancelSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchCancelSpotOrders() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_BatchCancelSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCancelSpotOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchUpdateOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchUpdateOrders() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_BatchUpdateOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchUpdateOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrivilegedExecuteContract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrivilegedExecuteContract() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_PrivilegedExecuteContract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrivilegedExecuteContract(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* /*request*/, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrivilegedExecuteContract(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateDerivativeLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateDerivativeLimitOrder() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_CreateDerivativeLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateDerivativeLimitOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchCreateDerivativeLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchCreateDerivativeLimitOrders() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_BatchCreateDerivativeLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCreateDerivativeLimitOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateDerivativeMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateDerivativeMarketOrder() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_CreateDerivativeMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateDerivativeMarketOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelDerivativeOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelDerivativeOrder() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_CancelDerivativeOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelDerivativeOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelDerivativeOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchCancelDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchCancelDerivativeOrders() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_BatchCancelDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCancelDerivativeOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InstantBinaryOptionsMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InstantBinaryOptionsMarketLaunch() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_InstantBinaryOptionsMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantBinaryOptionsMarketLaunch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateBinaryOptionsLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateBinaryOptionsLimitOrder() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_CreateBinaryOptionsLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateBinaryOptionsLimitOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateBinaryOptionsMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateBinaryOptionsMarketOrder() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_CreateBinaryOptionsMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateBinaryOptionsMarketOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelBinaryOptionsOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelBinaryOptionsOrder() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_CancelBinaryOptionsOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelBinaryOptionsOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelBinaryOptionsOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchCancelBinaryOptionsOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchCancelBinaryOptionsOrders() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_BatchCancelBinaryOptionsOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCancelBinaryOptionsOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountTransfer() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_SubaccountTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* /*request*/, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountTransfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExternalTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExternalTransfer() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_ExternalTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExternalTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgExternalTransfer* /*request*/, ::injective::exchange::v1beta1::MsgExternalTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExternalTransfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LiquidatePosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LiquidatePosition() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_LiquidatePosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidatePosition(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgLiquidatePosition* /*request*/, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLiquidatePosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IncreasePositionMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IncreasePositionMargin() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_IncreasePositionMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IncreasePositionMargin(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* /*request*/, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIncreasePositionMargin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RewardsOptOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RewardsOptOut() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_RewardsOptOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RewardsOptOut(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgRewardsOptOut* /*request*/, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRewardsOptOut(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AdminUpdateBinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AdminUpdateBinaryOptionsMarket() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_AdminUpdateBinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* /*request*/, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAdminUpdateBinaryOptionsMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReclaimLockedFunds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReclaimLockedFunds() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_ReclaimLockedFunds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReclaimLockedFunds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* /*request*/, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReclaimLockedFunds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateParams() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_UpdateParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgUpdateParams* /*request*/, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Deposit() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Deposit(context, request, response); }));
    }
    ~WithRawCallbackMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgDeposit* /*request*/, ::injective::exchange::v1beta1::MsgDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Deposit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Withdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Withdraw() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Withdraw(context, request, response); }));
    }
    ~WithRawCallbackMethod_Withdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdraw(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgWithdraw* /*request*/, ::injective::exchange::v1beta1::MsgWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Withdraw(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InstantSpotMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InstantSpotMarketLaunch() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InstantSpotMarketLaunch(context, request, response); }));
    }
    ~WithRawCallbackMethod_InstantSpotMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantSpotMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InstantSpotMarketLaunch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InstantPerpetualMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InstantPerpetualMarketLaunch() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InstantPerpetualMarketLaunch(context, request, response); }));
    }
    ~WithRawCallbackMethod_InstantPerpetualMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InstantPerpetualMarketLaunch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InstantExpiryFuturesMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InstantExpiryFuturesMarketLaunch() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InstantExpiryFuturesMarketLaunch(context, request, response); }));
    }
    ~WithRawCallbackMethod_InstantExpiryFuturesMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InstantExpiryFuturesMarketLaunch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateSpotLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateSpotLimitOrder() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateSpotLimitOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateSpotLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateSpotLimitOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchCreateSpotLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchCreateSpotLimitOrders() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchCreateSpotLimitOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchCreateSpotLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCreateSpotLimitOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateSpotMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateSpotMarketOrder() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateSpotMarketOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateSpotMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpotMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateSpotMarketOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CancelSpotOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CancelSpotOrder() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelSpotOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CancelSpotOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSpotOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelSpotOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchCancelSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchCancelSpotOrders() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchCancelSpotOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchCancelSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCancelSpotOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchUpdateOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchUpdateOrders() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchUpdateOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchUpdateOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchUpdateOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PrivilegedExecuteContract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PrivilegedExecuteContract() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrivilegedExecuteContract(context, request, response); }));
    }
    ~WithRawCallbackMethod_PrivilegedExecuteContract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrivilegedExecuteContract(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* /*request*/, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PrivilegedExecuteContract(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateDerivativeLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateDerivativeLimitOrder() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateDerivativeLimitOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateDerivativeLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateDerivativeLimitOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchCreateDerivativeLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchCreateDerivativeLimitOrders() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchCreateDerivativeLimitOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchCreateDerivativeLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCreateDerivativeLimitOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateDerivativeMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateDerivativeMarketOrder() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateDerivativeMarketOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateDerivativeMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateDerivativeMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateDerivativeMarketOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CancelDerivativeOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CancelDerivativeOrder() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelDerivativeOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CancelDerivativeOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelDerivativeOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelDerivativeOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchCancelDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchCancelDerivativeOrders() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchCancelDerivativeOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchCancelDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCancelDerivativeOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InstantBinaryOptionsMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InstantBinaryOptionsMarketLaunch() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InstantBinaryOptionsMarketLaunch(context, request, response); }));
    }
    ~WithRawCallbackMethod_InstantBinaryOptionsMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InstantBinaryOptionsMarketLaunch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateBinaryOptionsLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateBinaryOptionsLimitOrder() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateBinaryOptionsLimitOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateBinaryOptionsLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateBinaryOptionsLimitOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateBinaryOptionsMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateBinaryOptionsMarketOrder() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateBinaryOptionsMarketOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateBinaryOptionsMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateBinaryOptionsMarketOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CancelBinaryOptionsOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CancelBinaryOptionsOrder() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelBinaryOptionsOrder(context, request, response); }));
    }
    ~WithRawCallbackMethod_CancelBinaryOptionsOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelBinaryOptionsOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelBinaryOptionsOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchCancelBinaryOptionsOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchCancelBinaryOptionsOrders() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchCancelBinaryOptionsOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchCancelBinaryOptionsOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCancelBinaryOptionsOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountTransfer() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountTransfer(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* /*request*/, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExternalTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExternalTransfer() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExternalTransfer(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExternalTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExternalTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgExternalTransfer* /*request*/, ::injective::exchange::v1beta1::MsgExternalTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExternalTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LiquidatePosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LiquidatePosition() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LiquidatePosition(context, request, response); }));
    }
    ~WithRawCallbackMethod_LiquidatePosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidatePosition(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgLiquidatePosition* /*request*/, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LiquidatePosition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IncreasePositionMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IncreasePositionMargin() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IncreasePositionMargin(context, request, response); }));
    }
    ~WithRawCallbackMethod_IncreasePositionMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IncreasePositionMargin(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* /*request*/, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IncreasePositionMargin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RewardsOptOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RewardsOptOut() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RewardsOptOut(context, request, response); }));
    }
    ~WithRawCallbackMethod_RewardsOptOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RewardsOptOut(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgRewardsOptOut* /*request*/, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RewardsOptOut(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AdminUpdateBinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AdminUpdateBinaryOptionsMarket() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AdminUpdateBinaryOptionsMarket(context, request, response); }));
    }
    ~WithRawCallbackMethod_AdminUpdateBinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* /*request*/, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AdminUpdateBinaryOptionsMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReclaimLockedFunds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReclaimLockedFunds() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReclaimLockedFunds(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReclaimLockedFunds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReclaimLockedFunds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* /*request*/, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReclaimLockedFunds(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateParams() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateParams(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgUpdateParams* /*request*/, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Deposit() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgDeposit, ::injective::exchange::v1beta1::MsgDepositResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgDeposit, ::injective::exchange::v1beta1::MsgDepositResponse>* streamer) {
                       return this->StreamedDeposit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgDeposit* /*request*/, ::injective::exchange::v1beta1::MsgDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeposit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgDeposit,::injective::exchange::v1beta1::MsgDepositResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Withdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Withdraw() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgWithdraw, ::injective::exchange::v1beta1::MsgWithdrawResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgWithdraw, ::injective::exchange::v1beta1::MsgWithdrawResponse>* streamer) {
                       return this->StreamedWithdraw(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Withdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Withdraw(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgWithdraw* /*request*/, ::injective::exchange::v1beta1::MsgWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWithdraw(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgWithdraw,::injective::exchange::v1beta1::MsgWithdrawResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InstantSpotMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InstantSpotMarketLaunch() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>* streamer) {
                       return this->StreamedInstantSpotMarketLaunch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InstantSpotMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InstantSpotMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInstantSpotMarketLaunch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch,::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InstantPerpetualMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InstantPerpetualMarketLaunch() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>* streamer) {
                       return this->StreamedInstantPerpetualMarketLaunch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InstantPerpetualMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InstantPerpetualMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInstantPerpetualMarketLaunch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch,::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InstantExpiryFuturesMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InstantExpiryFuturesMarketLaunch() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>* streamer) {
                       return this->StreamedInstantExpiryFuturesMarketLaunch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InstantExpiryFuturesMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InstantExpiryFuturesMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInstantExpiryFuturesMarketLaunch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch,::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateSpotLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateSpotLimitOrder() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>* streamer) {
                       return this->StreamedCreateSpotLimitOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateSpotLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateSpotLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateSpotLimitOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCreateSpotLimitOrder,::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchCreateSpotLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchCreateSpotLimitOrders() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>* streamer) {
                       return this->StreamedBatchCreateSpotLimitOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchCreateSpotLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchCreateSpotLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchCreateSpotLimitOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders,::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateSpotMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateSpotMarketOrder() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>* streamer) {
                       return this->StreamedCreateSpotMarketOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateSpotMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateSpotMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateSpotMarketOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCreateSpotMarketOrder,::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelSpotOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelSpotOrder() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCancelSpotOrder, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCancelSpotOrder, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>* streamer) {
                       return this->StreamedCancelSpotOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelSpotOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelSpotOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelSpotOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelSpotOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCancelSpotOrder,::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchCancelSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchCancelSpotOrders() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>* streamer) {
                       return this->StreamedBatchCancelSpotOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchCancelSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchCancelSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchCancelSpotOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgBatchCancelSpotOrders,::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchUpdateOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchUpdateOrders() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgBatchUpdateOrders, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgBatchUpdateOrders, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>* streamer) {
                       return this->StreamedBatchUpdateOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchUpdateOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchUpdateOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchUpdateOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchUpdateOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgBatchUpdateOrders,::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrivilegedExecuteContract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrivilegedExecuteContract() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>* streamer) {
                       return this->StreamedPrivilegedExecuteContract(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrivilegedExecuteContract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrivilegedExecuteContract(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* /*request*/, ::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrivilegedExecuteContract(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgPrivilegedExecuteContract,::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateDerivativeLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateDerivativeLimitOrder() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>* streamer) {
                       return this->StreamedCreateDerivativeLimitOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateDerivativeLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateDerivativeLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateDerivativeLimitOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder,::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchCreateDerivativeLimitOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchCreateDerivativeLimitOrders() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>* streamer) {
                       return this->StreamedBatchCreateDerivativeLimitOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchCreateDerivativeLimitOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchCreateDerivativeLimitOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchCreateDerivativeLimitOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders,::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateDerivativeMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateDerivativeMarketOrder() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>* streamer) {
                       return this->StreamedCreateDerivativeMarketOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateDerivativeMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateDerivativeMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateDerivativeMarketOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder,::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelDerivativeOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelDerivativeOrder() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCancelDerivativeOrder, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCancelDerivativeOrder, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>* streamer) {
                       return this->StreamedCancelDerivativeOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelDerivativeOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelDerivativeOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelDerivativeOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelDerivativeOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCancelDerivativeOrder,::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchCancelDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchCancelDerivativeOrders() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>* streamer) {
                       return this->StreamedBatchCancelDerivativeOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchCancelDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchCancelDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchCancelDerivativeOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders,::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InstantBinaryOptionsMarketLaunch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InstantBinaryOptionsMarketLaunch() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>* streamer) {
                       return this->StreamedInstantBinaryOptionsMarketLaunch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InstantBinaryOptionsMarketLaunch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InstantBinaryOptionsMarketLaunch(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* /*request*/, ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInstantBinaryOptionsMarketLaunch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch,::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateBinaryOptionsLimitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateBinaryOptionsLimitOrder() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>* streamer) {
                       return this->StreamedCreateBinaryOptionsLimitOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateBinaryOptionsLimitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateBinaryOptionsLimitOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateBinaryOptionsLimitOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder,::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateBinaryOptionsMarketOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateBinaryOptionsMarketOrder() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>* streamer) {
                       return this->StreamedCreateBinaryOptionsMarketOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateBinaryOptionsMarketOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateBinaryOptionsMarketOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* /*request*/, ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateBinaryOptionsMarketOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder,::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelBinaryOptionsOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelBinaryOptionsOrder() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>* streamer) {
                       return this->StreamedCancelBinaryOptionsOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelBinaryOptionsOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelBinaryOptionsOrder(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* /*request*/, ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelBinaryOptionsOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder,::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchCancelBinaryOptionsOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchCancelBinaryOptionsOrders() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>* streamer) {
                       return this->StreamedBatchCancelBinaryOptionsOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchCancelBinaryOptionsOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchCancelBinaryOptionsOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* /*request*/, ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchCancelBinaryOptionsOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders,::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountTransfer() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgSubaccountTransfer, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgSubaccountTransfer, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse>* streamer) {
                       return this->StreamedSubaccountTransfer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgSubaccountTransfer* /*request*/, ::injective::exchange::v1beta1::MsgSubaccountTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountTransfer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgSubaccountTransfer,::injective::exchange::v1beta1::MsgSubaccountTransferResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExternalTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExternalTransfer() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgExternalTransfer, ::injective::exchange::v1beta1::MsgExternalTransferResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgExternalTransfer, ::injective::exchange::v1beta1::MsgExternalTransferResponse>* streamer) {
                       return this->StreamedExternalTransfer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExternalTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExternalTransfer(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgExternalTransfer* /*request*/, ::injective::exchange::v1beta1::MsgExternalTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExternalTransfer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgExternalTransfer,::injective::exchange::v1beta1::MsgExternalTransferResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LiquidatePosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LiquidatePosition() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgLiquidatePosition, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgLiquidatePosition, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse>* streamer) {
                       return this->StreamedLiquidatePosition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LiquidatePosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LiquidatePosition(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgLiquidatePosition* /*request*/, ::injective::exchange::v1beta1::MsgLiquidatePositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLiquidatePosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgLiquidatePosition,::injective::exchange::v1beta1::MsgLiquidatePositionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IncreasePositionMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IncreasePositionMargin() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgIncreasePositionMargin, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgIncreasePositionMargin, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>* streamer) {
                       return this->StreamedIncreasePositionMargin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IncreasePositionMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IncreasePositionMargin(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgIncreasePositionMargin* /*request*/, ::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIncreasePositionMargin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgIncreasePositionMargin,::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RewardsOptOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RewardsOptOut() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgRewardsOptOut, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgRewardsOptOut, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse>* streamer) {
                       return this->StreamedRewardsOptOut(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RewardsOptOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RewardsOptOut(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgRewardsOptOut* /*request*/, ::injective::exchange::v1beta1::MsgRewardsOptOutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRewardsOptOut(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgRewardsOptOut,::injective::exchange::v1beta1::MsgRewardsOptOutResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AdminUpdateBinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AdminUpdateBinaryOptionsMarket() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>* streamer) {
                       return this->StreamedAdminUpdateBinaryOptionsMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AdminUpdateBinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AdminUpdateBinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* /*request*/, ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAdminUpdateBinaryOptionsMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket,::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReclaimLockedFunds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReclaimLockedFunds() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgReclaimLockedFunds, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgReclaimLockedFunds, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>* streamer) {
                       return this->StreamedReclaimLockedFunds(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReclaimLockedFunds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReclaimLockedFunds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgReclaimLockedFunds* /*request*/, ::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReclaimLockedFunds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgReclaimLockedFunds,::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateParams() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MsgUpdateParams, ::injective::exchange::v1beta1::MsgUpdateParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MsgUpdateParams, ::injective::exchange::v1beta1::MsgUpdateParamsResponse>* streamer) {
                       return this->StreamedUpdateParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MsgUpdateParams* /*request*/, ::injective::exchange::v1beta1::MsgUpdateParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MsgUpdateParams,::injective::exchange::v1beta1::MsgUpdateParamsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Deposit<WithStreamedUnaryMethod_Withdraw<WithStreamedUnaryMethod_InstantSpotMarketLaunch<WithStreamedUnaryMethod_InstantPerpetualMarketLaunch<WithStreamedUnaryMethod_InstantExpiryFuturesMarketLaunch<WithStreamedUnaryMethod_CreateSpotLimitOrder<WithStreamedUnaryMethod_BatchCreateSpotLimitOrders<WithStreamedUnaryMethod_CreateSpotMarketOrder<WithStreamedUnaryMethod_CancelSpotOrder<WithStreamedUnaryMethod_BatchCancelSpotOrders<WithStreamedUnaryMethod_BatchUpdateOrders<WithStreamedUnaryMethod_PrivilegedExecuteContract<WithStreamedUnaryMethod_CreateDerivativeLimitOrder<WithStreamedUnaryMethod_BatchCreateDerivativeLimitOrders<WithStreamedUnaryMethod_CreateDerivativeMarketOrder<WithStreamedUnaryMethod_CancelDerivativeOrder<WithStreamedUnaryMethod_BatchCancelDerivativeOrders<WithStreamedUnaryMethod_InstantBinaryOptionsMarketLaunch<WithStreamedUnaryMethod_CreateBinaryOptionsLimitOrder<WithStreamedUnaryMethod_CreateBinaryOptionsMarketOrder<WithStreamedUnaryMethod_CancelBinaryOptionsOrder<WithStreamedUnaryMethod_BatchCancelBinaryOptionsOrders<WithStreamedUnaryMethod_SubaccountTransfer<WithStreamedUnaryMethod_ExternalTransfer<WithStreamedUnaryMethod_LiquidatePosition<WithStreamedUnaryMethod_IncreasePositionMargin<WithStreamedUnaryMethod_RewardsOptOut<WithStreamedUnaryMethod_AdminUpdateBinaryOptionsMarket<WithStreamedUnaryMethod_ReclaimLockedFunds<WithStreamedUnaryMethod_UpdateParams<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Deposit<WithStreamedUnaryMethod_Withdraw<WithStreamedUnaryMethod_InstantSpotMarketLaunch<WithStreamedUnaryMethod_InstantPerpetualMarketLaunch<WithStreamedUnaryMethod_InstantExpiryFuturesMarketLaunch<WithStreamedUnaryMethod_CreateSpotLimitOrder<WithStreamedUnaryMethod_BatchCreateSpotLimitOrders<WithStreamedUnaryMethod_CreateSpotMarketOrder<WithStreamedUnaryMethod_CancelSpotOrder<WithStreamedUnaryMethod_BatchCancelSpotOrders<WithStreamedUnaryMethod_BatchUpdateOrders<WithStreamedUnaryMethod_PrivilegedExecuteContract<WithStreamedUnaryMethod_CreateDerivativeLimitOrder<WithStreamedUnaryMethod_BatchCreateDerivativeLimitOrders<WithStreamedUnaryMethod_CreateDerivativeMarketOrder<WithStreamedUnaryMethod_CancelDerivativeOrder<WithStreamedUnaryMethod_BatchCancelDerivativeOrders<WithStreamedUnaryMethod_InstantBinaryOptionsMarketLaunch<WithStreamedUnaryMethod_CreateBinaryOptionsLimitOrder<WithStreamedUnaryMethod_CreateBinaryOptionsMarketOrder<WithStreamedUnaryMethod_CancelBinaryOptionsOrder<WithStreamedUnaryMethod_BatchCancelBinaryOptionsOrders<WithStreamedUnaryMethod_SubaccountTransfer<WithStreamedUnaryMethod_ExternalTransfer<WithStreamedUnaryMethod_LiquidatePosition<WithStreamedUnaryMethod_IncreasePositionMargin<WithStreamedUnaryMethod_RewardsOptOut<WithStreamedUnaryMethod_AdminUpdateBinaryOptionsMarket<WithStreamedUnaryMethod_ReclaimLockedFunds<WithStreamedUnaryMethod_UpdateParams<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective


#endif  // GRPC_injective_2fexchange_2fv1beta1_2ftx_2eproto__INCLUDED
