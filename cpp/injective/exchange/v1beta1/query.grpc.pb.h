// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: injective/exchange/v1beta1/query.proto
#ifndef GRPC_injective_2fexchange_2fv1beta1_2fquery_2eproto__INCLUDED
#define GRPC_injective_2fexchange_2fv1beta1_2fquery_2eproto__INCLUDED

#include "injective/exchange/v1beta1/query.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace injective {
namespace exchange {
namespace v1beta1 {

// Query defines the gRPC querier service.
class Query final {
 public:
  static constexpr char const* service_full_name() {
    return "injective.exchange.v1beta1.Query";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Retrieves exchange params
    virtual ::grpc::Status QueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>> AsyncQueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>>(AsyncQueryExchangeParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>> PrepareAsyncQueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>>(PrepareAsyncQueryExchangeParamsRaw(context, request, cq));
    }
    // Retrieves a Subaccount's Deposits
    virtual ::grpc::Status SubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>> AsyncSubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>>(AsyncSubaccountDepositsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>> PrepareAsyncSubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>>(PrepareAsyncSubaccountDepositsRaw(context, request, cq));
    }
    // Retrieves a Subaccount's Deposits
    virtual ::grpc::Status SubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>> AsyncSubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>>(AsyncSubaccountDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>> PrepareAsyncSubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>>(PrepareAsyncSubaccountDepositRaw(context, request, cq));
    }
    // Retrieves all of the balances of all users on the exchange.
    virtual ::grpc::Status ExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>> AsyncExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>>(AsyncExchangeBalancesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>> PrepareAsyncExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>>(PrepareAsyncExchangeBalancesRaw(context, request, cq));
    }
    // Retrieves the aggregate volumes for the specified account or subaccount
    virtual ::grpc::Status AggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>> AsyncAggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>>(AsyncAggregateVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>> PrepareAsyncAggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>>(PrepareAsyncAggregateVolumeRaw(context, request, cq));
    }
    // Retrieves the aggregate volumes for specified accounts
    virtual ::grpc::Status AggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>> AsyncAggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>>(AsyncAggregateVolumesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>> PrepareAsyncAggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>>(PrepareAsyncAggregateVolumesRaw(context, request, cq));
    }
    // Retrieves the aggregate volume for the specified market
    virtual ::grpc::Status AggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>> AsyncAggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>>(AsyncAggregateMarketVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>> PrepareAsyncAggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>>(PrepareAsyncAggregateMarketVolumeRaw(context, request, cq));
    }
    // Retrieves the aggregate market volumes for specified markets
    virtual ::grpc::Status AggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>> AsyncAggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>>(AsyncAggregateMarketVolumesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>> PrepareAsyncAggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>>(PrepareAsyncAggregateMarketVolumesRaw(context, request, cq));
    }
    // Retrieves the denom decimals for a denom.
    virtual ::grpc::Status DenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>> AsyncDenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>>(AsyncDenomDecimalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>> PrepareAsyncDenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>>(PrepareAsyncDenomDecimalRaw(context, request, cq));
    }
    // Retrieves the denom decimals for multiple denoms. Returns all denom
    // decimals if unspecified.
    virtual ::grpc::Status DenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>> AsyncDenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>>(AsyncDenomDecimalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>> PrepareAsyncDenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>>(PrepareAsyncDenomDecimalsRaw(context, request, cq));
    }
    // Retrieves a list of spot markets.
    virtual ::grpc::Status SpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>> AsyncSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>>(AsyncSpotMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>> PrepareAsyncSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>>(PrepareAsyncSpotMarketsRaw(context, request, cq));
    }
    // Retrieves a spot market by ticker
    virtual ::grpc::Status SpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::injective::exchange::v1beta1::QuerySpotMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketResponse>> AsyncSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketResponse>>(AsyncSpotMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketResponse>> PrepareAsyncSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketResponse>>(PrepareAsyncSpotMarketRaw(context, request, cq));
    }
    // Retrieves a list of spot markets with extra information.
    virtual ::grpc::Status FullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>> AsyncFullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>>(AsyncFullSpotMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>> PrepareAsyncFullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>>(PrepareAsyncFullSpotMarketsRaw(context, request, cq));
    }
    // Retrieves a spot market with extra information.
    virtual ::grpc::Status FullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>> AsyncFullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>>(AsyncFullSpotMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>> PrepareAsyncFullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>>(PrepareAsyncFullSpotMarketRaw(context, request, cq));
    }
    // Retrieves a spot market's orderbook by marketID
    virtual ::grpc::Status SpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>> AsyncSpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>>(AsyncSpotOrderbookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>> PrepareAsyncSpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>>(PrepareAsyncSpotOrderbookRaw(context, request, cq));
    }
    // Retrieves a trader's spot orders
    virtual ::grpc::Status TraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>> AsyncTraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>>(AsyncTraderSpotOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>> PrepareAsyncTraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>>(PrepareAsyncTraderSpotOrdersRaw(context, request, cq));
    }
    // Retrieves all account address spot orders
    virtual ::grpc::Status AccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>> AsyncAccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>>(AsyncAccountAddressSpotOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>> PrepareAsyncAccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>>(PrepareAsyncAccountAddressSpotOrdersRaw(context, request, cq));
    }
    // Retrieves spot orders corresponding to specified order hashes for a given
    // subaccountID and marketID
    virtual ::grpc::Status SpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>> AsyncSpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>>(AsyncSpotOrdersByHashesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>> PrepareAsyncSpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>>(PrepareAsyncSpotOrdersByHashesRaw(context, request, cq));
    }
    // Retrieves subaccount's orders
    virtual ::grpc::Status SubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>> AsyncSubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>>(AsyncSubaccountOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>> PrepareAsyncSubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>>(PrepareAsyncSubaccountOrdersRaw(context, request, cq));
    }
    // Retrieves a trader's transient spot orders
    virtual ::grpc::Status TraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>> AsyncTraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>>(AsyncTraderSpotTransientOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>> PrepareAsyncTraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>>(PrepareAsyncTraderSpotTransientOrdersRaw(context, request, cq));
    }
    // Retrieves a spot market's mid-price
    virtual ::grpc::Status SpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>> AsyncSpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>>(AsyncSpotMidPriceAndTOBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>> PrepareAsyncSpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>>(PrepareAsyncSpotMidPriceAndTOBRaw(context, request, cq));
    }
    // Retrieves a derivative market's mid-price
    virtual ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>> AsyncDerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>>(AsyncDerivativeMidPriceAndTOBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>> PrepareAsyncDerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>>(PrepareAsyncDerivativeMidPriceAndTOBRaw(context, request, cq));
    }
    // Retrieves a derivative market's orderbook by marketID
    virtual ::grpc::Status DerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>> AsyncDerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>>(AsyncDerivativeOrderbookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>> PrepareAsyncDerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>>(PrepareAsyncDerivativeOrderbookRaw(context, request, cq));
    }
    // Retrieves a trader's derivative orders
    virtual ::grpc::Status TraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>> AsyncTraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>>(AsyncTraderDerivativeOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>> PrepareAsyncTraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>>(PrepareAsyncTraderDerivativeOrdersRaw(context, request, cq));
    }
    // Retrieves all account address derivative orders
    virtual ::grpc::Status AccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>> AsyncAccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>>(AsyncAccountAddressDerivativeOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>> PrepareAsyncAccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>>(PrepareAsyncAccountAddressDerivativeOrdersRaw(context, request, cq));
    }
    // Retrieves a trader's derivative orders
    virtual ::grpc::Status DerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>> AsyncDerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>>(AsyncDerivativeOrdersByHashesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>> PrepareAsyncDerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>>(PrepareAsyncDerivativeOrdersByHashesRaw(context, request, cq));
    }
    // Retrieves a trader's transient derivative orders
    virtual ::grpc::Status TraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>> AsyncTraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>>(AsyncTraderDerivativeTransientOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>> PrepareAsyncTraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>>(PrepareAsyncTraderDerivativeTransientOrdersRaw(context, request, cq));
    }
    // Retrieves a list of derivative markets.
    virtual ::grpc::Status DerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>> AsyncDerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>>(AsyncDerivativeMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>> PrepareAsyncDerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>>(PrepareAsyncDerivativeMarketsRaw(context, request, cq));
    }
    // Retrieves a derivative market by ticker
    virtual ::grpc::Status DerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>> AsyncDerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>>(AsyncDerivativeMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>> PrepareAsyncDerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>>(PrepareAsyncDerivativeMarketRaw(context, request, cq));
    }
    // Retrieves a derivative market's corresponding address for fees that
    // contribute to the market's insurance fund
    virtual ::grpc::Status DerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>> AsyncDerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>>(AsyncDerivativeMarketAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>> PrepareAsyncDerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>>(PrepareAsyncDerivativeMarketAddressRaw(context, request, cq));
    }
    // Retrieves a subaccount's trade nonce
    virtual ::grpc::Status SubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>> AsyncSubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>>(AsyncSubaccountTradeNonceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>> PrepareAsyncSubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>>(PrepareAsyncSubaccountTradeNonceRaw(context, request, cq));
    }
    // Retrieves the entire exchange module's state
    virtual ::grpc::Status ExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::injective::exchange::v1beta1::QueryModuleStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryModuleStateResponse>> AsyncExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryModuleStateResponse>>(AsyncExchangeModuleStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryModuleStateResponse>> PrepareAsyncExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryModuleStateResponse>>(PrepareAsyncExchangeModuleStateRaw(context, request, cq));
    }
    // Retrieves the entire exchange module's positions
    virtual ::grpc::Status Positions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::injective::exchange::v1beta1::QueryPositionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPositionsResponse>> AsyncPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPositionsResponse>>(AsyncPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPositionsResponse>> PrepareAsyncPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPositionsResponse>>(PrepareAsyncPositionsRaw(context, request, cq));
    }
    // Retrieves subaccount's positions
    virtual ::grpc::Status SubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>> AsyncSubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>>(AsyncSubaccountPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>> PrepareAsyncSubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>>(PrepareAsyncSubaccountPositionsRaw(context, request, cq));
    }
    // Retrieves subaccount's position in market
    virtual ::grpc::Status SubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>> AsyncSubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>>(AsyncSubaccountPositionInMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>> PrepareAsyncSubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>>(PrepareAsyncSubaccountPositionInMarketRaw(context, request, cq));
    }
    // Retrieves subaccount's position in market
    virtual ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>> AsyncSubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>>(AsyncSubaccountEffectivePositionInMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>> PrepareAsyncSubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>>(PrepareAsyncSubaccountEffectivePositionInMarketRaw(context, request, cq));
    }
    // Retrieves perpetual market info
    virtual ::grpc::Status PerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>> AsyncPerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>>(AsyncPerpetualMarketInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>> PrepareAsyncPerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>>(PrepareAsyncPerpetualMarketInfoRaw(context, request, cq));
    }
    // Retrieves expiry market info
    virtual ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>> AsyncExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>>(AsyncExpiryFuturesMarketInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>> PrepareAsyncExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>>(PrepareAsyncExpiryFuturesMarketInfoRaw(context, request, cq));
    }
    // Retrieves perpetual market funding
    virtual ::grpc::Status PerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>> AsyncPerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>>(AsyncPerpetualMarketFundingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>> PrepareAsyncPerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>>(PrepareAsyncPerpetualMarketFundingRaw(context, request, cq));
    }
    // Retrieves subaccount's order metadata
    virtual ::grpc::Status SubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>> AsyncSubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>>(AsyncSubaccountOrderMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>> PrepareAsyncSubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>>(PrepareAsyncSubaccountOrderMetadataRaw(context, request, cq));
    }
    // Retrieves the account and total trade rewards points
    virtual ::grpc::Status TradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>> AsyncTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>>(AsyncTradeRewardPointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>> PrepareAsyncTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>>(PrepareAsyncTradeRewardPointsRaw(context, request, cq));
    }
    // Retrieves the pending account and total trade rewards points
    virtual ::grpc::Status PendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>> AsyncPendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>>(AsyncPendingTradeRewardPointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>> PrepareAsyncPendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>>(PrepareAsyncPendingTradeRewardPointsRaw(context, request, cq));
    }
    // Retrieves the trade reward campaign
    virtual ::grpc::Status TradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>> AsyncTradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>>(AsyncTradeRewardCampaignRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>> PrepareAsyncTradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>>(PrepareAsyncTradeRewardCampaignRaw(context, request, cq));
    }
    // Retrieves the account's fee discount info
    virtual ::grpc::Status FeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>> AsyncFeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>>(AsyncFeeDiscountAccountInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>> PrepareAsyncFeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>>(PrepareAsyncFeeDiscountAccountInfoRaw(context, request, cq));
    }
    // Retrieves the fee discount schedule
    virtual ::grpc::Status FeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>> AsyncFeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>>(AsyncFeeDiscountScheduleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>> PrepareAsyncFeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>>(PrepareAsyncFeeDiscountScheduleRaw(context, request, cq));
    }
    // Retrieves mismatches between available vs. total balance
    virtual ::grpc::Status BalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>> AsyncBalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>>(AsyncBalanceMismatchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>> PrepareAsyncBalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>>(PrepareAsyncBalanceMismatchesRaw(context, request, cq));
    }
    // Retrieves available and total balances with balance holds
    virtual ::grpc::Status BalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>> AsyncBalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>>(AsyncBalanceWithBalanceHoldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>> PrepareAsyncBalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>>(PrepareAsyncBalanceWithBalanceHoldsRaw(context, request, cq));
    }
    // Retrieves fee discount tier stats
    virtual ::grpc::Status FeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>> AsyncFeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>>(AsyncFeeDiscountTierStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>> PrepareAsyncFeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>>(PrepareAsyncFeeDiscountTierStatisticsRaw(context, request, cq));
    }
    // Retrieves market making pool info
    virtual ::grpc::Status MitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::injective::exchange::v1beta1::MitoVaultInfosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MitoVaultInfosResponse>> AsyncMitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MitoVaultInfosResponse>>(AsyncMitoVaultInfosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MitoVaultInfosResponse>> PrepareAsyncMitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MitoVaultInfosResponse>>(PrepareAsyncMitoVaultInfosRaw(context, request, cq));
    }
    // QueryMarketIDFromVault returns the market ID for a given vault subaccount ID
    virtual ::grpc::Status QueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>> AsyncQueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>>(AsyncQueryMarketIDFromVaultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>> PrepareAsyncQueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>>(PrepareAsyncQueryMarketIDFromVaultRaw(context, request, cq));
    }
    // Retrieves historical trade records for a given market ID
    virtual ::grpc::Status HistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>> AsyncHistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>>(AsyncHistoricalTradeRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>> PrepareAsyncHistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>>(PrepareAsyncHistoricalTradeRecordsRaw(context, request, cq));
    }
    // Retrieves if the account is opted out of rewards
    virtual ::grpc::Status IsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>> AsyncIsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>>(AsyncIsOptedOutOfRewardsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>> PrepareAsyncIsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>>(PrepareAsyncIsOptedOutOfRewardsRaw(context, request, cq));
    }
    // Retrieves all accounts opted out of rewards
    virtual ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>> AsyncOptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>>(AsyncOptedOutOfRewardsAccountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>> PrepareAsyncOptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>>(PrepareAsyncOptedOutOfRewardsAccountsRaw(context, request, cq));
    }
    // MarketVolatility computes the volatility for spot and derivative markets
    // trading history.
    virtual ::grpc::Status MarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>> AsyncMarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>>(AsyncMarketVolatilityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>> PrepareAsyncMarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>>(PrepareAsyncMarketVolatilityRaw(context, request, cq));
    }
    // Retrieves a spot market's orderbook by marketID
    virtual ::grpc::Status BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>> AsyncBinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>>(AsyncBinaryOptionsMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>> PrepareAsyncBinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>>(PrepareAsyncBinaryOptionsMarketsRaw(context, request, cq));
    }
    // Retrieves a trader's derivative conditional orders
    virtual ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>> AsyncTraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>>(AsyncTraderDerivativeConditionalOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>> PrepareAsyncTraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>>(PrepareAsyncTraderDerivativeConditionalOrdersRaw(context, request, cq));
    }
    virtual ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>> AsyncMarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>>(AsyncMarketAtomicExecutionFeeMultiplierRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>> PrepareAsyncMarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>>(PrepareAsyncMarketAtomicExecutionFeeMultiplierRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Retrieves exchange params
      virtual void QueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* request, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* request, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a Subaccount's Deposits
      virtual void SubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a Subaccount's Deposits
      virtual void SubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves all of the balances of all users on the exchange.
      virtual void ExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* request, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* request, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the aggregate volumes for the specified account or subaccount
      virtual void AggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the aggregate volumes for specified accounts
      virtual void AggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the aggregate volume for the specified market
      virtual void AggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the aggregate market volumes for specified markets
      virtual void AggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the denom decimals for a denom.
      virtual void DenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the denom decimals for multiple denoms. Returns all denom
      // decimals if unspecified.
      virtual void DenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a list of spot markets.
      virtual void SpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a spot market by ticker
      virtual void SpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a list of spot markets with extra information.
      virtual void FullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a spot market with extra information.
      virtual void FullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a spot market's orderbook by marketID
      virtual void SpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* request, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* request, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a trader's spot orders
      virtual void TraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves all account address spot orders
      virtual void AccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves spot orders corresponding to specified order hashes for a given
      // subaccountID and marketID
      virtual void SpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves subaccount's orders
      virtual void SubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a trader's transient spot orders
      virtual void TraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a spot market's mid-price
      virtual void SpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a derivative market's mid-price
      virtual void DerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a derivative market's orderbook by marketID
      virtual void DerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a trader's derivative orders
      virtual void TraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves all account address derivative orders
      virtual void AccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a trader's derivative orders
      virtual void DerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a trader's transient derivative orders
      virtual void TraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a list of derivative markets.
      virtual void DerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a derivative market by ticker
      virtual void DerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a derivative market's corresponding address for fees that
      // contribute to the market's insurance fund
      virtual void DerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a subaccount's trade nonce
      virtual void SubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* request, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* request, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the entire exchange module's state
      virtual void ExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest* request, ::injective::exchange::v1beta1::QueryModuleStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest* request, ::injective::exchange::v1beta1::QueryModuleStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the entire exchange module's positions
      virtual void Positions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest* request, ::injective::exchange::v1beta1::QueryPositionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Positions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest* request, ::injective::exchange::v1beta1::QueryPositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves subaccount's positions
      virtual void SubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves subaccount's position in market
      virtual void SubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves subaccount's position in market
      virtual void SubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves perpetual market info
      virtual void PerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves expiry market info
      virtual void ExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves perpetual market funding
      virtual void PerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves subaccount's order metadata
      virtual void SubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the account and total trade rewards points
      virtual void TradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the pending account and total trade rewards points
      virtual void PendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the trade reward campaign
      virtual void TradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the account's fee discount info
      virtual void FeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves the fee discount schedule
      virtual void FeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves mismatches between available vs. total balance
      virtual void BalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* request, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* request, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves available and total balances with balance holds
      virtual void BalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* request, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* request, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves fee discount tier stats
      virtual void FeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves market making pool info
      virtual void MitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* request, ::injective::exchange::v1beta1::MitoVaultInfosResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* request, ::injective::exchange::v1beta1::MitoVaultInfosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // QueryMarketIDFromVault returns the market ID for a given vault subaccount ID
      virtual void QueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* request, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* request, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves historical trade records for a given market ID
      virtual void HistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* request, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* request, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves if the account is opted out of rewards
      virtual void IsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* request, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* request, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves all accounts opted out of rewards
      virtual void OptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* request, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void OptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* request, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // MarketVolatility computes the volatility for spot and derivative markets
      // trading history.
      virtual void MarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* request, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* request, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a spot market's orderbook by marketID
      virtual void BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* request, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* request, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a trader's derivative conditional orders
      virtual void TraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* request, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* request, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>* AsyncQueryExchangeParamsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>* PrepareAsyncQueryExchangeParamsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>* AsyncSubaccountDepositsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>* PrepareAsyncSubaccountDepositsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>* AsyncSubaccountDepositRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>* PrepareAsyncSubaccountDepositRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>* AsyncExchangeBalancesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>* PrepareAsyncExchangeBalancesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>* AsyncAggregateVolumeRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>* PrepareAsyncAggregateVolumeRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>* AsyncAggregateVolumesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>* PrepareAsyncAggregateVolumesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>* AsyncAggregateMarketVolumeRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>* PrepareAsyncAggregateMarketVolumeRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>* AsyncAggregateMarketVolumesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>* PrepareAsyncAggregateMarketVolumesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>* AsyncDenomDecimalRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>* PrepareAsyncDenomDecimalRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>* AsyncDenomDecimalsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>* PrepareAsyncDenomDecimalsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>* AsyncSpotMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>* PrepareAsyncSpotMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketResponse>* AsyncSpotMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMarketResponse>* PrepareAsyncSpotMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>* AsyncFullSpotMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>* PrepareAsyncFullSpotMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>* AsyncFullSpotMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>* PrepareAsyncFullSpotMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>* AsyncSpotOrderbookRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>* PrepareAsyncSpotOrderbookRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* AsyncTraderSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* PrepareAsyncTraderSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>* AsyncAccountAddressSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>* PrepareAsyncAccountAddressSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>* AsyncSpotOrdersByHashesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>* PrepareAsyncSpotOrdersByHashesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>* AsyncSubaccountOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>* PrepareAsyncSubaccountOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* AsyncTraderSpotTransientOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* PrepareAsyncTraderSpotTransientOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>* AsyncSpotMidPriceAndTOBRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>* PrepareAsyncSpotMidPriceAndTOBRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>* AsyncDerivativeMidPriceAndTOBRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>* PrepareAsyncDerivativeMidPriceAndTOBRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>* AsyncDerivativeOrderbookRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>* PrepareAsyncDerivativeOrderbookRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* AsyncTraderDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* PrepareAsyncTraderDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>* AsyncAccountAddressDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>* PrepareAsyncAccountAddressDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>* AsyncDerivativeOrdersByHashesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>* PrepareAsyncDerivativeOrdersByHashesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* AsyncTraderDerivativeTransientOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* PrepareAsyncTraderDerivativeTransientOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>* AsyncDerivativeMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>* PrepareAsyncDerivativeMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>* AsyncDerivativeMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>* PrepareAsyncDerivativeMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>* AsyncDerivativeMarketAddressRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>* PrepareAsyncDerivativeMarketAddressRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>* AsyncSubaccountTradeNonceRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>* PrepareAsyncSubaccountTradeNonceRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryModuleStateResponse>* AsyncExchangeModuleStateRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryModuleStateResponse>* PrepareAsyncExchangeModuleStateRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPositionsResponse>* AsyncPositionsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPositionsResponse>* PrepareAsyncPositionsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>* AsyncSubaccountPositionsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>* PrepareAsyncSubaccountPositionsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>* AsyncSubaccountPositionInMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>* PrepareAsyncSubaccountPositionInMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>* AsyncSubaccountEffectivePositionInMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>* PrepareAsyncSubaccountEffectivePositionInMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>* AsyncPerpetualMarketInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>* PrepareAsyncPerpetualMarketInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>* AsyncExpiryFuturesMarketInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>* PrepareAsyncExpiryFuturesMarketInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>* AsyncPerpetualMarketFundingRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>* PrepareAsyncPerpetualMarketFundingRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>* AsyncSubaccountOrderMetadataRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>* PrepareAsyncSubaccountOrderMetadataRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* AsyncTradeRewardPointsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* PrepareAsyncTradeRewardPointsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* AsyncPendingTradeRewardPointsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* PrepareAsyncPendingTradeRewardPointsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>* AsyncTradeRewardCampaignRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>* PrepareAsyncTradeRewardCampaignRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>* AsyncFeeDiscountAccountInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>* PrepareAsyncFeeDiscountAccountInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>* AsyncFeeDiscountScheduleRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>* PrepareAsyncFeeDiscountScheduleRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>* AsyncBalanceMismatchesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>* PrepareAsyncBalanceMismatchesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>* AsyncBalanceWithBalanceHoldsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>* PrepareAsyncBalanceWithBalanceHoldsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>* AsyncFeeDiscountTierStatisticsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>* PrepareAsyncFeeDiscountTierStatisticsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MitoVaultInfosResponse>* AsyncMitoVaultInfosRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::MitoVaultInfosResponse>* PrepareAsyncMitoVaultInfosRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>* AsyncQueryMarketIDFromVaultRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>* PrepareAsyncQueryMarketIDFromVaultRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>* AsyncHistoricalTradeRecordsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>* PrepareAsyncHistoricalTradeRecordsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>* AsyncIsOptedOutOfRewardsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>* PrepareAsyncIsOptedOutOfRewardsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>* AsyncOptedOutOfRewardsAccountsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>* PrepareAsyncOptedOutOfRewardsAccountsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>* AsyncMarketVolatilityRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>* PrepareAsyncMarketVolatilityRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>* AsyncBinaryOptionsMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>* PrepareAsyncBinaryOptionsMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>* AsyncTraderDerivativeConditionalOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>* PrepareAsyncTraderDerivativeConditionalOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>* AsyncMarketAtomicExecutionFeeMultiplierRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>* PrepareAsyncMarketAtomicExecutionFeeMultiplierRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status QueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>> AsyncQueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>>(AsyncQueryExchangeParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>> PrepareAsyncQueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>>(PrepareAsyncQueryExchangeParamsRaw(context, request, cq));
    }
    ::grpc::Status SubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>> AsyncSubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>>(AsyncSubaccountDepositsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>> PrepareAsyncSubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>>(PrepareAsyncSubaccountDepositsRaw(context, request, cq));
    }
    ::grpc::Status SubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>> AsyncSubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>>(AsyncSubaccountDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>> PrepareAsyncSubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>>(PrepareAsyncSubaccountDepositRaw(context, request, cq));
    }
    ::grpc::Status ExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>> AsyncExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>>(AsyncExchangeBalancesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>> PrepareAsyncExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>>(PrepareAsyncExchangeBalancesRaw(context, request, cq));
    }
    ::grpc::Status AggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>> AsyncAggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>>(AsyncAggregateVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>> PrepareAsyncAggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>>(PrepareAsyncAggregateVolumeRaw(context, request, cq));
    }
    ::grpc::Status AggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>> AsyncAggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>>(AsyncAggregateVolumesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>> PrepareAsyncAggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>>(PrepareAsyncAggregateVolumesRaw(context, request, cq));
    }
    ::grpc::Status AggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>> AsyncAggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>>(AsyncAggregateMarketVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>> PrepareAsyncAggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>>(PrepareAsyncAggregateMarketVolumeRaw(context, request, cq));
    }
    ::grpc::Status AggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>> AsyncAggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>>(AsyncAggregateMarketVolumesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>> PrepareAsyncAggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>>(PrepareAsyncAggregateMarketVolumesRaw(context, request, cq));
    }
    ::grpc::Status DenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>> AsyncDenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>>(AsyncDenomDecimalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>> PrepareAsyncDenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>>(PrepareAsyncDenomDecimalRaw(context, request, cq));
    }
    ::grpc::Status DenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>> AsyncDenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>>(AsyncDenomDecimalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>> PrepareAsyncDenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>>(PrepareAsyncDenomDecimalsRaw(context, request, cq));
    }
    ::grpc::Status SpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>> AsyncSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>>(AsyncSpotMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>> PrepareAsyncSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>>(PrepareAsyncSpotMarketsRaw(context, request, cq));
    }
    ::grpc::Status SpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::injective::exchange::v1beta1::QuerySpotMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketResponse>> AsyncSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketResponse>>(AsyncSpotMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketResponse>> PrepareAsyncSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketResponse>>(PrepareAsyncSpotMarketRaw(context, request, cq));
    }
    ::grpc::Status FullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>> AsyncFullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>>(AsyncFullSpotMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>> PrepareAsyncFullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>>(PrepareAsyncFullSpotMarketsRaw(context, request, cq));
    }
    ::grpc::Status FullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>> AsyncFullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>>(AsyncFullSpotMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>> PrepareAsyncFullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>>(PrepareAsyncFullSpotMarketRaw(context, request, cq));
    }
    ::grpc::Status SpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>> AsyncSpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>>(AsyncSpotOrderbookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>> PrepareAsyncSpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>>(PrepareAsyncSpotOrderbookRaw(context, request, cq));
    }
    ::grpc::Status TraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>> AsyncTraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>>(AsyncTraderSpotOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>> PrepareAsyncTraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>>(PrepareAsyncTraderSpotOrdersRaw(context, request, cq));
    }
    ::grpc::Status AccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>> AsyncAccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>>(AsyncAccountAddressSpotOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>> PrepareAsyncAccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>>(PrepareAsyncAccountAddressSpotOrdersRaw(context, request, cq));
    }
    ::grpc::Status SpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>> AsyncSpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>>(AsyncSpotOrdersByHashesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>> PrepareAsyncSpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>>(PrepareAsyncSpotOrdersByHashesRaw(context, request, cq));
    }
    ::grpc::Status SubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>> AsyncSubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>>(AsyncSubaccountOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>> PrepareAsyncSubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>>(PrepareAsyncSubaccountOrdersRaw(context, request, cq));
    }
    ::grpc::Status TraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>> AsyncTraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>>(AsyncTraderSpotTransientOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>> PrepareAsyncTraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>>(PrepareAsyncTraderSpotTransientOrdersRaw(context, request, cq));
    }
    ::grpc::Status SpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>> AsyncSpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>>(AsyncSpotMidPriceAndTOBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>> PrepareAsyncSpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>>(PrepareAsyncSpotMidPriceAndTOBRaw(context, request, cq));
    }
    ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>> AsyncDerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>>(AsyncDerivativeMidPriceAndTOBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>> PrepareAsyncDerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>>(PrepareAsyncDerivativeMidPriceAndTOBRaw(context, request, cq));
    }
    ::grpc::Status DerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>> AsyncDerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>>(AsyncDerivativeOrderbookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>> PrepareAsyncDerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>>(PrepareAsyncDerivativeOrderbookRaw(context, request, cq));
    }
    ::grpc::Status TraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>> AsyncTraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>>(AsyncTraderDerivativeOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>> PrepareAsyncTraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>>(PrepareAsyncTraderDerivativeOrdersRaw(context, request, cq));
    }
    ::grpc::Status AccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>> AsyncAccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>>(AsyncAccountAddressDerivativeOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>> PrepareAsyncAccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>>(PrepareAsyncAccountAddressDerivativeOrdersRaw(context, request, cq));
    }
    ::grpc::Status DerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>> AsyncDerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>>(AsyncDerivativeOrdersByHashesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>> PrepareAsyncDerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>>(PrepareAsyncDerivativeOrdersByHashesRaw(context, request, cq));
    }
    ::grpc::Status TraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>> AsyncTraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>>(AsyncTraderDerivativeTransientOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>> PrepareAsyncTraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>>(PrepareAsyncTraderDerivativeTransientOrdersRaw(context, request, cq));
    }
    ::grpc::Status DerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>> AsyncDerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>>(AsyncDerivativeMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>> PrepareAsyncDerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>>(PrepareAsyncDerivativeMarketsRaw(context, request, cq));
    }
    ::grpc::Status DerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>> AsyncDerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>>(AsyncDerivativeMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>> PrepareAsyncDerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>>(PrepareAsyncDerivativeMarketRaw(context, request, cq));
    }
    ::grpc::Status DerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>> AsyncDerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>>(AsyncDerivativeMarketAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>> PrepareAsyncDerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>>(PrepareAsyncDerivativeMarketAddressRaw(context, request, cq));
    }
    ::grpc::Status SubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>> AsyncSubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>>(AsyncSubaccountTradeNonceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>> PrepareAsyncSubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>>(PrepareAsyncSubaccountTradeNonceRaw(context, request, cq));
    }
    ::grpc::Status ExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::injective::exchange::v1beta1::QueryModuleStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryModuleStateResponse>> AsyncExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryModuleStateResponse>>(AsyncExchangeModuleStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryModuleStateResponse>> PrepareAsyncExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryModuleStateResponse>>(PrepareAsyncExchangeModuleStateRaw(context, request, cq));
    }
    ::grpc::Status Positions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::injective::exchange::v1beta1::QueryPositionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPositionsResponse>> AsyncPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPositionsResponse>>(AsyncPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPositionsResponse>> PrepareAsyncPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPositionsResponse>>(PrepareAsyncPositionsRaw(context, request, cq));
    }
    ::grpc::Status SubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>> AsyncSubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>>(AsyncSubaccountPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>> PrepareAsyncSubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>>(PrepareAsyncSubaccountPositionsRaw(context, request, cq));
    }
    ::grpc::Status SubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>> AsyncSubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>>(AsyncSubaccountPositionInMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>> PrepareAsyncSubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>>(PrepareAsyncSubaccountPositionInMarketRaw(context, request, cq));
    }
    ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>> AsyncSubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>>(AsyncSubaccountEffectivePositionInMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>> PrepareAsyncSubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>>(PrepareAsyncSubaccountEffectivePositionInMarketRaw(context, request, cq));
    }
    ::grpc::Status PerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>> AsyncPerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>>(AsyncPerpetualMarketInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>> PrepareAsyncPerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>>(PrepareAsyncPerpetualMarketInfoRaw(context, request, cq));
    }
    ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>> AsyncExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>>(AsyncExpiryFuturesMarketInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>> PrepareAsyncExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>>(PrepareAsyncExpiryFuturesMarketInfoRaw(context, request, cq));
    }
    ::grpc::Status PerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>> AsyncPerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>>(AsyncPerpetualMarketFundingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>> PrepareAsyncPerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>>(PrepareAsyncPerpetualMarketFundingRaw(context, request, cq));
    }
    ::grpc::Status SubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>> AsyncSubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>>(AsyncSubaccountOrderMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>> PrepareAsyncSubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>>(PrepareAsyncSubaccountOrderMetadataRaw(context, request, cq));
    }
    ::grpc::Status TradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>> AsyncTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>>(AsyncTradeRewardPointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>> PrepareAsyncTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>>(PrepareAsyncTradeRewardPointsRaw(context, request, cq));
    }
    ::grpc::Status PendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>> AsyncPendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>>(AsyncPendingTradeRewardPointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>> PrepareAsyncPendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>>(PrepareAsyncPendingTradeRewardPointsRaw(context, request, cq));
    }
    ::grpc::Status TradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>> AsyncTradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>>(AsyncTradeRewardCampaignRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>> PrepareAsyncTradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>>(PrepareAsyncTradeRewardCampaignRaw(context, request, cq));
    }
    ::grpc::Status FeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>> AsyncFeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>>(AsyncFeeDiscountAccountInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>> PrepareAsyncFeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>>(PrepareAsyncFeeDiscountAccountInfoRaw(context, request, cq));
    }
    ::grpc::Status FeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>> AsyncFeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>>(AsyncFeeDiscountScheduleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>> PrepareAsyncFeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>>(PrepareAsyncFeeDiscountScheduleRaw(context, request, cq));
    }
    ::grpc::Status BalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>> AsyncBalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>>(AsyncBalanceMismatchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>> PrepareAsyncBalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>>(PrepareAsyncBalanceMismatchesRaw(context, request, cq));
    }
    ::grpc::Status BalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>> AsyncBalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>>(AsyncBalanceWithBalanceHoldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>> PrepareAsyncBalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>>(PrepareAsyncBalanceWithBalanceHoldsRaw(context, request, cq));
    }
    ::grpc::Status FeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>> AsyncFeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>>(AsyncFeeDiscountTierStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>> PrepareAsyncFeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>>(PrepareAsyncFeeDiscountTierStatisticsRaw(context, request, cq));
    }
    ::grpc::Status MitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::injective::exchange::v1beta1::MitoVaultInfosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MitoVaultInfosResponse>> AsyncMitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MitoVaultInfosResponse>>(AsyncMitoVaultInfosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MitoVaultInfosResponse>> PrepareAsyncMitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MitoVaultInfosResponse>>(PrepareAsyncMitoVaultInfosRaw(context, request, cq));
    }
    ::grpc::Status QueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>> AsyncQueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>>(AsyncQueryMarketIDFromVaultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>> PrepareAsyncQueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>>(PrepareAsyncQueryMarketIDFromVaultRaw(context, request, cq));
    }
    ::grpc::Status HistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>> AsyncHistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>>(AsyncHistoricalTradeRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>> PrepareAsyncHistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>>(PrepareAsyncHistoricalTradeRecordsRaw(context, request, cq));
    }
    ::grpc::Status IsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>> AsyncIsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>>(AsyncIsOptedOutOfRewardsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>> PrepareAsyncIsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>>(PrepareAsyncIsOptedOutOfRewardsRaw(context, request, cq));
    }
    ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>> AsyncOptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>>(AsyncOptedOutOfRewardsAccountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>> PrepareAsyncOptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>>(PrepareAsyncOptedOutOfRewardsAccountsRaw(context, request, cq));
    }
    ::grpc::Status MarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>> AsyncMarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>>(AsyncMarketVolatilityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>> PrepareAsyncMarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>>(PrepareAsyncMarketVolatilityRaw(context, request, cq));
    }
    ::grpc::Status BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>> AsyncBinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>>(AsyncBinaryOptionsMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>> PrepareAsyncBinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>>(PrepareAsyncBinaryOptionsMarketsRaw(context, request, cq));
    }
    ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>> AsyncTraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>>(AsyncTraderDerivativeConditionalOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>> PrepareAsyncTraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>>(PrepareAsyncTraderDerivativeConditionalOrdersRaw(context, request, cq));
    }
    ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>> AsyncMarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>>(AsyncMarketAtomicExecutionFeeMultiplierRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>> PrepareAsyncMarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>>(PrepareAsyncMarketAtomicExecutionFeeMultiplierRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void QueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* request, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void QueryExchangeParams(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* request, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountDeposits(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountDeposit(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* request, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* response, std::function<void(::grpc::Status)>) override;
      void ExchangeBalances(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* request, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void AggregateVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* response, std::function<void(::grpc::Status)>) override;
      void AggregateVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void AggregateMarketVolume(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* response, std::function<void(::grpc::Status)>) override;
      void AggregateMarketVolumes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* response, std::function<void(::grpc::Status)>) override;
      void DenomDecimal(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* response, std::function<void(::grpc::Status)>) override;
      void DenomDecimals(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* response, std::function<void(::grpc::Status)>) override;
      void SpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketResponse* response, std::function<void(::grpc::Status)>) override;
      void SpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* response, std::function<void(::grpc::Status)>) override;
      void FullSpotMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* response, std::function<void(::grpc::Status)>) override;
      void FullSpotMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* request, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* response, std::function<void(::grpc::Status)>) override;
      void SpotOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* request, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void TraderSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void AccountAddressSpotOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* response, std::function<void(::grpc::Status)>) override;
      void SpotOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void TraderSpotTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* response, std::function<void(::grpc::Status)>) override;
      void SpotMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* response, std::function<void(::grpc::Status)>) override;
      void DerivativeMidPriceAndTOB(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* response, std::function<void(::grpc::Status)>) override;
      void DerivativeOrderbook(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void TraderDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void AccountAddressDerivativeOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* response, std::function<void(::grpc::Status)>) override;
      void DerivativeOrdersByHashes(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void TraderDerivativeTransientOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* response, std::function<void(::grpc::Status)>) override;
      void DerivativeMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* response, std::function<void(::grpc::Status)>) override;
      void DerivativeMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* response, std::function<void(::grpc::Status)>) override;
      void DerivativeMarketAddress(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* request, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountTradeNonce(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* request, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest* request, ::injective::exchange::v1beta1::QueryModuleStateResponse* response, std::function<void(::grpc::Status)>) override;
      void ExchangeModuleState(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest* request, ::injective::exchange::v1beta1::QueryModuleStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Positions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest* request, ::injective::exchange::v1beta1::QueryPositionsResponse* response, std::function<void(::grpc::Status)>) override;
      void Positions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest* request, ::injective::exchange::v1beta1::QueryPositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountPositions(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountPositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountEffectivePositionInMarket(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void PerpetualMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void ExpiryFuturesMarketInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* response, std::function<void(::grpc::Status)>) override;
      void PerpetualMarketFunding(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountOrderMetadata(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response, std::function<void(::grpc::Status)>) override;
      void TradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response, std::function<void(::grpc::Status)>) override;
      void PendingTradeRewardPoints(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* response, std::function<void(::grpc::Status)>) override;
      void TradeRewardCampaign(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void FeeDiscountAccountInfo(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* response, std::function<void(::grpc::Status)>) override;
      void FeeDiscountSchedule(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* request, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* response, std::function<void(::grpc::Status)>) override;
      void BalanceMismatches(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* request, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* request, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* response, std::function<void(::grpc::Status)>) override;
      void BalanceWithBalanceHolds(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* request, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* response, std::function<void(::grpc::Status)>) override;
      void FeeDiscountTierStatistics(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* request, ::injective::exchange::v1beta1::MitoVaultInfosResponse* response, std::function<void(::grpc::Status)>) override;
      void MitoVaultInfos(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* request, ::injective::exchange::v1beta1::MitoVaultInfosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void QueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* request, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* response, std::function<void(::grpc::Status)>) override;
      void QueryMarketIDFromVault(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* request, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* request, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* response, std::function<void(::grpc::Status)>) override;
      void HistoricalTradeRecords(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* request, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* request, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* response, std::function<void(::grpc::Status)>) override;
      void IsOptedOutOfRewards(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* request, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void OptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* request, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* response, std::function<void(::grpc::Status)>) override;
      void OptedOutOfRewardsAccounts(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* request, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* request, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* response, std::function<void(::grpc::Status)>) override;
      void MarketVolatility(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* request, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* request, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* response, std::function<void(::grpc::Status)>) override;
      void BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* request, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void TraderDerivativeConditionalOrders(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* request, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* response, std::function<void(::grpc::Status)>) override;
      void MarketAtomicExecutionFeeMultiplier(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* request, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>* AsyncQueryExchangeParamsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>* PrepareAsyncQueryExchangeParamsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>* AsyncSubaccountDepositsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>* PrepareAsyncSubaccountDepositsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>* AsyncSubaccountDepositRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>* PrepareAsyncSubaccountDepositRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>* AsyncExchangeBalancesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>* PrepareAsyncExchangeBalancesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>* AsyncAggregateVolumeRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>* PrepareAsyncAggregateVolumeRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>* AsyncAggregateVolumesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>* PrepareAsyncAggregateVolumesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>* AsyncAggregateMarketVolumeRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>* PrepareAsyncAggregateMarketVolumeRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>* AsyncAggregateMarketVolumesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>* PrepareAsyncAggregateMarketVolumesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>* AsyncDenomDecimalRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>* PrepareAsyncDenomDecimalRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>* AsyncDenomDecimalsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>* PrepareAsyncDenomDecimalsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>* AsyncSpotMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>* PrepareAsyncSpotMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketResponse>* AsyncSpotMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMarketResponse>* PrepareAsyncSpotMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>* AsyncFullSpotMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>* PrepareAsyncFullSpotMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>* AsyncFullSpotMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>* PrepareAsyncFullSpotMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>* AsyncSpotOrderbookRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>* PrepareAsyncSpotOrderbookRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* AsyncTraderSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* PrepareAsyncTraderSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>* AsyncAccountAddressSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>* PrepareAsyncAccountAddressSpotOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>* AsyncSpotOrdersByHashesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>* PrepareAsyncSpotOrdersByHashesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>* AsyncSubaccountOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>* PrepareAsyncSubaccountOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* AsyncTraderSpotTransientOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* PrepareAsyncTraderSpotTransientOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>* AsyncSpotMidPriceAndTOBRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>* PrepareAsyncSpotMidPriceAndTOBRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>* AsyncDerivativeMidPriceAndTOBRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>* PrepareAsyncDerivativeMidPriceAndTOBRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>* AsyncDerivativeOrderbookRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>* PrepareAsyncDerivativeOrderbookRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* AsyncTraderDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* PrepareAsyncTraderDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>* AsyncAccountAddressDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>* PrepareAsyncAccountAddressDerivativeOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>* AsyncDerivativeOrdersByHashesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>* PrepareAsyncDerivativeOrdersByHashesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* AsyncTraderDerivativeTransientOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* PrepareAsyncTraderDerivativeTransientOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>* AsyncDerivativeMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>* PrepareAsyncDerivativeMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>* AsyncDerivativeMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>* PrepareAsyncDerivativeMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>* AsyncDerivativeMarketAddressRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>* PrepareAsyncDerivativeMarketAddressRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>* AsyncSubaccountTradeNonceRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>* PrepareAsyncSubaccountTradeNonceRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryModuleStateResponse>* AsyncExchangeModuleStateRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryModuleStateResponse>* PrepareAsyncExchangeModuleStateRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPositionsResponse>* AsyncPositionsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPositionsResponse>* PrepareAsyncPositionsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>* AsyncSubaccountPositionsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>* PrepareAsyncSubaccountPositionsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>* AsyncSubaccountPositionInMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>* PrepareAsyncSubaccountPositionInMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>* AsyncSubaccountEffectivePositionInMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>* PrepareAsyncSubaccountEffectivePositionInMarketRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>* AsyncPerpetualMarketInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>* PrepareAsyncPerpetualMarketInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>* AsyncExpiryFuturesMarketInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>* PrepareAsyncExpiryFuturesMarketInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>* AsyncPerpetualMarketFundingRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>* PrepareAsyncPerpetualMarketFundingRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>* AsyncSubaccountOrderMetadataRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>* PrepareAsyncSubaccountOrderMetadataRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* AsyncTradeRewardPointsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* PrepareAsyncTradeRewardPointsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* AsyncPendingTradeRewardPointsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* PrepareAsyncPendingTradeRewardPointsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>* AsyncTradeRewardCampaignRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>* PrepareAsyncTradeRewardCampaignRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>* AsyncFeeDiscountAccountInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>* PrepareAsyncFeeDiscountAccountInfoRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>* AsyncFeeDiscountScheduleRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>* PrepareAsyncFeeDiscountScheduleRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>* AsyncBalanceMismatchesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>* PrepareAsyncBalanceMismatchesRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>* AsyncBalanceWithBalanceHoldsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>* PrepareAsyncBalanceWithBalanceHoldsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>* AsyncFeeDiscountTierStatisticsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>* PrepareAsyncFeeDiscountTierStatisticsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MitoVaultInfosResponse>* AsyncMitoVaultInfosRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::MitoVaultInfosResponse>* PrepareAsyncMitoVaultInfosRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>* AsyncQueryMarketIDFromVaultRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>* PrepareAsyncQueryMarketIDFromVaultRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>* AsyncHistoricalTradeRecordsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>* PrepareAsyncHistoricalTradeRecordsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>* AsyncIsOptedOutOfRewardsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>* PrepareAsyncIsOptedOutOfRewardsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>* AsyncOptedOutOfRewardsAccountsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>* PrepareAsyncOptedOutOfRewardsAccountsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>* AsyncMarketVolatilityRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>* PrepareAsyncMarketVolatilityRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>* AsyncBinaryOptionsMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>* PrepareAsyncBinaryOptionsMarketsRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>* AsyncTraderDerivativeConditionalOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>* PrepareAsyncTraderDerivativeConditionalOrdersRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>* AsyncMarketAtomicExecutionFeeMultiplierRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>* PrepareAsyncMarketAtomicExecutionFeeMultiplierRaw(::grpc::ClientContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_QueryExchangeParams_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountDeposits_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountDeposit_;
    const ::grpc::internal::RpcMethod rpcmethod_ExchangeBalances_;
    const ::grpc::internal::RpcMethod rpcmethod_AggregateVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_AggregateVolumes_;
    const ::grpc::internal::RpcMethod rpcmethod_AggregateMarketVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_AggregateMarketVolumes_;
    const ::grpc::internal::RpcMethod rpcmethod_DenomDecimal_;
    const ::grpc::internal::RpcMethod rpcmethod_DenomDecimals_;
    const ::grpc::internal::RpcMethod rpcmethod_SpotMarkets_;
    const ::grpc::internal::RpcMethod rpcmethod_SpotMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_FullSpotMarkets_;
    const ::grpc::internal::RpcMethod rpcmethod_FullSpotMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_SpotOrderbook_;
    const ::grpc::internal::RpcMethod rpcmethod_TraderSpotOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_AccountAddressSpotOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_SpotOrdersByHashes_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_TraderSpotTransientOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_SpotMidPriceAndTOB_;
    const ::grpc::internal::RpcMethod rpcmethod_DerivativeMidPriceAndTOB_;
    const ::grpc::internal::RpcMethod rpcmethod_DerivativeOrderbook_;
    const ::grpc::internal::RpcMethod rpcmethod_TraderDerivativeOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_AccountAddressDerivativeOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_DerivativeOrdersByHashes_;
    const ::grpc::internal::RpcMethod rpcmethod_TraderDerivativeTransientOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_DerivativeMarkets_;
    const ::grpc::internal::RpcMethod rpcmethod_DerivativeMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_DerivativeMarketAddress_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountTradeNonce_;
    const ::grpc::internal::RpcMethod rpcmethod_ExchangeModuleState_;
    const ::grpc::internal::RpcMethod rpcmethod_Positions_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountPositions_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountPositionInMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountEffectivePositionInMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_PerpetualMarketInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ExpiryFuturesMarketInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_PerpetualMarketFunding_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountOrderMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_TradeRewardPoints_;
    const ::grpc::internal::RpcMethod rpcmethod_PendingTradeRewardPoints_;
    const ::grpc::internal::RpcMethod rpcmethod_TradeRewardCampaign_;
    const ::grpc::internal::RpcMethod rpcmethod_FeeDiscountAccountInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_FeeDiscountSchedule_;
    const ::grpc::internal::RpcMethod rpcmethod_BalanceMismatches_;
    const ::grpc::internal::RpcMethod rpcmethod_BalanceWithBalanceHolds_;
    const ::grpc::internal::RpcMethod rpcmethod_FeeDiscountTierStatistics_;
    const ::grpc::internal::RpcMethod rpcmethod_MitoVaultInfos_;
    const ::grpc::internal::RpcMethod rpcmethod_QueryMarketIDFromVault_;
    const ::grpc::internal::RpcMethod rpcmethod_HistoricalTradeRecords_;
    const ::grpc::internal::RpcMethod rpcmethod_IsOptedOutOfRewards_;
    const ::grpc::internal::RpcMethod rpcmethod_OptedOutOfRewardsAccounts_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketVolatility_;
    const ::grpc::internal::RpcMethod rpcmethod_BinaryOptionsMarkets_;
    const ::grpc::internal::RpcMethod rpcmethod_TraderDerivativeConditionalOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketAtomicExecutionFeeMultiplier_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Retrieves exchange params
    virtual ::grpc::Status QueryExchangeParams(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* request, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* response);
    // Retrieves a Subaccount's Deposits
    virtual ::grpc::Status SubaccountDeposits(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* response);
    // Retrieves a Subaccount's Deposits
    virtual ::grpc::Status SubaccountDeposit(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* response);
    // Retrieves all of the balances of all users on the exchange.
    virtual ::grpc::Status ExchangeBalances(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* request, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* response);
    // Retrieves the aggregate volumes for the specified account or subaccount
    virtual ::grpc::Status AggregateVolume(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* response);
    // Retrieves the aggregate volumes for specified accounts
    virtual ::grpc::Status AggregateVolumes(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* response);
    // Retrieves the aggregate volume for the specified market
    virtual ::grpc::Status AggregateMarketVolume(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* response);
    // Retrieves the aggregate market volumes for specified markets
    virtual ::grpc::Status AggregateMarketVolumes(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* response);
    // Retrieves the denom decimals for a denom.
    virtual ::grpc::Status DenomDecimal(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* response);
    // Retrieves the denom decimals for multiple denoms. Returns all denom
    // decimals if unspecified.
    virtual ::grpc::Status DenomDecimals(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* response);
    // Retrieves a list of spot markets.
    virtual ::grpc::Status SpotMarkets(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* response);
    // Retrieves a spot market by ticker
    virtual ::grpc::Status SpotMarket(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketResponse* response);
    // Retrieves a list of spot markets with extra information.
    virtual ::grpc::Status FullSpotMarkets(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* response);
    // Retrieves a spot market with extra information.
    virtual ::grpc::Status FullSpotMarket(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* response);
    // Retrieves a spot market's orderbook by marketID
    virtual ::grpc::Status SpotOrderbook(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* request, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* response);
    // Retrieves a trader's spot orders
    virtual ::grpc::Status TraderSpotOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response);
    // Retrieves all account address spot orders
    virtual ::grpc::Status AccountAddressSpotOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* response);
    // Retrieves spot orders corresponding to specified order hashes for a given
    // subaccountID and marketID
    virtual ::grpc::Status SpotOrdersByHashes(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* response);
    // Retrieves subaccount's orders
    virtual ::grpc::Status SubaccountOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* response);
    // Retrieves a trader's transient spot orders
    virtual ::grpc::Status TraderSpotTransientOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response);
    // Retrieves a spot market's mid-price
    virtual ::grpc::Status SpotMidPriceAndTOB(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* response);
    // Retrieves a derivative market's mid-price
    virtual ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* response);
    // Retrieves a derivative market's orderbook by marketID
    virtual ::grpc::Status DerivativeOrderbook(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* response);
    // Retrieves a trader's derivative orders
    virtual ::grpc::Status TraderDerivativeOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response);
    // Retrieves all account address derivative orders
    virtual ::grpc::Status AccountAddressDerivativeOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* response);
    // Retrieves a trader's derivative orders
    virtual ::grpc::Status DerivativeOrdersByHashes(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* response);
    // Retrieves a trader's transient derivative orders
    virtual ::grpc::Status TraderDerivativeTransientOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response);
    // Retrieves a list of derivative markets.
    virtual ::grpc::Status DerivativeMarkets(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* response);
    // Retrieves a derivative market by ticker
    virtual ::grpc::Status DerivativeMarket(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* response);
    // Retrieves a derivative market's corresponding address for fees that
    // contribute to the market's insurance fund
    virtual ::grpc::Status DerivativeMarketAddress(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* response);
    // Retrieves a subaccount's trade nonce
    virtual ::grpc::Status SubaccountTradeNonce(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* request, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* response);
    // Retrieves the entire exchange module's state
    virtual ::grpc::Status ExchangeModuleState(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest* request, ::injective::exchange::v1beta1::QueryModuleStateResponse* response);
    // Retrieves the entire exchange module's positions
    virtual ::grpc::Status Positions(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest* request, ::injective::exchange::v1beta1::QueryPositionsResponse* response);
    // Retrieves subaccount's positions
    virtual ::grpc::Status SubaccountPositions(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* response);
    // Retrieves subaccount's position in market
    virtual ::grpc::Status SubaccountPositionInMarket(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* response);
    // Retrieves subaccount's position in market
    virtual ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* response);
    // Retrieves perpetual market info
    virtual ::grpc::Status PerpetualMarketInfo(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* response);
    // Retrieves expiry market info
    virtual ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* response);
    // Retrieves perpetual market funding
    virtual ::grpc::Status PerpetualMarketFunding(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* response);
    // Retrieves subaccount's order metadata
    virtual ::grpc::Status SubaccountOrderMetadata(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* response);
    // Retrieves the account and total trade rewards points
    virtual ::grpc::Status TradeRewardPoints(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response);
    // Retrieves the pending account and total trade rewards points
    virtual ::grpc::Status PendingTradeRewardPoints(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response);
    // Retrieves the trade reward campaign
    virtual ::grpc::Status TradeRewardCampaign(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* response);
    // Retrieves the account's fee discount info
    virtual ::grpc::Status FeeDiscountAccountInfo(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* response);
    // Retrieves the fee discount schedule
    virtual ::grpc::Status FeeDiscountSchedule(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* response);
    // Retrieves mismatches between available vs. total balance
    virtual ::grpc::Status BalanceMismatches(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* request, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* response);
    // Retrieves available and total balances with balance holds
    virtual ::grpc::Status BalanceWithBalanceHolds(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* request, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* response);
    // Retrieves fee discount tier stats
    virtual ::grpc::Status FeeDiscountTierStatistics(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* response);
    // Retrieves market making pool info
    virtual ::grpc::Status MitoVaultInfos(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* request, ::injective::exchange::v1beta1::MitoVaultInfosResponse* response);
    // QueryMarketIDFromVault returns the market ID for a given vault subaccount ID
    virtual ::grpc::Status QueryMarketIDFromVault(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* request, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* response);
    // Retrieves historical trade records for a given market ID
    virtual ::grpc::Status HistoricalTradeRecords(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* request, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* response);
    // Retrieves if the account is opted out of rewards
    virtual ::grpc::Status IsOptedOutOfRewards(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* request, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* response);
    // Retrieves all accounts opted out of rewards
    virtual ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* request, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* response);
    // MarketVolatility computes the volatility for spot and derivative markets
    // trading history.
    virtual ::grpc::Status MarketVolatility(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* request, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* response);
    // Retrieves a spot market's orderbook by marketID
    virtual ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* request, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* response);
    // Retrieves a trader's derivative conditional orders
    virtual ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* response);
    virtual ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* request, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryExchangeParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryExchangeParams() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_QueryExchangeParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryExchangeParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryExchangeParams(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryExchangeParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryExchangeParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountDeposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountDeposits() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SubaccountDeposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposits(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountDeposits(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountDeposit() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SubaccountDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountDeposit(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExchangeBalances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExchangeBalances() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ExchangeBalances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeBalances(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExchangeBalances(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AggregateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AggregateVolume() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_AggregateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAggregateVolume(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AggregateVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AggregateVolumes() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_AggregateVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAggregateVolumes(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AggregateMarketVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AggregateMarketVolume() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_AggregateMarketVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAggregateMarketVolume(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AggregateMarketVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AggregateMarketVolumes() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_AggregateMarketVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAggregateMarketVolumes(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DenomDecimal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DenomDecimal() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_DenomDecimal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimal(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDenomDecimal(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryDenomDecimalRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryDenomDecimalResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DenomDecimals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DenomDecimals() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_DenomDecimals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimals(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDenomDecimals(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpotMarkets() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_SpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotMarkets(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySpotMarketsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySpotMarketsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpotMarket() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_SpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotMarket(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySpotMarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySpotMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FullSpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FullSpotMarkets() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_FullSpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFullSpotMarkets(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FullSpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FullSpotMarket() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_FullSpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFullSpotMarket(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpotOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpotOrderbook() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_SpotOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotOrderbook(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TraderSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TraderSpotOrders() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_TraderSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderSpotOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AccountAddressSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AccountAddressSpotOrders() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_AccountAddressSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccountAddressSpotOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpotOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpotOrdersByHashes() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_SpotOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotOrdersByHashes(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountOrders() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_SubaccountOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TraderSpotTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TraderSpotTransientOrders() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_TraderSpotTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderSpotTransientOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpotMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpotMidPriceAndTOB() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_SpotMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotMidPriceAndTOB(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DerivativeMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DerivativeMidPriceAndTOB() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_DerivativeMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeMidPriceAndTOB(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DerivativeOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DerivativeOrderbook() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_DerivativeOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeOrderbook(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TraderDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TraderDerivativeOrders() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_TraderDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderDerivativeOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AccountAddressDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AccountAddressDerivativeOrders() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_AccountAddressDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccountAddressDerivativeOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DerivativeOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DerivativeOrdersByHashes() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_DerivativeOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeOrdersByHashes(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TraderDerivativeTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TraderDerivativeTransientOrders() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_TraderDerivativeTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderDerivativeTransientOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DerivativeMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DerivativeMarkets() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_DerivativeMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeMarkets(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DerivativeMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DerivativeMarket() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_DerivativeMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeMarket(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DerivativeMarketAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DerivativeMarketAddress() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_DerivativeMarketAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarketAddress(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeMarketAddress(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountTradeNonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountTradeNonce() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_SubaccountTradeNonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradeNonce(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountTradeNonce(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExchangeModuleState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExchangeModuleState() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_ExchangeModuleState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeModuleState(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryModuleStateRequest* /*request*/, ::injective::exchange::v1beta1::QueryModuleStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExchangeModuleState(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryModuleStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryModuleStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Positions() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QueryPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositions(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryPositionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryPositionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountPositions() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_SubaccountPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountPositions(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountPositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountPositionInMarket() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_SubaccountPositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountPositionInMarket(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountEffectivePositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountEffectivePositionInMarket() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_SubaccountEffectivePositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountEffectivePositionInMarket(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PerpetualMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PerpetualMarketInfo() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_PerpetualMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPerpetualMarketInfo(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExpiryFuturesMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExpiryFuturesMarketInfo() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_ExpiryFuturesMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExpiryFuturesMarketInfo(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PerpetualMarketFunding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PerpetualMarketFunding() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_PerpetualMarketFunding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketFunding(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPerpetualMarketFunding(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountOrderMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountOrderMetadata() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_SubaccountOrderMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrderMetadata(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountOrderMetadata(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TradeRewardPoints() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_TradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradeRewardPoints(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PendingTradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PendingTradeRewardPoints() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_PendingTradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingTradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPendingTradeRewardPoints(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TradeRewardCampaign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TradeRewardCampaign() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_TradeRewardCampaign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardCampaign(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradeRewardCampaign(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FeeDiscountAccountInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FeeDiscountAccountInfo() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_FeeDiscountAccountInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountAccountInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeDiscountAccountInfo(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FeeDiscountSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FeeDiscountSchedule() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_FeeDiscountSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountSchedule(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeDiscountSchedule(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BalanceMismatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BalanceMismatches() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_BalanceMismatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceMismatches(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBalanceMismatches(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BalanceWithBalanceHolds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BalanceWithBalanceHolds() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_BalanceWithBalanceHolds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceWithBalanceHolds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBalanceWithBalanceHolds(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FeeDiscountTierStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FeeDiscountTierStatistics() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_FeeDiscountTierStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountTierStatistics(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeDiscountTierStatistics(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MitoVaultInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MitoVaultInfos() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_MitoVaultInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MitoVaultInfos(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* /*request*/, ::injective::exchange::v1beta1::MitoVaultInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMitoVaultInfos(::grpc::ServerContext* context, ::injective::exchange::v1beta1::MitoVaultInfosRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::MitoVaultInfosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryMarketIDFromVault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryMarketIDFromVault() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_QueryMarketIDFromVault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMarketIDFromVault(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryMarketIDFromVault(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HistoricalTradeRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HistoricalTradeRecords() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_HistoricalTradeRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HistoricalTradeRecords(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* /*request*/, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHistoricalTradeRecords(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsOptedOutOfRewards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsOptedOutOfRewards() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_IsOptedOutOfRewards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsOptedOutOfRewards(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* /*request*/, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsOptedOutOfRewards(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OptedOutOfRewardsAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OptedOutOfRewardsAccounts() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_OptedOutOfRewardsAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* /*request*/, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOptedOutOfRewardsAccounts(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketVolatility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketVolatility() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_MarketVolatility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketVolatility(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketVolatility(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBinaryOptionsMarkets(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TraderDerivativeConditionalOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TraderDerivativeConditionalOrders() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_TraderDerivativeConditionalOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderDerivativeConditionalOrders(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketAtomicExecutionFeeMultiplier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketAtomicExecutionFeeMultiplier() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_MarketAtomicExecutionFeeMultiplier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* context, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_QueryExchangeParams<WithAsyncMethod_SubaccountDeposits<WithAsyncMethod_SubaccountDeposit<WithAsyncMethod_ExchangeBalances<WithAsyncMethod_AggregateVolume<WithAsyncMethod_AggregateVolumes<WithAsyncMethod_AggregateMarketVolume<WithAsyncMethod_AggregateMarketVolumes<WithAsyncMethod_DenomDecimal<WithAsyncMethod_DenomDecimals<WithAsyncMethod_SpotMarkets<WithAsyncMethod_SpotMarket<WithAsyncMethod_FullSpotMarkets<WithAsyncMethod_FullSpotMarket<WithAsyncMethod_SpotOrderbook<WithAsyncMethod_TraderSpotOrders<WithAsyncMethod_AccountAddressSpotOrders<WithAsyncMethod_SpotOrdersByHashes<WithAsyncMethod_SubaccountOrders<WithAsyncMethod_TraderSpotTransientOrders<WithAsyncMethod_SpotMidPriceAndTOB<WithAsyncMethod_DerivativeMidPriceAndTOB<WithAsyncMethod_DerivativeOrderbook<WithAsyncMethod_TraderDerivativeOrders<WithAsyncMethod_AccountAddressDerivativeOrders<WithAsyncMethod_DerivativeOrdersByHashes<WithAsyncMethod_TraderDerivativeTransientOrders<WithAsyncMethod_DerivativeMarkets<WithAsyncMethod_DerivativeMarket<WithAsyncMethod_DerivativeMarketAddress<WithAsyncMethod_SubaccountTradeNonce<WithAsyncMethod_ExchangeModuleState<WithAsyncMethod_Positions<WithAsyncMethod_SubaccountPositions<WithAsyncMethod_SubaccountPositionInMarket<WithAsyncMethod_SubaccountEffectivePositionInMarket<WithAsyncMethod_PerpetualMarketInfo<WithAsyncMethod_ExpiryFuturesMarketInfo<WithAsyncMethod_PerpetualMarketFunding<WithAsyncMethod_SubaccountOrderMetadata<WithAsyncMethod_TradeRewardPoints<WithAsyncMethod_PendingTradeRewardPoints<WithAsyncMethod_TradeRewardCampaign<WithAsyncMethod_FeeDiscountAccountInfo<WithAsyncMethod_FeeDiscountSchedule<WithAsyncMethod_BalanceMismatches<WithAsyncMethod_BalanceWithBalanceHolds<WithAsyncMethod_FeeDiscountTierStatistics<WithAsyncMethod_MitoVaultInfos<WithAsyncMethod_QueryMarketIDFromVault<WithAsyncMethod_HistoricalTradeRecords<WithAsyncMethod_IsOptedOutOfRewards<WithAsyncMethod_OptedOutOfRewardsAccounts<WithAsyncMethod_MarketVolatility<WithAsyncMethod_BinaryOptionsMarkets<WithAsyncMethod_TraderDerivativeConditionalOrders<WithAsyncMethod_MarketAtomicExecutionFeeMultiplier<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_QueryExchangeParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_QueryExchangeParams() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryExchangeParamsRequest, ::injective::exchange::v1beta1::QueryExchangeParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* request, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* response) { return this->QueryExchangeParams(context, request, response); }));}
    void SetMessageAllocatorFor_QueryExchangeParams(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryExchangeParamsRequest, ::injective::exchange::v1beta1::QueryExchangeParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryExchangeParamsRequest, ::injective::exchange::v1beta1::QueryExchangeParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_QueryExchangeParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryExchangeParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryExchangeParams(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountDeposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountDeposits() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* response) { return this->SubaccountDeposits(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountDeposits(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountDeposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposits(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountDeposits(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountDeposit() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountDepositRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* request, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* response) { return this->SubaccountDeposit(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountDeposit(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySubaccountDepositRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountDepositRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountDeposit(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExchangeBalances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExchangeBalances() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryExchangeBalancesRequest, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* request, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* response) { return this->ExchangeBalances(context, request, response); }));}
    void SetMessageAllocatorFor_ExchangeBalances(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryExchangeBalancesRequest, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryExchangeBalancesRequest, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExchangeBalances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeBalances(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExchangeBalances(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AggregateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AggregateVolume() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAggregateVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* response) { return this->AggregateVolume(context, request, response); }));}
    void SetMessageAllocatorFor_AggregateVolume(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryAggregateVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAggregateVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AggregateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AggregateVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AggregateVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AggregateVolumes() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAggregateVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* response) { return this->AggregateVolumes(context, request, response); }));}
    void SetMessageAllocatorFor_AggregateVolumes(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryAggregateVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAggregateVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AggregateVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AggregateVolumes(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AggregateMarketVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AggregateMarketVolume() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* response) { return this->AggregateMarketVolume(context, request, response); }));}
    void SetMessageAllocatorFor_AggregateMarketVolume(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AggregateMarketVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AggregateMarketVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AggregateMarketVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AggregateMarketVolumes() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* request, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* response) { return this->AggregateMarketVolumes(context, request, response); }));}
    void SetMessageAllocatorFor_AggregateMarketVolumes(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AggregateMarketVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AggregateMarketVolumes(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DenomDecimal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DenomDecimal() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDenomDecimalRequest, ::injective::exchange::v1beta1::QueryDenomDecimalResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* response) { return this->DenomDecimal(context, request, response); }));}
    void SetMessageAllocatorFor_DenomDecimal(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryDenomDecimalRequest, ::injective::exchange::v1beta1::QueryDenomDecimalResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDenomDecimalRequest, ::injective::exchange::v1beta1::QueryDenomDecimalResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DenomDecimal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimal(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DenomDecimal(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DenomDecimals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DenomDecimals() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDenomDecimalsRequest, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* request, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* response) { return this->DenomDecimals(context, request, response); }));}
    void SetMessageAllocatorFor_DenomDecimals(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryDenomDecimalsRequest, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDenomDecimalsRequest, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DenomDecimals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimals(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DenomDecimals(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SpotMarkets() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotMarketsRequest, ::injective::exchange::v1beta1::QuerySpotMarketsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* response) { return this->SpotMarkets(context, request, response); }));}
    void SetMessageAllocatorFor_SpotMarkets(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySpotMarketsRequest, ::injective::exchange::v1beta1::QuerySpotMarketsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotMarketsRequest, ::injective::exchange::v1beta1::QuerySpotMarketsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SpotMarket() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotMarketRequest, ::injective::exchange::v1beta1::QuerySpotMarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* request, ::injective::exchange::v1beta1::QuerySpotMarketResponse* response) { return this->SpotMarket(context, request, response); }));}
    void SetMessageAllocatorFor_SpotMarket(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySpotMarketRequest, ::injective::exchange::v1beta1::QuerySpotMarketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotMarketRequest, ::injective::exchange::v1beta1::QuerySpotMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FullSpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FullSpotMarkets() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* response) { return this->FullSpotMarkets(context, request, response); }));}
    void SetMessageAllocatorFor_FullSpotMarkets(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FullSpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FullSpotMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FullSpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FullSpotMarket() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFullSpotMarketRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* request, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* response) { return this->FullSpotMarket(context, request, response); }));}
    void SetMessageAllocatorFor_FullSpotMarket(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryFullSpotMarketRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFullSpotMarketRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FullSpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FullSpotMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SpotOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SpotOrderbook() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotOrderbookRequest, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* request, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* response) { return this->SpotOrderbook(context, request, response); }));}
    void SetMessageAllocatorFor_SpotOrderbook(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySpotOrderbookRequest, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotOrderbookRequest, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SpotOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotOrderbook(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TraderSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TraderSpotOrders() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response) { return this->TraderSpotOrders(context, request, response); }));}
    void SetMessageAllocatorFor_TraderSpotOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TraderSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderSpotOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AccountAddressSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AccountAddressSpotOrders() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* response) { return this->AccountAddressSpotOrders(context, request, response); }));}
    void SetMessageAllocatorFor_AccountAddressSpotOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AccountAddressSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AccountAddressSpotOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SpotOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SpotOrdersByHashes() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* response) { return this->SpotOrdersByHashes(context, request, response); }));}
    void SetMessageAllocatorFor_SpotOrdersByHashes(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SpotOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotOrdersByHashes(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountOrders() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* response) { return this->SubaccountOrders(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TraderSpotTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TraderSpotTransientOrders() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* response) { return this->TraderSpotTransientOrders(context, request, response); }));}
    void SetMessageAllocatorFor_TraderSpotTransientOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TraderSpotTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderSpotTransientOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SpotMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SpotMidPriceAndTOB() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* response) { return this->SpotMidPriceAndTOB(context, request, response); }));}
    void SetMessageAllocatorFor_SpotMidPriceAndTOB(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SpotMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotMidPriceAndTOB(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DerivativeMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DerivativeMidPriceAndTOB() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* response) { return this->DerivativeMidPriceAndTOB(context, request, response); }));}
    void SetMessageAllocatorFor_DerivativeMidPriceAndTOB(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DerivativeMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeMidPriceAndTOB(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DerivativeOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DerivativeOrderbook() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* response) { return this->DerivativeOrderbook(context, request, response); }));}
    void SetMessageAllocatorFor_DerivativeOrderbook(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DerivativeOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeOrderbook(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TraderDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TraderDerivativeOrders() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response) { return this->TraderDerivativeOrders(context, request, response); }));}
    void SetMessageAllocatorFor_TraderDerivativeOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TraderDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderDerivativeOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AccountAddressDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AccountAddressDerivativeOrders() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* response) { return this->AccountAddressDerivativeOrders(context, request, response); }));}
    void SetMessageAllocatorFor_AccountAddressDerivativeOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AccountAddressDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AccountAddressDerivativeOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DerivativeOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DerivativeOrdersByHashes() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* request, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* response) { return this->DerivativeOrdersByHashes(context, request, response); }));}
    void SetMessageAllocatorFor_DerivativeOrdersByHashes(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DerivativeOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeOrdersByHashes(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TraderDerivativeTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TraderDerivativeTransientOrders() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* response) { return this->TraderDerivativeTransientOrders(context, request, response); }));}
    void SetMessageAllocatorFor_TraderDerivativeTransientOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TraderDerivativeTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderDerivativeTransientOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DerivativeMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DerivativeMarkets() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* response) { return this->DerivativeMarkets(context, request, response); }));}
    void SetMessageAllocatorFor_DerivativeMarkets(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DerivativeMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DerivativeMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DerivativeMarket() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeMarketRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* response) { return this->DerivativeMarket(context, request, response); }));}
    void SetMessageAllocatorFor_DerivativeMarket(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryDerivativeMarketRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeMarketRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DerivativeMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DerivativeMarketAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DerivativeMarketAddress() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* request, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* response) { return this->DerivativeMarketAddress(context, request, response); }));}
    void SetMessageAllocatorFor_DerivativeMarketAddress(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DerivativeMarketAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarketAddress(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeMarketAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountTradeNonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountTradeNonce() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* request, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* response) { return this->SubaccountTradeNonce(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountTradeNonce(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountTradeNonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradeNonce(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountTradeNonce(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExchangeModuleState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExchangeModuleState() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryModuleStateRequest, ::injective::exchange::v1beta1::QueryModuleStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryModuleStateRequest* request, ::injective::exchange::v1beta1::QueryModuleStateResponse* response) { return this->ExchangeModuleState(context, request, response); }));}
    void SetMessageAllocatorFor_ExchangeModuleState(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryModuleStateRequest, ::injective::exchange::v1beta1::QueryModuleStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryModuleStateRequest, ::injective::exchange::v1beta1::QueryModuleStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExchangeModuleState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeModuleState(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryModuleStateRequest* /*request*/, ::injective::exchange::v1beta1::QueryModuleStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExchangeModuleState(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryModuleStateRequest* /*request*/, ::injective::exchange::v1beta1::QueryModuleStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Positions() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryPositionsRequest, ::injective::exchange::v1beta1::QueryPositionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryPositionsRequest* request, ::injective::exchange::v1beta1::QueryPositionsResponse* response) { return this->Positions(context, request, response); }));}
    void SetMessageAllocatorFor_Positions(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryPositionsRequest, ::injective::exchange::v1beta1::QueryPositionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryPositionsRequest, ::injective::exchange::v1beta1::QueryPositionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QueryPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Positions(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QueryPositionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountPositions() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* response) { return this->SubaccountPositions(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountPositions(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountPositions(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountPositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountPositionInMarket() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* response) { return this->SubaccountPositionInMarket(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountPositionInMarket(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountPositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountPositionInMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountEffectivePositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountEffectivePositionInMarket() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* request, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* response) { return this->SubaccountEffectivePositionInMarket(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountEffectivePositionInMarket(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountEffectivePositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountEffectivePositionInMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PerpetualMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PerpetualMarketInfo() {
      ::grpc::Service::MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* response) { return this->PerpetualMarketInfo(context, request, response); }));}
    void SetMessageAllocatorFor_PerpetualMarketInfo(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PerpetualMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PerpetualMarketInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExpiryFuturesMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExpiryFuturesMarketInfo() {
      ::grpc::Service::MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* request, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* response) { return this->ExpiryFuturesMarketInfo(context, request, response); }));}
    void SetMessageAllocatorFor_ExpiryFuturesMarketInfo(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExpiryFuturesMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExpiryFuturesMarketInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PerpetualMarketFunding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PerpetualMarketFunding() {
      ::grpc::Service::MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* request, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* response) { return this->PerpetualMarketFunding(context, request, response); }));}
    void SetMessageAllocatorFor_PerpetualMarketFunding(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PerpetualMarketFunding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketFunding(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PerpetualMarketFunding(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountOrderMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountOrderMetadata() {
      ::grpc::Service::MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* request, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* response) { return this->SubaccountOrderMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountOrderMetadata(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountOrderMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrderMetadata(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountOrderMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TradeRewardPoints() {
      ::grpc::Service::MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response) { return this->TradeRewardPoints(context, request, response); }));}
    void SetMessageAllocatorFor_TradeRewardPoints(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TradeRewardPoints(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PendingTradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PendingTradeRewardPoints() {
      ::grpc::Service::MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* response) { return this->PendingTradeRewardPoints(context, request, response); }));}
    void SetMessageAllocatorFor_PendingTradeRewardPoints(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PendingTradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingTradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PendingTradeRewardPoints(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TradeRewardCampaign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TradeRewardCampaign() {
      ::grpc::Service::MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* request, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* response) { return this->TradeRewardCampaign(context, request, response); }));}
    void SetMessageAllocatorFor_TradeRewardCampaign(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TradeRewardCampaign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardCampaign(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TradeRewardCampaign(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FeeDiscountAccountInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FeeDiscountAccountInfo() {
      ::grpc::Service::MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* response) { return this->FeeDiscountAccountInfo(context, request, response); }));}
    void SetMessageAllocatorFor_FeeDiscountAccountInfo(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FeeDiscountAccountInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountAccountInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FeeDiscountAccountInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FeeDiscountSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FeeDiscountSchedule() {
      ::grpc::Service::MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* response) { return this->FeeDiscountSchedule(context, request, response); }));}
    void SetMessageAllocatorFor_FeeDiscountSchedule(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FeeDiscountSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountSchedule(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FeeDiscountSchedule(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BalanceMismatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BalanceMismatches() {
      ::grpc::Service::MarkMethodCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* request, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* response) { return this->BalanceMismatches(context, request, response); }));}
    void SetMessageAllocatorFor_BalanceMismatches(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BalanceMismatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceMismatches(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BalanceMismatches(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BalanceWithBalanceHolds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BalanceWithBalanceHolds() {
      ::grpc::Service::MarkMethodCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* request, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* response) { return this->BalanceWithBalanceHolds(context, request, response); }));}
    void SetMessageAllocatorFor_BalanceWithBalanceHolds(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BalanceWithBalanceHolds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceWithBalanceHolds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BalanceWithBalanceHolds(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FeeDiscountTierStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FeeDiscountTierStatistics() {
      ::grpc::Service::MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* request, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* response) { return this->FeeDiscountTierStatistics(context, request, response); }));}
    void SetMessageAllocatorFor_FeeDiscountTierStatistics(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FeeDiscountTierStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountTierStatistics(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FeeDiscountTierStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MitoVaultInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MitoVaultInfos() {
      ::grpc::Service::MarkMethodCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MitoVaultInfosRequest, ::injective::exchange::v1beta1::MitoVaultInfosResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* request, ::injective::exchange::v1beta1::MitoVaultInfosResponse* response) { return this->MitoVaultInfos(context, request, response); }));}
    void SetMessageAllocatorFor_MitoVaultInfos(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::MitoVaultInfosRequest, ::injective::exchange::v1beta1::MitoVaultInfosResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::MitoVaultInfosRequest, ::injective::exchange::v1beta1::MitoVaultInfosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MitoVaultInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MitoVaultInfos(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* /*request*/, ::injective::exchange::v1beta1::MitoVaultInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MitoVaultInfos(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* /*request*/, ::injective::exchange::v1beta1::MitoVaultInfosResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_QueryMarketIDFromVault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_QueryMarketIDFromVault() {
      ::grpc::Service::MarkMethodCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* request, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* response) { return this->QueryMarketIDFromVault(context, request, response); }));}
    void SetMessageAllocatorFor_QueryMarketIDFromVault(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_QueryMarketIDFromVault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMarketIDFromVault(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryMarketIDFromVault(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HistoricalTradeRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HistoricalTradeRecords() {
      ::grpc::Service::MarkMethodCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* request, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* response) { return this->HistoricalTradeRecords(context, request, response); }));}
    void SetMessageAllocatorFor_HistoricalTradeRecords(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HistoricalTradeRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HistoricalTradeRecords(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* /*request*/, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HistoricalTradeRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* /*request*/, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsOptedOutOfRewards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsOptedOutOfRewards() {
      ::grpc::Service::MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* request, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* response) { return this->IsOptedOutOfRewards(context, request, response); }));}
    void SetMessageAllocatorFor_IsOptedOutOfRewards(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsOptedOutOfRewards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsOptedOutOfRewards(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* /*request*/, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsOptedOutOfRewards(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* /*request*/, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OptedOutOfRewardsAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OptedOutOfRewardsAccounts() {
      ::grpc::Service::MarkMethodCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* request, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* response) { return this->OptedOutOfRewardsAccounts(context, request, response); }));}
    void SetMessageAllocatorFor_OptedOutOfRewardsAccounts(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_OptedOutOfRewardsAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* /*request*/, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* OptedOutOfRewardsAccounts(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* /*request*/, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MarketVolatility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MarketVolatility() {
      ::grpc::Service::MarkMethodCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryMarketVolatilityRequest, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* request, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* response) { return this->MarketVolatility(context, request, response); }));}
    void SetMessageAllocatorFor_MarketVolatility(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryMarketVolatilityRequest, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryMarketVolatilityRequest, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MarketVolatility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketVolatility(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MarketVolatility(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryBinaryMarketsRequest, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* request, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* response) { return this->BinaryOptionsMarkets(context, request, response); }));}
    void SetMessageAllocatorFor_BinaryOptionsMarkets(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryBinaryMarketsRequest, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(54);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryBinaryMarketsRequest, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BinaryOptionsMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TraderDerivativeConditionalOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TraderDerivativeConditionalOrders() {
      ::grpc::Service::MarkMethodCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* request, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* response) { return this->TraderDerivativeConditionalOrders(context, request, response); }));}
    void SetMessageAllocatorFor_TraderDerivativeConditionalOrders(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TraderDerivativeConditionalOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderDerivativeConditionalOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MarketAtomicExecutionFeeMultiplier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MarketAtomicExecutionFeeMultiplier() {
      ::grpc::Service::MarkMethodCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* request, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* response) { return this->MarketAtomicExecutionFeeMultiplier(context, request, response); }));}
    void SetMessageAllocatorFor_MarketAtomicExecutionFeeMultiplier(
        ::grpc::MessageAllocator< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MarketAtomicExecutionFeeMultiplier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MarketAtomicExecutionFeeMultiplier(
      ::grpc::CallbackServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_QueryExchangeParams<WithCallbackMethod_SubaccountDeposits<WithCallbackMethod_SubaccountDeposit<WithCallbackMethod_ExchangeBalances<WithCallbackMethod_AggregateVolume<WithCallbackMethod_AggregateVolumes<WithCallbackMethod_AggregateMarketVolume<WithCallbackMethod_AggregateMarketVolumes<WithCallbackMethod_DenomDecimal<WithCallbackMethod_DenomDecimals<WithCallbackMethod_SpotMarkets<WithCallbackMethod_SpotMarket<WithCallbackMethod_FullSpotMarkets<WithCallbackMethod_FullSpotMarket<WithCallbackMethod_SpotOrderbook<WithCallbackMethod_TraderSpotOrders<WithCallbackMethod_AccountAddressSpotOrders<WithCallbackMethod_SpotOrdersByHashes<WithCallbackMethod_SubaccountOrders<WithCallbackMethod_TraderSpotTransientOrders<WithCallbackMethod_SpotMidPriceAndTOB<WithCallbackMethod_DerivativeMidPriceAndTOB<WithCallbackMethod_DerivativeOrderbook<WithCallbackMethod_TraderDerivativeOrders<WithCallbackMethod_AccountAddressDerivativeOrders<WithCallbackMethod_DerivativeOrdersByHashes<WithCallbackMethod_TraderDerivativeTransientOrders<WithCallbackMethod_DerivativeMarkets<WithCallbackMethod_DerivativeMarket<WithCallbackMethod_DerivativeMarketAddress<WithCallbackMethod_SubaccountTradeNonce<WithCallbackMethod_ExchangeModuleState<WithCallbackMethod_Positions<WithCallbackMethod_SubaccountPositions<WithCallbackMethod_SubaccountPositionInMarket<WithCallbackMethod_SubaccountEffectivePositionInMarket<WithCallbackMethod_PerpetualMarketInfo<WithCallbackMethod_ExpiryFuturesMarketInfo<WithCallbackMethod_PerpetualMarketFunding<WithCallbackMethod_SubaccountOrderMetadata<WithCallbackMethod_TradeRewardPoints<WithCallbackMethod_PendingTradeRewardPoints<WithCallbackMethod_TradeRewardCampaign<WithCallbackMethod_FeeDiscountAccountInfo<WithCallbackMethod_FeeDiscountSchedule<WithCallbackMethod_BalanceMismatches<WithCallbackMethod_BalanceWithBalanceHolds<WithCallbackMethod_FeeDiscountTierStatistics<WithCallbackMethod_MitoVaultInfos<WithCallbackMethod_QueryMarketIDFromVault<WithCallbackMethod_HistoricalTradeRecords<WithCallbackMethod_IsOptedOutOfRewards<WithCallbackMethod_OptedOutOfRewardsAccounts<WithCallbackMethod_MarketVolatility<WithCallbackMethod_BinaryOptionsMarkets<WithCallbackMethod_TraderDerivativeConditionalOrders<WithCallbackMethod_MarketAtomicExecutionFeeMultiplier<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_QueryExchangeParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryExchangeParams() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_QueryExchangeParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryExchangeParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountDeposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountDeposits() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SubaccountDeposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposits(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountDeposit() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SubaccountDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExchangeBalances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExchangeBalances() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ExchangeBalances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeBalances(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AggregateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AggregateVolume() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_AggregateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AggregateVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AggregateVolumes() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_AggregateVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AggregateMarketVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AggregateMarketVolume() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_AggregateMarketVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AggregateMarketVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AggregateMarketVolumes() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_AggregateMarketVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DenomDecimal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DenomDecimal() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_DenomDecimal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimal(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DenomDecimals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DenomDecimals() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_DenomDecimals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimals(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpotMarkets() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_SpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpotMarket() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_SpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FullSpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FullSpotMarkets() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_FullSpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FullSpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FullSpotMarket() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_FullSpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpotOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpotOrderbook() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_SpotOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TraderSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TraderSpotOrders() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_TraderSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AccountAddressSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AccountAddressSpotOrders() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_AccountAddressSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpotOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpotOrdersByHashes() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_SpotOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountOrders() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_SubaccountOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TraderSpotTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TraderSpotTransientOrders() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_TraderSpotTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpotMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpotMidPriceAndTOB() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_SpotMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DerivativeMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DerivativeMidPriceAndTOB() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_DerivativeMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DerivativeOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DerivativeOrderbook() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_DerivativeOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TraderDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TraderDerivativeOrders() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_TraderDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AccountAddressDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AccountAddressDerivativeOrders() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_AccountAddressDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DerivativeOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DerivativeOrdersByHashes() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_DerivativeOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TraderDerivativeTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TraderDerivativeTransientOrders() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_TraderDerivativeTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DerivativeMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DerivativeMarkets() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_DerivativeMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DerivativeMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DerivativeMarket() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_DerivativeMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DerivativeMarketAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DerivativeMarketAddress() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_DerivativeMarketAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarketAddress(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountTradeNonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountTradeNonce() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_SubaccountTradeNonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradeNonce(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExchangeModuleState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExchangeModuleState() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_ExchangeModuleState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeModuleState(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryModuleStateRequest* /*request*/, ::injective::exchange::v1beta1::QueryModuleStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Positions() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QueryPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountPositions() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_SubaccountPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountPositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountPositionInMarket() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_SubaccountPositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountEffectivePositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountEffectivePositionInMarket() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_SubaccountEffectivePositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PerpetualMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PerpetualMarketInfo() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_PerpetualMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExpiryFuturesMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExpiryFuturesMarketInfo() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_ExpiryFuturesMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PerpetualMarketFunding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PerpetualMarketFunding() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_PerpetualMarketFunding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketFunding(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountOrderMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountOrderMetadata() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_SubaccountOrderMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrderMetadata(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TradeRewardPoints() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_TradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PendingTradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PendingTradeRewardPoints() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_PendingTradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingTradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TradeRewardCampaign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TradeRewardCampaign() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_TradeRewardCampaign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardCampaign(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FeeDiscountAccountInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FeeDiscountAccountInfo() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_FeeDiscountAccountInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountAccountInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FeeDiscountSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FeeDiscountSchedule() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_FeeDiscountSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountSchedule(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BalanceMismatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BalanceMismatches() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_BalanceMismatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceMismatches(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BalanceWithBalanceHolds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BalanceWithBalanceHolds() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_BalanceWithBalanceHolds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceWithBalanceHolds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FeeDiscountTierStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FeeDiscountTierStatistics() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_FeeDiscountTierStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountTierStatistics(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MitoVaultInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MitoVaultInfos() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_MitoVaultInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MitoVaultInfos(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* /*request*/, ::injective::exchange::v1beta1::MitoVaultInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QueryMarketIDFromVault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryMarketIDFromVault() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_QueryMarketIDFromVault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMarketIDFromVault(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HistoricalTradeRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HistoricalTradeRecords() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_HistoricalTradeRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HistoricalTradeRecords(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* /*request*/, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsOptedOutOfRewards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsOptedOutOfRewards() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_IsOptedOutOfRewards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsOptedOutOfRewards(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* /*request*/, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OptedOutOfRewardsAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OptedOutOfRewardsAccounts() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_OptedOutOfRewardsAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* /*request*/, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketVolatility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketVolatility() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_MarketVolatility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketVolatility(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TraderDerivativeConditionalOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TraderDerivativeConditionalOrders() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_TraderDerivativeConditionalOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketAtomicExecutionFeeMultiplier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketAtomicExecutionFeeMultiplier() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_MarketAtomicExecutionFeeMultiplier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryExchangeParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryExchangeParams() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_QueryExchangeParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryExchangeParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryExchangeParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountDeposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountDeposits() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SubaccountDeposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposits(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountDeposits(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountDeposit() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SubaccountDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountDeposit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExchangeBalances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExchangeBalances() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ExchangeBalances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeBalances(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExchangeBalances(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AggregateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AggregateVolume() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_AggregateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAggregateVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AggregateVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AggregateVolumes() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_AggregateVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAggregateVolumes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AggregateMarketVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AggregateMarketVolume() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_AggregateMarketVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAggregateMarketVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AggregateMarketVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AggregateMarketVolumes() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_AggregateMarketVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAggregateMarketVolumes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DenomDecimal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DenomDecimal() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_DenomDecimal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimal(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDenomDecimal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DenomDecimals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DenomDecimals() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_DenomDecimals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimals(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDenomDecimals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpotMarkets() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_SpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotMarkets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpotMarket() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_SpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FullSpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FullSpotMarkets() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_FullSpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFullSpotMarkets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FullSpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FullSpotMarket() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_FullSpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFullSpotMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpotOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpotOrderbook() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_SpotOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotOrderbook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TraderSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TraderSpotOrders() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_TraderSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderSpotOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AccountAddressSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AccountAddressSpotOrders() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_AccountAddressSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccountAddressSpotOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpotOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpotOrdersByHashes() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_SpotOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotOrdersByHashes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountOrders() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_SubaccountOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TraderSpotTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TraderSpotTransientOrders() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_TraderSpotTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderSpotTransientOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpotMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpotMidPriceAndTOB() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_SpotMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpotMidPriceAndTOB(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DerivativeMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DerivativeMidPriceAndTOB() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_DerivativeMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeMidPriceAndTOB(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DerivativeOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DerivativeOrderbook() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_DerivativeOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeOrderbook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TraderDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TraderDerivativeOrders() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_TraderDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderDerivativeOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AccountAddressDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AccountAddressDerivativeOrders() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_AccountAddressDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccountAddressDerivativeOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DerivativeOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DerivativeOrdersByHashes() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_DerivativeOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeOrdersByHashes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TraderDerivativeTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TraderDerivativeTransientOrders() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_TraderDerivativeTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderDerivativeTransientOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DerivativeMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DerivativeMarkets() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_DerivativeMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeMarkets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DerivativeMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DerivativeMarket() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_DerivativeMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DerivativeMarketAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DerivativeMarketAddress() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_DerivativeMarketAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarketAddress(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDerivativeMarketAddress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountTradeNonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountTradeNonce() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_SubaccountTradeNonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradeNonce(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountTradeNonce(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExchangeModuleState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExchangeModuleState() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_ExchangeModuleState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeModuleState(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryModuleStateRequest* /*request*/, ::injective::exchange::v1beta1::QueryModuleStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExchangeModuleState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Positions() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QueryPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountPositions() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_SubaccountPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountPositions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountPositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountPositionInMarket() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_SubaccountPositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountPositionInMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountEffectivePositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountEffectivePositionInMarket() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_SubaccountEffectivePositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountEffectivePositionInMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PerpetualMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PerpetualMarketInfo() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_PerpetualMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPerpetualMarketInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExpiryFuturesMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExpiryFuturesMarketInfo() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_ExpiryFuturesMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExpiryFuturesMarketInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PerpetualMarketFunding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PerpetualMarketFunding() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_PerpetualMarketFunding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketFunding(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPerpetualMarketFunding(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountOrderMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountOrderMetadata() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_SubaccountOrderMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrderMetadata(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountOrderMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TradeRewardPoints() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_TradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradeRewardPoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PendingTradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PendingTradeRewardPoints() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_PendingTradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingTradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPendingTradeRewardPoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TradeRewardCampaign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TradeRewardCampaign() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_TradeRewardCampaign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardCampaign(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradeRewardCampaign(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FeeDiscountAccountInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FeeDiscountAccountInfo() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_FeeDiscountAccountInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountAccountInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeDiscountAccountInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FeeDiscountSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FeeDiscountSchedule() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_FeeDiscountSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountSchedule(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeDiscountSchedule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BalanceMismatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BalanceMismatches() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_BalanceMismatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceMismatches(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBalanceMismatches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BalanceWithBalanceHolds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BalanceWithBalanceHolds() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_BalanceWithBalanceHolds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceWithBalanceHolds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBalanceWithBalanceHolds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FeeDiscountTierStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FeeDiscountTierStatistics() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_FeeDiscountTierStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountTierStatistics(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeDiscountTierStatistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MitoVaultInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MitoVaultInfos() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_MitoVaultInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MitoVaultInfos(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* /*request*/, ::injective::exchange::v1beta1::MitoVaultInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMitoVaultInfos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryMarketIDFromVault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryMarketIDFromVault() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_QueryMarketIDFromVault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMarketIDFromVault(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryMarketIDFromVault(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HistoricalTradeRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HistoricalTradeRecords() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_HistoricalTradeRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HistoricalTradeRecords(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* /*request*/, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHistoricalTradeRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsOptedOutOfRewards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsOptedOutOfRewards() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_IsOptedOutOfRewards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsOptedOutOfRewards(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* /*request*/, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsOptedOutOfRewards(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OptedOutOfRewardsAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OptedOutOfRewardsAccounts() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_OptedOutOfRewardsAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* /*request*/, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOptedOutOfRewardsAccounts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketVolatility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketVolatility() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_MarketVolatility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketVolatility(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketVolatility(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBinaryOptionsMarkets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TraderDerivativeConditionalOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TraderDerivativeConditionalOrders() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_TraderDerivativeConditionalOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTraderDerivativeConditionalOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketAtomicExecutionFeeMultiplier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketAtomicExecutionFeeMultiplier() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_MarketAtomicExecutionFeeMultiplier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_QueryExchangeParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_QueryExchangeParams() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryExchangeParams(context, request, response); }));
    }
    ~WithRawCallbackMethod_QueryExchangeParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryExchangeParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryExchangeParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountDeposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountDeposits() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountDeposits(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountDeposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposits(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountDeposits(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountDeposit() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountDeposit(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountDeposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountDeposit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExchangeBalances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExchangeBalances() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExchangeBalances(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExchangeBalances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeBalances(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExchangeBalances(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AggregateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AggregateVolume() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AggregateVolume(context, request, response); }));
    }
    ~WithRawCallbackMethod_AggregateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AggregateVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AggregateVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AggregateVolumes() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AggregateVolumes(context, request, response); }));
    }
    ~WithRawCallbackMethod_AggregateVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AggregateVolumes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AggregateMarketVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AggregateMarketVolume() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AggregateMarketVolume(context, request, response); }));
    }
    ~WithRawCallbackMethod_AggregateMarketVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AggregateMarketVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AggregateMarketVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AggregateMarketVolumes() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AggregateMarketVolumes(context, request, response); }));
    }
    ~WithRawCallbackMethod_AggregateMarketVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AggregateMarketVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AggregateMarketVolumes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DenomDecimal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DenomDecimal() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DenomDecimal(context, request, response); }));
    }
    ~WithRawCallbackMethod_DenomDecimal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimal(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DenomDecimal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DenomDecimals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DenomDecimals() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DenomDecimals(context, request, response); }));
    }
    ~WithRawCallbackMethod_DenomDecimals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DenomDecimals(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DenomDecimals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SpotMarkets() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SpotMarkets(context, request, response); }));
    }
    ~WithRawCallbackMethod_SpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SpotMarket() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SpotMarket(context, request, response); }));
    }
    ~WithRawCallbackMethod_SpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FullSpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FullSpotMarkets() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FullSpotMarkets(context, request, response); }));
    }
    ~WithRawCallbackMethod_FullSpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FullSpotMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FullSpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FullSpotMarket() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FullSpotMarket(context, request, response); }));
    }
    ~WithRawCallbackMethod_FullSpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullSpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FullSpotMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SpotOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SpotOrderbook() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SpotOrderbook(context, request, response); }));
    }
    ~WithRawCallbackMethod_SpotOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotOrderbook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TraderSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TraderSpotOrders() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TraderSpotOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_TraderSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderSpotOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AccountAddressSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AccountAddressSpotOrders() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AccountAddressSpotOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_AccountAddressSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AccountAddressSpotOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SpotOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SpotOrdersByHashes() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SpotOrdersByHashes(context, request, response); }));
    }
    ~WithRawCallbackMethod_SpotOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotOrdersByHashes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountOrders() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TraderSpotTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TraderSpotTransientOrders() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TraderSpotTransientOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_TraderSpotTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderSpotTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderSpotTransientOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SpotMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SpotMidPriceAndTOB() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SpotMidPriceAndTOB(context, request, response); }));
    }
    ~WithRawCallbackMethod_SpotMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpotMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpotMidPriceAndTOB(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DerivativeMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DerivativeMidPriceAndTOB() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DerivativeMidPriceAndTOB(context, request, response); }));
    }
    ~WithRawCallbackMethod_DerivativeMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeMidPriceAndTOB(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DerivativeOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DerivativeOrderbook() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DerivativeOrderbook(context, request, response); }));
    }
    ~WithRawCallbackMethod_DerivativeOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeOrderbook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TraderDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TraderDerivativeOrders() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TraderDerivativeOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_TraderDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderDerivativeOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AccountAddressDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AccountAddressDerivativeOrders() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AccountAddressDerivativeOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_AccountAddressDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountAddressDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AccountAddressDerivativeOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DerivativeOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DerivativeOrdersByHashes() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DerivativeOrdersByHashes(context, request, response); }));
    }
    ~WithRawCallbackMethod_DerivativeOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeOrdersByHashes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TraderDerivativeTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TraderDerivativeTransientOrders() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TraderDerivativeTransientOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_TraderDerivativeTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderDerivativeTransientOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DerivativeMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DerivativeMarkets() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DerivativeMarkets(context, request, response); }));
    }
    ~WithRawCallbackMethod_DerivativeMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DerivativeMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DerivativeMarket() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DerivativeMarket(context, request, response); }));
    }
    ~WithRawCallbackMethod_DerivativeMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DerivativeMarketAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DerivativeMarketAddress() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DerivativeMarketAddress(context, request, response); }));
    }
    ~WithRawCallbackMethod_DerivativeMarketAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DerivativeMarketAddress(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DerivativeMarketAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountTradeNonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountTradeNonce() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountTradeNonce(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountTradeNonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradeNonce(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountTradeNonce(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExchangeModuleState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExchangeModuleState() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExchangeModuleState(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExchangeModuleState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExchangeModuleState(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryModuleStateRequest* /*request*/, ::injective::exchange::v1beta1::QueryModuleStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExchangeModuleState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Positions() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Positions(context, request, response); }));
    }
    ~WithRawCallbackMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QueryPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Positions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountPositions() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountPositions(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountPositions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountPositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountPositionInMarket() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountPositionInMarket(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountPositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountPositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountPositionInMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountEffectivePositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountEffectivePositionInMarket() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountEffectivePositionInMarket(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountEffectivePositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountEffectivePositionInMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PerpetualMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PerpetualMarketInfo() {
      ::grpc::Service::MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PerpetualMarketInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_PerpetualMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PerpetualMarketInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExpiryFuturesMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExpiryFuturesMarketInfo() {
      ::grpc::Service::MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExpiryFuturesMarketInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExpiryFuturesMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExpiryFuturesMarketInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PerpetualMarketFunding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PerpetualMarketFunding() {
      ::grpc::Service::MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PerpetualMarketFunding(context, request, response); }));
    }
    ~WithRawCallbackMethod_PerpetualMarketFunding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PerpetualMarketFunding(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PerpetualMarketFunding(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountOrderMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountOrderMetadata() {
      ::grpc::Service::MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountOrderMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountOrderMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrderMetadata(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountOrderMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TradeRewardPoints() {
      ::grpc::Service::MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TradeRewardPoints(context, request, response); }));
    }
    ~WithRawCallbackMethod_TradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TradeRewardPoints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PendingTradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PendingTradeRewardPoints() {
      ::grpc::Service::MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PendingTradeRewardPoints(context, request, response); }));
    }
    ~WithRawCallbackMethod_PendingTradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingTradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PendingTradeRewardPoints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TradeRewardCampaign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TradeRewardCampaign() {
      ::grpc::Service::MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TradeRewardCampaign(context, request, response); }));
    }
    ~WithRawCallbackMethod_TradeRewardCampaign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradeRewardCampaign(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TradeRewardCampaign(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FeeDiscountAccountInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FeeDiscountAccountInfo() {
      ::grpc::Service::MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FeeDiscountAccountInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_FeeDiscountAccountInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountAccountInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FeeDiscountAccountInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FeeDiscountSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FeeDiscountSchedule() {
      ::grpc::Service::MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FeeDiscountSchedule(context, request, response); }));
    }
    ~WithRawCallbackMethod_FeeDiscountSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountSchedule(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FeeDiscountSchedule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BalanceMismatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BalanceMismatches() {
      ::grpc::Service::MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BalanceMismatches(context, request, response); }));
    }
    ~WithRawCallbackMethod_BalanceMismatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceMismatches(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BalanceMismatches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BalanceWithBalanceHolds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BalanceWithBalanceHolds() {
      ::grpc::Service::MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BalanceWithBalanceHolds(context, request, response); }));
    }
    ~WithRawCallbackMethod_BalanceWithBalanceHolds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BalanceWithBalanceHolds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BalanceWithBalanceHolds(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FeeDiscountTierStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FeeDiscountTierStatistics() {
      ::grpc::Service::MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FeeDiscountTierStatistics(context, request, response); }));
    }
    ~WithRawCallbackMethod_FeeDiscountTierStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeDiscountTierStatistics(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FeeDiscountTierStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MitoVaultInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MitoVaultInfos() {
      ::grpc::Service::MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MitoVaultInfos(context, request, response); }));
    }
    ~WithRawCallbackMethod_MitoVaultInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MitoVaultInfos(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* /*request*/, ::injective::exchange::v1beta1::MitoVaultInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MitoVaultInfos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_QueryMarketIDFromVault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_QueryMarketIDFromVault() {
      ::grpc::Service::MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryMarketIDFromVault(context, request, response); }));
    }
    ~WithRawCallbackMethod_QueryMarketIDFromVault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMarketIDFromVault(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryMarketIDFromVault(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HistoricalTradeRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HistoricalTradeRecords() {
      ::grpc::Service::MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HistoricalTradeRecords(context, request, response); }));
    }
    ~WithRawCallbackMethod_HistoricalTradeRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HistoricalTradeRecords(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* /*request*/, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HistoricalTradeRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsOptedOutOfRewards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsOptedOutOfRewards() {
      ::grpc::Service::MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsOptedOutOfRewards(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsOptedOutOfRewards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsOptedOutOfRewards(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* /*request*/, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsOptedOutOfRewards(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OptedOutOfRewardsAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OptedOutOfRewardsAccounts() {
      ::grpc::Service::MarkMethodRawCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OptedOutOfRewardsAccounts(context, request, response); }));
    }
    ~WithRawCallbackMethod_OptedOutOfRewardsAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* /*request*/, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* OptedOutOfRewardsAccounts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MarketVolatility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MarketVolatility() {
      ::grpc::Service::MarkMethodRawCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MarketVolatility(context, request, response); }));
    }
    ~WithRawCallbackMethod_MarketVolatility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketVolatility(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MarketVolatility(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodRawCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BinaryOptionsMarkets(context, request, response); }));
    }
    ~WithRawCallbackMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BinaryOptionsMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TraderDerivativeConditionalOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TraderDerivativeConditionalOrders() {
      ::grpc::Service::MarkMethodRawCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TraderDerivativeConditionalOrders(context, request, response); }));
    }
    ~WithRawCallbackMethod_TraderDerivativeConditionalOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TraderDerivativeConditionalOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MarketAtomicExecutionFeeMultiplier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MarketAtomicExecutionFeeMultiplier() {
      ::grpc::Service::MarkMethodRawCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MarketAtomicExecutionFeeMultiplier(context, request, response); }));
    }
    ~WithRawCallbackMethod_MarketAtomicExecutionFeeMultiplier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MarketAtomicExecutionFeeMultiplier(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryExchangeParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryExchangeParams() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryExchangeParamsRequest, ::injective::exchange::v1beta1::QueryExchangeParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryExchangeParamsRequest, ::injective::exchange::v1beta1::QueryExchangeParamsResponse>* streamer) {
                       return this->StreamedQueryExchangeParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QueryExchangeParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryExchangeParams(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeParamsRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryExchangeParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryExchangeParamsRequest,::injective::exchange::v1beta1::QueryExchangeParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountDeposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountDeposits() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>* streamer) {
                       return this->StreamedSubaccountDeposits(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountDeposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountDeposits(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountDeposits(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySubaccountDepositsRequest,::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountDeposit() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySubaccountDepositRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySubaccountDepositRequest, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse>* streamer) {
                       return this->StreamedSubaccountDeposit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountDeposit(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountDepositRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountDepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountDeposit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySubaccountDepositRequest,::injective::exchange::v1beta1::QuerySubaccountDepositResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExchangeBalances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExchangeBalances() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryExchangeBalancesRequest, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryExchangeBalancesRequest, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse>* streamer) {
                       return this->StreamedExchangeBalances(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExchangeBalances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExchangeBalances(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExchangeBalancesRequest* /*request*/, ::injective::exchange::v1beta1::QueryExchangeBalancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExchangeBalances(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryExchangeBalancesRequest,::injective::exchange::v1beta1::QueryExchangeBalancesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AggregateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AggregateVolume() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryAggregateVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryAggregateVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse>* streamer) {
                       return this->StreamedAggregateVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AggregateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AggregateVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAggregateVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryAggregateVolumeRequest,::injective::exchange::v1beta1::QueryAggregateVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AggregateVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AggregateVolumes() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryAggregateVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryAggregateVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse>* streamer) {
                       return this->StreamedAggregateVolumes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AggregateVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AggregateVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAggregateVolumes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryAggregateVolumesRequest,::injective::exchange::v1beta1::QueryAggregateVolumesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AggregateMarketVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AggregateMarketVolume() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>* streamer) {
                       return this->StreamedAggregateMarketVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AggregateMarketVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AggregateMarketVolume(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAggregateMarketVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest,::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AggregateMarketVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AggregateMarketVolumes() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>* streamer) {
                       return this->StreamedAggregateMarketVolumes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AggregateMarketVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AggregateMarketVolumes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* /*request*/, ::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAggregateMarketVolumes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest,::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DenomDecimal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DenomDecimal() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryDenomDecimalRequest, ::injective::exchange::v1beta1::QueryDenomDecimalResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryDenomDecimalRequest, ::injective::exchange::v1beta1::QueryDenomDecimalResponse>* streamer) {
                       return this->StreamedDenomDecimal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DenomDecimal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DenomDecimal(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDenomDecimal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryDenomDecimalRequest,::injective::exchange::v1beta1::QueryDenomDecimalResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DenomDecimals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DenomDecimals() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryDenomDecimalsRequest, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryDenomDecimalsRequest, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse>* streamer) {
                       return this->StreamedDenomDecimals(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DenomDecimals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DenomDecimals(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDenomDecimalsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDenomDecimalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDenomDecimals(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryDenomDecimalsRequest,::injective::exchange::v1beta1::QueryDenomDecimalsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SpotMarkets() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySpotMarketsRequest, ::injective::exchange::v1beta1::QuerySpotMarketsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySpotMarketsRequest, ::injective::exchange::v1beta1::QuerySpotMarketsResponse>* streamer) {
                       return this->StreamedSpotMarkets(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpotMarkets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySpotMarketsRequest,::injective::exchange::v1beta1::QuerySpotMarketsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SpotMarket() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySpotMarketRequest, ::injective::exchange::v1beta1::QuerySpotMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySpotMarketRequest, ::injective::exchange::v1beta1::QuerySpotMarketResponse>* streamer) {
                       return this->StreamedSpotMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpotMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySpotMarketRequest,::injective::exchange::v1beta1::QuerySpotMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FullSpotMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FullSpotMarkets() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>* streamer) {
                       return this->StreamedFullSpotMarkets(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FullSpotMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FullSpotMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFullSpotMarkets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryFullSpotMarketsRequest,::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FullSpotMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FullSpotMarket() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryFullSpotMarketRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryFullSpotMarketRequest, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse>* streamer) {
                       return this->StreamedFullSpotMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FullSpotMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FullSpotMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFullSpotMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryFullSpotMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFullSpotMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryFullSpotMarketRequest,::injective::exchange::v1beta1::QueryFullSpotMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpotOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SpotOrderbook() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySpotOrderbookRequest, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySpotOrderbookRequest, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse>* streamer) {
                       return this->StreamedSpotOrderbook(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SpotOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpotOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpotOrderbook(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySpotOrderbookRequest,::injective::exchange::v1beta1::QuerySpotOrderbookResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TraderSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TraderSpotOrders() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* streamer) {
                       return this->StreamedTraderSpotOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TraderSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TraderSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTraderSpotOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest,::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AccountAddressSpotOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AccountAddressSpotOrders() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>* streamer) {
                       return this->StreamedAccountAddressSpotOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AccountAddressSpotOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AccountAddressSpotOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAccountAddressSpotOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest,::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpotOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SpotOrdersByHashes() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>* streamer) {
                       return this->StreamedSpotOrdersByHashes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SpotOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpotOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpotOrdersByHashes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest,::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountOrders() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>* streamer) {
                       return this->StreamedSubaccountOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySubaccountOrdersRequest,::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TraderSpotTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TraderSpotTransientOrders() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* streamer) {
                       return this->StreamedTraderSpotTransientOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TraderSpotTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TraderSpotTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTraderSpotTransientOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest,::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpotMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SpotMidPriceAndTOB() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>* streamer) {
                       return this->StreamedSpotMidPriceAndTOB(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SpotMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpotMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpotMidPriceAndTOB(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest,::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DerivativeMidPriceAndTOB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DerivativeMidPriceAndTOB() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>* streamer) {
                       return this->StreamedDerivativeMidPriceAndTOB(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DerivativeMidPriceAndTOB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DerivativeMidPriceAndTOB(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDerivativeMidPriceAndTOB(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest,::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DerivativeOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DerivativeOrderbook() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>* streamer) {
                       return this->StreamedDerivativeOrderbook(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DerivativeOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DerivativeOrderbook(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDerivativeOrderbook(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest,::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TraderDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TraderDerivativeOrders() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* streamer) {
                       return this->StreamedTraderDerivativeOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TraderDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TraderDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTraderDerivativeOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest,::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AccountAddressDerivativeOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AccountAddressDerivativeOrders() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>* streamer) {
                       return this->StreamedAccountAddressDerivativeOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AccountAddressDerivativeOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AccountAddressDerivativeOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAccountAddressDerivativeOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest,::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DerivativeOrdersByHashes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DerivativeOrdersByHashes() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>* streamer) {
                       return this->StreamedDerivativeOrdersByHashes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DerivativeOrdersByHashes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DerivativeOrdersByHashes(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDerivativeOrdersByHashes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest,::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TraderDerivativeTransientOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TraderDerivativeTransientOrders() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* streamer) {
                       return this->StreamedTraderDerivativeTransientOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TraderDerivativeTransientOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TraderDerivativeTransientOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTraderDerivativeTransientOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest,::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DerivativeMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DerivativeMarkets() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>* streamer) {
                       return this->StreamedDerivativeMarkets(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DerivativeMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DerivativeMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDerivativeMarkets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryDerivativeMarketsRequest,::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DerivativeMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DerivativeMarket() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryDerivativeMarketRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryDerivativeMarketRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse>* streamer) {
                       return this->StreamedDerivativeMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DerivativeMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DerivativeMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDerivativeMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryDerivativeMarketRequest,::injective::exchange::v1beta1::QueryDerivativeMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DerivativeMarketAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DerivativeMarketAddress() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>* streamer) {
                       return this->StreamedDerivativeMarketAddress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DerivativeMarketAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DerivativeMarketAddress(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* /*request*/, ::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDerivativeMarketAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest,::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountTradeNonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountTradeNonce() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>* streamer) {
                       return this->StreamedSubaccountTradeNonce(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountTradeNonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountTradeNonce(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountTradeNonce(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest,::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExchangeModuleState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExchangeModuleState() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryModuleStateRequest, ::injective::exchange::v1beta1::QueryModuleStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryModuleStateRequest, ::injective::exchange::v1beta1::QueryModuleStateResponse>* streamer) {
                       return this->StreamedExchangeModuleState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExchangeModuleState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExchangeModuleState(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryModuleStateRequest* /*request*/, ::injective::exchange::v1beta1::QueryModuleStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExchangeModuleState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryModuleStateRequest,::injective::exchange::v1beta1::QueryModuleStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Positions() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryPositionsRequest, ::injective::exchange::v1beta1::QueryPositionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryPositionsRequest, ::injective::exchange::v1beta1::QueryPositionsResponse>* streamer) {
                       return this->StreamedPositions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QueryPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPositions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryPositionsRequest,::injective::exchange::v1beta1::QueryPositionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountPositions() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>* streamer) {
                       return this->StreamedSubaccountPositions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountPositions(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountPositions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySubaccountPositionsRequest,::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountPositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountPositionInMarket() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>* streamer) {
                       return this->StreamedSubaccountPositionInMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountPositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountPositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountPositionInMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest,::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountEffectivePositionInMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountEffectivePositionInMarket() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>* streamer) {
                       return this->StreamedSubaccountEffectivePositionInMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountEffectivePositionInMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountEffectivePositionInMarket(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountEffectivePositionInMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest,::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PerpetualMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PerpetualMarketInfo() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>* streamer) {
                       return this->StreamedPerpetualMarketInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PerpetualMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PerpetualMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPerpetualMarketInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest,::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExpiryFuturesMarketInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExpiryFuturesMarketInfo() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>* streamer) {
                       return this->StreamedExpiryFuturesMarketInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExpiryFuturesMarketInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExpiryFuturesMarketInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExpiryFuturesMarketInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest,::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PerpetualMarketFunding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PerpetualMarketFunding() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>* streamer) {
                       return this->StreamedPerpetualMarketFunding(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PerpetualMarketFunding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PerpetualMarketFunding(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* /*request*/, ::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPerpetualMarketFunding(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest,::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountOrderMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountOrderMetadata() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>* streamer) {
                       return this->StreamedSubaccountOrderMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountOrderMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountOrderMetadata(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* /*request*/, ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountOrderMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest,::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TradeRewardPoints() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* streamer) {
                       return this->StreamedTradeRewardPoints(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTradeRewardPoints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest,::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PendingTradeRewardPoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PendingTradeRewardPoints() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* streamer) {
                       return this->StreamedPendingTradeRewardPoints(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PendingTradeRewardPoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PendingTradeRewardPoints(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPendingTradeRewardPoints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryTradeRewardPointsRequest,::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TradeRewardCampaign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TradeRewardCampaign() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>* streamer) {
                       return this->StreamedTradeRewardCampaign(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TradeRewardCampaign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TradeRewardCampaign(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* /*request*/, ::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTradeRewardCampaign(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest,::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FeeDiscountAccountInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FeeDiscountAccountInfo() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>* streamer) {
                       return this->StreamedFeeDiscountAccountInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FeeDiscountAccountInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FeeDiscountAccountInfo(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFeeDiscountAccountInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest,::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FeeDiscountSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FeeDiscountSchedule() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>* streamer) {
                       return this->StreamedFeeDiscountSchedule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FeeDiscountSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FeeDiscountSchedule(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFeeDiscountSchedule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest,::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BalanceMismatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BalanceMismatches() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>* streamer) {
                       return this->StreamedBalanceMismatches(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BalanceMismatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BalanceMismatches(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBalanceMismatches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryBalanceMismatchesRequest,::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BalanceWithBalanceHolds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BalanceWithBalanceHolds() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>* streamer) {
                       return this->StreamedBalanceWithBalanceHolds(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BalanceWithBalanceHolds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BalanceWithBalanceHolds(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBalanceWithBalanceHolds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest,::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FeeDiscountTierStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FeeDiscountTierStatistics() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>* streamer) {
                       return this->StreamedFeeDiscountTierStatistics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FeeDiscountTierStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FeeDiscountTierStatistics(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* /*request*/, ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFeeDiscountTierStatistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest,::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MitoVaultInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MitoVaultInfos() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::MitoVaultInfosRequest, ::injective::exchange::v1beta1::MitoVaultInfosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::MitoVaultInfosRequest, ::injective::exchange::v1beta1::MitoVaultInfosResponse>* streamer) {
                       return this->StreamedMitoVaultInfos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MitoVaultInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MitoVaultInfos(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::MitoVaultInfosRequest* /*request*/, ::injective::exchange::v1beta1::MitoVaultInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMitoVaultInfos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::MitoVaultInfosRequest,::injective::exchange::v1beta1::MitoVaultInfosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryMarketIDFromVault : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryMarketIDFromVault() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>* streamer) {
                       return this->StreamedQueryMarketIDFromVault(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QueryMarketIDFromVault() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryMarketIDFromVault(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryMarketIDFromVault(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest,::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HistoricalTradeRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HistoricalTradeRecords() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>* streamer) {
                       return this->StreamedHistoricalTradeRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HistoricalTradeRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HistoricalTradeRecords(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* /*request*/, ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHistoricalTradeRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest,::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsOptedOutOfRewards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsOptedOutOfRewards() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>* streamer) {
                       return this->StreamedIsOptedOutOfRewards(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsOptedOutOfRewards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsOptedOutOfRewards(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* /*request*/, ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsOptedOutOfRewards(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest,::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OptedOutOfRewardsAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OptedOutOfRewardsAccounts() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>* streamer) {
                       return this->StreamedOptedOutOfRewardsAccounts(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OptedOutOfRewardsAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OptedOutOfRewardsAccounts(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* /*request*/, ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOptedOutOfRewardsAccounts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest,::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MarketVolatility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MarketVolatility() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryMarketVolatilityRequest, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryMarketVolatilityRequest, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse>* streamer) {
                       return this->StreamedMarketVolatility(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MarketVolatility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketVolatility(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketVolatilityRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketVolatilityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarketVolatility(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryMarketVolatilityRequest,::injective::exchange::v1beta1::QueryMarketVolatilityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryBinaryMarketsRequest, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryBinaryMarketsRequest, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse>* streamer) {
                       return this->StreamedBinaryOptionsMarkets(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryBinaryMarketsRequest* /*request*/, ::injective::exchange::v1beta1::QueryBinaryMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBinaryOptionsMarkets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryBinaryMarketsRequest,::injective::exchange::v1beta1::QueryBinaryMarketsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TraderDerivativeConditionalOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TraderDerivativeConditionalOrders() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>* streamer) {
                       return this->StreamedTraderDerivativeConditionalOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TraderDerivativeConditionalOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TraderDerivativeConditionalOrders(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* /*request*/, ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTraderDerivativeConditionalOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest,::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MarketAtomicExecutionFeeMultiplier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MarketAtomicExecutionFeeMultiplier() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>* streamer) {
                       return this->StreamedMarketAtomicExecutionFeeMultiplier(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MarketAtomicExecutionFeeMultiplier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* /*context*/, const ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* /*request*/, ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarketAtomicExecutionFeeMultiplier(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest,::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_QueryExchangeParams<WithStreamedUnaryMethod_SubaccountDeposits<WithStreamedUnaryMethod_SubaccountDeposit<WithStreamedUnaryMethod_ExchangeBalances<WithStreamedUnaryMethod_AggregateVolume<WithStreamedUnaryMethod_AggregateVolumes<WithStreamedUnaryMethod_AggregateMarketVolume<WithStreamedUnaryMethod_AggregateMarketVolumes<WithStreamedUnaryMethod_DenomDecimal<WithStreamedUnaryMethod_DenomDecimals<WithStreamedUnaryMethod_SpotMarkets<WithStreamedUnaryMethod_SpotMarket<WithStreamedUnaryMethod_FullSpotMarkets<WithStreamedUnaryMethod_FullSpotMarket<WithStreamedUnaryMethod_SpotOrderbook<WithStreamedUnaryMethod_TraderSpotOrders<WithStreamedUnaryMethod_AccountAddressSpotOrders<WithStreamedUnaryMethod_SpotOrdersByHashes<WithStreamedUnaryMethod_SubaccountOrders<WithStreamedUnaryMethod_TraderSpotTransientOrders<WithStreamedUnaryMethod_SpotMidPriceAndTOB<WithStreamedUnaryMethod_DerivativeMidPriceAndTOB<WithStreamedUnaryMethod_DerivativeOrderbook<WithStreamedUnaryMethod_TraderDerivativeOrders<WithStreamedUnaryMethod_AccountAddressDerivativeOrders<WithStreamedUnaryMethod_DerivativeOrdersByHashes<WithStreamedUnaryMethod_TraderDerivativeTransientOrders<WithStreamedUnaryMethod_DerivativeMarkets<WithStreamedUnaryMethod_DerivativeMarket<WithStreamedUnaryMethod_DerivativeMarketAddress<WithStreamedUnaryMethod_SubaccountTradeNonce<WithStreamedUnaryMethod_ExchangeModuleState<WithStreamedUnaryMethod_Positions<WithStreamedUnaryMethod_SubaccountPositions<WithStreamedUnaryMethod_SubaccountPositionInMarket<WithStreamedUnaryMethod_SubaccountEffectivePositionInMarket<WithStreamedUnaryMethod_PerpetualMarketInfo<WithStreamedUnaryMethod_ExpiryFuturesMarketInfo<WithStreamedUnaryMethod_PerpetualMarketFunding<WithStreamedUnaryMethod_SubaccountOrderMetadata<WithStreamedUnaryMethod_TradeRewardPoints<WithStreamedUnaryMethod_PendingTradeRewardPoints<WithStreamedUnaryMethod_TradeRewardCampaign<WithStreamedUnaryMethod_FeeDiscountAccountInfo<WithStreamedUnaryMethod_FeeDiscountSchedule<WithStreamedUnaryMethod_BalanceMismatches<WithStreamedUnaryMethod_BalanceWithBalanceHolds<WithStreamedUnaryMethod_FeeDiscountTierStatistics<WithStreamedUnaryMethod_MitoVaultInfos<WithStreamedUnaryMethod_QueryMarketIDFromVault<WithStreamedUnaryMethod_HistoricalTradeRecords<WithStreamedUnaryMethod_IsOptedOutOfRewards<WithStreamedUnaryMethod_OptedOutOfRewardsAccounts<WithStreamedUnaryMethod_MarketVolatility<WithStreamedUnaryMethod_BinaryOptionsMarkets<WithStreamedUnaryMethod_TraderDerivativeConditionalOrders<WithStreamedUnaryMethod_MarketAtomicExecutionFeeMultiplier<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_QueryExchangeParams<WithStreamedUnaryMethod_SubaccountDeposits<WithStreamedUnaryMethod_SubaccountDeposit<WithStreamedUnaryMethod_ExchangeBalances<WithStreamedUnaryMethod_AggregateVolume<WithStreamedUnaryMethod_AggregateVolumes<WithStreamedUnaryMethod_AggregateMarketVolume<WithStreamedUnaryMethod_AggregateMarketVolumes<WithStreamedUnaryMethod_DenomDecimal<WithStreamedUnaryMethod_DenomDecimals<WithStreamedUnaryMethod_SpotMarkets<WithStreamedUnaryMethod_SpotMarket<WithStreamedUnaryMethod_FullSpotMarkets<WithStreamedUnaryMethod_FullSpotMarket<WithStreamedUnaryMethod_SpotOrderbook<WithStreamedUnaryMethod_TraderSpotOrders<WithStreamedUnaryMethod_AccountAddressSpotOrders<WithStreamedUnaryMethod_SpotOrdersByHashes<WithStreamedUnaryMethod_SubaccountOrders<WithStreamedUnaryMethod_TraderSpotTransientOrders<WithStreamedUnaryMethod_SpotMidPriceAndTOB<WithStreamedUnaryMethod_DerivativeMidPriceAndTOB<WithStreamedUnaryMethod_DerivativeOrderbook<WithStreamedUnaryMethod_TraderDerivativeOrders<WithStreamedUnaryMethod_AccountAddressDerivativeOrders<WithStreamedUnaryMethod_DerivativeOrdersByHashes<WithStreamedUnaryMethod_TraderDerivativeTransientOrders<WithStreamedUnaryMethod_DerivativeMarkets<WithStreamedUnaryMethod_DerivativeMarket<WithStreamedUnaryMethod_DerivativeMarketAddress<WithStreamedUnaryMethod_SubaccountTradeNonce<WithStreamedUnaryMethod_ExchangeModuleState<WithStreamedUnaryMethod_Positions<WithStreamedUnaryMethod_SubaccountPositions<WithStreamedUnaryMethod_SubaccountPositionInMarket<WithStreamedUnaryMethod_SubaccountEffectivePositionInMarket<WithStreamedUnaryMethod_PerpetualMarketInfo<WithStreamedUnaryMethod_ExpiryFuturesMarketInfo<WithStreamedUnaryMethod_PerpetualMarketFunding<WithStreamedUnaryMethod_SubaccountOrderMetadata<WithStreamedUnaryMethod_TradeRewardPoints<WithStreamedUnaryMethod_PendingTradeRewardPoints<WithStreamedUnaryMethod_TradeRewardCampaign<WithStreamedUnaryMethod_FeeDiscountAccountInfo<WithStreamedUnaryMethod_FeeDiscountSchedule<WithStreamedUnaryMethod_BalanceMismatches<WithStreamedUnaryMethod_BalanceWithBalanceHolds<WithStreamedUnaryMethod_FeeDiscountTierStatistics<WithStreamedUnaryMethod_MitoVaultInfos<WithStreamedUnaryMethod_QueryMarketIDFromVault<WithStreamedUnaryMethod_HistoricalTradeRecords<WithStreamedUnaryMethod_IsOptedOutOfRewards<WithStreamedUnaryMethod_OptedOutOfRewardsAccounts<WithStreamedUnaryMethod_MarketVolatility<WithStreamedUnaryMethod_BinaryOptionsMarkets<WithStreamedUnaryMethod_TraderDerivativeConditionalOrders<WithStreamedUnaryMethod_MarketAtomicExecutionFeeMultiplier<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective


#endif  // GRPC_injective_2fexchange_2fv1beta1_2fquery_2eproto__INCLUDED
