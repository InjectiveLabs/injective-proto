// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/exchange/v1beta1/exchange.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fexchange_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fexchange_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "injective/oracle/v1beta1/oracle.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2fexchange_2fv1beta1_2fexchange_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
namespace injective {
namespace exchange {
namespace v1beta1 {
class AccountRewards;
struct AccountRewardsDefaultTypeInternal;
extern AccountRewardsDefaultTypeInternal _AccountRewards_default_instance_;
class AggregateAccountVolumeRecord;
struct AggregateAccountVolumeRecordDefaultTypeInternal;
extern AggregateAccountVolumeRecordDefaultTypeInternal _AggregateAccountVolumeRecord_default_instance_;
class AggregateSubaccountVolumeRecord;
struct AggregateSubaccountVolumeRecordDefaultTypeInternal;
extern AggregateSubaccountVolumeRecordDefaultTypeInternal _AggregateSubaccountVolumeRecord_default_instance_;
class BinaryOptionsMarket;
struct BinaryOptionsMarketDefaultTypeInternal;
extern BinaryOptionsMarketDefaultTypeInternal _BinaryOptionsMarket_default_instance_;
class CampaignRewardPool;
struct CampaignRewardPoolDefaultTypeInternal;
extern CampaignRewardPoolDefaultTypeInternal _CampaignRewardPool_default_instance_;
class DenomDecimals;
struct DenomDecimalsDefaultTypeInternal;
extern DenomDecimalsDefaultTypeInternal _DenomDecimals_default_instance_;
class Deposit;
struct DepositDefaultTypeInternal;
extern DepositDefaultTypeInternal _Deposit_default_instance_;
class DepositUpdate;
struct DepositUpdateDefaultTypeInternal;
extern DepositUpdateDefaultTypeInternal _DepositUpdate_default_instance_;
class DerivativeLimitOrder;
struct DerivativeLimitOrderDefaultTypeInternal;
extern DerivativeLimitOrderDefaultTypeInternal _DerivativeLimitOrder_default_instance_;
class DerivativeMarket;
struct DerivativeMarketDefaultTypeInternal;
extern DerivativeMarketDefaultTypeInternal _DerivativeMarket_default_instance_;
class DerivativeMarketOrder;
struct DerivativeMarketOrderDefaultTypeInternal;
extern DerivativeMarketOrderDefaultTypeInternal _DerivativeMarketOrder_default_instance_;
class DerivativeMarketSettlementInfo;
struct DerivativeMarketSettlementInfoDefaultTypeInternal;
extern DerivativeMarketSettlementInfoDefaultTypeInternal _DerivativeMarketSettlementInfo_default_instance_;
class DerivativeOrder;
struct DerivativeOrderDefaultTypeInternal;
extern DerivativeOrderDefaultTypeInternal _DerivativeOrder_default_instance_;
class DerivativeTradeLog;
struct DerivativeTradeLogDefaultTypeInternal;
extern DerivativeTradeLogDefaultTypeInternal _DerivativeTradeLog_default_instance_;
class ExpiryFuturesMarketInfo;
struct ExpiryFuturesMarketInfoDefaultTypeInternal;
extern ExpiryFuturesMarketInfoDefaultTypeInternal _ExpiryFuturesMarketInfo_default_instance_;
class FeeDiscountSchedule;
struct FeeDiscountScheduleDefaultTypeInternal;
extern FeeDiscountScheduleDefaultTypeInternal _FeeDiscountSchedule_default_instance_;
class FeeDiscountTierInfo;
struct FeeDiscountTierInfoDefaultTypeInternal;
extern FeeDiscountTierInfoDefaultTypeInternal _FeeDiscountTierInfo_default_instance_;
class FeeDiscountTierTTL;
struct FeeDiscountTierTTLDefaultTypeInternal;
extern FeeDiscountTierTTLDefaultTypeInternal _FeeDiscountTierTTL_default_instance_;
class Level;
struct LevelDefaultTypeInternal;
extern LevelDefaultTypeInternal _Level_default_instance_;
class MarketFeeMultiplier;
struct MarketFeeMultiplierDefaultTypeInternal;
extern MarketFeeMultiplierDefaultTypeInternal _MarketFeeMultiplier_default_instance_;
class MarketOrderIndicator;
struct MarketOrderIndicatorDefaultTypeInternal;
extern MarketOrderIndicatorDefaultTypeInternal _MarketOrderIndicator_default_instance_;
class MarketVolume;
struct MarketVolumeDefaultTypeInternal;
extern MarketVolumeDefaultTypeInternal _MarketVolume_default_instance_;
class MidPriceAndTOB;
struct MidPriceAndTOBDefaultTypeInternal;
extern MidPriceAndTOBDefaultTypeInternal _MidPriceAndTOB_default_instance_;
class NextFundingTimestamp;
struct NextFundingTimestampDefaultTypeInternal;
extern NextFundingTimestampDefaultTypeInternal _NextFundingTimestamp_default_instance_;
class OrderInfo;
struct OrderInfoDefaultTypeInternal;
extern OrderInfoDefaultTypeInternal _OrderInfo_default_instance_;
class Params;
struct ParamsDefaultTypeInternal;
extern ParamsDefaultTypeInternal _Params_default_instance_;
class PerpetualMarketFunding;
struct PerpetualMarketFundingDefaultTypeInternal;
extern PerpetualMarketFundingDefaultTypeInternal _PerpetualMarketFunding_default_instance_;
class PerpetualMarketInfo;
struct PerpetualMarketInfoDefaultTypeInternal;
extern PerpetualMarketInfoDefaultTypeInternal _PerpetualMarketInfo_default_instance_;
class PointsMultiplier;
struct PointsMultiplierDefaultTypeInternal;
extern PointsMultiplierDefaultTypeInternal _PointsMultiplier_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class PositionDelta;
struct PositionDeltaDefaultTypeInternal;
extern PositionDeltaDefaultTypeInternal _PositionDelta_default_instance_;
class SpotLimitOrder;
struct SpotLimitOrderDefaultTypeInternal;
extern SpotLimitOrderDefaultTypeInternal _SpotLimitOrder_default_instance_;
class SpotMarket;
struct SpotMarketDefaultTypeInternal;
extern SpotMarketDefaultTypeInternal _SpotMarket_default_instance_;
class SpotMarketOrder;
struct SpotMarketOrderDefaultTypeInternal;
extern SpotMarketOrderDefaultTypeInternal _SpotMarketOrder_default_instance_;
class SpotOrder;
struct SpotOrderDefaultTypeInternal;
extern SpotOrderDefaultTypeInternal _SpotOrder_default_instance_;
class SubaccountDeposit;
struct SubaccountDepositDefaultTypeInternal;
extern SubaccountDepositDefaultTypeInternal _SubaccountDeposit_default_instance_;
class SubaccountIDs;
struct SubaccountIDsDefaultTypeInternal;
extern SubaccountIDsDefaultTypeInternal _SubaccountIDs_default_instance_;
class SubaccountOrder;
struct SubaccountOrderDefaultTypeInternal;
extern SubaccountOrderDefaultTypeInternal _SubaccountOrder_default_instance_;
class SubaccountOrderData;
struct SubaccountOrderDataDefaultTypeInternal;
extern SubaccountOrderDataDefaultTypeInternal _SubaccountOrderData_default_instance_;
class SubaccountOrderbookMetadata;
struct SubaccountOrderbookMetadataDefaultTypeInternal;
extern SubaccountOrderbookMetadataDefaultTypeInternal _SubaccountOrderbookMetadata_default_instance_;
class SubaccountPosition;
struct SubaccountPositionDefaultTypeInternal;
extern SubaccountPositionDefaultTypeInternal _SubaccountPosition_default_instance_;
class SubaccountTradeNonce;
struct SubaccountTradeNonceDefaultTypeInternal;
extern SubaccountTradeNonceDefaultTypeInternal _SubaccountTradeNonce_default_instance_;
class TradeLog;
struct TradeLogDefaultTypeInternal;
extern TradeLogDefaultTypeInternal _TradeLog_default_instance_;
class TradeRecord;
struct TradeRecordDefaultTypeInternal;
extern TradeRecordDefaultTypeInternal _TradeRecord_default_instance_;
class TradeRecords;
struct TradeRecordsDefaultTypeInternal;
extern TradeRecordsDefaultTypeInternal _TradeRecords_default_instance_;
class TradingRewardCampaignBoostInfo;
struct TradingRewardCampaignBoostInfoDefaultTypeInternal;
extern TradingRewardCampaignBoostInfoDefaultTypeInternal _TradingRewardCampaignBoostInfo_default_instance_;
class TradingRewardCampaignInfo;
struct TradingRewardCampaignInfoDefaultTypeInternal;
extern TradingRewardCampaignInfoDefaultTypeInternal _TradingRewardCampaignInfo_default_instance_;
class VolumeRecord;
struct VolumeRecordDefaultTypeInternal;
extern VolumeRecordDefaultTypeInternal _VolumeRecord_default_instance_;
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::exchange::v1beta1::AccountRewards* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::AccountRewards>(Arena*);
template <>
::injective::exchange::v1beta1::AggregateAccountVolumeRecord* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::AggregateAccountVolumeRecord>(Arena*);
template <>
::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord>(Arena*);
template <>
::injective::exchange::v1beta1::BinaryOptionsMarket* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::BinaryOptionsMarket>(Arena*);
template <>
::injective::exchange::v1beta1::CampaignRewardPool* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::CampaignRewardPool>(Arena*);
template <>
::injective::exchange::v1beta1::DenomDecimals* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DenomDecimals>(Arena*);
template <>
::injective::exchange::v1beta1::Deposit* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::Deposit>(Arena*);
template <>
::injective::exchange::v1beta1::DepositUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DepositUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::DerivativeLimitOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeLimitOrder>(Arena*);
template <>
::injective::exchange::v1beta1::DerivativeMarket* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarket>(Arena*);
template <>
::injective::exchange::v1beta1::DerivativeMarketOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketOrder>(Arena*);
template <>
::injective::exchange::v1beta1::DerivativeMarketSettlementInfo* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketSettlementInfo>(Arena*);
template <>
::injective::exchange::v1beta1::DerivativeOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeOrder>(Arena*);
template <>
::injective::exchange::v1beta1::DerivativeTradeLog* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeTradeLog>(Arena*);
template <>
::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::ExpiryFuturesMarketInfo>(Arena*);
template <>
::injective::exchange::v1beta1::FeeDiscountSchedule* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountSchedule>(Arena*);
template <>
::injective::exchange::v1beta1::FeeDiscountTierInfo* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountTierInfo>(Arena*);
template <>
::injective::exchange::v1beta1::FeeDiscountTierTTL* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountTierTTL>(Arena*);
template <>
::injective::exchange::v1beta1::Level* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::Level>(Arena*);
template <>
::injective::exchange::v1beta1::MarketFeeMultiplier* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MarketFeeMultiplier>(Arena*);
template <>
::injective::exchange::v1beta1::MarketOrderIndicator* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MarketOrderIndicator>(Arena*);
template <>
::injective::exchange::v1beta1::MarketVolume* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MarketVolume>(Arena*);
template <>
::injective::exchange::v1beta1::MidPriceAndTOB* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MidPriceAndTOB>(Arena*);
template <>
::injective::exchange::v1beta1::NextFundingTimestamp* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::NextFundingTimestamp>(Arena*);
template <>
::injective::exchange::v1beta1::OrderInfo* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::OrderInfo>(Arena*);
template <>
::injective::exchange::v1beta1::Params* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::Params>(Arena*);
template <>
::injective::exchange::v1beta1::PerpetualMarketFunding* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketFunding>(Arena*);
template <>
::injective::exchange::v1beta1::PerpetualMarketInfo* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketInfo>(Arena*);
template <>
::injective::exchange::v1beta1::PointsMultiplier* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::PointsMultiplier>(Arena*);
template <>
::injective::exchange::v1beta1::Position* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::Position>(Arena*);
template <>
::injective::exchange::v1beta1::PositionDelta* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::PositionDelta>(Arena*);
template <>
::injective::exchange::v1beta1::SpotLimitOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SpotLimitOrder>(Arena*);
template <>
::injective::exchange::v1beta1::SpotMarket* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarket>(Arena*);
template <>
::injective::exchange::v1beta1::SpotMarketOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarketOrder>(Arena*);
template <>
::injective::exchange::v1beta1::SpotOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SpotOrder>(Arena*);
template <>
::injective::exchange::v1beta1::SubaccountDeposit* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountDeposit>(Arena*);
template <>
::injective::exchange::v1beta1::SubaccountIDs* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountIDs>(Arena*);
template <>
::injective::exchange::v1beta1::SubaccountOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountOrder>(Arena*);
template <>
::injective::exchange::v1beta1::SubaccountOrderData* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountOrderData>(Arena*);
template <>
::injective::exchange::v1beta1::SubaccountOrderbookMetadata* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountOrderbookMetadata>(Arena*);
template <>
::injective::exchange::v1beta1::SubaccountPosition* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountPosition>(Arena*);
template <>
::injective::exchange::v1beta1::SubaccountTradeNonce* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountTradeNonce>(Arena*);
template <>
::injective::exchange::v1beta1::TradeLog* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradeLog>(Arena*);
template <>
::injective::exchange::v1beta1::TradeRecord* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradeRecord>(Arena*);
template <>
::injective::exchange::v1beta1::TradeRecords* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradeRecords>(Arena*);
template <>
::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo>(Arena*);
template <>
::injective::exchange::v1beta1::TradingRewardCampaignInfo* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignInfo>(Arena*);
template <>
::injective::exchange::v1beta1::VolumeRecord* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::VolumeRecord>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace exchange {
namespace v1beta1 {
enum AtomicMarketOrderAccessLevel : int {
  Nobody = 0,
  BeginBlockerSmartContractsOnly = 1,
  SmartContractsOnly = 2,
  Everyone = 3,
  AtomicMarketOrderAccessLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AtomicMarketOrderAccessLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AtomicMarketOrderAccessLevel_IsValid(int value);
constexpr AtomicMarketOrderAccessLevel AtomicMarketOrderAccessLevel_MIN = static_cast<AtomicMarketOrderAccessLevel>(0);
constexpr AtomicMarketOrderAccessLevel AtomicMarketOrderAccessLevel_MAX = static_cast<AtomicMarketOrderAccessLevel>(3);
constexpr int AtomicMarketOrderAccessLevel_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AtomicMarketOrderAccessLevel_descriptor();
template <typename T>
const std::string& AtomicMarketOrderAccessLevel_Name(T value) {
  static_assert(std::is_same<T, AtomicMarketOrderAccessLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AtomicMarketOrderAccessLevel_Name().");
  return AtomicMarketOrderAccessLevel_Name(static_cast<AtomicMarketOrderAccessLevel>(value));
}
template <>
inline const std::string& AtomicMarketOrderAccessLevel_Name(AtomicMarketOrderAccessLevel value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AtomicMarketOrderAccessLevel_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AtomicMarketOrderAccessLevel_Parse(absl::string_view name, AtomicMarketOrderAccessLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AtomicMarketOrderAccessLevel>(
      AtomicMarketOrderAccessLevel_descriptor(), name, value);
}
enum MarketStatus : int {
  Unspecified = 0,
  Active = 1,
  Paused = 2,
  Demolished = 3,
  Expired = 4,
  MarketStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MarketStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MarketStatus_IsValid(int value);
constexpr MarketStatus MarketStatus_MIN = static_cast<MarketStatus>(0);
constexpr MarketStatus MarketStatus_MAX = static_cast<MarketStatus>(4);
constexpr int MarketStatus_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
MarketStatus_descriptor();
template <typename T>
const std::string& MarketStatus_Name(T value) {
  static_assert(std::is_same<T, MarketStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MarketStatus_Name().");
  return MarketStatus_Name(static_cast<MarketStatus>(value));
}
template <>
inline const std::string& MarketStatus_Name(MarketStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<MarketStatus_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool MarketStatus_Parse(absl::string_view name, MarketStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketStatus>(
      MarketStatus_descriptor(), name, value);
}
enum OrderType : int {
  UNSPECIFIED = 0,
  BUY = 1,
  SELL = 2,
  STOP_BUY = 3,
  STOP_SELL = 4,
  TAKE_BUY = 5,
  TAKE_SELL = 6,
  BUY_PO = 7,
  SELL_PO = 8,
  BUY_ATOMIC = 9,
  SELL_ATOMIC = 10,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderType_IsValid(int value);
constexpr OrderType OrderType_MIN = static_cast<OrderType>(0);
constexpr OrderType OrderType_MAX = static_cast<OrderType>(10);
constexpr int OrderType_ARRAYSIZE = 10 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderType_descriptor();
template <typename T>
const std::string& OrderType_Name(T value) {
  static_assert(std::is_same<T, OrderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderType_Name().");
  return OrderType_Name(static_cast<OrderType>(value));
}
template <>
inline const std::string& OrderType_Name(OrderType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool OrderType_Parse(absl::string_view name, OrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderType>(
      OrderType_descriptor(), name, value);
}
enum ExecutionType : int {
  UnspecifiedExecutionType = 0,
  Market = 1,
  LimitFill = 2,
  LimitMatchRestingOrder = 3,
  LimitMatchNewOrder = 4,
  MarketLiquidation = 5,
  ExpiryMarketSettlement = 6,
  ExecutionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExecutionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExecutionType_IsValid(int value);
constexpr ExecutionType ExecutionType_MIN = static_cast<ExecutionType>(0);
constexpr ExecutionType ExecutionType_MAX = static_cast<ExecutionType>(6);
constexpr int ExecutionType_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ExecutionType_descriptor();
template <typename T>
const std::string& ExecutionType_Name(T value) {
  static_assert(std::is_same<T, ExecutionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExecutionType_Name().");
  return ExecutionType_Name(static_cast<ExecutionType>(value));
}
template <>
inline const std::string& ExecutionType_Name(ExecutionType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ExecutionType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ExecutionType_Parse(absl::string_view name, ExecutionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecutionType>(
      ExecutionType_descriptor(), name, value);
}
enum OrderMask : int {
  UNUSED = 0,
  ANY = 1,
  REGULAR = 2,
  CONDITIONAL = 4,
  DIRECTION_BUY_OR_HIGHER = 8,
  DIRECTION_SELL_OR_LOWER = 16,
  TYPE_MARKET = 32,
  TYPE_LIMIT = 64,
  OrderMask_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderMask_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderMask_IsValid(int value);
constexpr OrderMask OrderMask_MIN = static_cast<OrderMask>(0);
constexpr OrderMask OrderMask_MAX = static_cast<OrderMask>(64);
constexpr int OrderMask_ARRAYSIZE = 64 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderMask_descriptor();
template <typename T>
const std::string& OrderMask_Name(T value) {
  static_assert(std::is_same<T, OrderMask>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderMask_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(OrderMask_descriptor(), value);
}
inline bool OrderMask_Parse(absl::string_view name, OrderMask* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderMask>(
      OrderMask_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Params final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.Params) */ {
 public:
  inline Params() : Params(nullptr) {}
  ~Params() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Params(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Params(const Params& from);
  Params(Params&& from) noexcept
    : Params() {
    *this = ::std::move(from);
  }

  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline Params& operator=(Params&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const Params* internal_default_instance() {
    return reinterpret_cast<const Params*>(
               &_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Params& a, Params& b) {
    a.Swap(&b);
  }
  inline void Swap(Params* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Params* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Params* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Params>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Params& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Params& from) {
    Params::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Params* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.Params";
  }
  protected:
  explicit Params(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultSpotMakerFeeRateFieldNumber = 3,
    kDefaultSpotTakerFeeRateFieldNumber = 4,
    kDefaultDerivativeMakerFeeRateFieldNumber = 5,
    kDefaultDerivativeTakerFeeRateFieldNumber = 6,
    kDefaultInitialMarginRatioFieldNumber = 7,
    kDefaultMaintenanceMarginRatioFieldNumber = 8,
    kRelayerFeeShareRateFieldNumber = 11,
    kDefaultHourlyFundingRateCapFieldNumber = 12,
    kDefaultHourlyInterestRateFieldNumber = 13,
    kInjRewardStakedRequirementThresholdFieldNumber = 15,
    kLiquidatorRewardShareRateFieldNumber = 17,
    kSpotAtomicMarketOrderFeeMultiplierFieldNumber = 20,
    kDerivativeAtomicMarketOrderFeeMultiplierFieldNumber = 21,
    kBinaryOptionsAtomicMarketOrderFeeMultiplierFieldNumber = 22,
    kMinimalProtocolFeeRateFieldNumber = 23,
    kSpotMarketInstantListingFeeFieldNumber = 1,
    kDerivativeMarketInstantListingFeeFieldNumber = 2,
    kBinaryOptionsMarketInstantListingFeeFieldNumber = 18,
    kDefaultFundingIntervalFieldNumber = 9,
    kFundingMultipleFieldNumber = 10,
    kTradingRewardsVestingDurationFieldNumber = 16,
    kMaxDerivativeOrderSideCountFieldNumber = 14,
    kAtomicMarketOrderAccessLevelFieldNumber = 19,
    kIsInstantDerivativeMarketLaunchEnabledFieldNumber = 24,
  };
  // string default_spot_maker_fee_rate = 3 [json_name = "defaultSpotMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_default_spot_maker_fee_rate() ;
  const std::string& default_spot_maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_spot_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_default_spot_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_default_spot_maker_fee_rate();
  void set_allocated_default_spot_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_default_spot_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_spot_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_default_spot_maker_fee_rate();

  public:
  // string default_spot_taker_fee_rate = 4 [json_name = "defaultSpotTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_default_spot_taker_fee_rate() ;
  const std::string& default_spot_taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_spot_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_default_spot_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_default_spot_taker_fee_rate();
  void set_allocated_default_spot_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_default_spot_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_spot_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_default_spot_taker_fee_rate();

  public:
  // string default_derivative_maker_fee_rate = 5 [json_name = "defaultDerivativeMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_default_derivative_maker_fee_rate() ;
  const std::string& default_derivative_maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_derivative_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_default_derivative_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_default_derivative_maker_fee_rate();
  void set_allocated_default_derivative_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_default_derivative_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_derivative_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_default_derivative_maker_fee_rate();

  public:
  // string default_derivative_taker_fee_rate = 6 [json_name = "defaultDerivativeTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_default_derivative_taker_fee_rate() ;
  const std::string& default_derivative_taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_derivative_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_default_derivative_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_default_derivative_taker_fee_rate();
  void set_allocated_default_derivative_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_default_derivative_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_derivative_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_default_derivative_taker_fee_rate();

  public:
  // string default_initial_margin_ratio = 7 [json_name = "defaultInitialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_default_initial_margin_ratio() ;
  const std::string& default_initial_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_initial_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_default_initial_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_default_initial_margin_ratio();
  void set_allocated_default_initial_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_default_initial_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_initial_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_default_initial_margin_ratio();

  public:
  // string default_maintenance_margin_ratio = 8 [json_name = "defaultMaintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_default_maintenance_margin_ratio() ;
  const std::string& default_maintenance_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_maintenance_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_default_maintenance_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_default_maintenance_margin_ratio();
  void set_allocated_default_maintenance_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_default_maintenance_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_maintenance_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_default_maintenance_margin_ratio();

  public:
  // string relayer_fee_share_rate = 11 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_relayer_fee_share_rate() ;
  const std::string& relayer_fee_share_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer_fee_share_rate(Arg_&& arg, Args_... args);
  std::string* mutable_relayer_fee_share_rate();
  PROTOBUF_NODISCARD std::string* release_relayer_fee_share_rate();
  void set_allocated_relayer_fee_share_rate(std::string* ptr);

  private:
  const std::string& _internal_relayer_fee_share_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer_fee_share_rate(
      const std::string& value);
  std::string* _internal_mutable_relayer_fee_share_rate();

  public:
  // string default_hourly_funding_rate_cap = 12 [json_name = "defaultHourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_default_hourly_funding_rate_cap() ;
  const std::string& default_hourly_funding_rate_cap() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_hourly_funding_rate_cap(Arg_&& arg, Args_... args);
  std::string* mutable_default_hourly_funding_rate_cap();
  PROTOBUF_NODISCARD std::string* release_default_hourly_funding_rate_cap();
  void set_allocated_default_hourly_funding_rate_cap(std::string* ptr);

  private:
  const std::string& _internal_default_hourly_funding_rate_cap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_hourly_funding_rate_cap(
      const std::string& value);
  std::string* _internal_mutable_default_hourly_funding_rate_cap();

  public:
  // string default_hourly_interest_rate = 13 [json_name = "defaultHourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_default_hourly_interest_rate() ;
  const std::string& default_hourly_interest_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_hourly_interest_rate(Arg_&& arg, Args_... args);
  std::string* mutable_default_hourly_interest_rate();
  PROTOBUF_NODISCARD std::string* release_default_hourly_interest_rate();
  void set_allocated_default_hourly_interest_rate(std::string* ptr);

  private:
  const std::string& _internal_default_hourly_interest_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_hourly_interest_rate(
      const std::string& value);
  std::string* _internal_mutable_default_hourly_interest_rate();

  public:
  // string inj_reward_staked_requirement_threshold = 15 [json_name = "injRewardStakedRequirementThreshold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_inj_reward_staked_requirement_threshold() ;
  const std::string& inj_reward_staked_requirement_threshold() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_inj_reward_staked_requirement_threshold(Arg_&& arg, Args_... args);
  std::string* mutable_inj_reward_staked_requirement_threshold();
  PROTOBUF_NODISCARD std::string* release_inj_reward_staked_requirement_threshold();
  void set_allocated_inj_reward_staked_requirement_threshold(std::string* ptr);

  private:
  const std::string& _internal_inj_reward_staked_requirement_threshold() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inj_reward_staked_requirement_threshold(
      const std::string& value);
  std::string* _internal_mutable_inj_reward_staked_requirement_threshold();

  public:
  // string liquidator_reward_share_rate = 17 [json_name = "liquidatorRewardShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_liquidator_reward_share_rate() ;
  const std::string& liquidator_reward_share_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_liquidator_reward_share_rate(Arg_&& arg, Args_... args);
  std::string* mutable_liquidator_reward_share_rate();
  PROTOBUF_NODISCARD std::string* release_liquidator_reward_share_rate();
  void set_allocated_liquidator_reward_share_rate(std::string* ptr);

  private:
  const std::string& _internal_liquidator_reward_share_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liquidator_reward_share_rate(
      const std::string& value);
  std::string* _internal_mutable_liquidator_reward_share_rate();

  public:
  // string spot_atomic_market_order_fee_multiplier = 20 [json_name = "spotAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_spot_atomic_market_order_fee_multiplier() ;
  const std::string& spot_atomic_market_order_fee_multiplier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_spot_atomic_market_order_fee_multiplier(Arg_&& arg, Args_... args);
  std::string* mutable_spot_atomic_market_order_fee_multiplier();
  PROTOBUF_NODISCARD std::string* release_spot_atomic_market_order_fee_multiplier();
  void set_allocated_spot_atomic_market_order_fee_multiplier(std::string* ptr);

  private:
  const std::string& _internal_spot_atomic_market_order_fee_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spot_atomic_market_order_fee_multiplier(
      const std::string& value);
  std::string* _internal_mutable_spot_atomic_market_order_fee_multiplier();

  public:
  // string derivative_atomic_market_order_fee_multiplier = 21 [json_name = "derivativeAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_derivative_atomic_market_order_fee_multiplier() ;
  const std::string& derivative_atomic_market_order_fee_multiplier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_derivative_atomic_market_order_fee_multiplier(Arg_&& arg, Args_... args);
  std::string* mutable_derivative_atomic_market_order_fee_multiplier();
  PROTOBUF_NODISCARD std::string* release_derivative_atomic_market_order_fee_multiplier();
  void set_allocated_derivative_atomic_market_order_fee_multiplier(std::string* ptr);

  private:
  const std::string& _internal_derivative_atomic_market_order_fee_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_derivative_atomic_market_order_fee_multiplier(
      const std::string& value);
  std::string* _internal_mutable_derivative_atomic_market_order_fee_multiplier();

  public:
  // string binary_options_atomic_market_order_fee_multiplier = 22 [json_name = "binaryOptionsAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_binary_options_atomic_market_order_fee_multiplier() ;
  const std::string& binary_options_atomic_market_order_fee_multiplier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_binary_options_atomic_market_order_fee_multiplier(Arg_&& arg, Args_... args);
  std::string* mutable_binary_options_atomic_market_order_fee_multiplier();
  PROTOBUF_NODISCARD std::string* release_binary_options_atomic_market_order_fee_multiplier();
  void set_allocated_binary_options_atomic_market_order_fee_multiplier(std::string* ptr);

  private:
  const std::string& _internal_binary_options_atomic_market_order_fee_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_options_atomic_market_order_fee_multiplier(
      const std::string& value);
  std::string* _internal_mutable_binary_options_atomic_market_order_fee_multiplier();

  public:
  // string minimal_protocol_fee_rate = 23 [json_name = "minimalProtocolFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_minimal_protocol_fee_rate() ;
  const std::string& minimal_protocol_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_minimal_protocol_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_minimal_protocol_fee_rate();
  PROTOBUF_NODISCARD std::string* release_minimal_protocol_fee_rate();
  void set_allocated_minimal_protocol_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_minimal_protocol_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimal_protocol_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_minimal_protocol_fee_rate();

  public:
  // .cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1 [json_name = "spotMarketInstantListingFee", (.gogoproto.nullable) = false];
  bool has_spot_market_instant_listing_fee() const;
  void clear_spot_market_instant_listing_fee() ;
  const ::cosmos::base::v1beta1::Coin& spot_market_instant_listing_fee() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_spot_market_instant_listing_fee();
  ::cosmos::base::v1beta1::Coin* mutable_spot_market_instant_listing_fee();
  void set_allocated_spot_market_instant_listing_fee(::cosmos::base::v1beta1::Coin* spot_market_instant_listing_fee);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_spot_market_instant_listing_fee() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_spot_market_instant_listing_fee();
  public:
  void unsafe_arena_set_allocated_spot_market_instant_listing_fee(
      ::cosmos::base::v1beta1::Coin* spot_market_instant_listing_fee);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_spot_market_instant_listing_fee();
  // .cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2 [json_name = "derivativeMarketInstantListingFee", (.gogoproto.nullable) = false];
  bool has_derivative_market_instant_listing_fee() const;
  void clear_derivative_market_instant_listing_fee() ;
  const ::cosmos::base::v1beta1::Coin& derivative_market_instant_listing_fee() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_derivative_market_instant_listing_fee();
  ::cosmos::base::v1beta1::Coin* mutable_derivative_market_instant_listing_fee();
  void set_allocated_derivative_market_instant_listing_fee(::cosmos::base::v1beta1::Coin* derivative_market_instant_listing_fee);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_derivative_market_instant_listing_fee() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_derivative_market_instant_listing_fee();
  public:
  void unsafe_arena_set_allocated_derivative_market_instant_listing_fee(
      ::cosmos::base::v1beta1::Coin* derivative_market_instant_listing_fee);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_derivative_market_instant_listing_fee();
  // .cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18 [json_name = "binaryOptionsMarketInstantListingFee", (.gogoproto.nullable) = false];
  bool has_binary_options_market_instant_listing_fee() const;
  void clear_binary_options_market_instant_listing_fee() ;
  const ::cosmos::base::v1beta1::Coin& binary_options_market_instant_listing_fee() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_binary_options_market_instant_listing_fee();
  ::cosmos::base::v1beta1::Coin* mutable_binary_options_market_instant_listing_fee();
  void set_allocated_binary_options_market_instant_listing_fee(::cosmos::base::v1beta1::Coin* binary_options_market_instant_listing_fee);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_binary_options_market_instant_listing_fee() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_binary_options_market_instant_listing_fee();
  public:
  void unsafe_arena_set_allocated_binary_options_market_instant_listing_fee(
      ::cosmos::base::v1beta1::Coin* binary_options_market_instant_listing_fee);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_binary_options_market_instant_listing_fee();
  // int64 default_funding_interval = 9 [json_name = "defaultFundingInterval"];
  void clear_default_funding_interval() ;
  ::int64_t default_funding_interval() const;
  void set_default_funding_interval(::int64_t value);

  private:
  ::int64_t _internal_default_funding_interval() const;
  void _internal_set_default_funding_interval(::int64_t value);

  public:
  // int64 funding_multiple = 10 [json_name = "fundingMultiple"];
  void clear_funding_multiple() ;
  ::int64_t funding_multiple() const;
  void set_funding_multiple(::int64_t value);

  private:
  ::int64_t _internal_funding_multiple() const;
  void _internal_set_funding_multiple(::int64_t value);

  public:
  // int64 trading_rewards_vesting_duration = 16 [json_name = "tradingRewardsVestingDuration"];
  void clear_trading_rewards_vesting_duration() ;
  ::int64_t trading_rewards_vesting_duration() const;
  void set_trading_rewards_vesting_duration(::int64_t value);

  private:
  ::int64_t _internal_trading_rewards_vesting_duration() const;
  void _internal_set_trading_rewards_vesting_duration(::int64_t value);

  public:
  // uint32 max_derivative_order_side_count = 14 [json_name = "maxDerivativeOrderSideCount"];
  void clear_max_derivative_order_side_count() ;
  ::uint32_t max_derivative_order_side_count() const;
  void set_max_derivative_order_side_count(::uint32_t value);

  private:
  ::uint32_t _internal_max_derivative_order_side_count() const;
  void _internal_set_max_derivative_order_side_count(::uint32_t value);

  public:
  // .injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19 [json_name = "atomicMarketOrderAccessLevel"];
  void clear_atomic_market_order_access_level() ;
  ::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel atomic_market_order_access_level() const;
  void set_atomic_market_order_access_level(::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel value);

  private:
  ::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel _internal_atomic_market_order_access_level() const;
  void _internal_set_atomic_market_order_access_level(::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel value);

  public:
  // bool is_instant_derivative_market_launch_enabled = 24 [json_name = "isInstantDerivativeMarketLaunchEnabled"];
  void clear_is_instant_derivative_market_launch_enabled() ;
  bool is_instant_derivative_market_launch_enabled() const;
  void set_is_instant_derivative_market_launch_enabled(bool value);

  private:
  bool _internal_is_instant_derivative_market_launch_enabled() const;
  void _internal_set_is_instant_derivative_market_launch_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.Params)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_spot_maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_spot_taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_derivative_maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_derivative_taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_initial_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_maintenance_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_fee_share_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_hourly_funding_rate_cap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_hourly_interest_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inj_reward_staked_requirement_threshold_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liquidator_reward_share_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spot_atomic_market_order_fee_multiplier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr derivative_atomic_market_order_fee_multiplier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_options_atomic_market_order_fee_multiplier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimal_protocol_fee_rate_;
    ::cosmos::base::v1beta1::Coin* spot_market_instant_listing_fee_;
    ::cosmos::base::v1beta1::Coin* derivative_market_instant_listing_fee_;
    ::cosmos::base::v1beta1::Coin* binary_options_market_instant_listing_fee_;
    ::int64_t default_funding_interval_;
    ::int64_t funding_multiple_;
    ::int64_t trading_rewards_vesting_duration_;
    ::uint32_t max_derivative_order_side_count_;
    int atomic_market_order_access_level_;
    bool is_instant_derivative_market_launch_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class MarketFeeMultiplier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MarketFeeMultiplier) */ {
 public:
  inline MarketFeeMultiplier() : MarketFeeMultiplier(nullptr) {}
  ~MarketFeeMultiplier() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketFeeMultiplier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketFeeMultiplier(const MarketFeeMultiplier& from);
  MarketFeeMultiplier(MarketFeeMultiplier&& from) noexcept
    : MarketFeeMultiplier() {
    *this = ::std::move(from);
  }

  inline MarketFeeMultiplier& operator=(const MarketFeeMultiplier& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketFeeMultiplier& operator=(MarketFeeMultiplier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketFeeMultiplier& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketFeeMultiplier* internal_default_instance() {
    return reinterpret_cast<const MarketFeeMultiplier*>(
               &_MarketFeeMultiplier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MarketFeeMultiplier& a, MarketFeeMultiplier& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketFeeMultiplier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketFeeMultiplier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketFeeMultiplier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketFeeMultiplier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketFeeMultiplier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketFeeMultiplier& from) {
    MarketFeeMultiplier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketFeeMultiplier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MarketFeeMultiplier";
  }
  protected:
  explicit MarketFeeMultiplier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kFeeMultiplierFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string fee_multiplier = 2 [json_name = "feeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fee_multiplier() ;
  const std::string& fee_multiplier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_multiplier(Arg_&& arg, Args_... args);
  std::string* mutable_fee_multiplier();
  PROTOBUF_NODISCARD std::string* release_fee_multiplier();
  void set_allocated_fee_multiplier(std::string* ptr);

  private:
  const std::string& _internal_fee_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_multiplier(
      const std::string& value);
  std::string* _internal_mutable_fee_multiplier();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MarketFeeMultiplier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_multiplier_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class DerivativeMarket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeMarket) */ {
 public:
  inline DerivativeMarket() : DerivativeMarket(nullptr) {}
  ~DerivativeMarket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeMarket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeMarket(const DerivativeMarket& from);
  DerivativeMarket(DerivativeMarket&& from) noexcept
    : DerivativeMarket() {
    *this = ::std::move(from);
  }

  inline DerivativeMarket& operator=(const DerivativeMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeMarket& operator=(DerivativeMarket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeMarket& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeMarket* internal_default_instance() {
    return reinterpret_cast<const DerivativeMarket*>(
               &_DerivativeMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DerivativeMarket& a, DerivativeMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeMarket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeMarket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeMarket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeMarket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeMarket& from) {
    DerivativeMarket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeMarket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeMarket";
  }
  protected:
  explicit DerivativeMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickerFieldNumber = 1,
    kOracleBaseFieldNumber = 2,
    kOracleQuoteFieldNumber = 3,
    kQuoteDenomFieldNumber = 6,
    kMarketIdFieldNumber = 7,
    kInitialMarginRatioFieldNumber = 8,
    kMaintenanceMarginRatioFieldNumber = 9,
    kMakerFeeRateFieldNumber = 10,
    kTakerFeeRateFieldNumber = 11,
    kRelayerFeeShareRateFieldNumber = 12,
    kMinPriceTickSizeFieldNumber = 15,
    kMinQuantityTickSizeFieldNumber = 16,
    kOracleTypeFieldNumber = 4,
    kOracleScaleFactorFieldNumber = 5,
    kIsPerpetualFieldNumber = 13,
    kStatusFieldNumber = 14,
  };
  // string ticker = 1 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string oracle_base = 2 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 3 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // string quote_denom = 6 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string market_id = 7 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string initial_margin_ratio = 8 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_initial_margin_ratio() ;
  const std::string& initial_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_initial_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_initial_margin_ratio();
  void set_allocated_initial_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_initial_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_initial_margin_ratio();

  public:
  // string maintenance_margin_ratio = 9 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maintenance_margin_ratio() ;
  const std::string& maintenance_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maintenance_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_maintenance_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_maintenance_margin_ratio();
  void set_allocated_maintenance_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_maintenance_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_maintenance_margin_ratio();

  public:
  // string maker_fee_rate = 10 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 11 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string relayer_fee_share_rate = 12 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_relayer_fee_share_rate() ;
  const std::string& relayer_fee_share_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer_fee_share_rate(Arg_&& arg, Args_... args);
  std::string* mutable_relayer_fee_share_rate();
  PROTOBUF_NODISCARD std::string* release_relayer_fee_share_rate();
  void set_allocated_relayer_fee_share_rate(std::string* ptr);

  private:
  const std::string& _internal_relayer_fee_share_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer_fee_share_rate(
      const std::string& value);
  std::string* _internal_mutable_relayer_fee_share_rate();

  public:
  // string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // bool isPerpetual = 13 [json_name = "isPerpetual"];
  void clear_isperpetual() ;
  bool isperpetual() const;
  void set_isperpetual(bool value);

  private:
  bool _internal_isperpetual() const;
  void _internal_set_isperpetual(bool value);

  public:
  // .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
  void clear_status() ;
  ::injective::exchange::v1beta1::MarketStatus status() const;
  void set_status(::injective::exchange::v1beta1::MarketStatus value);

  private:
  ::injective::exchange::v1beta1::MarketStatus _internal_status() const;
  void _internal_set_status(::injective::exchange::v1beta1::MarketStatus value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maintenance_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_fee_share_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    int oracle_type_;
    ::uint32_t oracle_scale_factor_;
    bool isperpetual_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class BinaryOptionsMarket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.BinaryOptionsMarket) */ {
 public:
  inline BinaryOptionsMarket() : BinaryOptionsMarket(nullptr) {}
  ~BinaryOptionsMarket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryOptionsMarket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOptionsMarket(const BinaryOptionsMarket& from);
  BinaryOptionsMarket(BinaryOptionsMarket&& from) noexcept
    : BinaryOptionsMarket() {
    *this = ::std::move(from);
  }

  inline BinaryOptionsMarket& operator=(const BinaryOptionsMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOptionsMarket& operator=(BinaryOptionsMarket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOptionsMarket& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOptionsMarket* internal_default_instance() {
    return reinterpret_cast<const BinaryOptionsMarket*>(
               &_BinaryOptionsMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BinaryOptionsMarket& a, BinaryOptionsMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOptionsMarket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOptionsMarket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOptionsMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOptionsMarket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOptionsMarket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOptionsMarket& from) {
    BinaryOptionsMarket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOptionsMarket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.BinaryOptionsMarket";
  }
  protected:
  explicit BinaryOptionsMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickerFieldNumber = 1,
    kOracleSymbolFieldNumber = 2,
    kOracleProviderFieldNumber = 3,
    kAdminFieldNumber = 8,
    kQuoteDenomFieldNumber = 9,
    kMarketIdFieldNumber = 10,
    kMakerFeeRateFieldNumber = 11,
    kTakerFeeRateFieldNumber = 12,
    kRelayerFeeShareRateFieldNumber = 13,
    kMinPriceTickSizeFieldNumber = 15,
    kMinQuantityTickSizeFieldNumber = 16,
    kSettlementPriceFieldNumber = 17,
    kOracleTypeFieldNumber = 4,
    kOracleScaleFactorFieldNumber = 5,
    kExpirationTimestampFieldNumber = 6,
    kSettlementTimestampFieldNumber = 7,
    kStatusFieldNumber = 14,
  };
  // string ticker = 1 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string oracle_symbol = 2 [json_name = "oracleSymbol"];
  void clear_oracle_symbol() ;
  const std::string& oracle_symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_symbol();
  PROTOBUF_NODISCARD std::string* release_oracle_symbol();
  void set_allocated_oracle_symbol(std::string* ptr);

  private:
  const std::string& _internal_oracle_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_symbol(
      const std::string& value);
  std::string* _internal_mutable_oracle_symbol();

  public:
  // string oracle_provider = 3 [json_name = "oracleProvider"];
  void clear_oracle_provider() ;
  const std::string& oracle_provider() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_provider(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_provider();
  PROTOBUF_NODISCARD std::string* release_oracle_provider();
  void set_allocated_oracle_provider(std::string* ptr);

  private:
  const std::string& _internal_oracle_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_provider(
      const std::string& value);
  std::string* _internal_mutable_oracle_provider();

  public:
  // string admin = 8 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string quote_denom = 9 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string market_id = 10 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string maker_fee_rate = 11 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 12 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string relayer_fee_share_rate = 13 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_relayer_fee_share_rate() ;
  const std::string& relayer_fee_share_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer_fee_share_rate(Arg_&& arg, Args_... args);
  std::string* mutable_relayer_fee_share_rate();
  PROTOBUF_NODISCARD std::string* release_relayer_fee_share_rate();
  void set_allocated_relayer_fee_share_rate(std::string* ptr);

  private:
  const std::string& _internal_relayer_fee_share_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer_fee_share_rate(
      const std::string& value);
  std::string* _internal_mutable_relayer_fee_share_rate();

  public:
  // string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // string settlement_price = 17 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_settlement_price() ;
  const std::string& settlement_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlement_price(Arg_&& arg, Args_... args);
  std::string* mutable_settlement_price();
  PROTOBUF_NODISCARD std::string* release_settlement_price();
  void set_allocated_settlement_price(std::string* ptr);

  private:
  const std::string& _internal_settlement_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlement_price(
      const std::string& value);
  std::string* _internal_mutable_settlement_price();

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // int64 expiration_timestamp = 6 [json_name = "expirationTimestamp"];
  void clear_expiration_timestamp() ;
  ::int64_t expiration_timestamp() const;
  void set_expiration_timestamp(::int64_t value);

  private:
  ::int64_t _internal_expiration_timestamp() const;
  void _internal_set_expiration_timestamp(::int64_t value);

  public:
  // int64 settlement_timestamp = 7 [json_name = "settlementTimestamp"];
  void clear_settlement_timestamp() ;
  ::int64_t settlement_timestamp() const;
  void set_settlement_timestamp(::int64_t value);

  private:
  ::int64_t _internal_settlement_timestamp() const;
  void _internal_set_settlement_timestamp(::int64_t value);

  public:
  // .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
  void clear_status() ;
  ::injective::exchange::v1beta1::MarketStatus status() const;
  void set_status(::injective::exchange::v1beta1::MarketStatus value);

  private:
  ::injective::exchange::v1beta1::MarketStatus _internal_status() const;
  void _internal_set_status(::injective::exchange::v1beta1::MarketStatus value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.BinaryOptionsMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_fee_share_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_;
    int oracle_type_;
    ::uint32_t oracle_scale_factor_;
    ::int64_t expiration_timestamp_;
    ::int64_t settlement_timestamp_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class ExpiryFuturesMarketInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.ExpiryFuturesMarketInfo) */ {
 public:
  inline ExpiryFuturesMarketInfo() : ExpiryFuturesMarketInfo(nullptr) {}
  ~ExpiryFuturesMarketInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExpiryFuturesMarketInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpiryFuturesMarketInfo(const ExpiryFuturesMarketInfo& from);
  ExpiryFuturesMarketInfo(ExpiryFuturesMarketInfo&& from) noexcept
    : ExpiryFuturesMarketInfo() {
    *this = ::std::move(from);
  }

  inline ExpiryFuturesMarketInfo& operator=(const ExpiryFuturesMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpiryFuturesMarketInfo& operator=(ExpiryFuturesMarketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpiryFuturesMarketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpiryFuturesMarketInfo* internal_default_instance() {
    return reinterpret_cast<const ExpiryFuturesMarketInfo*>(
               &_ExpiryFuturesMarketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExpiryFuturesMarketInfo& a, ExpiryFuturesMarketInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpiryFuturesMarketInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpiryFuturesMarketInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpiryFuturesMarketInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpiryFuturesMarketInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpiryFuturesMarketInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpiryFuturesMarketInfo& from) {
    ExpiryFuturesMarketInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpiryFuturesMarketInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.ExpiryFuturesMarketInfo";
  }
  protected:
  explicit ExpiryFuturesMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kExpirationTwapStartPriceCumulativeFieldNumber = 4,
    kSettlementPriceFieldNumber = 5,
    kExpirationTimestampFieldNumber = 2,
    kTwapStartTimestampFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string expiration_twap_start_price_cumulative = 4 [json_name = "expirationTwapStartPriceCumulative", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_expiration_twap_start_price_cumulative() ;
  const std::string& expiration_twap_start_price_cumulative() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expiration_twap_start_price_cumulative(Arg_&& arg, Args_... args);
  std::string* mutable_expiration_twap_start_price_cumulative();
  PROTOBUF_NODISCARD std::string* release_expiration_twap_start_price_cumulative();
  void set_allocated_expiration_twap_start_price_cumulative(std::string* ptr);

  private:
  const std::string& _internal_expiration_twap_start_price_cumulative() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expiration_twap_start_price_cumulative(
      const std::string& value);
  std::string* _internal_mutable_expiration_twap_start_price_cumulative();

  public:
  // string settlement_price = 5 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_settlement_price() ;
  const std::string& settlement_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlement_price(Arg_&& arg, Args_... args);
  std::string* mutable_settlement_price();
  PROTOBUF_NODISCARD std::string* release_settlement_price();
  void set_allocated_settlement_price(std::string* ptr);

  private:
  const std::string& _internal_settlement_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlement_price(
      const std::string& value);
  std::string* _internal_mutable_settlement_price();

  public:
  // int64 expiration_timestamp = 2 [json_name = "expirationTimestamp"];
  void clear_expiration_timestamp() ;
  ::int64_t expiration_timestamp() const;
  void set_expiration_timestamp(::int64_t value);

  private:
  ::int64_t _internal_expiration_timestamp() const;
  void _internal_set_expiration_timestamp(::int64_t value);

  public:
  // int64 twap_start_timestamp = 3 [json_name = "twapStartTimestamp"];
  void clear_twap_start_timestamp() ;
  ::int64_t twap_start_timestamp() const;
  void set_twap_start_timestamp(::int64_t value);

  private:
  ::int64_t _internal_twap_start_timestamp() const;
  void _internal_set_twap_start_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expiration_twap_start_price_cumulative_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_;
    ::int64_t expiration_timestamp_;
    ::int64_t twap_start_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class PerpetualMarketInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.PerpetualMarketInfo) */ {
 public:
  inline PerpetualMarketInfo() : PerpetualMarketInfo(nullptr) {}
  ~PerpetualMarketInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerpetualMarketInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerpetualMarketInfo(const PerpetualMarketInfo& from);
  PerpetualMarketInfo(PerpetualMarketInfo&& from) noexcept
    : PerpetualMarketInfo() {
    *this = ::std::move(from);
  }

  inline PerpetualMarketInfo& operator=(const PerpetualMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerpetualMarketInfo& operator=(PerpetualMarketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerpetualMarketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerpetualMarketInfo* internal_default_instance() {
    return reinterpret_cast<const PerpetualMarketInfo*>(
               &_PerpetualMarketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PerpetualMarketInfo& a, PerpetualMarketInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PerpetualMarketInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerpetualMarketInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerpetualMarketInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerpetualMarketInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerpetualMarketInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerpetualMarketInfo& from) {
    PerpetualMarketInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerpetualMarketInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.PerpetualMarketInfo";
  }
  protected:
  explicit PerpetualMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kHourlyFundingRateCapFieldNumber = 2,
    kHourlyInterestRateFieldNumber = 3,
    kNextFundingTimestampFieldNumber = 4,
    kFundingIntervalFieldNumber = 5,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string hourly_funding_rate_cap = 2 [json_name = "hourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_hourly_funding_rate_cap() ;
  const std::string& hourly_funding_rate_cap() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hourly_funding_rate_cap(Arg_&& arg, Args_... args);
  std::string* mutable_hourly_funding_rate_cap();
  PROTOBUF_NODISCARD std::string* release_hourly_funding_rate_cap();
  void set_allocated_hourly_funding_rate_cap(std::string* ptr);

  private:
  const std::string& _internal_hourly_funding_rate_cap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hourly_funding_rate_cap(
      const std::string& value);
  std::string* _internal_mutable_hourly_funding_rate_cap();

  public:
  // string hourly_interest_rate = 3 [json_name = "hourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_hourly_interest_rate() ;
  const std::string& hourly_interest_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hourly_interest_rate(Arg_&& arg, Args_... args);
  std::string* mutable_hourly_interest_rate();
  PROTOBUF_NODISCARD std::string* release_hourly_interest_rate();
  void set_allocated_hourly_interest_rate(std::string* ptr);

  private:
  const std::string& _internal_hourly_interest_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hourly_interest_rate(
      const std::string& value);
  std::string* _internal_mutable_hourly_interest_rate();

  public:
  // int64 next_funding_timestamp = 4 [json_name = "nextFundingTimestamp"];
  void clear_next_funding_timestamp() ;
  ::int64_t next_funding_timestamp() const;
  void set_next_funding_timestamp(::int64_t value);

  private:
  ::int64_t _internal_next_funding_timestamp() const;
  void _internal_set_next_funding_timestamp(::int64_t value);

  public:
  // int64 funding_interval = 5 [json_name = "fundingInterval"];
  void clear_funding_interval() ;
  ::int64_t funding_interval() const;
  void set_funding_interval(::int64_t value);

  private:
  ::int64_t _internal_funding_interval() const;
  void _internal_set_funding_interval(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.PerpetualMarketInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hourly_funding_rate_cap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hourly_interest_rate_;
    ::int64_t next_funding_timestamp_;
    ::int64_t funding_interval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class PerpetualMarketFunding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.PerpetualMarketFunding) */ {
 public:
  inline PerpetualMarketFunding() : PerpetualMarketFunding(nullptr) {}
  ~PerpetualMarketFunding() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerpetualMarketFunding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerpetualMarketFunding(const PerpetualMarketFunding& from);
  PerpetualMarketFunding(PerpetualMarketFunding&& from) noexcept
    : PerpetualMarketFunding() {
    *this = ::std::move(from);
  }

  inline PerpetualMarketFunding& operator=(const PerpetualMarketFunding& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerpetualMarketFunding& operator=(PerpetualMarketFunding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerpetualMarketFunding& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerpetualMarketFunding* internal_default_instance() {
    return reinterpret_cast<const PerpetualMarketFunding*>(
               &_PerpetualMarketFunding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PerpetualMarketFunding& a, PerpetualMarketFunding& b) {
    a.Swap(&b);
  }
  inline void Swap(PerpetualMarketFunding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerpetualMarketFunding* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerpetualMarketFunding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerpetualMarketFunding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerpetualMarketFunding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerpetualMarketFunding& from) {
    PerpetualMarketFunding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerpetualMarketFunding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.PerpetualMarketFunding";
  }
  protected:
  explicit PerpetualMarketFunding(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCumulativeFundingFieldNumber = 1,
    kCumulativePriceFieldNumber = 2,
    kLastTimestampFieldNumber = 3,
  };
  // string cumulative_funding = 1 [json_name = "cumulativeFunding", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_cumulative_funding() ;
  const std::string& cumulative_funding() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cumulative_funding(Arg_&& arg, Args_... args);
  std::string* mutable_cumulative_funding();
  PROTOBUF_NODISCARD std::string* release_cumulative_funding();
  void set_allocated_cumulative_funding(std::string* ptr);

  private:
  const std::string& _internal_cumulative_funding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cumulative_funding(
      const std::string& value);
  std::string* _internal_mutable_cumulative_funding();

  public:
  // string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_cumulative_price() ;
  const std::string& cumulative_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cumulative_price(Arg_&& arg, Args_... args);
  std::string* mutable_cumulative_price();
  PROTOBUF_NODISCARD std::string* release_cumulative_price();
  void set_allocated_cumulative_price(std::string* ptr);

  private:
  const std::string& _internal_cumulative_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cumulative_price(
      const std::string& value);
  std::string* _internal_mutable_cumulative_price();

  public:
  // int64 last_timestamp = 3 [json_name = "lastTimestamp"];
  void clear_last_timestamp() ;
  ::int64_t last_timestamp() const;
  void set_last_timestamp(::int64_t value);

  private:
  ::int64_t _internal_last_timestamp() const;
  void _internal_set_last_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.PerpetualMarketFunding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cumulative_funding_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cumulative_price_;
    ::int64_t last_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class DerivativeMarketSettlementInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeMarketSettlementInfo) */ {
 public:
  inline DerivativeMarketSettlementInfo() : DerivativeMarketSettlementInfo(nullptr) {}
  ~DerivativeMarketSettlementInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeMarketSettlementInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeMarketSettlementInfo(const DerivativeMarketSettlementInfo& from);
  DerivativeMarketSettlementInfo(DerivativeMarketSettlementInfo&& from) noexcept
    : DerivativeMarketSettlementInfo() {
    *this = ::std::move(from);
  }

  inline DerivativeMarketSettlementInfo& operator=(const DerivativeMarketSettlementInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeMarketSettlementInfo& operator=(DerivativeMarketSettlementInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeMarketSettlementInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeMarketSettlementInfo* internal_default_instance() {
    return reinterpret_cast<const DerivativeMarketSettlementInfo*>(
               &_DerivativeMarketSettlementInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DerivativeMarketSettlementInfo& a, DerivativeMarketSettlementInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeMarketSettlementInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeMarketSettlementInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeMarketSettlementInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeMarketSettlementInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeMarketSettlementInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeMarketSettlementInfo& from) {
    DerivativeMarketSettlementInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeMarketSettlementInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeMarketSettlementInfo";
  }
  protected:
  explicit DerivativeMarketSettlementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSettlementPriceFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string settlement_price = 2 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_settlement_price() ;
  const std::string& settlement_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlement_price(Arg_&& arg, Args_... args);
  std::string* mutable_settlement_price();
  PROTOBUF_NODISCARD std::string* release_settlement_price();
  void set_allocated_settlement_price(std::string* ptr);

  private:
  const std::string& _internal_settlement_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlement_price(
      const std::string& value);
  std::string* _internal_mutable_settlement_price();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class NextFundingTimestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.NextFundingTimestamp) */ {
 public:
  inline NextFundingTimestamp() : NextFundingTimestamp(nullptr) {}
  ~NextFundingTimestamp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NextFundingTimestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextFundingTimestamp(const NextFundingTimestamp& from);
  NextFundingTimestamp(NextFundingTimestamp&& from) noexcept
    : NextFundingTimestamp() {
    *this = ::std::move(from);
  }

  inline NextFundingTimestamp& operator=(const NextFundingTimestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextFundingTimestamp& operator=(NextFundingTimestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextFundingTimestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextFundingTimestamp* internal_default_instance() {
    return reinterpret_cast<const NextFundingTimestamp*>(
               &_NextFundingTimestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NextFundingTimestamp& a, NextFundingTimestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(NextFundingTimestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextFundingTimestamp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextFundingTimestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextFundingTimestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextFundingTimestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextFundingTimestamp& from) {
    NextFundingTimestamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextFundingTimestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.NextFundingTimestamp";
  }
  protected:
  explicit NextFundingTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextTimestampFieldNumber = 1,
  };
  // int64 next_timestamp = 1 [json_name = "nextTimestamp"];
  void clear_next_timestamp() ;
  ::int64_t next_timestamp() const;
  void set_next_timestamp(::int64_t value);

  private:
  ::int64_t _internal_next_timestamp() const;
  void _internal_set_next_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.NextFundingTimestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t next_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class MidPriceAndTOB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MidPriceAndTOB) */ {
 public:
  inline MidPriceAndTOB() : MidPriceAndTOB(nullptr) {}
  ~MidPriceAndTOB() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MidPriceAndTOB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MidPriceAndTOB(const MidPriceAndTOB& from);
  MidPriceAndTOB(MidPriceAndTOB&& from) noexcept
    : MidPriceAndTOB() {
    *this = ::std::move(from);
  }

  inline MidPriceAndTOB& operator=(const MidPriceAndTOB& from) {
    CopyFrom(from);
    return *this;
  }
  inline MidPriceAndTOB& operator=(MidPriceAndTOB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MidPriceAndTOB& default_instance() {
    return *internal_default_instance();
  }
  static inline const MidPriceAndTOB* internal_default_instance() {
    return reinterpret_cast<const MidPriceAndTOB*>(
               &_MidPriceAndTOB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MidPriceAndTOB& a, MidPriceAndTOB& b) {
    a.Swap(&b);
  }
  inline void Swap(MidPriceAndTOB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MidPriceAndTOB* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MidPriceAndTOB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MidPriceAndTOB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MidPriceAndTOB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MidPriceAndTOB& from) {
    MidPriceAndTOB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MidPriceAndTOB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MidPriceAndTOB";
  }
  protected:
  explicit MidPriceAndTOB(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMidPriceFieldNumber = 1,
    kBestBuyPriceFieldNumber = 2,
    kBestSellPriceFieldNumber = 3,
  };
  // string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_mid_price() ;
  const std::string& mid_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mid_price(Arg_&& arg, Args_... args);
  std::string* mutable_mid_price();
  PROTOBUF_NODISCARD std::string* release_mid_price();
  void set_allocated_mid_price(std::string* ptr);

  private:
  const std::string& _internal_mid_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mid_price(
      const std::string& value);
  std::string* _internal_mutable_mid_price();

  public:
  // string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_best_buy_price() ;
  const std::string& best_buy_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_best_buy_price(Arg_&& arg, Args_... args);
  std::string* mutable_best_buy_price();
  PROTOBUF_NODISCARD std::string* release_best_buy_price();
  void set_allocated_best_buy_price(std::string* ptr);

  private:
  const std::string& _internal_best_buy_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_best_buy_price(
      const std::string& value);
  std::string* _internal_mutable_best_buy_price();

  public:
  // string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_best_sell_price() ;
  const std::string& best_sell_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_best_sell_price(Arg_&& arg, Args_... args);
  std::string* mutable_best_sell_price();
  PROTOBUF_NODISCARD std::string* release_best_sell_price();
  void set_allocated_best_sell_price(std::string* ptr);

  private:
  const std::string& _internal_best_sell_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_best_sell_price(
      const std::string& value);
  std::string* _internal_mutable_best_sell_price();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MidPriceAndTOB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mid_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr best_buy_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr best_sell_price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SpotMarket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SpotMarket) */ {
 public:
  inline SpotMarket() : SpotMarket(nullptr) {}
  ~SpotMarket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotMarket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotMarket(const SpotMarket& from);
  SpotMarket(SpotMarket&& from) noexcept
    : SpotMarket() {
    *this = ::std::move(from);
  }

  inline SpotMarket& operator=(const SpotMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotMarket& operator=(SpotMarket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotMarket& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotMarket* internal_default_instance() {
    return reinterpret_cast<const SpotMarket*>(
               &_SpotMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SpotMarket& a, SpotMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotMarket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotMarket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotMarket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotMarket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotMarket& from) {
    SpotMarket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotMarket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SpotMarket";
  }
  protected:
  explicit SpotMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickerFieldNumber = 1,
    kBaseDenomFieldNumber = 2,
    kQuoteDenomFieldNumber = 3,
    kMakerFeeRateFieldNumber = 4,
    kTakerFeeRateFieldNumber = 5,
    kRelayerFeeShareRateFieldNumber = 6,
    kMarketIdFieldNumber = 7,
    kMinPriceTickSizeFieldNumber = 9,
    kMinQuantityTickSizeFieldNumber = 10,
    kStatusFieldNumber = 8,
  };
  // string ticker = 1 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string base_denom = 2 [json_name = "baseDenom"];
  void clear_base_denom() ;
  const std::string& base_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_denom(Arg_&& arg, Args_... args);
  std::string* mutable_base_denom();
  PROTOBUF_NODISCARD std::string* release_base_denom();
  void set_allocated_base_denom(std::string* ptr);

  private:
  const std::string& _internal_base_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_denom(
      const std::string& value);
  std::string* _internal_mutable_base_denom();

  public:
  // string quote_denom = 3 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_relayer_fee_share_rate() ;
  const std::string& relayer_fee_share_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer_fee_share_rate(Arg_&& arg, Args_... args);
  std::string* mutable_relayer_fee_share_rate();
  PROTOBUF_NODISCARD std::string* release_relayer_fee_share_rate();
  void set_allocated_relayer_fee_share_rate(std::string* ptr);

  private:
  const std::string& _internal_relayer_fee_share_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer_fee_share_rate(
      const std::string& value);
  std::string* _internal_mutable_relayer_fee_share_rate();

  public:
  // string market_id = 7 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string min_price_tick_size = 9 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 10 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // .injective.exchange.v1beta1.MarketStatus status = 8 [json_name = "status"];
  void clear_status() ;
  ::injective::exchange::v1beta1::MarketStatus status() const;
  void set_status(::injective::exchange::v1beta1::MarketStatus value);

  private:
  ::injective::exchange::v1beta1::MarketStatus _internal_status() const;
  void _internal_set_status(::injective::exchange::v1beta1::MarketStatus value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SpotMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_fee_share_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class Deposit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.Deposit) */ {
 public:
  inline Deposit() : Deposit(nullptr) {}
  ~Deposit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Deposit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Deposit(const Deposit& from);
  Deposit(Deposit&& from) noexcept
    : Deposit() {
    *this = ::std::move(from);
  }

  inline Deposit& operator=(const Deposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Deposit& operator=(Deposit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Deposit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Deposit* internal_default_instance() {
    return reinterpret_cast<const Deposit*>(
               &_Deposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Deposit& a, Deposit& b) {
    a.Swap(&b);
  }
  inline void Swap(Deposit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Deposit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Deposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Deposit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Deposit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Deposit& from) {
    Deposit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Deposit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.Deposit";
  }
  protected:
  explicit Deposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableBalanceFieldNumber = 1,
    kTotalBalanceFieldNumber = 2,
  };
  // string available_balance = 1 [json_name = "availableBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_available_balance() ;
  const std::string& available_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_available_balance(Arg_&& arg, Args_... args);
  std::string* mutable_available_balance();
  PROTOBUF_NODISCARD std::string* release_available_balance();
  void set_allocated_available_balance(std::string* ptr);

  private:
  const std::string& _internal_available_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_available_balance(
      const std::string& value);
  std::string* _internal_mutable_available_balance();

  public:
  // string total_balance = 2 [json_name = "totalBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_total_balance() ;
  const std::string& total_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total_balance(Arg_&& arg, Args_... args);
  std::string* mutable_total_balance();
  PROTOBUF_NODISCARD std::string* release_total_balance();
  void set_allocated_total_balance(std::string* ptr);

  private:
  const std::string& _internal_total_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_balance(
      const std::string& value);
  std::string* _internal_mutable_total_balance();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.Deposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr available_balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SubaccountTradeNonce final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SubaccountTradeNonce) */ {
 public:
  inline SubaccountTradeNonce() : SubaccountTradeNonce(nullptr) {}
  ~SubaccountTradeNonce() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountTradeNonce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountTradeNonce(const SubaccountTradeNonce& from);
  SubaccountTradeNonce(SubaccountTradeNonce&& from) noexcept
    : SubaccountTradeNonce() {
    *this = ::std::move(from);
  }

  inline SubaccountTradeNonce& operator=(const SubaccountTradeNonce& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountTradeNonce& operator=(SubaccountTradeNonce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountTradeNonce& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountTradeNonce* internal_default_instance() {
    return reinterpret_cast<const SubaccountTradeNonce*>(
               &_SubaccountTradeNonce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SubaccountTradeNonce& a, SubaccountTradeNonce& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountTradeNonce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountTradeNonce* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountTradeNonce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountTradeNonce>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountTradeNonce& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountTradeNonce& from) {
    SubaccountTradeNonce::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountTradeNonce* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SubaccountTradeNonce";
  }
  protected:
  explicit SubaccountTradeNonce(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint32 nonce = 1 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint32_t nonce() const;
  void set_nonce(::uint32_t value);

  private:
  ::uint32_t _internal_nonce() const;
  void _internal_set_nonce(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SubaccountTradeNonce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class OrderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.OrderInfo) */ {
 public:
  inline OrderInfo() : OrderInfo(nullptr) {}
  ~OrderInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderInfo(const OrderInfo& from);
  OrderInfo(OrderInfo&& from) noexcept
    : OrderInfo() {
    *this = ::std::move(from);
  }

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderInfo& operator=(OrderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderInfo* internal_default_instance() {
    return reinterpret_cast<const OrderInfo*>(
               &_OrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(OrderInfo& a, OrderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderInfo& from) {
    OrderInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.OrderInfo";
  }
  protected:
  explicit OrderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kFeeRecipientFieldNumber = 2,
    kPriceFieldNumber = 3,
    kQuantityFieldNumber = 4,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string fee_recipient = 2 [json_name = "feeRecipient"];
  void clear_fee_recipient() ;
  const std::string& fee_recipient() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_recipient(Arg_&& arg, Args_... args);
  std::string* mutable_fee_recipient();
  PROTOBUF_NODISCARD std::string* release_fee_recipient();
  void set_allocated_fee_recipient(std::string* ptr);

  private:
  const std::string& _internal_fee_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_recipient(
      const std::string& value);
  std::string* _internal_mutable_fee_recipient();

  public:
  // string price = 3 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 4 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.OrderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_recipient_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SpotOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SpotOrder) */ {
 public:
  inline SpotOrder() : SpotOrder(nullptr) {}
  ~SpotOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotOrder(const SpotOrder& from);
  SpotOrder(SpotOrder&& from) noexcept
    : SpotOrder() {
    *this = ::std::move(from);
  }

  inline SpotOrder& operator=(const SpotOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotOrder& operator=(SpotOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotOrder* internal_default_instance() {
    return reinterpret_cast<const SpotOrder*>(
               &_SpotOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SpotOrder& a, SpotOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotOrder& from) {
    SpotOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SpotOrder";
  }
  protected:
  explicit SpotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kTriggerPriceFieldNumber = 4,
    kOrderInfoFieldNumber = 2,
    kOrderTypeFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  bool has_order_info() const;
  void clear_order_info() ;
  const ::injective::exchange::v1beta1::OrderInfo& order_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::OrderInfo* release_order_info();
  ::injective::exchange::v1beta1::OrderInfo* mutable_order_info();
  void set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info);
  private:
  const ::injective::exchange::v1beta1::OrderInfo& _internal_order_info() const;
  ::injective::exchange::v1beta1::OrderInfo* _internal_mutable_order_info();
  public:
  void unsafe_arena_set_allocated_order_info(
      ::injective::exchange::v1beta1::OrderInfo* order_info);
  ::injective::exchange::v1beta1::OrderInfo* unsafe_arena_release_order_info();
  // .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
  void clear_order_type() ;
  ::injective::exchange::v1beta1::OrderType order_type() const;
  void set_order_type(::injective::exchange::v1beta1::OrderType value);

  private:
  ::injective::exchange::v1beta1::OrderType _internal_order_type() const;
  void _internal_set_order_type(::injective::exchange::v1beta1::OrderType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SpotOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::injective::exchange::v1beta1::OrderInfo* order_info_;
    int order_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SpotLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SpotLimitOrder) */ {
 public:
  inline SpotLimitOrder() : SpotLimitOrder(nullptr) {}
  ~SpotLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotLimitOrder(const SpotLimitOrder& from);
  SpotLimitOrder(SpotLimitOrder&& from) noexcept
    : SpotLimitOrder() {
    *this = ::std::move(from);
  }

  inline SpotLimitOrder& operator=(const SpotLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotLimitOrder& operator=(SpotLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotLimitOrder* internal_default_instance() {
    return reinterpret_cast<const SpotLimitOrder*>(
               &_SpotLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SpotLimitOrder& a, SpotLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotLimitOrder& from) {
    SpotLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SpotLimitOrder";
  }
  protected:
  explicit SpotLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFillableFieldNumber = 3,
    kTriggerPriceFieldNumber = 4,
    kOrderHashFieldNumber = 5,
    kOrderInfoFieldNumber = 1,
    kOrderTypeFieldNumber = 2,
  };
  // string fillable = 3 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fillable() ;
  const std::string& fillable() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fillable(Arg_&& arg, Args_... args);
  std::string* mutable_fillable();
  PROTOBUF_NODISCARD std::string* release_fillable();
  void set_allocated_fillable(std::string* ptr);

  private:
  const std::string& _internal_fillable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fillable(
      const std::string& value);
  std::string* _internal_mutable_fillable();

  public:
  // string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // bytes order_hash = 5 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  bool has_order_info() const;
  void clear_order_info() ;
  const ::injective::exchange::v1beta1::OrderInfo& order_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::OrderInfo* release_order_info();
  ::injective::exchange::v1beta1::OrderInfo* mutable_order_info();
  void set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info);
  private:
  const ::injective::exchange::v1beta1::OrderInfo& _internal_order_info() const;
  ::injective::exchange::v1beta1::OrderInfo* _internal_mutable_order_info();
  public:
  void unsafe_arena_set_allocated_order_info(
      ::injective::exchange::v1beta1::OrderInfo* order_info);
  ::injective::exchange::v1beta1::OrderInfo* unsafe_arena_release_order_info();
  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  void clear_order_type() ;
  ::injective::exchange::v1beta1::OrderType order_type() const;
  void set_order_type(::injective::exchange::v1beta1::OrderType value);

  private:
  ::injective::exchange::v1beta1::OrderType _internal_order_type() const;
  void _internal_set_order_type(::injective::exchange::v1beta1::OrderType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SpotLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fillable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::injective::exchange::v1beta1::OrderInfo* order_info_;
    int order_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SpotMarketOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SpotMarketOrder) */ {
 public:
  inline SpotMarketOrder() : SpotMarketOrder(nullptr) {}
  ~SpotMarketOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotMarketOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotMarketOrder(const SpotMarketOrder& from);
  SpotMarketOrder(SpotMarketOrder&& from) noexcept
    : SpotMarketOrder() {
    *this = ::std::move(from);
  }

  inline SpotMarketOrder& operator=(const SpotMarketOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotMarketOrder& operator=(SpotMarketOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotMarketOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotMarketOrder* internal_default_instance() {
    return reinterpret_cast<const SpotMarketOrder*>(
               &_SpotMarketOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SpotMarketOrder& a, SpotMarketOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotMarketOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotMarketOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotMarketOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotMarketOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotMarketOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotMarketOrder& from) {
    SpotMarketOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotMarketOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SpotMarketOrder";
  }
  protected:
  explicit SpotMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceHoldFieldNumber = 2,
    kOrderHashFieldNumber = 3,
    kTriggerPriceFieldNumber = 5,
    kOrderInfoFieldNumber = 1,
    kOrderTypeFieldNumber = 4,
  };
  // string balance_hold = 2 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_balance_hold() ;
  const std::string& balance_hold() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance_hold(Arg_&& arg, Args_... args);
  std::string* mutable_balance_hold();
  PROTOBUF_NODISCARD std::string* release_balance_hold();
  void set_allocated_balance_hold(std::string* ptr);

  private:
  const std::string& _internal_balance_hold() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance_hold(
      const std::string& value);
  std::string* _internal_mutable_balance_hold();

  public:
  // bytes order_hash = 3 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  bool has_order_info() const;
  void clear_order_info() ;
  const ::injective::exchange::v1beta1::OrderInfo& order_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::OrderInfo* release_order_info();
  ::injective::exchange::v1beta1::OrderInfo* mutable_order_info();
  void set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info);
  private:
  const ::injective::exchange::v1beta1::OrderInfo& _internal_order_info() const;
  ::injective::exchange::v1beta1::OrderInfo* _internal_mutable_order_info();
  public:
  void unsafe_arena_set_allocated_order_info(
      ::injective::exchange::v1beta1::OrderInfo* order_info);
  ::injective::exchange::v1beta1::OrderInfo* unsafe_arena_release_order_info();
  // .injective.exchange.v1beta1.OrderType order_type = 4 [json_name = "orderType"];
  void clear_order_type() ;
  ::injective::exchange::v1beta1::OrderType order_type() const;
  void set_order_type(::injective::exchange::v1beta1::OrderType value);

  private:
  ::injective::exchange::v1beta1::OrderType _internal_order_type() const;
  void _internal_set_order_type(::injective::exchange::v1beta1::OrderType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SpotMarketOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_hold_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::injective::exchange::v1beta1::OrderInfo* order_info_;
    int order_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class DerivativeOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeOrder) */ {
 public:
  inline DerivativeOrder() : DerivativeOrder(nullptr) {}
  ~DerivativeOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeOrder(const DerivativeOrder& from);
  DerivativeOrder(DerivativeOrder&& from) noexcept
    : DerivativeOrder() {
    *this = ::std::move(from);
  }

  inline DerivativeOrder& operator=(const DerivativeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeOrder& operator=(DerivativeOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeOrder* internal_default_instance() {
    return reinterpret_cast<const DerivativeOrder*>(
               &_DerivativeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DerivativeOrder& a, DerivativeOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeOrder& from) {
    DerivativeOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeOrder";
  }
  protected:
  explicit DerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kMarginFieldNumber = 4,
    kTriggerPriceFieldNumber = 5,
    kOrderInfoFieldNumber = 2,
    kOrderTypeFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  bool has_order_info() const;
  void clear_order_info() ;
  const ::injective::exchange::v1beta1::OrderInfo& order_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::OrderInfo* release_order_info();
  ::injective::exchange::v1beta1::OrderInfo* mutable_order_info();
  void set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info);
  private:
  const ::injective::exchange::v1beta1::OrderInfo& _internal_order_info() const;
  ::injective::exchange::v1beta1::OrderInfo* _internal_mutable_order_info();
  public:
  void unsafe_arena_set_allocated_order_info(
      ::injective::exchange::v1beta1::OrderInfo* order_info);
  ::injective::exchange::v1beta1::OrderInfo* unsafe_arena_release_order_info();
  // .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
  void clear_order_type() ;
  ::injective::exchange::v1beta1::OrderType order_type() const;
  void set_order_type(::injective::exchange::v1beta1::OrderType value);

  private:
  ::injective::exchange::v1beta1::OrderType _internal_order_type() const;
  void _internal_set_order_type(::injective::exchange::v1beta1::OrderType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::injective::exchange::v1beta1::OrderInfo* order_info_;
    int order_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrderbookMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SubaccountOrderbookMetadata) */ {
 public:
  inline SubaccountOrderbookMetadata() : SubaccountOrderbookMetadata(nullptr) {}
  ~SubaccountOrderbookMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrderbookMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrderbookMetadata(const SubaccountOrderbookMetadata& from);
  SubaccountOrderbookMetadata(SubaccountOrderbookMetadata&& from) noexcept
    : SubaccountOrderbookMetadata() {
    *this = ::std::move(from);
  }

  inline SubaccountOrderbookMetadata& operator=(const SubaccountOrderbookMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrderbookMetadata& operator=(SubaccountOrderbookMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrderbookMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrderbookMetadata* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrderbookMetadata*>(
               &_SubaccountOrderbookMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SubaccountOrderbookMetadata& a, SubaccountOrderbookMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrderbookMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrderbookMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrderbookMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrderbookMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrderbookMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrderbookMetadata& from) {
    SubaccountOrderbookMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrderbookMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SubaccountOrderbookMetadata";
  }
  protected:
  explicit SubaccountOrderbookMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAggregateReduceOnlyQuantityFieldNumber = 3,
    kAggregateVanillaQuantityFieldNumber = 4,
    kVanillaLimitOrderCountFieldNumber = 1,
    kReduceOnlyLimitOrderCountFieldNumber = 2,
    kVanillaConditionalOrderCountFieldNumber = 5,
    kReduceOnlyConditionalOrderCountFieldNumber = 6,
  };
  // string aggregate_reduce_only_quantity = 3 [json_name = "aggregateReduceOnlyQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_aggregate_reduce_only_quantity() ;
  const std::string& aggregate_reduce_only_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aggregate_reduce_only_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_aggregate_reduce_only_quantity();
  PROTOBUF_NODISCARD std::string* release_aggregate_reduce_only_quantity();
  void set_allocated_aggregate_reduce_only_quantity(std::string* ptr);

  private:
  const std::string& _internal_aggregate_reduce_only_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregate_reduce_only_quantity(
      const std::string& value);
  std::string* _internal_mutable_aggregate_reduce_only_quantity();

  public:
  // string aggregate_vanilla_quantity = 4 [json_name = "aggregateVanillaQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_aggregate_vanilla_quantity() ;
  const std::string& aggregate_vanilla_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aggregate_vanilla_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_aggregate_vanilla_quantity();
  PROTOBUF_NODISCARD std::string* release_aggregate_vanilla_quantity();
  void set_allocated_aggregate_vanilla_quantity(std::string* ptr);

  private:
  const std::string& _internal_aggregate_vanilla_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregate_vanilla_quantity(
      const std::string& value);
  std::string* _internal_mutable_aggregate_vanilla_quantity();

  public:
  // uint32 vanilla_limit_order_count = 1 [json_name = "vanillaLimitOrderCount"];
  void clear_vanilla_limit_order_count() ;
  ::uint32_t vanilla_limit_order_count() const;
  void set_vanilla_limit_order_count(::uint32_t value);

  private:
  ::uint32_t _internal_vanilla_limit_order_count() const;
  void _internal_set_vanilla_limit_order_count(::uint32_t value);

  public:
  // uint32 reduce_only_limit_order_count = 2 [json_name = "reduceOnlyLimitOrderCount"];
  void clear_reduce_only_limit_order_count() ;
  ::uint32_t reduce_only_limit_order_count() const;
  void set_reduce_only_limit_order_count(::uint32_t value);

  private:
  ::uint32_t _internal_reduce_only_limit_order_count() const;
  void _internal_set_reduce_only_limit_order_count(::uint32_t value);

  public:
  // uint32 vanilla_conditional_order_count = 5 [json_name = "vanillaConditionalOrderCount"];
  void clear_vanilla_conditional_order_count() ;
  ::uint32_t vanilla_conditional_order_count() const;
  void set_vanilla_conditional_order_count(::uint32_t value);

  private:
  ::uint32_t _internal_vanilla_conditional_order_count() const;
  void _internal_set_vanilla_conditional_order_count(::uint32_t value);

  public:
  // uint32 reduce_only_conditional_order_count = 6 [json_name = "reduceOnlyConditionalOrderCount"];
  void clear_reduce_only_conditional_order_count() ;
  ::uint32_t reduce_only_conditional_order_count() const;
  void set_reduce_only_conditional_order_count(::uint32_t value);

  private:
  ::uint32_t _internal_reduce_only_conditional_order_count() const;
  void _internal_set_reduce_only_conditional_order_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aggregate_reduce_only_quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aggregate_vanilla_quantity_;
    ::uint32_t vanilla_limit_order_count_;
    ::uint32_t reduce_only_limit_order_count_;
    ::uint32_t vanilla_conditional_order_count_;
    ::uint32_t reduce_only_conditional_order_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SubaccountOrder) */ {
 public:
  inline SubaccountOrder() : SubaccountOrder(nullptr) {}
  ~SubaccountOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrder(const SubaccountOrder& from);
  SubaccountOrder(SubaccountOrder&& from) noexcept
    : SubaccountOrder() {
    *this = ::std::move(from);
  }

  inline SubaccountOrder& operator=(const SubaccountOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrder& operator=(SubaccountOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrder* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrder*>(
               &_SubaccountOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SubaccountOrder& a, SubaccountOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrder& from) {
    SubaccountOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SubaccountOrder";
  }
  protected:
  explicit SubaccountOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kIsReduceOnlyFieldNumber = 3,
  };
  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // bool isReduceOnly = 3 [json_name = "isReduceOnly"];
  void clear_isreduceonly() ;
  bool isreduceonly() const;
  void set_isreduceonly(bool value);

  private:
  bool _internal_isreduceonly() const;
  void _internal_set_isreduceonly(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SubaccountOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    bool isreduceonly_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrderData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SubaccountOrderData) */ {
 public:
  inline SubaccountOrderData() : SubaccountOrderData(nullptr) {}
  ~SubaccountOrderData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrderData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrderData(const SubaccountOrderData& from);
  SubaccountOrderData(SubaccountOrderData&& from) noexcept
    : SubaccountOrderData() {
    *this = ::std::move(from);
  }

  inline SubaccountOrderData& operator=(const SubaccountOrderData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrderData& operator=(SubaccountOrderData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrderData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrderData* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrderData*>(
               &_SubaccountOrderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SubaccountOrderData& a, SubaccountOrderData& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrderData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrderData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrderData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrderData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrderData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrderData& from) {
    SubaccountOrderData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrderData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SubaccountOrderData";
  }
  protected:
  explicit SubaccountOrderData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 2,
    kOrderFieldNumber = 1,
  };
  // bytes order_hash = 2 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // .injective.exchange.v1beta1.SubaccountOrder order = 1 [json_name = "order"];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::SubaccountOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SubaccountOrder* release_order();
  ::injective::exchange::v1beta1::SubaccountOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::SubaccountOrder* order);
  private:
  const ::injective::exchange::v1beta1::SubaccountOrder& _internal_order() const;
  ::injective::exchange::v1beta1::SubaccountOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::SubaccountOrder* order);
  ::injective::exchange::v1beta1::SubaccountOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SubaccountOrderData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::injective::exchange::v1beta1::SubaccountOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class DerivativeLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeLimitOrder) */ {
 public:
  inline DerivativeLimitOrder() : DerivativeLimitOrder(nullptr) {}
  ~DerivativeLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeLimitOrder(const DerivativeLimitOrder& from);
  DerivativeLimitOrder(DerivativeLimitOrder&& from) noexcept
    : DerivativeLimitOrder() {
    *this = ::std::move(from);
  }

  inline DerivativeLimitOrder& operator=(const DerivativeLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeLimitOrder& operator=(DerivativeLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeLimitOrder* internal_default_instance() {
    return reinterpret_cast<const DerivativeLimitOrder*>(
               &_DerivativeLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DerivativeLimitOrder& a, DerivativeLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeLimitOrder& from) {
    DerivativeLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeLimitOrder";
  }
  protected:
  explicit DerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarginFieldNumber = 3,
    kFillableFieldNumber = 4,
    kTriggerPriceFieldNumber = 5,
    kOrderHashFieldNumber = 6,
    kOrderInfoFieldNumber = 1,
    kOrderTypeFieldNumber = 2,
  };
  // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // string fillable = 4 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fillable() ;
  const std::string& fillable() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fillable(Arg_&& arg, Args_... args);
  std::string* mutable_fillable();
  PROTOBUF_NODISCARD std::string* release_fillable();
  void set_allocated_fillable(std::string* ptr);

  private:
  const std::string& _internal_fillable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fillable(
      const std::string& value);
  std::string* _internal_mutable_fillable();

  public:
  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // bytes order_hash = 6 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  bool has_order_info() const;
  void clear_order_info() ;
  const ::injective::exchange::v1beta1::OrderInfo& order_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::OrderInfo* release_order_info();
  ::injective::exchange::v1beta1::OrderInfo* mutable_order_info();
  void set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info);
  private:
  const ::injective::exchange::v1beta1::OrderInfo& _internal_order_info() const;
  ::injective::exchange::v1beta1::OrderInfo* _internal_mutable_order_info();
  public:
  void unsafe_arena_set_allocated_order_info(
      ::injective::exchange::v1beta1::OrderInfo* order_info);
  ::injective::exchange::v1beta1::OrderInfo* unsafe_arena_release_order_info();
  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  void clear_order_type() ;
  ::injective::exchange::v1beta1::OrderType order_type() const;
  void set_order_type(::injective::exchange::v1beta1::OrderType value);

  private:
  ::injective::exchange::v1beta1::OrderType _internal_order_type() const;
  void _internal_set_order_type(::injective::exchange::v1beta1::OrderType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fillable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::injective::exchange::v1beta1::OrderInfo* order_info_;
    int order_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class DerivativeMarketOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeMarketOrder) */ {
 public:
  inline DerivativeMarketOrder() : DerivativeMarketOrder(nullptr) {}
  ~DerivativeMarketOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeMarketOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeMarketOrder(const DerivativeMarketOrder& from);
  DerivativeMarketOrder(DerivativeMarketOrder&& from) noexcept
    : DerivativeMarketOrder() {
    *this = ::std::move(from);
  }

  inline DerivativeMarketOrder& operator=(const DerivativeMarketOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeMarketOrder& operator=(DerivativeMarketOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeMarketOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeMarketOrder* internal_default_instance() {
    return reinterpret_cast<const DerivativeMarketOrder*>(
               &_DerivativeMarketOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DerivativeMarketOrder& a, DerivativeMarketOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeMarketOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeMarketOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeMarketOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeMarketOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeMarketOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeMarketOrder& from) {
    DerivativeMarketOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeMarketOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeMarketOrder";
  }
  protected:
  explicit DerivativeMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarginFieldNumber = 3,
    kMarginHoldFieldNumber = 4,
    kTriggerPriceFieldNumber = 5,
    kOrderHashFieldNumber = 6,
    kOrderInfoFieldNumber = 1,
    kOrderTypeFieldNumber = 2,
  };
  // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // string margin_hold = 4 [json_name = "marginHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_margin_hold() ;
  const std::string& margin_hold() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin_hold(Arg_&& arg, Args_... args);
  std::string* mutable_margin_hold();
  PROTOBUF_NODISCARD std::string* release_margin_hold();
  void set_allocated_margin_hold(std::string* ptr);

  private:
  const std::string& _internal_margin_hold() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin_hold(
      const std::string& value);
  std::string* _internal_mutable_margin_hold();

  public:
  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // bytes order_hash = 6 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  bool has_order_info() const;
  void clear_order_info() ;
  const ::injective::exchange::v1beta1::OrderInfo& order_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::OrderInfo* release_order_info();
  ::injective::exchange::v1beta1::OrderInfo* mutable_order_info();
  void set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info);
  private:
  const ::injective::exchange::v1beta1::OrderInfo& _internal_order_info() const;
  ::injective::exchange::v1beta1::OrderInfo* _internal_mutable_order_info();
  public:
  void unsafe_arena_set_allocated_order_info(
      ::injective::exchange::v1beta1::OrderInfo* order_info);
  ::injective::exchange::v1beta1::OrderInfo* unsafe_arena_release_order_info();
  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  void clear_order_type() ;
  ::injective::exchange::v1beta1::OrderType order_type() const;
  void set_order_type(::injective::exchange::v1beta1::OrderType value);

  private:
  ::injective::exchange::v1beta1::OrderType _internal_order_type() const;
  void _internal_set_order_type(::injective::exchange::v1beta1::OrderType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeMarketOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_hold_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::injective::exchange::v1beta1::OrderInfo* order_info_;
    int order_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuantityFieldNumber = 2,
    kEntryPriceFieldNumber = 3,
    kMarginFieldNumber = 4,
    kCumulativeFundingEntryFieldNumber = 5,
    kIsLongFieldNumber = 1,
  };
  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string entry_price = 3 [json_name = "entryPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_entry_price() ;
  const std::string& entry_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entry_price(Arg_&& arg, Args_... args);
  std::string* mutable_entry_price();
  PROTOBUF_NODISCARD std::string* release_entry_price();
  void set_allocated_entry_price(std::string* ptr);

  private:
  const std::string& _internal_entry_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entry_price(
      const std::string& value);
  std::string* _internal_mutable_entry_price();

  public:
  // string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // string cumulative_funding_entry = 5 [json_name = "cumulativeFundingEntry", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_cumulative_funding_entry() ;
  const std::string& cumulative_funding_entry() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cumulative_funding_entry(Arg_&& arg, Args_... args);
  std::string* mutable_cumulative_funding_entry();
  PROTOBUF_NODISCARD std::string* release_cumulative_funding_entry();
  void set_allocated_cumulative_funding_entry(std::string* ptr);

  private:
  const std::string& _internal_cumulative_funding_entry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cumulative_funding_entry(
      const std::string& value);
  std::string* _internal_mutable_cumulative_funding_entry();

  public:
  // bool isLong = 1 [json_name = "isLong"];
  void clear_islong() ;
  bool islong() const;
  void set_islong(bool value);

  private:
  bool _internal_islong() const;
  void _internal_set_islong(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entry_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cumulative_funding_entry_;
    bool islong_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class MarketOrderIndicator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MarketOrderIndicator) */ {
 public:
  inline MarketOrderIndicator() : MarketOrderIndicator(nullptr) {}
  ~MarketOrderIndicator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketOrderIndicator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketOrderIndicator(const MarketOrderIndicator& from);
  MarketOrderIndicator(MarketOrderIndicator&& from) noexcept
    : MarketOrderIndicator() {
    *this = ::std::move(from);
  }

  inline MarketOrderIndicator& operator=(const MarketOrderIndicator& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketOrderIndicator& operator=(MarketOrderIndicator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketOrderIndicator& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketOrderIndicator* internal_default_instance() {
    return reinterpret_cast<const MarketOrderIndicator*>(
               &_MarketOrderIndicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MarketOrderIndicator& a, MarketOrderIndicator& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketOrderIndicator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketOrderIndicator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketOrderIndicator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketOrderIndicator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketOrderIndicator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketOrderIndicator& from) {
    MarketOrderIndicator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketOrderIndicator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MarketOrderIndicator";
  }
  protected:
  explicit MarketOrderIndicator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kIsBuyFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // bool isBuy = 2 [json_name = "isBuy"];
  void clear_isbuy() ;
  bool isbuy() const;
  void set_isbuy(bool value);

  private:
  bool _internal_isbuy() const;
  void _internal_set_isbuy(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MarketOrderIndicator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    bool isbuy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class TradeLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradeLog) */ {
 public:
  inline TradeLog() : TradeLog(nullptr) {}
  ~TradeLog() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeLog(const TradeLog& from);
  TradeLog(TradeLog&& from) noexcept
    : TradeLog() {
    *this = ::std::move(from);
  }

  inline TradeLog& operator=(const TradeLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeLog& operator=(TradeLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeLog* internal_default_instance() {
    return reinterpret_cast<const TradeLog*>(
               &_TradeLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TradeLog& a, TradeLog& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeLog& from) {
    TradeLog::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradeLog";
  }
  protected:
  explicit TradeLog(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuantityFieldNumber = 1,
    kPriceFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kFeeFieldNumber = 4,
    kOrderHashFieldNumber = 5,
    kFeeRecipientAddressFieldNumber = 6,
  };
  // string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // bytes subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fee() ;
  const std::string& fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee(Arg_&& arg, Args_... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* ptr);

  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(
      const std::string& value);
  std::string* _internal_mutable_fee();

  public:
  // bytes order_hash = 5 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
  void clear_fee_recipient_address() ;
  const std::string& fee_recipient_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_recipient_address(Arg_&& arg, Args_... args);
  std::string* mutable_fee_recipient_address();
  PROTOBUF_NODISCARD std::string* release_fee_recipient_address();
  void set_allocated_fee_recipient_address(std::string* ptr);

  private:
  const std::string& _internal_fee_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_recipient_address(
      const std::string& value);
  std::string* _internal_mutable_fee_recipient_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradeLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_recipient_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class PositionDelta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.PositionDelta) */ {
 public:
  inline PositionDelta() : PositionDelta(nullptr) {}
  ~PositionDelta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionDelta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionDelta(const PositionDelta& from);
  PositionDelta(PositionDelta&& from) noexcept
    : PositionDelta() {
    *this = ::std::move(from);
  }

  inline PositionDelta& operator=(const PositionDelta& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionDelta& operator=(PositionDelta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionDelta& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionDelta* internal_default_instance() {
    return reinterpret_cast<const PositionDelta*>(
               &_PositionDelta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PositionDelta& a, PositionDelta& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionDelta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionDelta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionDelta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionDelta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionDelta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionDelta& from) {
    PositionDelta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionDelta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.PositionDelta";
  }
  protected:
  explicit PositionDelta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionQuantityFieldNumber = 2,
    kExecutionMarginFieldNumber = 3,
    kExecutionPriceFieldNumber = 4,
    kIsLongFieldNumber = 1,
  };
  // string execution_quantity = 2 [json_name = "executionQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_execution_quantity() ;
  const std::string& execution_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_execution_quantity();
  PROTOBUF_NODISCARD std::string* release_execution_quantity();
  void set_allocated_execution_quantity(std::string* ptr);

  private:
  const std::string& _internal_execution_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_quantity(
      const std::string& value);
  std::string* _internal_mutable_execution_quantity();

  public:
  // string execution_margin = 3 [json_name = "executionMargin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_execution_margin() ;
  const std::string& execution_margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_margin(Arg_&& arg, Args_... args);
  std::string* mutable_execution_margin();
  PROTOBUF_NODISCARD std::string* release_execution_margin();
  void set_allocated_execution_margin(std::string* ptr);

  private:
  const std::string& _internal_execution_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_margin(
      const std::string& value);
  std::string* _internal_mutable_execution_margin();

  public:
  // string execution_price = 4 [json_name = "executionPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_execution_price() ;
  const std::string& execution_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_price(Arg_&& arg, Args_... args);
  std::string* mutable_execution_price();
  PROTOBUF_NODISCARD std::string* release_execution_price();
  void set_allocated_execution_price(std::string* ptr);

  private:
  const std::string& _internal_execution_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_price(
      const std::string& value);
  std::string* _internal_mutable_execution_price();

  public:
  // bool is_long = 1 [json_name = "isLong"];
  void clear_is_long() ;
  bool is_long() const;
  void set_is_long(bool value);

  private:
  bool _internal_is_long() const;
  void _internal_set_is_long(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.PositionDelta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_price_;
    bool is_long_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class DerivativeTradeLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeTradeLog) */ {
 public:
  inline DerivativeTradeLog() : DerivativeTradeLog(nullptr) {}
  ~DerivativeTradeLog() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeTradeLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeTradeLog(const DerivativeTradeLog& from);
  DerivativeTradeLog(DerivativeTradeLog&& from) noexcept
    : DerivativeTradeLog() {
    *this = ::std::move(from);
  }

  inline DerivativeTradeLog& operator=(const DerivativeTradeLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeTradeLog& operator=(DerivativeTradeLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeTradeLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeTradeLog* internal_default_instance() {
    return reinterpret_cast<const DerivativeTradeLog*>(
               &_DerivativeTradeLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DerivativeTradeLog& a, DerivativeTradeLog& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeTradeLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeTradeLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeTradeLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeTradeLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeTradeLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeTradeLog& from) {
    DerivativeTradeLog::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeTradeLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeTradeLog";
  }
  protected:
  explicit DerivativeTradeLog(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kPayoutFieldNumber = 3,
    kFeeFieldNumber = 4,
    kOrderHashFieldNumber = 5,
    kFeeRecipientAddressFieldNumber = 6,
    kPositionDeltaFieldNumber = 2,
  };
  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string payout = 3 [json_name = "payout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_payout() ;
  const std::string& payout() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payout(Arg_&& arg, Args_... args);
  std::string* mutable_payout();
  PROTOBUF_NODISCARD std::string* release_payout();
  void set_allocated_payout(std::string* ptr);

  private:
  const std::string& _internal_payout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payout(
      const std::string& value);
  std::string* _internal_mutable_payout();

  public:
  // string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fee() ;
  const std::string& fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee(Arg_&& arg, Args_... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* ptr);

  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(
      const std::string& value);
  std::string* _internal_mutable_fee();

  public:
  // bytes order_hash = 5 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
  void clear_fee_recipient_address() ;
  const std::string& fee_recipient_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_recipient_address(Arg_&& arg, Args_... args);
  std::string* mutable_fee_recipient_address();
  PROTOBUF_NODISCARD std::string* release_fee_recipient_address();
  void set_allocated_fee_recipient_address(std::string* ptr);

  private:
  const std::string& _internal_fee_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_recipient_address(
      const std::string& value);
  std::string* _internal_mutable_fee_recipient_address();

  public:
  // .injective.exchange.v1beta1.PositionDelta position_delta = 2 [json_name = "positionDelta"];
  bool has_position_delta() const;
  void clear_position_delta() ;
  const ::injective::exchange::v1beta1::PositionDelta& position_delta() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PositionDelta* release_position_delta();
  ::injective::exchange::v1beta1::PositionDelta* mutable_position_delta();
  void set_allocated_position_delta(::injective::exchange::v1beta1::PositionDelta* position_delta);
  private:
  const ::injective::exchange::v1beta1::PositionDelta& _internal_position_delta() const;
  ::injective::exchange::v1beta1::PositionDelta* _internal_mutable_position_delta();
  public:
  void unsafe_arena_set_allocated_position_delta(
      ::injective::exchange::v1beta1::PositionDelta* position_delta);
  ::injective::exchange::v1beta1::PositionDelta* unsafe_arena_release_position_delta();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeTradeLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payout_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_recipient_address_;
    ::injective::exchange::v1beta1::PositionDelta* position_delta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SubaccountPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SubaccountPosition) */ {
 public:
  inline SubaccountPosition() : SubaccountPosition(nullptr) {}
  ~SubaccountPosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountPosition(const SubaccountPosition& from);
  SubaccountPosition(SubaccountPosition&& from) noexcept
    : SubaccountPosition() {
    *this = ::std::move(from);
  }

  inline SubaccountPosition& operator=(const SubaccountPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountPosition& operator=(SubaccountPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountPosition* internal_default_instance() {
    return reinterpret_cast<const SubaccountPosition*>(
               &_SubaccountPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SubaccountPosition& a, SubaccountPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountPosition& from) {
    SubaccountPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SubaccountPosition";
  }
  protected:
  explicit SubaccountPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 2,
    kPositionFieldNumber = 1,
  };
  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // .injective.exchange.v1beta1.Position position = 1 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::injective::exchange::v1beta1::Position& position() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::Position* release_position();
  ::injective::exchange::v1beta1::Position* mutable_position();
  void set_allocated_position(::injective::exchange::v1beta1::Position* position);
  private:
  const ::injective::exchange::v1beta1::Position& _internal_position() const;
  ::injective::exchange::v1beta1::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::injective::exchange::v1beta1::Position* position);
  ::injective::exchange::v1beta1::Position* unsafe_arena_release_position();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SubaccountPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::injective::exchange::v1beta1::Position* position_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SubaccountDeposit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SubaccountDeposit) */ {
 public:
  inline SubaccountDeposit() : SubaccountDeposit(nullptr) {}
  ~SubaccountDeposit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountDeposit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountDeposit(const SubaccountDeposit& from);
  SubaccountDeposit(SubaccountDeposit&& from) noexcept
    : SubaccountDeposit() {
    *this = ::std::move(from);
  }

  inline SubaccountDeposit& operator=(const SubaccountDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountDeposit& operator=(SubaccountDeposit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountDeposit& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountDeposit* internal_default_instance() {
    return reinterpret_cast<const SubaccountDeposit*>(
               &_SubaccountDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SubaccountDeposit& a, SubaccountDeposit& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountDeposit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountDeposit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountDeposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountDeposit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountDeposit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountDeposit& from) {
    SubaccountDeposit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountDeposit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SubaccountDeposit";
  }
  protected:
  explicit SubaccountDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kDepositFieldNumber = 2,
  };
  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // .injective.exchange.v1beta1.Deposit deposit = 2 [json_name = "deposit"];
  bool has_deposit() const;
  void clear_deposit() ;
  const ::injective::exchange::v1beta1::Deposit& deposit() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::Deposit* release_deposit();
  ::injective::exchange::v1beta1::Deposit* mutable_deposit();
  void set_allocated_deposit(::injective::exchange::v1beta1::Deposit* deposit);
  private:
  const ::injective::exchange::v1beta1::Deposit& _internal_deposit() const;
  ::injective::exchange::v1beta1::Deposit* _internal_mutable_deposit();
  public:
  void unsafe_arena_set_allocated_deposit(
      ::injective::exchange::v1beta1::Deposit* deposit);
  ::injective::exchange::v1beta1::Deposit* unsafe_arena_release_deposit();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SubaccountDeposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::injective::exchange::v1beta1::Deposit* deposit_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class DepositUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DepositUpdate) */ {
 public:
  inline DepositUpdate() : DepositUpdate(nullptr) {}
  ~DepositUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DepositUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DepositUpdate(const DepositUpdate& from);
  DepositUpdate(DepositUpdate&& from) noexcept
    : DepositUpdate() {
    *this = ::std::move(from);
  }

  inline DepositUpdate& operator=(const DepositUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepositUpdate& operator=(DepositUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DepositUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const DepositUpdate* internal_default_instance() {
    return reinterpret_cast<const DepositUpdate*>(
               &_DepositUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DepositUpdate& a, DepositUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(DepositUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DepositUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DepositUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DepositUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DepositUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DepositUpdate& from) {
    DepositUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepositUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DepositUpdate";
  }
  protected:
  explicit DepositUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepositsFieldNumber = 2,
    kDenomFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.SubaccountDeposit deposits = 2 [json_name = "deposits"];
  int deposits_size() const;
  private:
  int _internal_deposits_size() const;

  public:
  void clear_deposits() ;
  ::injective::exchange::v1beta1::SubaccountDeposit* mutable_deposits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountDeposit >*
      mutable_deposits();
  private:
  const ::injective::exchange::v1beta1::SubaccountDeposit& _internal_deposits(int index) const;
  ::injective::exchange::v1beta1::SubaccountDeposit* _internal_add_deposits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountDeposit>& _internal_deposits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountDeposit>* _internal_mutable_deposits();
  public:
  const ::injective::exchange::v1beta1::SubaccountDeposit& deposits(int index) const;
  ::injective::exchange::v1beta1::SubaccountDeposit* add_deposits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountDeposit >&
      deposits() const;
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DepositUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountDeposit > deposits_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class PointsMultiplier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.PointsMultiplier) */ {
 public:
  inline PointsMultiplier() : PointsMultiplier(nullptr) {}
  ~PointsMultiplier() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointsMultiplier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointsMultiplier(const PointsMultiplier& from);
  PointsMultiplier(PointsMultiplier&& from) noexcept
    : PointsMultiplier() {
    *this = ::std::move(from);
  }

  inline PointsMultiplier& operator=(const PointsMultiplier& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointsMultiplier& operator=(PointsMultiplier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointsMultiplier& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointsMultiplier* internal_default_instance() {
    return reinterpret_cast<const PointsMultiplier*>(
               &_PointsMultiplier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(PointsMultiplier& a, PointsMultiplier& b) {
    a.Swap(&b);
  }
  inline void Swap(PointsMultiplier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointsMultiplier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointsMultiplier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointsMultiplier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointsMultiplier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointsMultiplier& from) {
    PointsMultiplier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointsMultiplier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.PointsMultiplier";
  }
  protected:
  explicit PointsMultiplier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakerPointsMultiplierFieldNumber = 1,
    kTakerPointsMultiplierFieldNumber = 2,
  };
  // string maker_points_multiplier = 1 [json_name = "makerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_points_multiplier() ;
  const std::string& maker_points_multiplier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_points_multiplier(Arg_&& arg, Args_... args);
  std::string* mutable_maker_points_multiplier();
  PROTOBUF_NODISCARD std::string* release_maker_points_multiplier();
  void set_allocated_maker_points_multiplier(std::string* ptr);

  private:
  const std::string& _internal_maker_points_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_points_multiplier(
      const std::string& value);
  std::string* _internal_mutable_maker_points_multiplier();

  public:
  // string taker_points_multiplier = 2 [json_name = "takerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_points_multiplier() ;
  const std::string& taker_points_multiplier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_points_multiplier(Arg_&& arg, Args_... args);
  std::string* mutable_taker_points_multiplier();
  PROTOBUF_NODISCARD std::string* release_taker_points_multiplier();
  void set_allocated_taker_points_multiplier(std::string* ptr);

  private:
  const std::string& _internal_taker_points_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_points_multiplier(
      const std::string& value);
  std::string* _internal_mutable_taker_points_multiplier();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.PointsMultiplier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_points_multiplier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_points_multiplier_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class TradingRewardCampaignBoostInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo) */ {
 public:
  inline TradingRewardCampaignBoostInfo() : TradingRewardCampaignBoostInfo(nullptr) {}
  ~TradingRewardCampaignBoostInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradingRewardCampaignBoostInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradingRewardCampaignBoostInfo(const TradingRewardCampaignBoostInfo& from);
  TradingRewardCampaignBoostInfo(TradingRewardCampaignBoostInfo&& from) noexcept
    : TradingRewardCampaignBoostInfo() {
    *this = ::std::move(from);
  }

  inline TradingRewardCampaignBoostInfo& operator=(const TradingRewardCampaignBoostInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradingRewardCampaignBoostInfo& operator=(TradingRewardCampaignBoostInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradingRewardCampaignBoostInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradingRewardCampaignBoostInfo* internal_default_instance() {
    return reinterpret_cast<const TradingRewardCampaignBoostInfo*>(
               &_TradingRewardCampaignBoostInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(TradingRewardCampaignBoostInfo& a, TradingRewardCampaignBoostInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TradingRewardCampaignBoostInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradingRewardCampaignBoostInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradingRewardCampaignBoostInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradingRewardCampaignBoostInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradingRewardCampaignBoostInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradingRewardCampaignBoostInfo& from) {
    TradingRewardCampaignBoostInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingRewardCampaignBoostInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo";
  }
  protected:
  explicit TradingRewardCampaignBoostInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoostedSpotMarketIdsFieldNumber = 1,
    kSpotMarketMultipliersFieldNumber = 2,
    kBoostedDerivativeMarketIdsFieldNumber = 3,
    kDerivativeMarketMultipliersFieldNumber = 4,
  };
  // repeated string boosted_spot_market_ids = 1 [json_name = "boostedSpotMarketIds"];
  int boosted_spot_market_ids_size() const;
  private:
  int _internal_boosted_spot_market_ids_size() const;

  public:
  void clear_boosted_spot_market_ids() ;
  const std::string& boosted_spot_market_ids(int index) const;
  std::string* mutable_boosted_spot_market_ids(int index);
  void set_boosted_spot_market_ids(int index, const std::string& value);
  void set_boosted_spot_market_ids(int index, std::string&& value);
  void set_boosted_spot_market_ids(int index, const char* value);
  void set_boosted_spot_market_ids(int index, const char* value, std::size_t size);
  void set_boosted_spot_market_ids(int index, absl::string_view value);
  std::string* add_boosted_spot_market_ids();
  void add_boosted_spot_market_ids(const std::string& value);
  void add_boosted_spot_market_ids(std::string&& value);
  void add_boosted_spot_market_ids(const char* value);
  void add_boosted_spot_market_ids(const char* value, std::size_t size);
  void add_boosted_spot_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& boosted_spot_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_boosted_spot_market_ids();

  private:
  const std::string& _internal_boosted_spot_market_ids(int index) const;
  std::string* _internal_add_boosted_spot_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_boosted_spot_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_boosted_spot_market_ids();

  public:
  // repeated .injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2 [json_name = "spotMarketMultipliers", (.gogoproto.nullable) = false];
  int spot_market_multipliers_size() const;
  private:
  int _internal_spot_market_multipliers_size() const;

  public:
  void clear_spot_market_multipliers() ;
  ::injective::exchange::v1beta1::PointsMultiplier* mutable_spot_market_multipliers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier >*
      mutable_spot_market_multipliers();
  private:
  const ::injective::exchange::v1beta1::PointsMultiplier& _internal_spot_market_multipliers(int index) const;
  ::injective::exchange::v1beta1::PointsMultiplier* _internal_add_spot_market_multipliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PointsMultiplier>& _internal_spot_market_multipliers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PointsMultiplier>* _internal_mutable_spot_market_multipliers();
  public:
  const ::injective::exchange::v1beta1::PointsMultiplier& spot_market_multipliers(int index) const;
  ::injective::exchange::v1beta1::PointsMultiplier* add_spot_market_multipliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier >&
      spot_market_multipliers() const;
  // repeated string boosted_derivative_market_ids = 3 [json_name = "boostedDerivativeMarketIds"];
  int boosted_derivative_market_ids_size() const;
  private:
  int _internal_boosted_derivative_market_ids_size() const;

  public:
  void clear_boosted_derivative_market_ids() ;
  const std::string& boosted_derivative_market_ids(int index) const;
  std::string* mutable_boosted_derivative_market_ids(int index);
  void set_boosted_derivative_market_ids(int index, const std::string& value);
  void set_boosted_derivative_market_ids(int index, std::string&& value);
  void set_boosted_derivative_market_ids(int index, const char* value);
  void set_boosted_derivative_market_ids(int index, const char* value, std::size_t size);
  void set_boosted_derivative_market_ids(int index, absl::string_view value);
  std::string* add_boosted_derivative_market_ids();
  void add_boosted_derivative_market_ids(const std::string& value);
  void add_boosted_derivative_market_ids(std::string&& value);
  void add_boosted_derivative_market_ids(const char* value);
  void add_boosted_derivative_market_ids(const char* value, std::size_t size);
  void add_boosted_derivative_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& boosted_derivative_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_boosted_derivative_market_ids();

  private:
  const std::string& _internal_boosted_derivative_market_ids(int index) const;
  std::string* _internal_add_boosted_derivative_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_boosted_derivative_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_boosted_derivative_market_ids();

  public:
  // repeated .injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4 [json_name = "derivativeMarketMultipliers", (.gogoproto.nullable) = false];
  int derivative_market_multipliers_size() const;
  private:
  int _internal_derivative_market_multipliers_size() const;

  public:
  void clear_derivative_market_multipliers() ;
  ::injective::exchange::v1beta1::PointsMultiplier* mutable_derivative_market_multipliers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier >*
      mutable_derivative_market_multipliers();
  private:
  const ::injective::exchange::v1beta1::PointsMultiplier& _internal_derivative_market_multipliers(int index) const;
  ::injective::exchange::v1beta1::PointsMultiplier* _internal_add_derivative_market_multipliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PointsMultiplier>& _internal_derivative_market_multipliers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PointsMultiplier>* _internal_mutable_derivative_market_multipliers();
  public:
  const ::injective::exchange::v1beta1::PointsMultiplier& derivative_market_multipliers(int index) const;
  ::injective::exchange::v1beta1::PointsMultiplier* add_derivative_market_multipliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier >&
      derivative_market_multipliers() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> boosted_spot_market_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier > spot_market_multipliers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> boosted_derivative_market_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier > derivative_market_multipliers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class CampaignRewardPool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.CampaignRewardPool) */ {
 public:
  inline CampaignRewardPool() : CampaignRewardPool(nullptr) {}
  ~CampaignRewardPool() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CampaignRewardPool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CampaignRewardPool(const CampaignRewardPool& from);
  CampaignRewardPool(CampaignRewardPool&& from) noexcept
    : CampaignRewardPool() {
    *this = ::std::move(from);
  }

  inline CampaignRewardPool& operator=(const CampaignRewardPool& from) {
    CopyFrom(from);
    return *this;
  }
  inline CampaignRewardPool& operator=(CampaignRewardPool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CampaignRewardPool& default_instance() {
    return *internal_default_instance();
  }
  static inline const CampaignRewardPool* internal_default_instance() {
    return reinterpret_cast<const CampaignRewardPool*>(
               &_CampaignRewardPool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CampaignRewardPool& a, CampaignRewardPool& b) {
    a.Swap(&b);
  }
  inline void Swap(CampaignRewardPool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CampaignRewardPool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CampaignRewardPool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CampaignRewardPool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CampaignRewardPool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CampaignRewardPool& from) {
    CampaignRewardPool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CampaignRewardPool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.CampaignRewardPool";
  }
  protected:
  explicit CampaignRewardPool(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxCampaignRewardsFieldNumber = 2,
    kStartTimestampFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.Coin max_campaign_rewards = 2 [json_name = "maxCampaignRewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  int max_campaign_rewards_size() const;
  private:
  int _internal_max_campaign_rewards_size() const;

  public:
  void clear_max_campaign_rewards() ;
  ::cosmos::base::v1beta1::Coin* mutable_max_campaign_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_max_campaign_rewards();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_max_campaign_rewards(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_max_campaign_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_max_campaign_rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_max_campaign_rewards();
  public:
  const ::cosmos::base::v1beta1::Coin& max_campaign_rewards(int index) const;
  ::cosmos::base::v1beta1::Coin* add_max_campaign_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      max_campaign_rewards() const;
  // int64 start_timestamp = 1 [json_name = "startTimestamp"];
  void clear_start_timestamp() ;
  ::int64_t start_timestamp() const;
  void set_start_timestamp(::int64_t value);

  private:
  ::int64_t _internal_start_timestamp() const;
  void _internal_set_start_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.CampaignRewardPool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > max_campaign_rewards_;
    ::int64_t start_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class TradingRewardCampaignInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradingRewardCampaignInfo) */ {
 public:
  inline TradingRewardCampaignInfo() : TradingRewardCampaignInfo(nullptr) {}
  ~TradingRewardCampaignInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradingRewardCampaignInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradingRewardCampaignInfo(const TradingRewardCampaignInfo& from);
  TradingRewardCampaignInfo(TradingRewardCampaignInfo&& from) noexcept
    : TradingRewardCampaignInfo() {
    *this = ::std::move(from);
  }

  inline TradingRewardCampaignInfo& operator=(const TradingRewardCampaignInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradingRewardCampaignInfo& operator=(TradingRewardCampaignInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradingRewardCampaignInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradingRewardCampaignInfo* internal_default_instance() {
    return reinterpret_cast<const TradingRewardCampaignInfo*>(
               &_TradingRewardCampaignInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TradingRewardCampaignInfo& a, TradingRewardCampaignInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TradingRewardCampaignInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradingRewardCampaignInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradingRewardCampaignInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradingRewardCampaignInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradingRewardCampaignInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradingRewardCampaignInfo& from) {
    TradingRewardCampaignInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingRewardCampaignInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradingRewardCampaignInfo";
  }
  protected:
  explicit TradingRewardCampaignInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuoteDenomsFieldNumber = 2,
    kDisqualifiedMarketIdsFieldNumber = 4,
    kTradingRewardBoostInfoFieldNumber = 3,
    kCampaignDurationSecondsFieldNumber = 1,
  };
  // repeated string quote_denoms = 2 [json_name = "quoteDenoms"];
  int quote_denoms_size() const;
  private:
  int _internal_quote_denoms_size() const;

  public:
  void clear_quote_denoms() ;
  const std::string& quote_denoms(int index) const;
  std::string* mutable_quote_denoms(int index);
  void set_quote_denoms(int index, const std::string& value);
  void set_quote_denoms(int index, std::string&& value);
  void set_quote_denoms(int index, const char* value);
  void set_quote_denoms(int index, const char* value, std::size_t size);
  void set_quote_denoms(int index, absl::string_view value);
  std::string* add_quote_denoms();
  void add_quote_denoms(const std::string& value);
  void add_quote_denoms(std::string&& value);
  void add_quote_denoms(const char* value);
  void add_quote_denoms(const char* value, std::size_t size);
  void add_quote_denoms(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& quote_denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_quote_denoms();

  private:
  const std::string& _internal_quote_denoms(int index) const;
  std::string* _internal_add_quote_denoms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_quote_denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_quote_denoms();

  public:
  // repeated string disqualified_market_ids = 4 [json_name = "disqualifiedMarketIds"];
  int disqualified_market_ids_size() const;
  private:
  int _internal_disqualified_market_ids_size() const;

  public:
  void clear_disqualified_market_ids() ;
  const std::string& disqualified_market_ids(int index) const;
  std::string* mutable_disqualified_market_ids(int index);
  void set_disqualified_market_ids(int index, const std::string& value);
  void set_disqualified_market_ids(int index, std::string&& value);
  void set_disqualified_market_ids(int index, const char* value);
  void set_disqualified_market_ids(int index, const char* value, std::size_t size);
  void set_disqualified_market_ids(int index, absl::string_view value);
  std::string* add_disqualified_market_ids();
  void add_disqualified_market_ids(const std::string& value);
  void add_disqualified_market_ids(std::string&& value);
  void add_disqualified_market_ids(const char* value);
  void add_disqualified_market_ids(const char* value, std::size_t size);
  void add_disqualified_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& disqualified_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_disqualified_market_ids();

  private:
  const std::string& _internal_disqualified_market_ids(int index) const;
  std::string* _internal_add_disqualified_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_disqualified_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_disqualified_market_ids();

  public:
  // .injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3 [json_name = "tradingRewardBoostInfo"];
  bool has_trading_reward_boost_info() const;
  void clear_trading_reward_boost_info() ;
  const ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo& trading_reward_boost_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* release_trading_reward_boost_info();
  ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* mutable_trading_reward_boost_info();
  void set_allocated_trading_reward_boost_info(::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* trading_reward_boost_info);
  private:
  const ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo& _internal_trading_reward_boost_info() const;
  ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* _internal_mutable_trading_reward_boost_info();
  public:
  void unsafe_arena_set_allocated_trading_reward_boost_info(
      ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* trading_reward_boost_info);
  ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* unsafe_arena_release_trading_reward_boost_info();
  // int64 campaign_duration_seconds = 1 [json_name = "campaignDurationSeconds"];
  void clear_campaign_duration_seconds() ;
  ::int64_t campaign_duration_seconds() const;
  void set_campaign_duration_seconds(::int64_t value);

  private:
  ::int64_t _internal_campaign_duration_seconds() const;
  void _internal_set_campaign_duration_seconds(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradingRewardCampaignInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> quote_denoms_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> disqualified_market_ids_;
    ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* trading_reward_boost_info_;
    ::int64_t campaign_duration_seconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class FeeDiscountTierInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.FeeDiscountTierInfo) */ {
 public:
  inline FeeDiscountTierInfo() : FeeDiscountTierInfo(nullptr) {}
  ~FeeDiscountTierInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeeDiscountTierInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeeDiscountTierInfo(const FeeDiscountTierInfo& from);
  FeeDiscountTierInfo(FeeDiscountTierInfo&& from) noexcept
    : FeeDiscountTierInfo() {
    *this = ::std::move(from);
  }

  inline FeeDiscountTierInfo& operator=(const FeeDiscountTierInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeDiscountTierInfo& operator=(FeeDiscountTierInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeeDiscountTierInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeeDiscountTierInfo* internal_default_instance() {
    return reinterpret_cast<const FeeDiscountTierInfo*>(
               &_FeeDiscountTierInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(FeeDiscountTierInfo& a, FeeDiscountTierInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeDiscountTierInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeDiscountTierInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeeDiscountTierInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeeDiscountTierInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeeDiscountTierInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeeDiscountTierInfo& from) {
    FeeDiscountTierInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeDiscountTierInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.FeeDiscountTierInfo";
  }
  protected:
  explicit FeeDiscountTierInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakerDiscountRateFieldNumber = 1,
    kTakerDiscountRateFieldNumber = 2,
    kStakedAmountFieldNumber = 3,
    kVolumeFieldNumber = 4,
  };
  // string maker_discount_rate = 1 [json_name = "makerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_discount_rate() ;
  const std::string& maker_discount_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_discount_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_discount_rate();
  PROTOBUF_NODISCARD std::string* release_maker_discount_rate();
  void set_allocated_maker_discount_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_discount_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_discount_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_discount_rate();

  public:
  // string taker_discount_rate = 2 [json_name = "takerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_discount_rate() ;
  const std::string& taker_discount_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_discount_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_discount_rate();
  PROTOBUF_NODISCARD std::string* release_taker_discount_rate();
  void set_allocated_taker_discount_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_discount_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_discount_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_discount_rate();

  public:
  // string staked_amount = 3 [json_name = "stakedAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_staked_amount() ;
  const std::string& staked_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_staked_amount(Arg_&& arg, Args_... args);
  std::string* mutable_staked_amount();
  PROTOBUF_NODISCARD std::string* release_staked_amount();
  void set_allocated_staked_amount(std::string* ptr);

  private:
  const std::string& _internal_staked_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staked_amount(
      const std::string& value);
  std::string* _internal_mutable_staked_amount();

  public:
  // string volume = 4 [json_name = "volume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_volume() ;
  const std::string& volume() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume(Arg_&& arg, Args_... args);
  std::string* mutable_volume();
  PROTOBUF_NODISCARD std::string* release_volume();
  void set_allocated_volume(std::string* ptr);

  private:
  const std::string& _internal_volume() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume(
      const std::string& value);
  std::string* _internal_mutable_volume();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.FeeDiscountTierInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_discount_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_discount_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staked_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class FeeDiscountSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.FeeDiscountSchedule) */ {
 public:
  inline FeeDiscountSchedule() : FeeDiscountSchedule(nullptr) {}
  ~FeeDiscountSchedule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeeDiscountSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeeDiscountSchedule(const FeeDiscountSchedule& from);
  FeeDiscountSchedule(FeeDiscountSchedule&& from) noexcept
    : FeeDiscountSchedule() {
    *this = ::std::move(from);
  }

  inline FeeDiscountSchedule& operator=(const FeeDiscountSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeDiscountSchedule& operator=(FeeDiscountSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeeDiscountSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeeDiscountSchedule* internal_default_instance() {
    return reinterpret_cast<const FeeDiscountSchedule*>(
               &_FeeDiscountSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(FeeDiscountSchedule& a, FeeDiscountSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeDiscountSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeDiscountSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeeDiscountSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeeDiscountSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeeDiscountSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeeDiscountSchedule& from) {
    FeeDiscountSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeDiscountSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.FeeDiscountSchedule";
  }
  protected:
  explicit FeeDiscountSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuoteDenomsFieldNumber = 3,
    kTierInfosFieldNumber = 4,
    kDisqualifiedMarketIdsFieldNumber = 5,
    kBucketCountFieldNumber = 1,
    kBucketDurationFieldNumber = 2,
  };
  // repeated string quote_denoms = 3 [json_name = "quoteDenoms"];
  int quote_denoms_size() const;
  private:
  int _internal_quote_denoms_size() const;

  public:
  void clear_quote_denoms() ;
  const std::string& quote_denoms(int index) const;
  std::string* mutable_quote_denoms(int index);
  void set_quote_denoms(int index, const std::string& value);
  void set_quote_denoms(int index, std::string&& value);
  void set_quote_denoms(int index, const char* value);
  void set_quote_denoms(int index, const char* value, std::size_t size);
  void set_quote_denoms(int index, absl::string_view value);
  std::string* add_quote_denoms();
  void add_quote_denoms(const std::string& value);
  void add_quote_denoms(std::string&& value);
  void add_quote_denoms(const char* value);
  void add_quote_denoms(const char* value, std::size_t size);
  void add_quote_denoms(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& quote_denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_quote_denoms();

  private:
  const std::string& _internal_quote_denoms(int index) const;
  std::string* _internal_add_quote_denoms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_quote_denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_quote_denoms();

  public:
  // repeated .injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4 [json_name = "tierInfos"];
  int tier_infos_size() const;
  private:
  int _internal_tier_infos_size() const;

  public:
  void clear_tier_infos() ;
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* mutable_tier_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FeeDiscountTierInfo >*
      mutable_tier_infos();
  private:
  const ::injective::exchange::v1beta1::FeeDiscountTierInfo& _internal_tier_infos(int index) const;
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* _internal_add_tier_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FeeDiscountTierInfo>& _internal_tier_infos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FeeDiscountTierInfo>* _internal_mutable_tier_infos();
  public:
  const ::injective::exchange::v1beta1::FeeDiscountTierInfo& tier_infos(int index) const;
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* add_tier_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FeeDiscountTierInfo >&
      tier_infos() const;
  // repeated string disqualified_market_ids = 5 [json_name = "disqualifiedMarketIds"];
  int disqualified_market_ids_size() const;
  private:
  int _internal_disqualified_market_ids_size() const;

  public:
  void clear_disqualified_market_ids() ;
  const std::string& disqualified_market_ids(int index) const;
  std::string* mutable_disqualified_market_ids(int index);
  void set_disqualified_market_ids(int index, const std::string& value);
  void set_disqualified_market_ids(int index, std::string&& value);
  void set_disqualified_market_ids(int index, const char* value);
  void set_disqualified_market_ids(int index, const char* value, std::size_t size);
  void set_disqualified_market_ids(int index, absl::string_view value);
  std::string* add_disqualified_market_ids();
  void add_disqualified_market_ids(const std::string& value);
  void add_disqualified_market_ids(std::string&& value);
  void add_disqualified_market_ids(const char* value);
  void add_disqualified_market_ids(const char* value, std::size_t size);
  void add_disqualified_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& disqualified_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_disqualified_market_ids();

  private:
  const std::string& _internal_disqualified_market_ids(int index) const;
  std::string* _internal_add_disqualified_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_disqualified_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_disqualified_market_ids();

  public:
  // uint64 bucket_count = 1 [json_name = "bucketCount"];
  void clear_bucket_count() ;
  ::uint64_t bucket_count() const;
  void set_bucket_count(::uint64_t value);

  private:
  ::uint64_t _internal_bucket_count() const;
  void _internal_set_bucket_count(::uint64_t value);

  public:
  // int64 bucket_duration = 2 [json_name = "bucketDuration"];
  void clear_bucket_duration() ;
  ::int64_t bucket_duration() const;
  void set_bucket_duration(::int64_t value);

  private:
  ::int64_t _internal_bucket_duration() const;
  void _internal_set_bucket_duration(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.FeeDiscountSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> quote_denoms_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FeeDiscountTierInfo > tier_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> disqualified_market_ids_;
    ::uint64_t bucket_count_;
    ::int64_t bucket_duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class FeeDiscountTierTTL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.FeeDiscountTierTTL) */ {
 public:
  inline FeeDiscountTierTTL() : FeeDiscountTierTTL(nullptr) {}
  ~FeeDiscountTierTTL() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeeDiscountTierTTL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeeDiscountTierTTL(const FeeDiscountTierTTL& from);
  FeeDiscountTierTTL(FeeDiscountTierTTL&& from) noexcept
    : FeeDiscountTierTTL() {
    *this = ::std::move(from);
  }

  inline FeeDiscountTierTTL& operator=(const FeeDiscountTierTTL& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeDiscountTierTTL& operator=(FeeDiscountTierTTL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeeDiscountTierTTL& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeeDiscountTierTTL* internal_default_instance() {
    return reinterpret_cast<const FeeDiscountTierTTL*>(
               &_FeeDiscountTierTTL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(FeeDiscountTierTTL& a, FeeDiscountTierTTL& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeDiscountTierTTL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeDiscountTierTTL* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeeDiscountTierTTL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeeDiscountTierTTL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeeDiscountTierTTL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeeDiscountTierTTL& from) {
    FeeDiscountTierTTL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeDiscountTierTTL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.FeeDiscountTierTTL";
  }
  protected:
  explicit FeeDiscountTierTTL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTierFieldNumber = 1,
    kTtlTimestampFieldNumber = 2,
  };
  // uint64 tier = 1 [json_name = "tier"];
  void clear_tier() ;
  ::uint64_t tier() const;
  void set_tier(::uint64_t value);

  private:
  ::uint64_t _internal_tier() const;
  void _internal_set_tier(::uint64_t value);

  public:
  // int64 ttl_timestamp = 2 [json_name = "ttlTimestamp"];
  void clear_ttl_timestamp() ;
  ::int64_t ttl_timestamp() const;
  void set_ttl_timestamp(::int64_t value);

  private:
  ::int64_t _internal_ttl_timestamp() const;
  void _internal_set_ttl_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.FeeDiscountTierTTL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t tier_;
    ::int64_t ttl_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class VolumeRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.VolumeRecord) */ {
 public:
  inline VolumeRecord() : VolumeRecord(nullptr) {}
  ~VolumeRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VolumeRecord(const VolumeRecord& from);
  VolumeRecord(VolumeRecord&& from) noexcept
    : VolumeRecord() {
    *this = ::std::move(from);
  }

  inline VolumeRecord& operator=(const VolumeRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeRecord& operator=(VolumeRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeRecord* internal_default_instance() {
    return reinterpret_cast<const VolumeRecord*>(
               &_VolumeRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(VolumeRecord& a, VolumeRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VolumeRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VolumeRecord& from) {
    VolumeRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.VolumeRecord";
  }
  protected:
  explicit VolumeRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakerVolumeFieldNumber = 1,
    kTakerVolumeFieldNumber = 2,
  };
  // string maker_volume = 1 [json_name = "makerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_volume() ;
  const std::string& maker_volume() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_volume(Arg_&& arg, Args_... args);
  std::string* mutable_maker_volume();
  PROTOBUF_NODISCARD std::string* release_maker_volume();
  void set_allocated_maker_volume(std::string* ptr);

  private:
  const std::string& _internal_maker_volume() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_volume(
      const std::string& value);
  std::string* _internal_mutable_maker_volume();

  public:
  // string taker_volume = 2 [json_name = "takerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_volume() ;
  const std::string& taker_volume() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_volume(Arg_&& arg, Args_... args);
  std::string* mutable_taker_volume();
  PROTOBUF_NODISCARD std::string* release_taker_volume();
  void set_allocated_taker_volume(std::string* ptr);

  private:
  const std::string& _internal_taker_volume() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_volume(
      const std::string& value);
  std::string* _internal_mutable_taker_volume();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.VolumeRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_volume_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class AccountRewards final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.AccountRewards) */ {
 public:
  inline AccountRewards() : AccountRewards(nullptr) {}
  ~AccountRewards() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AccountRewards(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountRewards(const AccountRewards& from);
  AccountRewards(AccountRewards&& from) noexcept
    : AccountRewards() {
    *this = ::std::move(from);
  }

  inline AccountRewards& operator=(const AccountRewards& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountRewards& operator=(AccountRewards&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountRewards& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountRewards* internal_default_instance() {
    return reinterpret_cast<const AccountRewards*>(
               &_AccountRewards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(AccountRewards& a, AccountRewards& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountRewards* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountRewards* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountRewards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountRewards>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountRewards& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountRewards& from) {
    AccountRewards::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountRewards* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.AccountRewards";
  }
  protected:
  explicit AccountRewards(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardsFieldNumber = 2,
    kAccountFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.Coin rewards = 2 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;

  public:
  void clear_rewards() ;
  ::cosmos::base::v1beta1::Coin* mutable_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_rewards();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_rewards(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_rewards();
  public:
  const ::cosmos::base::v1beta1::Coin& rewards(int index) const;
  ::cosmos::base::v1beta1::Coin* add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      rewards() const;
  // string account = 1 [json_name = "account"];
  void clear_account() ;
  const std::string& account() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* ptr);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.AccountRewards)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > rewards_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class TradeRecords final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradeRecords) */ {
 public:
  inline TradeRecords() : TradeRecords(nullptr) {}
  ~TradeRecords() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeRecords(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeRecords(const TradeRecords& from);
  TradeRecords(TradeRecords&& from) noexcept
    : TradeRecords() {
    *this = ::std::move(from);
  }

  inline TradeRecords& operator=(const TradeRecords& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeRecords& operator=(TradeRecords&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeRecords& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeRecords* internal_default_instance() {
    return reinterpret_cast<const TradeRecords*>(
               &_TradeRecords_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TradeRecords& a, TradeRecords& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeRecords* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeRecords* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeRecords* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeRecords>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeRecords& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeRecords& from) {
    TradeRecords::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeRecords* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradeRecords";
  }
  protected:
  explicit TradeRecords(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestTradeRecordsFieldNumber = 2,
    kMarketIdFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TradeRecord latest_trade_records = 2 [json_name = "latestTradeRecords"];
  int latest_trade_records_size() const;
  private:
  int _internal_latest_trade_records_size() const;

  public:
  void clear_latest_trade_records() ;
  ::injective::exchange::v1beta1::TradeRecord* mutable_latest_trade_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord >*
      mutable_latest_trade_records();
  private:
  const ::injective::exchange::v1beta1::TradeRecord& _internal_latest_trade_records(int index) const;
  ::injective::exchange::v1beta1::TradeRecord* _internal_add_latest_trade_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecord>& _internal_latest_trade_records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecord>* _internal_mutable_latest_trade_records();
  public:
  const ::injective::exchange::v1beta1::TradeRecord& latest_trade_records(int index) const;
  ::injective::exchange::v1beta1::TradeRecord* add_latest_trade_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord >&
      latest_trade_records() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradeRecords)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord > latest_trade_records_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class SubaccountIDs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SubaccountIDs) */ {
 public:
  inline SubaccountIDs() : SubaccountIDs(nullptr) {}
  ~SubaccountIDs() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountIDs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountIDs(const SubaccountIDs& from);
  SubaccountIDs(SubaccountIDs&& from) noexcept
    : SubaccountIDs() {
    *this = ::std::move(from);
  }

  inline SubaccountIDs& operator=(const SubaccountIDs& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountIDs& operator=(SubaccountIDs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountIDs& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountIDs* internal_default_instance() {
    return reinterpret_cast<const SubaccountIDs*>(
               &_SubaccountIDs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(SubaccountIDs& a, SubaccountIDs& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountIDs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountIDs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountIDs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountIDs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountIDs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountIDs& from) {
    SubaccountIDs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountIDs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SubaccountIDs";
  }
  protected:
  explicit SubaccountIDs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdsFieldNumber = 1,
  };
  // repeated bytes subaccount_ids = 1 [json_name = "subaccountIds"];
  int subaccount_ids_size() const;
  private:
  int _internal_subaccount_ids_size() const;

  public:
  void clear_subaccount_ids() ;
  const std::string& subaccount_ids(int index) const;
  std::string* mutable_subaccount_ids(int index);
  void set_subaccount_ids(int index, const std::string& value);
  void set_subaccount_ids(int index, std::string&& value);
  void set_subaccount_ids(int index, const char* value);
  void set_subaccount_ids(int index, const void* value, std::size_t size);
  void set_subaccount_ids(int index, absl::string_view value);
  std::string* add_subaccount_ids();
  void add_subaccount_ids(const std::string& value);
  void add_subaccount_ids(std::string&& value);
  void add_subaccount_ids(const char* value);
  void add_subaccount_ids(const void* value, std::size_t size);
  void add_subaccount_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subaccount_ids();

  private:
  const std::string& _internal_subaccount_ids(int index) const;
  std::string* _internal_add_subaccount_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_subaccount_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SubaccountIDs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subaccount_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class TradeRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradeRecord) */ {
 public:
  inline TradeRecord() : TradeRecord(nullptr) {}
  ~TradeRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeRecord(const TradeRecord& from);
  TradeRecord(TradeRecord&& from) noexcept
    : TradeRecord() {
    *this = ::std::move(from);
  }

  inline TradeRecord& operator=(const TradeRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeRecord& operator=(TradeRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeRecord* internal_default_instance() {
    return reinterpret_cast<const TradeRecord*>(
               &_TradeRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(TradeRecord& a, TradeRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeRecord& from) {
    TradeRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradeRecord";
  }
  protected:
  explicit TradeRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 2,
    kQuantityFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 3 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // int64 timestamp = 1 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradeRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class Level final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.Level) */ {
 public:
  inline Level() : Level(nullptr) {}
  ~Level() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Level(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Level(const Level& from);
  Level(Level&& from) noexcept
    : Level() {
    *this = ::std::move(from);
  }

  inline Level& operator=(const Level& from) {
    CopyFrom(from);
    return *this;
  }
  inline Level& operator=(Level&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Level& default_instance() {
    return *internal_default_instance();
  }
  static inline const Level* internal_default_instance() {
    return reinterpret_cast<const Level*>(
               &_Level_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(Level& a, Level& b) {
    a.Swap(&b);
  }
  inline void Swap(Level* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Level* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Level* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Level>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Level& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Level& from) {
    Level::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Level* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.Level";
  }
  protected:
  explicit Level(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPFieldNumber = 1,
    kQFieldNumber = 2,
  };
  // string p = 1 [json_name = "p", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_p() ;
  const std::string& p() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_p(Arg_&& arg, Args_... args);
  std::string* mutable_p();
  PROTOBUF_NODISCARD std::string* release_p();
  void set_allocated_p(std::string* ptr);

  private:
  const std::string& _internal_p() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p(
      const std::string& value);
  std::string* _internal_mutable_p();

  public:
  // string q = 2 [json_name = "q", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_q() ;
  const std::string& q() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_q(Arg_&& arg, Args_... args);
  std::string* mutable_q();
  PROTOBUF_NODISCARD std::string* release_q();
  void set_allocated_q(std::string* ptr);

  private:
  const std::string& _internal_q() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_q(
      const std::string& value);
  std::string* _internal_mutable_q();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.Level)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr q_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class AggregateSubaccountVolumeRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord) */ {
 public:
  inline AggregateSubaccountVolumeRecord() : AggregateSubaccountVolumeRecord(nullptr) {}
  ~AggregateSubaccountVolumeRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateSubaccountVolumeRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateSubaccountVolumeRecord(const AggregateSubaccountVolumeRecord& from);
  AggregateSubaccountVolumeRecord(AggregateSubaccountVolumeRecord&& from) noexcept
    : AggregateSubaccountVolumeRecord() {
    *this = ::std::move(from);
  }

  inline AggregateSubaccountVolumeRecord& operator=(const AggregateSubaccountVolumeRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateSubaccountVolumeRecord& operator=(AggregateSubaccountVolumeRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateSubaccountVolumeRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateSubaccountVolumeRecord* internal_default_instance() {
    return reinterpret_cast<const AggregateSubaccountVolumeRecord*>(
               &_AggregateSubaccountVolumeRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(AggregateSubaccountVolumeRecord& a, AggregateSubaccountVolumeRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateSubaccountVolumeRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateSubaccountVolumeRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateSubaccountVolumeRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateSubaccountVolumeRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateSubaccountVolumeRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AggregateSubaccountVolumeRecord& from) {
    AggregateSubaccountVolumeRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateSubaccountVolumeRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.AggregateSubaccountVolumeRecord";
  }
  protected:
  explicit AggregateSubaccountVolumeRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketVolumesFieldNumber = 2,
    kSubaccountIdFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
  int market_volumes_size() const;
  private:
  int _internal_market_volumes_size() const;

  public:
  void clear_market_volumes() ;
  ::injective::exchange::v1beta1::MarketVolume* mutable_market_volumes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
      mutable_market_volumes();
  private:
  const ::injective::exchange::v1beta1::MarketVolume& _internal_market_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* _internal_add_market_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>& _internal_market_volumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>* _internal_mutable_market_volumes();
  public:
  const ::injective::exchange::v1beta1::MarketVolume& market_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* add_market_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
      market_volumes() const;
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume > market_volumes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class AggregateAccountVolumeRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.AggregateAccountVolumeRecord) */ {
 public:
  inline AggregateAccountVolumeRecord() : AggregateAccountVolumeRecord(nullptr) {}
  ~AggregateAccountVolumeRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateAccountVolumeRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateAccountVolumeRecord(const AggregateAccountVolumeRecord& from);
  AggregateAccountVolumeRecord(AggregateAccountVolumeRecord&& from) noexcept
    : AggregateAccountVolumeRecord() {
    *this = ::std::move(from);
  }

  inline AggregateAccountVolumeRecord& operator=(const AggregateAccountVolumeRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateAccountVolumeRecord& operator=(AggregateAccountVolumeRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateAccountVolumeRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateAccountVolumeRecord* internal_default_instance() {
    return reinterpret_cast<const AggregateAccountVolumeRecord*>(
               &_AggregateAccountVolumeRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(AggregateAccountVolumeRecord& a, AggregateAccountVolumeRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateAccountVolumeRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateAccountVolumeRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateAccountVolumeRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateAccountVolumeRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateAccountVolumeRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AggregateAccountVolumeRecord& from) {
    AggregateAccountVolumeRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateAccountVolumeRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.AggregateAccountVolumeRecord";
  }
  protected:
  explicit AggregateAccountVolumeRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketVolumesFieldNumber = 2,
    kAccountFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
  int market_volumes_size() const;
  private:
  int _internal_market_volumes_size() const;

  public:
  void clear_market_volumes() ;
  ::injective::exchange::v1beta1::MarketVolume* mutable_market_volumes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
      mutable_market_volumes();
  private:
  const ::injective::exchange::v1beta1::MarketVolume& _internal_market_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* _internal_add_market_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>& _internal_market_volumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>* _internal_mutable_market_volumes();
  public:
  const ::injective::exchange::v1beta1::MarketVolume& market_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* add_market_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
      market_volumes() const;
  // string account = 1 [json_name = "account"];
  void clear_account() ;
  const std::string& account() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* ptr);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume > market_volumes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class MarketVolume final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MarketVolume) */ {
 public:
  inline MarketVolume() : MarketVolume(nullptr) {}
  ~MarketVolume() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketVolume(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketVolume(const MarketVolume& from);
  MarketVolume(MarketVolume&& from) noexcept
    : MarketVolume() {
    *this = ::std::move(from);
  }

  inline MarketVolume& operator=(const MarketVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketVolume& operator=(MarketVolume&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketVolume& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketVolume* internal_default_instance() {
    return reinterpret_cast<const MarketVolume*>(
               &_MarketVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(MarketVolume& a, MarketVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketVolume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketVolume* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketVolume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketVolume>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketVolume& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketVolume& from) {
    MarketVolume::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketVolume* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MarketVolume";
  }
  protected:
  explicit MarketVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kVolumeFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective.exchange.v1beta1.VolumeRecord volume = 2 [json_name = "volume", (.gogoproto.nullable) = false];
  bool has_volume() const;
  void clear_volume() ;
  const ::injective::exchange::v1beta1::VolumeRecord& volume() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::VolumeRecord* release_volume();
  ::injective::exchange::v1beta1::VolumeRecord* mutable_volume();
  void set_allocated_volume(::injective::exchange::v1beta1::VolumeRecord* volume);
  private:
  const ::injective::exchange::v1beta1::VolumeRecord& _internal_volume() const;
  ::injective::exchange::v1beta1::VolumeRecord* _internal_mutable_volume();
  public:
  void unsafe_arena_set_allocated_volume(
      ::injective::exchange::v1beta1::VolumeRecord* volume);
  ::injective::exchange::v1beta1::VolumeRecord* unsafe_arena_release_volume();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MarketVolume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective::exchange::v1beta1::VolumeRecord* volume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};// -------------------------------------------------------------------

class DenomDecimals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DenomDecimals) */ {
 public:
  inline DenomDecimals() : DenomDecimals(nullptr) {}
  ~DenomDecimals() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DenomDecimals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DenomDecimals(const DenomDecimals& from);
  DenomDecimals(DenomDecimals&& from) noexcept
    : DenomDecimals() {
    *this = ::std::move(from);
  }

  inline DenomDecimals& operator=(const DenomDecimals& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenomDecimals& operator=(DenomDecimals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenomDecimals& default_instance() {
    return *internal_default_instance();
  }
  static inline const DenomDecimals* internal_default_instance() {
    return reinterpret_cast<const DenomDecimals*>(
               &_DenomDecimals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(DenomDecimals& a, DenomDecimals& b) {
    a.Swap(&b);
  }
  inline void Swap(DenomDecimals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenomDecimals* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DenomDecimals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DenomDecimals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DenomDecimals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DenomDecimals& from) {
    DenomDecimals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DenomDecimals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DenomDecimals";
  }
  protected:
  explicit DenomDecimals(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
    kDecimalsFieldNumber = 2,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // uint64 decimals = 2 [json_name = "decimals"];
  void clear_decimals() ;
  ::uint64_t decimals() const;
  void set_decimals(::uint64_t value);

  private:
  ::uint64_t _internal_decimals() const;
  void _internal_set_decimals(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DenomDecimals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::uint64_t decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Params

// .cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1 [json_name = "spotMarketInstantListingFee", (.gogoproto.nullable) = false];
inline bool Params::has_spot_market_instant_listing_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spot_market_instant_listing_fee_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& Params::_internal_spot_market_instant_listing_fee() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.spot_market_instant_listing_fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& Params::spot_market_instant_listing_fee() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.spot_market_instant_listing_fee)
  return _internal_spot_market_instant_listing_fee();
}
inline void Params::unsafe_arena_set_allocated_spot_market_instant_listing_fee(
    ::cosmos::base::v1beta1::Coin* spot_market_instant_listing_fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spot_market_instant_listing_fee_);
  }
  _impl_.spot_market_instant_listing_fee_ = spot_market_instant_listing_fee;
  if (spot_market_instant_listing_fee) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.Params.spot_market_instant_listing_fee)
}
inline ::cosmos::base::v1beta1::Coin* Params::release_spot_market_instant_listing_fee() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.spot_market_instant_listing_fee_;
  _impl_.spot_market_instant_listing_fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* Params::unsafe_arena_release_spot_market_instant_listing_fee() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.spot_market_instant_listing_fee)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.spot_market_instant_listing_fee_;
  _impl_.spot_market_instant_listing_fee_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* Params::_internal_mutable_spot_market_instant_listing_fee() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spot_market_instant_listing_fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.spot_market_instant_listing_fee_ = p;
  }
  return _impl_.spot_market_instant_listing_fee_;
}
inline ::cosmos::base::v1beta1::Coin* Params::mutable_spot_market_instant_listing_fee() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_spot_market_instant_listing_fee();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.spot_market_instant_listing_fee)
  return _msg;
}
inline void Params::set_allocated_spot_market_instant_listing_fee(::cosmos::base::v1beta1::Coin* spot_market_instant_listing_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spot_market_instant_listing_fee_);
  }
  if (spot_market_instant_listing_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spot_market_instant_listing_fee));
    if (message_arena != submessage_arena) {
      spot_market_instant_listing_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spot_market_instant_listing_fee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.spot_market_instant_listing_fee_ = spot_market_instant_listing_fee;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.spot_market_instant_listing_fee)
}

// .cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2 [json_name = "derivativeMarketInstantListingFee", (.gogoproto.nullable) = false];
inline bool Params::has_derivative_market_instant_listing_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.derivative_market_instant_listing_fee_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& Params::_internal_derivative_market_instant_listing_fee() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.derivative_market_instant_listing_fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& Params::derivative_market_instant_listing_fee() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.derivative_market_instant_listing_fee)
  return _internal_derivative_market_instant_listing_fee();
}
inline void Params::unsafe_arena_set_allocated_derivative_market_instant_listing_fee(
    ::cosmos::base::v1beta1::Coin* derivative_market_instant_listing_fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.derivative_market_instant_listing_fee_);
  }
  _impl_.derivative_market_instant_listing_fee_ = derivative_market_instant_listing_fee;
  if (derivative_market_instant_listing_fee) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.Params.derivative_market_instant_listing_fee)
}
inline ::cosmos::base::v1beta1::Coin* Params::release_derivative_market_instant_listing_fee() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.derivative_market_instant_listing_fee_;
  _impl_.derivative_market_instant_listing_fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* Params::unsafe_arena_release_derivative_market_instant_listing_fee() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.derivative_market_instant_listing_fee)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.derivative_market_instant_listing_fee_;
  _impl_.derivative_market_instant_listing_fee_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* Params::_internal_mutable_derivative_market_instant_listing_fee() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.derivative_market_instant_listing_fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.derivative_market_instant_listing_fee_ = p;
  }
  return _impl_.derivative_market_instant_listing_fee_;
}
inline ::cosmos::base::v1beta1::Coin* Params::mutable_derivative_market_instant_listing_fee() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_derivative_market_instant_listing_fee();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.derivative_market_instant_listing_fee)
  return _msg;
}
inline void Params::set_allocated_derivative_market_instant_listing_fee(::cosmos::base::v1beta1::Coin* derivative_market_instant_listing_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.derivative_market_instant_listing_fee_);
  }
  if (derivative_market_instant_listing_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(derivative_market_instant_listing_fee));
    if (message_arena != submessage_arena) {
      derivative_market_instant_listing_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, derivative_market_instant_listing_fee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.derivative_market_instant_listing_fee_ = derivative_market_instant_listing_fee;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.derivative_market_instant_listing_fee)
}

// string default_spot_maker_fee_rate = 3 [json_name = "defaultSpotMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_default_spot_maker_fee_rate() {
  _impl_.default_spot_maker_fee_rate_.ClearToEmpty();
}
inline const std::string& Params::default_spot_maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_spot_maker_fee_rate)
  return _internal_default_spot_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_default_spot_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default_spot_maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_spot_maker_fee_rate)
}
inline std::string* Params::mutable_default_spot_maker_fee_rate() {
  std::string* _s = _internal_mutable_default_spot_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.default_spot_maker_fee_rate)
  return _s;
}
inline const std::string& Params::_internal_default_spot_maker_fee_rate() const {
  return _impl_.default_spot_maker_fee_rate_.Get();
}
inline void Params::_internal_set_default_spot_maker_fee_rate(const std::string& value) {
  ;


  _impl_.default_spot_maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_default_spot_maker_fee_rate() {
  ;
  return _impl_.default_spot_maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_default_spot_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.default_spot_maker_fee_rate)
  return _impl_.default_spot_maker_fee_rate_.Release();
}
inline void Params::set_allocated_default_spot_maker_fee_rate(std::string* value) {
  _impl_.default_spot_maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_spot_maker_fee_rate_.IsDefault()) {
          _impl_.default_spot_maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.default_spot_maker_fee_rate)
}

// string default_spot_taker_fee_rate = 4 [json_name = "defaultSpotTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_default_spot_taker_fee_rate() {
  _impl_.default_spot_taker_fee_rate_.ClearToEmpty();
}
inline const std::string& Params::default_spot_taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_spot_taker_fee_rate)
  return _internal_default_spot_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_default_spot_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default_spot_taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_spot_taker_fee_rate)
}
inline std::string* Params::mutable_default_spot_taker_fee_rate() {
  std::string* _s = _internal_mutable_default_spot_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.default_spot_taker_fee_rate)
  return _s;
}
inline const std::string& Params::_internal_default_spot_taker_fee_rate() const {
  return _impl_.default_spot_taker_fee_rate_.Get();
}
inline void Params::_internal_set_default_spot_taker_fee_rate(const std::string& value) {
  ;


  _impl_.default_spot_taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_default_spot_taker_fee_rate() {
  ;
  return _impl_.default_spot_taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_default_spot_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.default_spot_taker_fee_rate)
  return _impl_.default_spot_taker_fee_rate_.Release();
}
inline void Params::set_allocated_default_spot_taker_fee_rate(std::string* value) {
  _impl_.default_spot_taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_spot_taker_fee_rate_.IsDefault()) {
          _impl_.default_spot_taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.default_spot_taker_fee_rate)
}

// string default_derivative_maker_fee_rate = 5 [json_name = "defaultDerivativeMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_default_derivative_maker_fee_rate() {
  _impl_.default_derivative_maker_fee_rate_.ClearToEmpty();
}
inline const std::string& Params::default_derivative_maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_derivative_maker_fee_rate)
  return _internal_default_derivative_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_default_derivative_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default_derivative_maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_derivative_maker_fee_rate)
}
inline std::string* Params::mutable_default_derivative_maker_fee_rate() {
  std::string* _s = _internal_mutable_default_derivative_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.default_derivative_maker_fee_rate)
  return _s;
}
inline const std::string& Params::_internal_default_derivative_maker_fee_rate() const {
  return _impl_.default_derivative_maker_fee_rate_.Get();
}
inline void Params::_internal_set_default_derivative_maker_fee_rate(const std::string& value) {
  ;


  _impl_.default_derivative_maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_default_derivative_maker_fee_rate() {
  ;
  return _impl_.default_derivative_maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_default_derivative_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.default_derivative_maker_fee_rate)
  return _impl_.default_derivative_maker_fee_rate_.Release();
}
inline void Params::set_allocated_default_derivative_maker_fee_rate(std::string* value) {
  _impl_.default_derivative_maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_derivative_maker_fee_rate_.IsDefault()) {
          _impl_.default_derivative_maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.default_derivative_maker_fee_rate)
}

// string default_derivative_taker_fee_rate = 6 [json_name = "defaultDerivativeTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_default_derivative_taker_fee_rate() {
  _impl_.default_derivative_taker_fee_rate_.ClearToEmpty();
}
inline const std::string& Params::default_derivative_taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_derivative_taker_fee_rate)
  return _internal_default_derivative_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_default_derivative_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default_derivative_taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_derivative_taker_fee_rate)
}
inline std::string* Params::mutable_default_derivative_taker_fee_rate() {
  std::string* _s = _internal_mutable_default_derivative_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.default_derivative_taker_fee_rate)
  return _s;
}
inline const std::string& Params::_internal_default_derivative_taker_fee_rate() const {
  return _impl_.default_derivative_taker_fee_rate_.Get();
}
inline void Params::_internal_set_default_derivative_taker_fee_rate(const std::string& value) {
  ;


  _impl_.default_derivative_taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_default_derivative_taker_fee_rate() {
  ;
  return _impl_.default_derivative_taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_default_derivative_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.default_derivative_taker_fee_rate)
  return _impl_.default_derivative_taker_fee_rate_.Release();
}
inline void Params::set_allocated_default_derivative_taker_fee_rate(std::string* value) {
  _impl_.default_derivative_taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_derivative_taker_fee_rate_.IsDefault()) {
          _impl_.default_derivative_taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.default_derivative_taker_fee_rate)
}

// string default_initial_margin_ratio = 7 [json_name = "defaultInitialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_default_initial_margin_ratio() {
  _impl_.default_initial_margin_ratio_.ClearToEmpty();
}
inline const std::string& Params::default_initial_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_initial_margin_ratio)
  return _internal_default_initial_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_default_initial_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default_initial_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_initial_margin_ratio)
}
inline std::string* Params::mutable_default_initial_margin_ratio() {
  std::string* _s = _internal_mutable_default_initial_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.default_initial_margin_ratio)
  return _s;
}
inline const std::string& Params::_internal_default_initial_margin_ratio() const {
  return _impl_.default_initial_margin_ratio_.Get();
}
inline void Params::_internal_set_default_initial_margin_ratio(const std::string& value) {
  ;


  _impl_.default_initial_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_default_initial_margin_ratio() {
  ;
  return _impl_.default_initial_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_default_initial_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.default_initial_margin_ratio)
  return _impl_.default_initial_margin_ratio_.Release();
}
inline void Params::set_allocated_default_initial_margin_ratio(std::string* value) {
  _impl_.default_initial_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_initial_margin_ratio_.IsDefault()) {
          _impl_.default_initial_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.default_initial_margin_ratio)
}

// string default_maintenance_margin_ratio = 8 [json_name = "defaultMaintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_default_maintenance_margin_ratio() {
  _impl_.default_maintenance_margin_ratio_.ClearToEmpty();
}
inline const std::string& Params::default_maintenance_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_maintenance_margin_ratio)
  return _internal_default_maintenance_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_default_maintenance_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default_maintenance_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_maintenance_margin_ratio)
}
inline std::string* Params::mutable_default_maintenance_margin_ratio() {
  std::string* _s = _internal_mutable_default_maintenance_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.default_maintenance_margin_ratio)
  return _s;
}
inline const std::string& Params::_internal_default_maintenance_margin_ratio() const {
  return _impl_.default_maintenance_margin_ratio_.Get();
}
inline void Params::_internal_set_default_maintenance_margin_ratio(const std::string& value) {
  ;


  _impl_.default_maintenance_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_default_maintenance_margin_ratio() {
  ;
  return _impl_.default_maintenance_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_default_maintenance_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.default_maintenance_margin_ratio)
  return _impl_.default_maintenance_margin_ratio_.Release();
}
inline void Params::set_allocated_default_maintenance_margin_ratio(std::string* value) {
  _impl_.default_maintenance_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_maintenance_margin_ratio_.IsDefault()) {
          _impl_.default_maintenance_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.default_maintenance_margin_ratio)
}

// int64 default_funding_interval = 9 [json_name = "defaultFundingInterval"];
inline void Params::clear_default_funding_interval() {
  _impl_.default_funding_interval_ = ::int64_t{0};
}
inline ::int64_t Params::default_funding_interval() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_funding_interval)
  return _internal_default_funding_interval();
}
inline void Params::set_default_funding_interval(::int64_t value) {
  _internal_set_default_funding_interval(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_funding_interval)
}
inline ::int64_t Params::_internal_default_funding_interval() const {
  return _impl_.default_funding_interval_;
}
inline void Params::_internal_set_default_funding_interval(::int64_t value) {
  ;
  _impl_.default_funding_interval_ = value;
}

// int64 funding_multiple = 10 [json_name = "fundingMultiple"];
inline void Params::clear_funding_multiple() {
  _impl_.funding_multiple_ = ::int64_t{0};
}
inline ::int64_t Params::funding_multiple() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.funding_multiple)
  return _internal_funding_multiple();
}
inline void Params::set_funding_multiple(::int64_t value) {
  _internal_set_funding_multiple(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.funding_multiple)
}
inline ::int64_t Params::_internal_funding_multiple() const {
  return _impl_.funding_multiple_;
}
inline void Params::_internal_set_funding_multiple(::int64_t value) {
  ;
  _impl_.funding_multiple_ = value;
}

// string relayer_fee_share_rate = 11 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_relayer_fee_share_rate() {
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
}
inline const std::string& Params::relayer_fee_share_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.relayer_fee_share_rate)
  return _internal_relayer_fee_share_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_relayer_fee_share_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_fee_share_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.relayer_fee_share_rate)
}
inline std::string* Params::mutable_relayer_fee_share_rate() {
  std::string* _s = _internal_mutable_relayer_fee_share_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.relayer_fee_share_rate)
  return _s;
}
inline const std::string& Params::_internal_relayer_fee_share_rate() const {
  return _impl_.relayer_fee_share_rate_.Get();
}
inline void Params::_internal_set_relayer_fee_share_rate(const std::string& value) {
  ;


  _impl_.relayer_fee_share_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_relayer_fee_share_rate() {
  ;
  return _impl_.relayer_fee_share_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_relayer_fee_share_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.relayer_fee_share_rate)
  return _impl_.relayer_fee_share_rate_.Release();
}
inline void Params::set_allocated_relayer_fee_share_rate(std::string* value) {
  _impl_.relayer_fee_share_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_fee_share_rate_.IsDefault()) {
          _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.relayer_fee_share_rate)
}

// string default_hourly_funding_rate_cap = 12 [json_name = "defaultHourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_default_hourly_funding_rate_cap() {
  _impl_.default_hourly_funding_rate_cap_.ClearToEmpty();
}
inline const std::string& Params::default_hourly_funding_rate_cap() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_hourly_funding_rate_cap)
  return _internal_default_hourly_funding_rate_cap();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_default_hourly_funding_rate_cap(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default_hourly_funding_rate_cap_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_hourly_funding_rate_cap)
}
inline std::string* Params::mutable_default_hourly_funding_rate_cap() {
  std::string* _s = _internal_mutable_default_hourly_funding_rate_cap();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.default_hourly_funding_rate_cap)
  return _s;
}
inline const std::string& Params::_internal_default_hourly_funding_rate_cap() const {
  return _impl_.default_hourly_funding_rate_cap_.Get();
}
inline void Params::_internal_set_default_hourly_funding_rate_cap(const std::string& value) {
  ;


  _impl_.default_hourly_funding_rate_cap_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_default_hourly_funding_rate_cap() {
  ;
  return _impl_.default_hourly_funding_rate_cap_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_default_hourly_funding_rate_cap() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.default_hourly_funding_rate_cap)
  return _impl_.default_hourly_funding_rate_cap_.Release();
}
inline void Params::set_allocated_default_hourly_funding_rate_cap(std::string* value) {
  _impl_.default_hourly_funding_rate_cap_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_hourly_funding_rate_cap_.IsDefault()) {
          _impl_.default_hourly_funding_rate_cap_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.default_hourly_funding_rate_cap)
}

// string default_hourly_interest_rate = 13 [json_name = "defaultHourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_default_hourly_interest_rate() {
  _impl_.default_hourly_interest_rate_.ClearToEmpty();
}
inline const std::string& Params::default_hourly_interest_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.default_hourly_interest_rate)
  return _internal_default_hourly_interest_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_default_hourly_interest_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default_hourly_interest_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.default_hourly_interest_rate)
}
inline std::string* Params::mutable_default_hourly_interest_rate() {
  std::string* _s = _internal_mutable_default_hourly_interest_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.default_hourly_interest_rate)
  return _s;
}
inline const std::string& Params::_internal_default_hourly_interest_rate() const {
  return _impl_.default_hourly_interest_rate_.Get();
}
inline void Params::_internal_set_default_hourly_interest_rate(const std::string& value) {
  ;


  _impl_.default_hourly_interest_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_default_hourly_interest_rate() {
  ;
  return _impl_.default_hourly_interest_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_default_hourly_interest_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.default_hourly_interest_rate)
  return _impl_.default_hourly_interest_rate_.Release();
}
inline void Params::set_allocated_default_hourly_interest_rate(std::string* value) {
  _impl_.default_hourly_interest_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_hourly_interest_rate_.IsDefault()) {
          _impl_.default_hourly_interest_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.default_hourly_interest_rate)
}

// uint32 max_derivative_order_side_count = 14 [json_name = "maxDerivativeOrderSideCount"];
inline void Params::clear_max_derivative_order_side_count() {
  _impl_.max_derivative_order_side_count_ = 0u;
}
inline ::uint32_t Params::max_derivative_order_side_count() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.max_derivative_order_side_count)
  return _internal_max_derivative_order_side_count();
}
inline void Params::set_max_derivative_order_side_count(::uint32_t value) {
  _internal_set_max_derivative_order_side_count(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.max_derivative_order_side_count)
}
inline ::uint32_t Params::_internal_max_derivative_order_side_count() const {
  return _impl_.max_derivative_order_side_count_;
}
inline void Params::_internal_set_max_derivative_order_side_count(::uint32_t value) {
  ;
  _impl_.max_derivative_order_side_count_ = value;
}

// string inj_reward_staked_requirement_threshold = 15 [json_name = "injRewardStakedRequirementThreshold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void Params::clear_inj_reward_staked_requirement_threshold() {
  _impl_.inj_reward_staked_requirement_threshold_.ClearToEmpty();
}
inline const std::string& Params::inj_reward_staked_requirement_threshold() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.inj_reward_staked_requirement_threshold)
  return _internal_inj_reward_staked_requirement_threshold();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_inj_reward_staked_requirement_threshold(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.inj_reward_staked_requirement_threshold_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.inj_reward_staked_requirement_threshold)
}
inline std::string* Params::mutable_inj_reward_staked_requirement_threshold() {
  std::string* _s = _internal_mutable_inj_reward_staked_requirement_threshold();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.inj_reward_staked_requirement_threshold)
  return _s;
}
inline const std::string& Params::_internal_inj_reward_staked_requirement_threshold() const {
  return _impl_.inj_reward_staked_requirement_threshold_.Get();
}
inline void Params::_internal_set_inj_reward_staked_requirement_threshold(const std::string& value) {
  ;


  _impl_.inj_reward_staked_requirement_threshold_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_inj_reward_staked_requirement_threshold() {
  ;
  return _impl_.inj_reward_staked_requirement_threshold_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_inj_reward_staked_requirement_threshold() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.inj_reward_staked_requirement_threshold)
  return _impl_.inj_reward_staked_requirement_threshold_.Release();
}
inline void Params::set_allocated_inj_reward_staked_requirement_threshold(std::string* value) {
  _impl_.inj_reward_staked_requirement_threshold_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.inj_reward_staked_requirement_threshold_.IsDefault()) {
          _impl_.inj_reward_staked_requirement_threshold_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.inj_reward_staked_requirement_threshold)
}

// int64 trading_rewards_vesting_duration = 16 [json_name = "tradingRewardsVestingDuration"];
inline void Params::clear_trading_rewards_vesting_duration() {
  _impl_.trading_rewards_vesting_duration_ = ::int64_t{0};
}
inline ::int64_t Params::trading_rewards_vesting_duration() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.trading_rewards_vesting_duration)
  return _internal_trading_rewards_vesting_duration();
}
inline void Params::set_trading_rewards_vesting_duration(::int64_t value) {
  _internal_set_trading_rewards_vesting_duration(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.trading_rewards_vesting_duration)
}
inline ::int64_t Params::_internal_trading_rewards_vesting_duration() const {
  return _impl_.trading_rewards_vesting_duration_;
}
inline void Params::_internal_set_trading_rewards_vesting_duration(::int64_t value) {
  ;
  _impl_.trading_rewards_vesting_duration_ = value;
}

// string liquidator_reward_share_rate = 17 [json_name = "liquidatorRewardShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_liquidator_reward_share_rate() {
  _impl_.liquidator_reward_share_rate_.ClearToEmpty();
}
inline const std::string& Params::liquidator_reward_share_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.liquidator_reward_share_rate)
  return _internal_liquidator_reward_share_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_liquidator_reward_share_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.liquidator_reward_share_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.liquidator_reward_share_rate)
}
inline std::string* Params::mutable_liquidator_reward_share_rate() {
  std::string* _s = _internal_mutable_liquidator_reward_share_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.liquidator_reward_share_rate)
  return _s;
}
inline const std::string& Params::_internal_liquidator_reward_share_rate() const {
  return _impl_.liquidator_reward_share_rate_.Get();
}
inline void Params::_internal_set_liquidator_reward_share_rate(const std::string& value) {
  ;


  _impl_.liquidator_reward_share_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_liquidator_reward_share_rate() {
  ;
  return _impl_.liquidator_reward_share_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_liquidator_reward_share_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.liquidator_reward_share_rate)
  return _impl_.liquidator_reward_share_rate_.Release();
}
inline void Params::set_allocated_liquidator_reward_share_rate(std::string* value) {
  _impl_.liquidator_reward_share_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.liquidator_reward_share_rate_.IsDefault()) {
          _impl_.liquidator_reward_share_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.liquidator_reward_share_rate)
}

// .cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18 [json_name = "binaryOptionsMarketInstantListingFee", (.gogoproto.nullable) = false];
inline bool Params::has_binary_options_market_instant_listing_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.binary_options_market_instant_listing_fee_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& Params::_internal_binary_options_market_instant_listing_fee() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.binary_options_market_instant_listing_fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& Params::binary_options_market_instant_listing_fee() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.binary_options_market_instant_listing_fee)
  return _internal_binary_options_market_instant_listing_fee();
}
inline void Params::unsafe_arena_set_allocated_binary_options_market_instant_listing_fee(
    ::cosmos::base::v1beta1::Coin* binary_options_market_instant_listing_fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.binary_options_market_instant_listing_fee_);
  }
  _impl_.binary_options_market_instant_listing_fee_ = binary_options_market_instant_listing_fee;
  if (binary_options_market_instant_listing_fee) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.Params.binary_options_market_instant_listing_fee)
}
inline ::cosmos::base::v1beta1::Coin* Params::release_binary_options_market_instant_listing_fee() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.binary_options_market_instant_listing_fee_;
  _impl_.binary_options_market_instant_listing_fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* Params::unsafe_arena_release_binary_options_market_instant_listing_fee() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.binary_options_market_instant_listing_fee)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.binary_options_market_instant_listing_fee_;
  _impl_.binary_options_market_instant_listing_fee_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* Params::_internal_mutable_binary_options_market_instant_listing_fee() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.binary_options_market_instant_listing_fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.binary_options_market_instant_listing_fee_ = p;
  }
  return _impl_.binary_options_market_instant_listing_fee_;
}
inline ::cosmos::base::v1beta1::Coin* Params::mutable_binary_options_market_instant_listing_fee() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_binary_options_market_instant_listing_fee();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.binary_options_market_instant_listing_fee)
  return _msg;
}
inline void Params::set_allocated_binary_options_market_instant_listing_fee(::cosmos::base::v1beta1::Coin* binary_options_market_instant_listing_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.binary_options_market_instant_listing_fee_);
  }
  if (binary_options_market_instant_listing_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binary_options_market_instant_listing_fee));
    if (message_arena != submessage_arena) {
      binary_options_market_instant_listing_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binary_options_market_instant_listing_fee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.binary_options_market_instant_listing_fee_ = binary_options_market_instant_listing_fee;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.binary_options_market_instant_listing_fee)
}

// .injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19 [json_name = "atomicMarketOrderAccessLevel"];
inline void Params::clear_atomic_market_order_access_level() {
  _impl_.atomic_market_order_access_level_ = 0;
}
inline ::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel Params::atomic_market_order_access_level() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.atomic_market_order_access_level)
  return _internal_atomic_market_order_access_level();
}
inline void Params::set_atomic_market_order_access_level(::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel value) {
   _internal_set_atomic_market_order_access_level(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.atomic_market_order_access_level)
}
inline ::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel Params::_internal_atomic_market_order_access_level() const {
  return static_cast<::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel>(_impl_.atomic_market_order_access_level_);
}
inline void Params::_internal_set_atomic_market_order_access_level(::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel value) {
  ;
  _impl_.atomic_market_order_access_level_ = value;
}

// string spot_atomic_market_order_fee_multiplier = 20 [json_name = "spotAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_spot_atomic_market_order_fee_multiplier() {
  _impl_.spot_atomic_market_order_fee_multiplier_.ClearToEmpty();
}
inline const std::string& Params::spot_atomic_market_order_fee_multiplier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.spot_atomic_market_order_fee_multiplier)
  return _internal_spot_atomic_market_order_fee_multiplier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_spot_atomic_market_order_fee_multiplier(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.spot_atomic_market_order_fee_multiplier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.spot_atomic_market_order_fee_multiplier)
}
inline std::string* Params::mutable_spot_atomic_market_order_fee_multiplier() {
  std::string* _s = _internal_mutable_spot_atomic_market_order_fee_multiplier();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.spot_atomic_market_order_fee_multiplier)
  return _s;
}
inline const std::string& Params::_internal_spot_atomic_market_order_fee_multiplier() const {
  return _impl_.spot_atomic_market_order_fee_multiplier_.Get();
}
inline void Params::_internal_set_spot_atomic_market_order_fee_multiplier(const std::string& value) {
  ;


  _impl_.spot_atomic_market_order_fee_multiplier_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_spot_atomic_market_order_fee_multiplier() {
  ;
  return _impl_.spot_atomic_market_order_fee_multiplier_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_spot_atomic_market_order_fee_multiplier() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.spot_atomic_market_order_fee_multiplier)
  return _impl_.spot_atomic_market_order_fee_multiplier_.Release();
}
inline void Params::set_allocated_spot_atomic_market_order_fee_multiplier(std::string* value) {
  _impl_.spot_atomic_market_order_fee_multiplier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.spot_atomic_market_order_fee_multiplier_.IsDefault()) {
          _impl_.spot_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.spot_atomic_market_order_fee_multiplier)
}

// string derivative_atomic_market_order_fee_multiplier = 21 [json_name = "derivativeAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_derivative_atomic_market_order_fee_multiplier() {
  _impl_.derivative_atomic_market_order_fee_multiplier_.ClearToEmpty();
}
inline const std::string& Params::derivative_atomic_market_order_fee_multiplier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.derivative_atomic_market_order_fee_multiplier)
  return _internal_derivative_atomic_market_order_fee_multiplier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_derivative_atomic_market_order_fee_multiplier(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.derivative_atomic_market_order_fee_multiplier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.derivative_atomic_market_order_fee_multiplier)
}
inline std::string* Params::mutable_derivative_atomic_market_order_fee_multiplier() {
  std::string* _s = _internal_mutable_derivative_atomic_market_order_fee_multiplier();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.derivative_atomic_market_order_fee_multiplier)
  return _s;
}
inline const std::string& Params::_internal_derivative_atomic_market_order_fee_multiplier() const {
  return _impl_.derivative_atomic_market_order_fee_multiplier_.Get();
}
inline void Params::_internal_set_derivative_atomic_market_order_fee_multiplier(const std::string& value) {
  ;


  _impl_.derivative_atomic_market_order_fee_multiplier_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_derivative_atomic_market_order_fee_multiplier() {
  ;
  return _impl_.derivative_atomic_market_order_fee_multiplier_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_derivative_atomic_market_order_fee_multiplier() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.derivative_atomic_market_order_fee_multiplier)
  return _impl_.derivative_atomic_market_order_fee_multiplier_.Release();
}
inline void Params::set_allocated_derivative_atomic_market_order_fee_multiplier(std::string* value) {
  _impl_.derivative_atomic_market_order_fee_multiplier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.derivative_atomic_market_order_fee_multiplier_.IsDefault()) {
          _impl_.derivative_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.derivative_atomic_market_order_fee_multiplier)
}

// string binary_options_atomic_market_order_fee_multiplier = 22 [json_name = "binaryOptionsAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_binary_options_atomic_market_order_fee_multiplier() {
  _impl_.binary_options_atomic_market_order_fee_multiplier_.ClearToEmpty();
}
inline const std::string& Params::binary_options_atomic_market_order_fee_multiplier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.binary_options_atomic_market_order_fee_multiplier)
  return _internal_binary_options_atomic_market_order_fee_multiplier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_binary_options_atomic_market_order_fee_multiplier(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.binary_options_atomic_market_order_fee_multiplier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.binary_options_atomic_market_order_fee_multiplier)
}
inline std::string* Params::mutable_binary_options_atomic_market_order_fee_multiplier() {
  std::string* _s = _internal_mutable_binary_options_atomic_market_order_fee_multiplier();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.binary_options_atomic_market_order_fee_multiplier)
  return _s;
}
inline const std::string& Params::_internal_binary_options_atomic_market_order_fee_multiplier() const {
  return _impl_.binary_options_atomic_market_order_fee_multiplier_.Get();
}
inline void Params::_internal_set_binary_options_atomic_market_order_fee_multiplier(const std::string& value) {
  ;


  _impl_.binary_options_atomic_market_order_fee_multiplier_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_binary_options_atomic_market_order_fee_multiplier() {
  ;
  return _impl_.binary_options_atomic_market_order_fee_multiplier_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_binary_options_atomic_market_order_fee_multiplier() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.binary_options_atomic_market_order_fee_multiplier)
  return _impl_.binary_options_atomic_market_order_fee_multiplier_.Release();
}
inline void Params::set_allocated_binary_options_atomic_market_order_fee_multiplier(std::string* value) {
  _impl_.binary_options_atomic_market_order_fee_multiplier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.binary_options_atomic_market_order_fee_multiplier_.IsDefault()) {
          _impl_.binary_options_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.binary_options_atomic_market_order_fee_multiplier)
}

// string minimal_protocol_fee_rate = 23 [json_name = "minimalProtocolFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Params::clear_minimal_protocol_fee_rate() {
  _impl_.minimal_protocol_fee_rate_.ClearToEmpty();
}
inline const std::string& Params::minimal_protocol_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.minimal_protocol_fee_rate)
  return _internal_minimal_protocol_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_minimal_protocol_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.minimal_protocol_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.minimal_protocol_fee_rate)
}
inline std::string* Params::mutable_minimal_protocol_fee_rate() {
  std::string* _s = _internal_mutable_minimal_protocol_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Params.minimal_protocol_fee_rate)
  return _s;
}
inline const std::string& Params::_internal_minimal_protocol_fee_rate() const {
  return _impl_.minimal_protocol_fee_rate_.Get();
}
inline void Params::_internal_set_minimal_protocol_fee_rate(const std::string& value) {
  ;


  _impl_.minimal_protocol_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_minimal_protocol_fee_rate() {
  ;
  return _impl_.minimal_protocol_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_minimal_protocol_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Params.minimal_protocol_fee_rate)
  return _impl_.minimal_protocol_fee_rate_.Release();
}
inline void Params::set_allocated_minimal_protocol_fee_rate(std::string* value) {
  _impl_.minimal_protocol_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.minimal_protocol_fee_rate_.IsDefault()) {
          _impl_.minimal_protocol_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Params.minimal_protocol_fee_rate)
}

// bool is_instant_derivative_market_launch_enabled = 24 [json_name = "isInstantDerivativeMarketLaunchEnabled"];
inline void Params::clear_is_instant_derivative_market_launch_enabled() {
  _impl_.is_instant_derivative_market_launch_enabled_ = false;
}
inline bool Params::is_instant_derivative_market_launch_enabled() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Params.is_instant_derivative_market_launch_enabled)
  return _internal_is_instant_derivative_market_launch_enabled();
}
inline void Params::set_is_instant_derivative_market_launch_enabled(bool value) {
  _internal_set_is_instant_derivative_market_launch_enabled(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Params.is_instant_derivative_market_launch_enabled)
}
inline bool Params::_internal_is_instant_derivative_market_launch_enabled() const {
  return _impl_.is_instant_derivative_market_launch_enabled_;
}
inline void Params::_internal_set_is_instant_derivative_market_launch_enabled(bool value) {
  ;
  _impl_.is_instant_derivative_market_launch_enabled_ = value;
}

// -------------------------------------------------------------------

// MarketFeeMultiplier

// string market_id = 1 [json_name = "marketId"];
inline void MarketFeeMultiplier::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MarketFeeMultiplier::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketFeeMultiplier.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketFeeMultiplier::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketFeeMultiplier.market_id)
}
inline std::string* MarketFeeMultiplier::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketFeeMultiplier.market_id)
  return _s;
}
inline const std::string& MarketFeeMultiplier::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MarketFeeMultiplier::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketFeeMultiplier::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketFeeMultiplier::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketFeeMultiplier.market_id)
  return _impl_.market_id_.Release();
}
inline void MarketFeeMultiplier::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketFeeMultiplier.market_id)
}

// string fee_multiplier = 2 [json_name = "feeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MarketFeeMultiplier::clear_fee_multiplier() {
  _impl_.fee_multiplier_.ClearToEmpty();
}
inline const std::string& MarketFeeMultiplier::fee_multiplier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketFeeMultiplier.fee_multiplier)
  return _internal_fee_multiplier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketFeeMultiplier::set_fee_multiplier(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_multiplier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketFeeMultiplier.fee_multiplier)
}
inline std::string* MarketFeeMultiplier::mutable_fee_multiplier() {
  std::string* _s = _internal_mutable_fee_multiplier();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketFeeMultiplier.fee_multiplier)
  return _s;
}
inline const std::string& MarketFeeMultiplier::_internal_fee_multiplier() const {
  return _impl_.fee_multiplier_.Get();
}
inline void MarketFeeMultiplier::_internal_set_fee_multiplier(const std::string& value) {
  ;


  _impl_.fee_multiplier_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketFeeMultiplier::_internal_mutable_fee_multiplier() {
  ;
  return _impl_.fee_multiplier_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketFeeMultiplier::release_fee_multiplier() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketFeeMultiplier.fee_multiplier)
  return _impl_.fee_multiplier_.Release();
}
inline void MarketFeeMultiplier::set_allocated_fee_multiplier(std::string* value) {
  _impl_.fee_multiplier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_multiplier_.IsDefault()) {
          _impl_.fee_multiplier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketFeeMultiplier.fee_multiplier)
}

// -------------------------------------------------------------------

// DerivativeMarket

// string ticker = 1 [json_name = "ticker"];
inline void DerivativeMarket::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.ticker)
}
inline std::string* DerivativeMarket::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.ticker)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void DerivativeMarket::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.ticker)
  return _impl_.ticker_.Release();
}
inline void DerivativeMarket::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.ticker)
}

// string oracle_base = 2 [json_name = "oracleBase"];
inline void DerivativeMarket::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.oracle_base)
}
inline std::string* DerivativeMarket::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.oracle_base)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void DerivativeMarket::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void DerivativeMarket::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.oracle_base)
}

// string oracle_quote = 3 [json_name = "oracleQuote"];
inline void DerivativeMarket::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.oracle_quote)
}
inline std::string* DerivativeMarket::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.oracle_quote)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void DerivativeMarket::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void DerivativeMarket::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.oracle_quote)
}

// .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
inline void DerivativeMarket::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType DerivativeMarket::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.oracle_type)
  return _internal_oracle_type();
}
inline void DerivativeMarket::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType DerivativeMarket::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void DerivativeMarket::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
inline void DerivativeMarket::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t DerivativeMarket::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void DerivativeMarket::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.oracle_scale_factor)
}
inline ::uint32_t DerivativeMarket::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void DerivativeMarket::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// string quote_denom = 6 [json_name = "quoteDenom"];
inline void DerivativeMarket::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.quote_denom)
}
inline std::string* DerivativeMarket::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.quote_denom)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void DerivativeMarket::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void DerivativeMarket::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.quote_denom)
}

// string market_id = 7 [json_name = "marketId"];
inline void DerivativeMarket::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.market_id)
}
inline std::string* DerivativeMarket::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.market_id)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativeMarket::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativeMarket::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.market_id)
}

// string initial_margin_ratio = 8 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarket::clear_initial_margin_ratio() {
  _impl_.initial_margin_ratio_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::initial_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.initial_margin_ratio)
  return _internal_initial_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_initial_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.initial_margin_ratio)
}
inline std::string* DerivativeMarket::mutable_initial_margin_ratio() {
  std::string* _s = _internal_mutable_initial_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.initial_margin_ratio)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_initial_margin_ratio() const {
  return _impl_.initial_margin_ratio_.Get();
}
inline void DerivativeMarket::_internal_set_initial_margin_ratio(const std::string& value) {
  ;


  _impl_.initial_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_initial_margin_ratio() {
  ;
  return _impl_.initial_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_initial_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.initial_margin_ratio)
  return _impl_.initial_margin_ratio_.Release();
}
inline void DerivativeMarket::set_allocated_initial_margin_ratio(std::string* value) {
  _impl_.initial_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_margin_ratio_.IsDefault()) {
          _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.initial_margin_ratio)
}

// string maintenance_margin_ratio = 9 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarket::clear_maintenance_margin_ratio() {
  _impl_.maintenance_margin_ratio_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::maintenance_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.maintenance_margin_ratio)
  return _internal_maintenance_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_maintenance_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maintenance_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.maintenance_margin_ratio)
}
inline std::string* DerivativeMarket::mutable_maintenance_margin_ratio() {
  std::string* _s = _internal_mutable_maintenance_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.maintenance_margin_ratio)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_maintenance_margin_ratio() const {
  return _impl_.maintenance_margin_ratio_.Get();
}
inline void DerivativeMarket::_internal_set_maintenance_margin_ratio(const std::string& value) {
  ;


  _impl_.maintenance_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_maintenance_margin_ratio() {
  ;
  return _impl_.maintenance_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_maintenance_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.maintenance_margin_ratio)
  return _impl_.maintenance_margin_ratio_.Release();
}
inline void DerivativeMarket::set_allocated_maintenance_margin_ratio(std::string* value) {
  _impl_.maintenance_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maintenance_margin_ratio_.IsDefault()) {
          _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.maintenance_margin_ratio)
}

// string maker_fee_rate = 10 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarket::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.maker_fee_rate)
}
inline std::string* DerivativeMarket::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.maker_fee_rate)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void DerivativeMarket::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void DerivativeMarket::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.maker_fee_rate)
}

// string taker_fee_rate = 11 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarket::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.taker_fee_rate)
}
inline std::string* DerivativeMarket::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.taker_fee_rate)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void DerivativeMarket::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void DerivativeMarket::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.taker_fee_rate)
}

// string relayer_fee_share_rate = 12 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarket::clear_relayer_fee_share_rate() {
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::relayer_fee_share_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.relayer_fee_share_rate)
  return _internal_relayer_fee_share_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_relayer_fee_share_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_fee_share_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.relayer_fee_share_rate)
}
inline std::string* DerivativeMarket::mutable_relayer_fee_share_rate() {
  std::string* _s = _internal_mutable_relayer_fee_share_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.relayer_fee_share_rate)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_relayer_fee_share_rate() const {
  return _impl_.relayer_fee_share_rate_.Get();
}
inline void DerivativeMarket::_internal_set_relayer_fee_share_rate(const std::string& value) {
  ;


  _impl_.relayer_fee_share_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_relayer_fee_share_rate() {
  ;
  return _impl_.relayer_fee_share_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_relayer_fee_share_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.relayer_fee_share_rate)
  return _impl_.relayer_fee_share_rate_.Release();
}
inline void DerivativeMarket::set_allocated_relayer_fee_share_rate(std::string* value) {
  _impl_.relayer_fee_share_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_fee_share_rate_.IsDefault()) {
          _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.relayer_fee_share_rate)
}

// bool isPerpetual = 13 [json_name = "isPerpetual"];
inline void DerivativeMarket::clear_isperpetual() {
  _impl_.isperpetual_ = false;
}
inline bool DerivativeMarket::isperpetual() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.isPerpetual)
  return _internal_isperpetual();
}
inline void DerivativeMarket::set_isperpetual(bool value) {
  _internal_set_isperpetual(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.isPerpetual)
}
inline bool DerivativeMarket::_internal_isperpetual() const {
  return _impl_.isperpetual_;
}
inline void DerivativeMarket::_internal_set_isperpetual(bool value) {
  ;
  _impl_.isperpetual_ = value;
}

// .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
inline void DerivativeMarket::clear_status() {
  _impl_.status_ = 0;
}
inline ::injective::exchange::v1beta1::MarketStatus DerivativeMarket::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.status)
  return _internal_status();
}
inline void DerivativeMarket::set_status(::injective::exchange::v1beta1::MarketStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.status)
}
inline ::injective::exchange::v1beta1::MarketStatus DerivativeMarket::_internal_status() const {
  return static_cast<::injective::exchange::v1beta1::MarketStatus>(_impl_.status_);
}
inline void DerivativeMarket::_internal_set_status(::injective::exchange::v1beta1::MarketStatus value) {
  ;
  _impl_.status_ = value;
}

// string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarket::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.min_price_tick_size)
}
inline std::string* DerivativeMarket::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.min_price_tick_size)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void DerivativeMarket::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void DerivativeMarket::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.min_price_tick_size)
}

// string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarket::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& DerivativeMarket::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarket.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarket::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarket.min_quantity_tick_size)
}
inline std::string* DerivativeMarket::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarket.min_quantity_tick_size)
  return _s;
}
inline const std::string& DerivativeMarket::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void DerivativeMarket::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarket::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarket::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarket.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void DerivativeMarket::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarket.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// BinaryOptionsMarket

// string ticker = 1 [json_name = "ticker"];
inline void BinaryOptionsMarket::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.ticker)
}
inline std::string* BinaryOptionsMarket::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.ticker)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void BinaryOptionsMarket::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.ticker)
  return _impl_.ticker_.Release();
}
inline void BinaryOptionsMarket::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.ticker)
}

// string oracle_symbol = 2 [json_name = "oracleSymbol"];
inline void BinaryOptionsMarket::clear_oracle_symbol() {
  _impl_.oracle_symbol_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::oracle_symbol() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_symbol)
  return _internal_oracle_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_oracle_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_symbol)
}
inline std::string* BinaryOptionsMarket::mutable_oracle_symbol() {
  std::string* _s = _internal_mutable_oracle_symbol();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_symbol)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_oracle_symbol() const {
  return _impl_.oracle_symbol_.Get();
}
inline void BinaryOptionsMarket::_internal_set_oracle_symbol(const std::string& value) {
  ;


  _impl_.oracle_symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_oracle_symbol() {
  ;
  return _impl_.oracle_symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_oracle_symbol() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_symbol)
  return _impl_.oracle_symbol_.Release();
}
inline void BinaryOptionsMarket::set_allocated_oracle_symbol(std::string* value) {
  _impl_.oracle_symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_symbol_.IsDefault()) {
          _impl_.oracle_symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_symbol)
}

// string oracle_provider = 3 [json_name = "oracleProvider"];
inline void BinaryOptionsMarket::clear_oracle_provider() {
  _impl_.oracle_provider_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::oracle_provider() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_provider)
  return _internal_oracle_provider();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_oracle_provider(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_provider_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_provider)
}
inline std::string* BinaryOptionsMarket::mutable_oracle_provider() {
  std::string* _s = _internal_mutable_oracle_provider();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_provider)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_oracle_provider() const {
  return _impl_.oracle_provider_.Get();
}
inline void BinaryOptionsMarket::_internal_set_oracle_provider(const std::string& value) {
  ;


  _impl_.oracle_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_oracle_provider() {
  ;
  return _impl_.oracle_provider_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_oracle_provider() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_provider)
  return _impl_.oracle_provider_.Release();
}
inline void BinaryOptionsMarket::set_allocated_oracle_provider(std::string* value) {
  _impl_.oracle_provider_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_provider_.IsDefault()) {
          _impl_.oracle_provider_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_provider)
}

// .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
inline void BinaryOptionsMarket::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType BinaryOptionsMarket::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_type)
  return _internal_oracle_type();
}
inline void BinaryOptionsMarket::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType BinaryOptionsMarket::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void BinaryOptionsMarket::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
inline void BinaryOptionsMarket::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t BinaryOptionsMarket::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void BinaryOptionsMarket::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.oracle_scale_factor)
}
inline ::uint32_t BinaryOptionsMarket::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void BinaryOptionsMarket::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// int64 expiration_timestamp = 6 [json_name = "expirationTimestamp"];
inline void BinaryOptionsMarket::clear_expiration_timestamp() {
  _impl_.expiration_timestamp_ = ::int64_t{0};
}
inline ::int64_t BinaryOptionsMarket::expiration_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void BinaryOptionsMarket::set_expiration_timestamp(::int64_t value) {
  _internal_set_expiration_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.expiration_timestamp)
}
inline ::int64_t BinaryOptionsMarket::_internal_expiration_timestamp() const {
  return _impl_.expiration_timestamp_;
}
inline void BinaryOptionsMarket::_internal_set_expiration_timestamp(::int64_t value) {
  ;
  _impl_.expiration_timestamp_ = value;
}

// int64 settlement_timestamp = 7 [json_name = "settlementTimestamp"];
inline void BinaryOptionsMarket::clear_settlement_timestamp() {
  _impl_.settlement_timestamp_ = ::int64_t{0};
}
inline ::int64_t BinaryOptionsMarket::settlement_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.settlement_timestamp)
  return _internal_settlement_timestamp();
}
inline void BinaryOptionsMarket::set_settlement_timestamp(::int64_t value) {
  _internal_set_settlement_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.settlement_timestamp)
}
inline ::int64_t BinaryOptionsMarket::_internal_settlement_timestamp() const {
  return _impl_.settlement_timestamp_;
}
inline void BinaryOptionsMarket::_internal_set_settlement_timestamp(::int64_t value) {
  ;
  _impl_.settlement_timestamp_ = value;
}

// string admin = 8 [json_name = "admin"];
inline void BinaryOptionsMarket::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::admin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.admin)
}
inline std::string* BinaryOptionsMarket::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.admin)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void BinaryOptionsMarket::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_admin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.admin)
  return _impl_.admin_.Release();
}
inline void BinaryOptionsMarket::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.admin)
}

// string quote_denom = 9 [json_name = "quoteDenom"];
inline void BinaryOptionsMarket::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.quote_denom)
}
inline std::string* BinaryOptionsMarket::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.quote_denom)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void BinaryOptionsMarket::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void BinaryOptionsMarket::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.quote_denom)
}

// string market_id = 10 [json_name = "marketId"];
inline void BinaryOptionsMarket::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.market_id)
}
inline std::string* BinaryOptionsMarket::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.market_id)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void BinaryOptionsMarket::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.market_id)
  return _impl_.market_id_.Release();
}
inline void BinaryOptionsMarket::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.market_id)
}

// string maker_fee_rate = 11 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarket::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.maker_fee_rate)
}
inline std::string* BinaryOptionsMarket::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.maker_fee_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void BinaryOptionsMarket::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void BinaryOptionsMarket::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.maker_fee_rate)
}

// string taker_fee_rate = 12 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarket::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.taker_fee_rate)
}
inline std::string* BinaryOptionsMarket::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.taker_fee_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void BinaryOptionsMarket::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void BinaryOptionsMarket::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.taker_fee_rate)
}

// string relayer_fee_share_rate = 13 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarket::clear_relayer_fee_share_rate() {
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::relayer_fee_share_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.relayer_fee_share_rate)
  return _internal_relayer_fee_share_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_relayer_fee_share_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_fee_share_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.relayer_fee_share_rate)
}
inline std::string* BinaryOptionsMarket::mutable_relayer_fee_share_rate() {
  std::string* _s = _internal_mutable_relayer_fee_share_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.relayer_fee_share_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_relayer_fee_share_rate() const {
  return _impl_.relayer_fee_share_rate_.Get();
}
inline void BinaryOptionsMarket::_internal_set_relayer_fee_share_rate(const std::string& value) {
  ;


  _impl_.relayer_fee_share_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_relayer_fee_share_rate() {
  ;
  return _impl_.relayer_fee_share_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_relayer_fee_share_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.relayer_fee_share_rate)
  return _impl_.relayer_fee_share_rate_.Release();
}
inline void BinaryOptionsMarket::set_allocated_relayer_fee_share_rate(std::string* value) {
  _impl_.relayer_fee_share_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_fee_share_rate_.IsDefault()) {
          _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.relayer_fee_share_rate)
}

// .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
inline void BinaryOptionsMarket::clear_status() {
  _impl_.status_ = 0;
}
inline ::injective::exchange::v1beta1::MarketStatus BinaryOptionsMarket::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.status)
  return _internal_status();
}
inline void BinaryOptionsMarket::set_status(::injective::exchange::v1beta1::MarketStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.status)
}
inline ::injective::exchange::v1beta1::MarketStatus BinaryOptionsMarket::_internal_status() const {
  return static_cast<::injective::exchange::v1beta1::MarketStatus>(_impl_.status_);
}
inline void BinaryOptionsMarket::_internal_set_status(::injective::exchange::v1beta1::MarketStatus value) {
  ;
  _impl_.status_ = value;
}

// string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarket::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.min_price_tick_size)
}
inline std::string* BinaryOptionsMarket::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.min_price_tick_size)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void BinaryOptionsMarket::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void BinaryOptionsMarket::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.min_price_tick_size)
}

// string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarket::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.min_quantity_tick_size)
}
inline std::string* BinaryOptionsMarket::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.min_quantity_tick_size)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void BinaryOptionsMarket::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void BinaryOptionsMarket::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.min_quantity_tick_size)
}

// string settlement_price = 17 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarket::clear_settlement_price() {
  _impl_.settlement_price_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarket::settlement_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarket.settlement_price)
  return _internal_settlement_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarket::set_settlement_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settlement_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarket.settlement_price)
}
inline std::string* BinaryOptionsMarket::mutable_settlement_price() {
  std::string* _s = _internal_mutable_settlement_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarket.settlement_price)
  return _s;
}
inline const std::string& BinaryOptionsMarket::_internal_settlement_price() const {
  return _impl_.settlement_price_.Get();
}
inline void BinaryOptionsMarket::_internal_set_settlement_price(const std::string& value) {
  ;


  _impl_.settlement_price_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::_internal_mutable_settlement_price() {
  ;
  return _impl_.settlement_price_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarket::release_settlement_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarket.settlement_price)
  return _impl_.settlement_price_.Release();
}
inline void BinaryOptionsMarket::set_allocated_settlement_price(std::string* value) {
  _impl_.settlement_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlement_price_.IsDefault()) {
          _impl_.settlement_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarket.settlement_price)
}

// -------------------------------------------------------------------

// ExpiryFuturesMarketInfo

// string market_id = 1 [json_name = "marketId"];
inline void ExpiryFuturesMarketInfo::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketInfo::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketInfo::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.market_id)
}
inline std::string* ExpiryFuturesMarketInfo::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.market_id)
  return _s;
}
inline const std::string& ExpiryFuturesMarketInfo::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void ExpiryFuturesMarketInfo::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketInfo::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketInfo::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.market_id)
  return _impl_.market_id_.Release();
}
inline void ExpiryFuturesMarketInfo::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.market_id)
}

// int64 expiration_timestamp = 2 [json_name = "expirationTimestamp"];
inline void ExpiryFuturesMarketInfo::clear_expiration_timestamp() {
  _impl_.expiration_timestamp_ = ::int64_t{0};
}
inline ::int64_t ExpiryFuturesMarketInfo::expiration_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void ExpiryFuturesMarketInfo::set_expiration_timestamp(::int64_t value) {
  _internal_set_expiration_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_timestamp)
}
inline ::int64_t ExpiryFuturesMarketInfo::_internal_expiration_timestamp() const {
  return _impl_.expiration_timestamp_;
}
inline void ExpiryFuturesMarketInfo::_internal_set_expiration_timestamp(::int64_t value) {
  ;
  _impl_.expiration_timestamp_ = value;
}

// int64 twap_start_timestamp = 3 [json_name = "twapStartTimestamp"];
inline void ExpiryFuturesMarketInfo::clear_twap_start_timestamp() {
  _impl_.twap_start_timestamp_ = ::int64_t{0};
}
inline ::int64_t ExpiryFuturesMarketInfo::twap_start_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.twap_start_timestamp)
  return _internal_twap_start_timestamp();
}
inline void ExpiryFuturesMarketInfo::set_twap_start_timestamp(::int64_t value) {
  _internal_set_twap_start_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.twap_start_timestamp)
}
inline ::int64_t ExpiryFuturesMarketInfo::_internal_twap_start_timestamp() const {
  return _impl_.twap_start_timestamp_;
}
inline void ExpiryFuturesMarketInfo::_internal_set_twap_start_timestamp(::int64_t value) {
  ;
  _impl_.twap_start_timestamp_ = value;
}

// string expiration_twap_start_price_cumulative = 4 [json_name = "expirationTwapStartPriceCumulative", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ExpiryFuturesMarketInfo::clear_expiration_twap_start_price_cumulative() {
  _impl_.expiration_twap_start_price_cumulative_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketInfo::expiration_twap_start_price_cumulative() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_twap_start_price_cumulative)
  return _internal_expiration_twap_start_price_cumulative();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketInfo::set_expiration_twap_start_price_cumulative(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.expiration_twap_start_price_cumulative_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_twap_start_price_cumulative)
}
inline std::string* ExpiryFuturesMarketInfo::mutable_expiration_twap_start_price_cumulative() {
  std::string* _s = _internal_mutable_expiration_twap_start_price_cumulative();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_twap_start_price_cumulative)
  return _s;
}
inline const std::string& ExpiryFuturesMarketInfo::_internal_expiration_twap_start_price_cumulative() const {
  return _impl_.expiration_twap_start_price_cumulative_.Get();
}
inline void ExpiryFuturesMarketInfo::_internal_set_expiration_twap_start_price_cumulative(const std::string& value) {
  ;


  _impl_.expiration_twap_start_price_cumulative_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketInfo::_internal_mutable_expiration_twap_start_price_cumulative() {
  ;
  return _impl_.expiration_twap_start_price_cumulative_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketInfo::release_expiration_twap_start_price_cumulative() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_twap_start_price_cumulative)
  return _impl_.expiration_twap_start_price_cumulative_.Release();
}
inline void ExpiryFuturesMarketInfo::set_allocated_expiration_twap_start_price_cumulative(std::string* value) {
  _impl_.expiration_twap_start_price_cumulative_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.expiration_twap_start_price_cumulative_.IsDefault()) {
          _impl_.expiration_twap_start_price_cumulative_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_twap_start_price_cumulative)
}

// string settlement_price = 5 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ExpiryFuturesMarketInfo::clear_settlement_price() {
  _impl_.settlement_price_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketInfo::settlement_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.settlement_price)
  return _internal_settlement_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketInfo::set_settlement_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settlement_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.settlement_price)
}
inline std::string* ExpiryFuturesMarketInfo::mutable_settlement_price() {
  std::string* _s = _internal_mutable_settlement_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.settlement_price)
  return _s;
}
inline const std::string& ExpiryFuturesMarketInfo::_internal_settlement_price() const {
  return _impl_.settlement_price_.Get();
}
inline void ExpiryFuturesMarketInfo::_internal_set_settlement_price(const std::string& value) {
  ;


  _impl_.settlement_price_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketInfo::_internal_mutable_settlement_price() {
  ;
  return _impl_.settlement_price_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketInfo::release_settlement_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.settlement_price)
  return _impl_.settlement_price_.Release();
}
inline void ExpiryFuturesMarketInfo::set_allocated_settlement_price(std::string* value) {
  _impl_.settlement_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlement_price_.IsDefault()) {
          _impl_.settlement_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketInfo.settlement_price)
}

// -------------------------------------------------------------------

// PerpetualMarketInfo

// string market_id = 1 [json_name = "marketId"];
inline void PerpetualMarketInfo::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& PerpetualMarketInfo::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketInfo.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketInfo::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketInfo.market_id)
}
inline std::string* PerpetualMarketInfo::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketInfo.market_id)
  return _s;
}
inline const std::string& PerpetualMarketInfo::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void PerpetualMarketInfo::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketInfo.market_id)
  return _impl_.market_id_.Release();
}
inline void PerpetualMarketInfo::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketInfo.market_id)
}

// string hourly_funding_rate_cap = 2 [json_name = "hourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketInfo::clear_hourly_funding_rate_cap() {
  _impl_.hourly_funding_rate_cap_.ClearToEmpty();
}
inline const std::string& PerpetualMarketInfo::hourly_funding_rate_cap() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_funding_rate_cap)
  return _internal_hourly_funding_rate_cap();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketInfo::set_hourly_funding_rate_cap(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hourly_funding_rate_cap_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_funding_rate_cap)
}
inline std::string* PerpetualMarketInfo::mutable_hourly_funding_rate_cap() {
  std::string* _s = _internal_mutable_hourly_funding_rate_cap();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_funding_rate_cap)
  return _s;
}
inline const std::string& PerpetualMarketInfo::_internal_hourly_funding_rate_cap() const {
  return _impl_.hourly_funding_rate_cap_.Get();
}
inline void PerpetualMarketInfo::_internal_set_hourly_funding_rate_cap(const std::string& value) {
  ;


  _impl_.hourly_funding_rate_cap_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::_internal_mutable_hourly_funding_rate_cap() {
  ;
  return _impl_.hourly_funding_rate_cap_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::release_hourly_funding_rate_cap() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_funding_rate_cap)
  return _impl_.hourly_funding_rate_cap_.Release();
}
inline void PerpetualMarketInfo::set_allocated_hourly_funding_rate_cap(std::string* value) {
  _impl_.hourly_funding_rate_cap_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hourly_funding_rate_cap_.IsDefault()) {
          _impl_.hourly_funding_rate_cap_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_funding_rate_cap)
}

// string hourly_interest_rate = 3 [json_name = "hourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketInfo::clear_hourly_interest_rate() {
  _impl_.hourly_interest_rate_.ClearToEmpty();
}
inline const std::string& PerpetualMarketInfo::hourly_interest_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_interest_rate)
  return _internal_hourly_interest_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketInfo::set_hourly_interest_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hourly_interest_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_interest_rate)
}
inline std::string* PerpetualMarketInfo::mutable_hourly_interest_rate() {
  std::string* _s = _internal_mutable_hourly_interest_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_interest_rate)
  return _s;
}
inline const std::string& PerpetualMarketInfo::_internal_hourly_interest_rate() const {
  return _impl_.hourly_interest_rate_.Get();
}
inline void PerpetualMarketInfo::_internal_set_hourly_interest_rate(const std::string& value) {
  ;


  _impl_.hourly_interest_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::_internal_mutable_hourly_interest_rate() {
  ;
  return _impl_.hourly_interest_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::release_hourly_interest_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_interest_rate)
  return _impl_.hourly_interest_rate_.Release();
}
inline void PerpetualMarketInfo::set_allocated_hourly_interest_rate(std::string* value) {
  _impl_.hourly_interest_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hourly_interest_rate_.IsDefault()) {
          _impl_.hourly_interest_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketInfo.hourly_interest_rate)
}

// int64 next_funding_timestamp = 4 [json_name = "nextFundingTimestamp"];
inline void PerpetualMarketInfo::clear_next_funding_timestamp() {
  _impl_.next_funding_timestamp_ = ::int64_t{0};
}
inline ::int64_t PerpetualMarketInfo::next_funding_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketInfo.next_funding_timestamp)
  return _internal_next_funding_timestamp();
}
inline void PerpetualMarketInfo::set_next_funding_timestamp(::int64_t value) {
  _internal_set_next_funding_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketInfo.next_funding_timestamp)
}
inline ::int64_t PerpetualMarketInfo::_internal_next_funding_timestamp() const {
  return _impl_.next_funding_timestamp_;
}
inline void PerpetualMarketInfo::_internal_set_next_funding_timestamp(::int64_t value) {
  ;
  _impl_.next_funding_timestamp_ = value;
}

// int64 funding_interval = 5 [json_name = "fundingInterval"];
inline void PerpetualMarketInfo::clear_funding_interval() {
  _impl_.funding_interval_ = ::int64_t{0};
}
inline ::int64_t PerpetualMarketInfo::funding_interval() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketInfo.funding_interval)
  return _internal_funding_interval();
}
inline void PerpetualMarketInfo::set_funding_interval(::int64_t value) {
  _internal_set_funding_interval(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketInfo.funding_interval)
}
inline ::int64_t PerpetualMarketInfo::_internal_funding_interval() const {
  return _impl_.funding_interval_;
}
inline void PerpetualMarketInfo::_internal_set_funding_interval(::int64_t value) {
  ;
  _impl_.funding_interval_ = value;
}

// -------------------------------------------------------------------

// PerpetualMarketFunding

// string cumulative_funding = 1 [json_name = "cumulativeFunding", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketFunding::clear_cumulative_funding() {
  _impl_.cumulative_funding_.ClearToEmpty();
}
inline const std::string& PerpetualMarketFunding::cumulative_funding() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_funding)
  return _internal_cumulative_funding();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketFunding::set_cumulative_funding(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cumulative_funding_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_funding)
}
inline std::string* PerpetualMarketFunding::mutable_cumulative_funding() {
  std::string* _s = _internal_mutable_cumulative_funding();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_funding)
  return _s;
}
inline const std::string& PerpetualMarketFunding::_internal_cumulative_funding() const {
  return _impl_.cumulative_funding_.Get();
}
inline void PerpetualMarketFunding::_internal_set_cumulative_funding(const std::string& value) {
  ;


  _impl_.cumulative_funding_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketFunding::_internal_mutable_cumulative_funding() {
  ;
  return _impl_.cumulative_funding_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketFunding::release_cumulative_funding() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_funding)
  return _impl_.cumulative_funding_.Release();
}
inline void PerpetualMarketFunding::set_allocated_cumulative_funding(std::string* value) {
  _impl_.cumulative_funding_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cumulative_funding_.IsDefault()) {
          _impl_.cumulative_funding_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_funding)
}

// string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketFunding::clear_cumulative_price() {
  _impl_.cumulative_price_.ClearToEmpty();
}
inline const std::string& PerpetualMarketFunding::cumulative_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_price)
  return _internal_cumulative_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketFunding::set_cumulative_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cumulative_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_price)
}
inline std::string* PerpetualMarketFunding::mutable_cumulative_price() {
  std::string* _s = _internal_mutable_cumulative_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_price)
  return _s;
}
inline const std::string& PerpetualMarketFunding::_internal_cumulative_price() const {
  return _impl_.cumulative_price_.Get();
}
inline void PerpetualMarketFunding::_internal_set_cumulative_price(const std::string& value) {
  ;


  _impl_.cumulative_price_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketFunding::_internal_mutable_cumulative_price() {
  ;
  return _impl_.cumulative_price_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketFunding::release_cumulative_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_price)
  return _impl_.cumulative_price_.Release();
}
inline void PerpetualMarketFunding::set_allocated_cumulative_price(std::string* value) {
  _impl_.cumulative_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cumulative_price_.IsDefault()) {
          _impl_.cumulative_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_price)
}

// int64 last_timestamp = 3 [json_name = "lastTimestamp"];
inline void PerpetualMarketFunding::clear_last_timestamp() {
  _impl_.last_timestamp_ = ::int64_t{0};
}
inline ::int64_t PerpetualMarketFunding::last_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketFunding.last_timestamp)
  return _internal_last_timestamp();
}
inline void PerpetualMarketFunding::set_last_timestamp(::int64_t value) {
  _internal_set_last_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketFunding.last_timestamp)
}
inline ::int64_t PerpetualMarketFunding::_internal_last_timestamp() const {
  return _impl_.last_timestamp_;
}
inline void PerpetualMarketFunding::_internal_set_last_timestamp(::int64_t value) {
  ;
  _impl_.last_timestamp_ = value;
}

// -------------------------------------------------------------------

// DerivativeMarketSettlementInfo

// string market_id = 1 [json_name = "marketId"];
inline void DerivativeMarketSettlementInfo::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativeMarketSettlementInfo::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketSettlementInfo::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.market_id)
}
inline std::string* DerivativeMarketSettlementInfo::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.market_id)
  return _s;
}
inline const std::string& DerivativeMarketSettlementInfo::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativeMarketSettlementInfo::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketSettlementInfo::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketSettlementInfo::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativeMarketSettlementInfo::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.market_id)
}

// string settlement_price = 2 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketSettlementInfo::clear_settlement_price() {
  _impl_.settlement_price_.ClearToEmpty();
}
inline const std::string& DerivativeMarketSettlementInfo::settlement_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.settlement_price)
  return _internal_settlement_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketSettlementInfo::set_settlement_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settlement_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.settlement_price)
}
inline std::string* DerivativeMarketSettlementInfo::mutable_settlement_price() {
  std::string* _s = _internal_mutable_settlement_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.settlement_price)
  return _s;
}
inline const std::string& DerivativeMarketSettlementInfo::_internal_settlement_price() const {
  return _impl_.settlement_price_.Get();
}
inline void DerivativeMarketSettlementInfo::_internal_set_settlement_price(const std::string& value) {
  ;


  _impl_.settlement_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketSettlementInfo::_internal_mutable_settlement_price() {
  ;
  return _impl_.settlement_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketSettlementInfo::release_settlement_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.settlement_price)
  return _impl_.settlement_price_.Release();
}
inline void DerivativeMarketSettlementInfo::set_allocated_settlement_price(std::string* value) {
  _impl_.settlement_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlement_price_.IsDefault()) {
          _impl_.settlement_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketSettlementInfo.settlement_price)
}

// -------------------------------------------------------------------

// NextFundingTimestamp

// int64 next_timestamp = 1 [json_name = "nextTimestamp"];
inline void NextFundingTimestamp::clear_next_timestamp() {
  _impl_.next_timestamp_ = ::int64_t{0};
}
inline ::int64_t NextFundingTimestamp::next_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.NextFundingTimestamp.next_timestamp)
  return _internal_next_timestamp();
}
inline void NextFundingTimestamp::set_next_timestamp(::int64_t value) {
  _internal_set_next_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.NextFundingTimestamp.next_timestamp)
}
inline ::int64_t NextFundingTimestamp::_internal_next_timestamp() const {
  return _impl_.next_timestamp_;
}
inline void NextFundingTimestamp::_internal_set_next_timestamp(::int64_t value) {
  ;
  _impl_.next_timestamp_ = value;
}

// -------------------------------------------------------------------

// MidPriceAndTOB

// string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MidPriceAndTOB::clear_mid_price() {
  _impl_.mid_price_.ClearToEmpty();
}
inline const std::string& MidPriceAndTOB::mid_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MidPriceAndTOB.mid_price)
  return _internal_mid_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MidPriceAndTOB::set_mid_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mid_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MidPriceAndTOB.mid_price)
}
inline std::string* MidPriceAndTOB::mutable_mid_price() {
  std::string* _s = _internal_mutable_mid_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MidPriceAndTOB.mid_price)
  return _s;
}
inline const std::string& MidPriceAndTOB::_internal_mid_price() const {
  return _impl_.mid_price_.Get();
}
inline void MidPriceAndTOB::_internal_set_mid_price(const std::string& value) {
  ;


  _impl_.mid_price_.Set(value, GetArenaForAllocation());
}
inline std::string* MidPriceAndTOB::_internal_mutable_mid_price() {
  ;
  return _impl_.mid_price_.Mutable( GetArenaForAllocation());
}
inline std::string* MidPriceAndTOB::release_mid_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MidPriceAndTOB.mid_price)
  return _impl_.mid_price_.Release();
}
inline void MidPriceAndTOB::set_allocated_mid_price(std::string* value) {
  _impl_.mid_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mid_price_.IsDefault()) {
          _impl_.mid_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MidPriceAndTOB.mid_price)
}

// string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MidPriceAndTOB::clear_best_buy_price() {
  _impl_.best_buy_price_.ClearToEmpty();
}
inline const std::string& MidPriceAndTOB::best_buy_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MidPriceAndTOB.best_buy_price)
  return _internal_best_buy_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MidPriceAndTOB::set_best_buy_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.best_buy_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MidPriceAndTOB.best_buy_price)
}
inline std::string* MidPriceAndTOB::mutable_best_buy_price() {
  std::string* _s = _internal_mutable_best_buy_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MidPriceAndTOB.best_buy_price)
  return _s;
}
inline const std::string& MidPriceAndTOB::_internal_best_buy_price() const {
  return _impl_.best_buy_price_.Get();
}
inline void MidPriceAndTOB::_internal_set_best_buy_price(const std::string& value) {
  ;


  _impl_.best_buy_price_.Set(value, GetArenaForAllocation());
}
inline std::string* MidPriceAndTOB::_internal_mutable_best_buy_price() {
  ;
  return _impl_.best_buy_price_.Mutable( GetArenaForAllocation());
}
inline std::string* MidPriceAndTOB::release_best_buy_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MidPriceAndTOB.best_buy_price)
  return _impl_.best_buy_price_.Release();
}
inline void MidPriceAndTOB::set_allocated_best_buy_price(std::string* value) {
  _impl_.best_buy_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.best_buy_price_.IsDefault()) {
          _impl_.best_buy_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MidPriceAndTOB.best_buy_price)
}

// string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MidPriceAndTOB::clear_best_sell_price() {
  _impl_.best_sell_price_.ClearToEmpty();
}
inline const std::string& MidPriceAndTOB::best_sell_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MidPriceAndTOB.best_sell_price)
  return _internal_best_sell_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MidPriceAndTOB::set_best_sell_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.best_sell_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MidPriceAndTOB.best_sell_price)
}
inline std::string* MidPriceAndTOB::mutable_best_sell_price() {
  std::string* _s = _internal_mutable_best_sell_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MidPriceAndTOB.best_sell_price)
  return _s;
}
inline const std::string& MidPriceAndTOB::_internal_best_sell_price() const {
  return _impl_.best_sell_price_.Get();
}
inline void MidPriceAndTOB::_internal_set_best_sell_price(const std::string& value) {
  ;


  _impl_.best_sell_price_.Set(value, GetArenaForAllocation());
}
inline std::string* MidPriceAndTOB::_internal_mutable_best_sell_price() {
  ;
  return _impl_.best_sell_price_.Mutable( GetArenaForAllocation());
}
inline std::string* MidPriceAndTOB::release_best_sell_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MidPriceAndTOB.best_sell_price)
  return _impl_.best_sell_price_.Release();
}
inline void MidPriceAndTOB::set_allocated_best_sell_price(std::string* value) {
  _impl_.best_sell_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.best_sell_price_.IsDefault()) {
          _impl_.best_sell_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MidPriceAndTOB.best_sell_price)
}

// -------------------------------------------------------------------

// SpotMarket

// string ticker = 1 [json_name = "ticker"];
inline void SpotMarket::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& SpotMarket::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.ticker)
}
inline std::string* SpotMarket::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.ticker)
  return _s;
}
inline const std::string& SpotMarket::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void SpotMarket::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.ticker)
  return _impl_.ticker_.Release();
}
inline void SpotMarket::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.ticker)
}

// string base_denom = 2 [json_name = "baseDenom"];
inline void SpotMarket::clear_base_denom() {
  _impl_.base_denom_.ClearToEmpty();
}
inline const std::string& SpotMarket::base_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.base_denom)
  return _internal_base_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_base_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.base_denom)
}
inline std::string* SpotMarket::mutable_base_denom() {
  std::string* _s = _internal_mutable_base_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.base_denom)
  return _s;
}
inline const std::string& SpotMarket::_internal_base_denom() const {
  return _impl_.base_denom_.Get();
}
inline void SpotMarket::_internal_set_base_denom(const std::string& value) {
  ;


  _impl_.base_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_base_denom() {
  ;
  return _impl_.base_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_base_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.base_denom)
  return _impl_.base_denom_.Release();
}
inline void SpotMarket::set_allocated_base_denom(std::string* value) {
  _impl_.base_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_denom_.IsDefault()) {
          _impl_.base_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.base_denom)
}

// string quote_denom = 3 [json_name = "quoteDenom"];
inline void SpotMarket::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& SpotMarket::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.quote_denom)
}
inline std::string* SpotMarket::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.quote_denom)
  return _s;
}
inline const std::string& SpotMarket::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void SpotMarket::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void SpotMarket::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.quote_denom)
}

// string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarket::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& SpotMarket::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.maker_fee_rate)
}
inline std::string* SpotMarket::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.maker_fee_rate)
  return _s;
}
inline const std::string& SpotMarket::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void SpotMarket::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void SpotMarket::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.maker_fee_rate)
}

// string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarket::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& SpotMarket::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.taker_fee_rate)
}
inline std::string* SpotMarket::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.taker_fee_rate)
  return _s;
}
inline const std::string& SpotMarket::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void SpotMarket::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void SpotMarket::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.taker_fee_rate)
}

// string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarket::clear_relayer_fee_share_rate() {
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
}
inline const std::string& SpotMarket::relayer_fee_share_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.relayer_fee_share_rate)
  return _internal_relayer_fee_share_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_relayer_fee_share_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_fee_share_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.relayer_fee_share_rate)
}
inline std::string* SpotMarket::mutable_relayer_fee_share_rate() {
  std::string* _s = _internal_mutable_relayer_fee_share_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.relayer_fee_share_rate)
  return _s;
}
inline const std::string& SpotMarket::_internal_relayer_fee_share_rate() const {
  return _impl_.relayer_fee_share_rate_.Get();
}
inline void SpotMarket::_internal_set_relayer_fee_share_rate(const std::string& value) {
  ;


  _impl_.relayer_fee_share_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_relayer_fee_share_rate() {
  ;
  return _impl_.relayer_fee_share_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_relayer_fee_share_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.relayer_fee_share_rate)
  return _impl_.relayer_fee_share_rate_.Release();
}
inline void SpotMarket::set_allocated_relayer_fee_share_rate(std::string* value) {
  _impl_.relayer_fee_share_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_fee_share_rate_.IsDefault()) {
          _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.relayer_fee_share_rate)
}

// string market_id = 7 [json_name = "marketId"];
inline void SpotMarket::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SpotMarket::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.market_id)
}
inline std::string* SpotMarket::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.market_id)
  return _s;
}
inline const std::string& SpotMarket::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SpotMarket::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.market_id)
  return _impl_.market_id_.Release();
}
inline void SpotMarket::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.market_id)
}

// .injective.exchange.v1beta1.MarketStatus status = 8 [json_name = "status"];
inline void SpotMarket::clear_status() {
  _impl_.status_ = 0;
}
inline ::injective::exchange::v1beta1::MarketStatus SpotMarket::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.status)
  return _internal_status();
}
inline void SpotMarket::set_status(::injective::exchange::v1beta1::MarketStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.status)
}
inline ::injective::exchange::v1beta1::MarketStatus SpotMarket::_internal_status() const {
  return static_cast<::injective::exchange::v1beta1::MarketStatus>(_impl_.status_);
}
inline void SpotMarket::_internal_set_status(::injective::exchange::v1beta1::MarketStatus value) {
  ;
  _impl_.status_ = value;
}

// string min_price_tick_size = 9 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarket::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& SpotMarket::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.min_price_tick_size)
}
inline std::string* SpotMarket::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.min_price_tick_size)
  return _s;
}
inline const std::string& SpotMarket::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void SpotMarket::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void SpotMarket::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.min_price_tick_size)
}

// string min_quantity_tick_size = 10 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarket::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& SpotMarket::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarket.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarket::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarket.min_quantity_tick_size)
}
inline std::string* SpotMarket::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarket.min_quantity_tick_size)
  return _s;
}
inline const std::string& SpotMarket::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void SpotMarket::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarket::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarket::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarket.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void SpotMarket::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarket.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// Deposit

// string available_balance = 1 [json_name = "availableBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Deposit::clear_available_balance() {
  _impl_.available_balance_.ClearToEmpty();
}
inline const std::string& Deposit::available_balance() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Deposit.available_balance)
  return _internal_available_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Deposit::set_available_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.available_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Deposit.available_balance)
}
inline std::string* Deposit::mutable_available_balance() {
  std::string* _s = _internal_mutable_available_balance();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Deposit.available_balance)
  return _s;
}
inline const std::string& Deposit::_internal_available_balance() const {
  return _impl_.available_balance_.Get();
}
inline void Deposit::_internal_set_available_balance(const std::string& value) {
  ;


  _impl_.available_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* Deposit::_internal_mutable_available_balance() {
  ;
  return _impl_.available_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* Deposit::release_available_balance() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Deposit.available_balance)
  return _impl_.available_balance_.Release();
}
inline void Deposit::set_allocated_available_balance(std::string* value) {
  _impl_.available_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.available_balance_.IsDefault()) {
          _impl_.available_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Deposit.available_balance)
}

// string total_balance = 2 [json_name = "totalBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Deposit::clear_total_balance() {
  _impl_.total_balance_.ClearToEmpty();
}
inline const std::string& Deposit::total_balance() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Deposit.total_balance)
  return _internal_total_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Deposit::set_total_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Deposit.total_balance)
}
inline std::string* Deposit::mutable_total_balance() {
  std::string* _s = _internal_mutable_total_balance();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Deposit.total_balance)
  return _s;
}
inline const std::string& Deposit::_internal_total_balance() const {
  return _impl_.total_balance_.Get();
}
inline void Deposit::_internal_set_total_balance(const std::string& value) {
  ;


  _impl_.total_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* Deposit::_internal_mutable_total_balance() {
  ;
  return _impl_.total_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* Deposit::release_total_balance() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Deposit.total_balance)
  return _impl_.total_balance_.Release();
}
inline void Deposit::set_allocated_total_balance(std::string* value) {
  _impl_.total_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_balance_.IsDefault()) {
          _impl_.total_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Deposit.total_balance)
}

// -------------------------------------------------------------------

// SubaccountTradeNonce

// uint32 nonce = 1 [json_name = "nonce"];
inline void SubaccountTradeNonce::clear_nonce() {
  _impl_.nonce_ = 0u;
}
inline ::uint32_t SubaccountTradeNonce::nonce() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountTradeNonce.nonce)
  return _internal_nonce();
}
inline void SubaccountTradeNonce::set_nonce(::uint32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountTradeNonce.nonce)
}
inline ::uint32_t SubaccountTradeNonce::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void SubaccountTradeNonce::_internal_set_nonce(::uint32_t value) {
  ;
  _impl_.nonce_ = value;
}

// -------------------------------------------------------------------

// OrderInfo

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void OrderInfo::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& OrderInfo::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderInfo.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderInfo::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderInfo.subaccount_id)
}
inline std::string* OrderInfo::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OrderInfo.subaccount_id)
  return _s;
}
inline const std::string& OrderInfo::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void OrderInfo::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderInfo::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OrderInfo.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void OrderInfo::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OrderInfo.subaccount_id)
}

// string fee_recipient = 2 [json_name = "feeRecipient"];
inline void OrderInfo::clear_fee_recipient() {
  _impl_.fee_recipient_.ClearToEmpty();
}
inline const std::string& OrderInfo::fee_recipient() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderInfo.fee_recipient)
  return _internal_fee_recipient();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderInfo::set_fee_recipient(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_recipient_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderInfo.fee_recipient)
}
inline std::string* OrderInfo::mutable_fee_recipient() {
  std::string* _s = _internal_mutable_fee_recipient();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OrderInfo.fee_recipient)
  return _s;
}
inline const std::string& OrderInfo::_internal_fee_recipient() const {
  return _impl_.fee_recipient_.Get();
}
inline void OrderInfo::_internal_set_fee_recipient(const std::string& value) {
  ;


  _impl_.fee_recipient_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_fee_recipient() {
  ;
  return _impl_.fee_recipient_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderInfo::release_fee_recipient() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OrderInfo.fee_recipient)
  return _impl_.fee_recipient_.Release();
}
inline void OrderInfo::set_allocated_fee_recipient(std::string* value) {
  _impl_.fee_recipient_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_recipient_.IsDefault()) {
          _impl_.fee_recipient_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OrderInfo.fee_recipient)
}

// string price = 3 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void OrderInfo::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& OrderInfo::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderInfo.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderInfo::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderInfo.price)
}
inline std::string* OrderInfo::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OrderInfo.price)
  return _s;
}
inline const std::string& OrderInfo::_internal_price() const {
  return _impl_.price_.Get();
}
inline void OrderInfo::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderInfo::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OrderInfo.price)
  return _impl_.price_.Release();
}
inline void OrderInfo::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OrderInfo.price)
}

// string quantity = 4 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void OrderInfo::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& OrderInfo::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderInfo.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderInfo::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderInfo.quantity)
}
inline std::string* OrderInfo::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OrderInfo.quantity)
  return _s;
}
inline const std::string& OrderInfo::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void OrderInfo::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderInfo::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OrderInfo.quantity)
  return _impl_.quantity_.Release();
}
inline void OrderInfo::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OrderInfo.quantity)
}

// -------------------------------------------------------------------

// SpotOrder

// string market_id = 1 [json_name = "marketId"];
inline void SpotOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SpotOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotOrder.market_id)
}
inline std::string* SpotOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotOrder.market_id)
  return _s;
}
inline const std::string& SpotOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SpotOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void SpotOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotOrder.market_id)
}

// .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
inline bool SpotOrder::has_order_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_info_ != nullptr);
  return value;
}
inline void SpotOrder::clear_order_info() {
  if (_impl_.order_info_ != nullptr) _impl_.order_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::OrderInfo& SpotOrder::_internal_order_info() const {
  const ::injective::exchange::v1beta1::OrderInfo* p = _impl_.order_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::OrderInfo&>(
      ::injective::exchange::v1beta1::_OrderInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::OrderInfo& SpotOrder::order_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotOrder.order_info)
  return _internal_order_info();
}
inline void SpotOrder::unsafe_arena_set_allocated_order_info(
    ::injective::exchange::v1beta1::OrderInfo* order_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_info_);
  }
  _impl_.order_info_ = order_info;
  if (order_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.SpotOrder.order_info)
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotOrder::release_order_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotOrder::unsafe_arena_release_order_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotOrder.order_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotOrder::_internal_mutable_order_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::OrderInfo>(GetArenaForAllocation());
    _impl_.order_info_ = p;
  }
  return _impl_.order_info_;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotOrder::mutable_order_info() {
  ::injective::exchange::v1beta1::OrderInfo* _msg = _internal_mutable_order_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotOrder.order_info)
  return _msg;
}
inline void SpotOrder::set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_info_;
  }
  if (order_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_info);
    if (message_arena != submessage_arena) {
      order_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_info_ = order_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotOrder.order_info)
}

// .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
inline void SpotOrder::clear_order_type() {
  _impl_.order_type_ = 0;
}
inline ::injective::exchange::v1beta1::OrderType SpotOrder::order_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotOrder.order_type)
  return _internal_order_type();
}
inline void SpotOrder::set_order_type(::injective::exchange::v1beta1::OrderType value) {
   _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotOrder.order_type)
}
inline ::injective::exchange::v1beta1::OrderType SpotOrder::_internal_order_type() const {
  return static_cast<::injective::exchange::v1beta1::OrderType>(_impl_.order_type_);
}
inline void SpotOrder::_internal_set_order_type(::injective::exchange::v1beta1::OrderType value) {
  ;
  _impl_.order_type_ = value;
}

// string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotOrder::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& SpotOrder::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotOrder.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrder::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotOrder.trigger_price)
}
inline std::string* SpotOrder::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotOrder.trigger_price)
  return _s;
}
inline const std::string& SpotOrder::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void SpotOrder::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrder::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrder::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotOrder.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void SpotOrder::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotOrder.trigger_price)
}

// -------------------------------------------------------------------

// SpotLimitOrder

// .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
inline bool SpotLimitOrder::has_order_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_info_ != nullptr);
  return value;
}
inline void SpotLimitOrder::clear_order_info() {
  if (_impl_.order_info_ != nullptr) _impl_.order_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::OrderInfo& SpotLimitOrder::_internal_order_info() const {
  const ::injective::exchange::v1beta1::OrderInfo* p = _impl_.order_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::OrderInfo&>(
      ::injective::exchange::v1beta1::_OrderInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::OrderInfo& SpotLimitOrder::order_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotLimitOrder.order_info)
  return _internal_order_info();
}
inline void SpotLimitOrder::unsafe_arena_set_allocated_order_info(
    ::injective::exchange::v1beta1::OrderInfo* order_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_info_);
  }
  _impl_.order_info_ = order_info;
  if (order_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.SpotLimitOrder.order_info)
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotLimitOrder::release_order_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotLimitOrder::unsafe_arena_release_order_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotLimitOrder.order_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotLimitOrder::_internal_mutable_order_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::OrderInfo>(GetArenaForAllocation());
    _impl_.order_info_ = p;
  }
  return _impl_.order_info_;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotLimitOrder::mutable_order_info() {
  ::injective::exchange::v1beta1::OrderInfo* _msg = _internal_mutable_order_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotLimitOrder.order_info)
  return _msg;
}
inline void SpotLimitOrder::set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_info_;
  }
  if (order_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_info);
    if (message_arena != submessage_arena) {
      order_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_info_ = order_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotLimitOrder.order_info)
}

// .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
inline void SpotLimitOrder::clear_order_type() {
  _impl_.order_type_ = 0;
}
inline ::injective::exchange::v1beta1::OrderType SpotLimitOrder::order_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotLimitOrder.order_type)
  return _internal_order_type();
}
inline void SpotLimitOrder::set_order_type(::injective::exchange::v1beta1::OrderType value) {
   _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotLimitOrder.order_type)
}
inline ::injective::exchange::v1beta1::OrderType SpotLimitOrder::_internal_order_type() const {
  return static_cast<::injective::exchange::v1beta1::OrderType>(_impl_.order_type_);
}
inline void SpotLimitOrder::_internal_set_order_type(::injective::exchange::v1beta1::OrderType value) {
  ;
  _impl_.order_type_ = value;
}

// string fillable = 3 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotLimitOrder::clear_fillable() {
  _impl_.fillable_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::fillable() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotLimitOrder.fillable)
  return _internal_fillable();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_fillable(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fillable_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotLimitOrder.fillable)
}
inline std::string* SpotLimitOrder::mutable_fillable() {
  std::string* _s = _internal_mutable_fillable();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotLimitOrder.fillable)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_fillable() const {
  return _impl_.fillable_.Get();
}
inline void SpotLimitOrder::_internal_set_fillable(const std::string& value) {
  ;


  _impl_.fillable_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_fillable() {
  ;
  return _impl_.fillable_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_fillable() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotLimitOrder.fillable)
  return _impl_.fillable_.Release();
}
inline void SpotLimitOrder::set_allocated_fillable(std::string* value) {
  _impl_.fillable_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fillable_.IsDefault()) {
          _impl_.fillable_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotLimitOrder.fillable)
}

// string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotLimitOrder::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotLimitOrder.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotLimitOrder.trigger_price)
}
inline std::string* SpotLimitOrder::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotLimitOrder.trigger_price)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void SpotLimitOrder::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotLimitOrder.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void SpotLimitOrder::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotLimitOrder.trigger_price)
}

// bytes order_hash = 5 [json_name = "orderHash"];
inline void SpotLimitOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotLimitOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotLimitOrder.order_hash)
}
inline std::string* SpotLimitOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotLimitOrder.order_hash)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void SpotLimitOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotLimitOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void SpotLimitOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotLimitOrder.order_hash)
}

// -------------------------------------------------------------------

// SpotMarketOrder

// .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
inline bool SpotMarketOrder::has_order_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_info_ != nullptr);
  return value;
}
inline void SpotMarketOrder::clear_order_info() {
  if (_impl_.order_info_ != nullptr) _impl_.order_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::OrderInfo& SpotMarketOrder::_internal_order_info() const {
  const ::injective::exchange::v1beta1::OrderInfo* p = _impl_.order_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::OrderInfo&>(
      ::injective::exchange::v1beta1::_OrderInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::OrderInfo& SpotMarketOrder::order_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketOrder.order_info)
  return _internal_order_info();
}
inline void SpotMarketOrder::unsafe_arena_set_allocated_order_info(
    ::injective::exchange::v1beta1::OrderInfo* order_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_info_);
  }
  _impl_.order_info_ = order_info;
  if (order_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.SpotMarketOrder.order_info)
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotMarketOrder::release_order_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotMarketOrder::unsafe_arena_release_order_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketOrder.order_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotMarketOrder::_internal_mutable_order_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::OrderInfo>(GetArenaForAllocation());
    _impl_.order_info_ = p;
  }
  return _impl_.order_info_;
}
inline ::injective::exchange::v1beta1::OrderInfo* SpotMarketOrder::mutable_order_info() {
  ::injective::exchange::v1beta1::OrderInfo* _msg = _internal_mutable_order_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketOrder.order_info)
  return _msg;
}
inline void SpotMarketOrder::set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_info_;
  }
  if (order_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_info);
    if (message_arena != submessage_arena) {
      order_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_info_ = order_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketOrder.order_info)
}

// string balance_hold = 2 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketOrder::clear_balance_hold() {
  _impl_.balance_hold_.ClearToEmpty();
}
inline const std::string& SpotMarketOrder::balance_hold() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketOrder.balance_hold)
  return _internal_balance_hold();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketOrder::set_balance_hold(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.balance_hold_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketOrder.balance_hold)
}
inline std::string* SpotMarketOrder::mutable_balance_hold() {
  std::string* _s = _internal_mutable_balance_hold();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketOrder.balance_hold)
  return _s;
}
inline const std::string& SpotMarketOrder::_internal_balance_hold() const {
  return _impl_.balance_hold_.Get();
}
inline void SpotMarketOrder::_internal_set_balance_hold(const std::string& value) {
  ;


  _impl_.balance_hold_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketOrder::_internal_mutable_balance_hold() {
  ;
  return _impl_.balance_hold_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketOrder::release_balance_hold() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketOrder.balance_hold)
  return _impl_.balance_hold_.Release();
}
inline void SpotMarketOrder::set_allocated_balance_hold(std::string* value) {
  _impl_.balance_hold_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_hold_.IsDefault()) {
          _impl_.balance_hold_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketOrder.balance_hold)
}

// bytes order_hash = 3 [json_name = "orderHash"];
inline void SpotMarketOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& SpotMarketOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketOrder.order_hash)
}
inline std::string* SpotMarketOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketOrder.order_hash)
  return _s;
}
inline const std::string& SpotMarketOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void SpotMarketOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void SpotMarketOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketOrder.order_hash)
}

// .injective.exchange.v1beta1.OrderType order_type = 4 [json_name = "orderType"];
inline void SpotMarketOrder::clear_order_type() {
  _impl_.order_type_ = 0;
}
inline ::injective::exchange::v1beta1::OrderType SpotMarketOrder::order_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketOrder.order_type)
  return _internal_order_type();
}
inline void SpotMarketOrder::set_order_type(::injective::exchange::v1beta1::OrderType value) {
   _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketOrder.order_type)
}
inline ::injective::exchange::v1beta1::OrderType SpotMarketOrder::_internal_order_type() const {
  return static_cast<::injective::exchange::v1beta1::OrderType>(_impl_.order_type_);
}
inline void SpotMarketOrder::_internal_set_order_type(::injective::exchange::v1beta1::OrderType value) {
  ;
  _impl_.order_type_ = value;
}

// string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketOrder::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& SpotMarketOrder::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketOrder.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketOrder::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketOrder.trigger_price)
}
inline std::string* SpotMarketOrder::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketOrder.trigger_price)
  return _s;
}
inline const std::string& SpotMarketOrder::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void SpotMarketOrder::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketOrder::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketOrder::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketOrder.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void SpotMarketOrder::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketOrder.trigger_price)
}

// -------------------------------------------------------------------

// DerivativeOrder

// string market_id = 1 [json_name = "marketId"];
inline void DerivativeOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativeOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeOrder.market_id)
}
inline std::string* DerivativeOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeOrder.market_id)
  return _s;
}
inline const std::string& DerivativeOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativeOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativeOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeOrder.market_id)
}

// .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
inline bool DerivativeOrder::has_order_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_info_ != nullptr);
  return value;
}
inline void DerivativeOrder::clear_order_info() {
  if (_impl_.order_info_ != nullptr) _impl_.order_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::OrderInfo& DerivativeOrder::_internal_order_info() const {
  const ::injective::exchange::v1beta1::OrderInfo* p = _impl_.order_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::OrderInfo&>(
      ::injective::exchange::v1beta1::_OrderInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::OrderInfo& DerivativeOrder::order_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeOrder.order_info)
  return _internal_order_info();
}
inline void DerivativeOrder::unsafe_arena_set_allocated_order_info(
    ::injective::exchange::v1beta1::OrderInfo* order_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_info_);
  }
  _impl_.order_info_ = order_info;
  if (order_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.DerivativeOrder.order_info)
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeOrder::release_order_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeOrder::unsafe_arena_release_order_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeOrder.order_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeOrder::_internal_mutable_order_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::OrderInfo>(GetArenaForAllocation());
    _impl_.order_info_ = p;
  }
  return _impl_.order_info_;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeOrder::mutable_order_info() {
  ::injective::exchange::v1beta1::OrderInfo* _msg = _internal_mutable_order_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeOrder.order_info)
  return _msg;
}
inline void DerivativeOrder::set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_info_;
  }
  if (order_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_info);
    if (message_arena != submessage_arena) {
      order_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_info_ = order_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeOrder.order_info)
}

// .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
inline void DerivativeOrder::clear_order_type() {
  _impl_.order_type_ = 0;
}
inline ::injective::exchange::v1beta1::OrderType DerivativeOrder::order_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeOrder.order_type)
  return _internal_order_type();
}
inline void DerivativeOrder::set_order_type(::injective::exchange::v1beta1::OrderType value) {
   _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeOrder.order_type)
}
inline ::injective::exchange::v1beta1::OrderType DerivativeOrder::_internal_order_type() const {
  return static_cast<::injective::exchange::v1beta1::OrderType>(_impl_.order_type_);
}
inline void DerivativeOrder::_internal_set_order_type(::injective::exchange::v1beta1::OrderType value) {
  ;
  _impl_.order_type_ = value;
}

// string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeOrder::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& DerivativeOrder::margin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeOrder.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrder::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeOrder.margin)
}
inline std::string* DerivativeOrder::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeOrder.margin)
  return _s;
}
inline const std::string& DerivativeOrder::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void DerivativeOrder::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrder::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrder::release_margin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeOrder.margin)
  return _impl_.margin_.Release();
}
inline void DerivativeOrder::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeOrder.margin)
}

// string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeOrder::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& DerivativeOrder::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeOrder.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrder::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeOrder.trigger_price)
}
inline std::string* DerivativeOrder::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeOrder.trigger_price)
  return _s;
}
inline const std::string& DerivativeOrder::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void DerivativeOrder::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrder::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrder::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeOrder.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void DerivativeOrder::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeOrder.trigger_price)
}

// -------------------------------------------------------------------

// SubaccountOrderbookMetadata

// uint32 vanilla_limit_order_count = 1 [json_name = "vanillaLimitOrderCount"];
inline void SubaccountOrderbookMetadata::clear_vanilla_limit_order_count() {
  _impl_.vanilla_limit_order_count_ = 0u;
}
inline ::uint32_t SubaccountOrderbookMetadata::vanilla_limit_order_count() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadata.vanilla_limit_order_count)
  return _internal_vanilla_limit_order_count();
}
inline void SubaccountOrderbookMetadata::set_vanilla_limit_order_count(::uint32_t value) {
  _internal_set_vanilla_limit_order_count(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderbookMetadata.vanilla_limit_order_count)
}
inline ::uint32_t SubaccountOrderbookMetadata::_internal_vanilla_limit_order_count() const {
  return _impl_.vanilla_limit_order_count_;
}
inline void SubaccountOrderbookMetadata::_internal_set_vanilla_limit_order_count(::uint32_t value) {
  ;
  _impl_.vanilla_limit_order_count_ = value;
}

// uint32 reduce_only_limit_order_count = 2 [json_name = "reduceOnlyLimitOrderCount"];
inline void SubaccountOrderbookMetadata::clear_reduce_only_limit_order_count() {
  _impl_.reduce_only_limit_order_count_ = 0u;
}
inline ::uint32_t SubaccountOrderbookMetadata::reduce_only_limit_order_count() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadata.reduce_only_limit_order_count)
  return _internal_reduce_only_limit_order_count();
}
inline void SubaccountOrderbookMetadata::set_reduce_only_limit_order_count(::uint32_t value) {
  _internal_set_reduce_only_limit_order_count(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderbookMetadata.reduce_only_limit_order_count)
}
inline ::uint32_t SubaccountOrderbookMetadata::_internal_reduce_only_limit_order_count() const {
  return _impl_.reduce_only_limit_order_count_;
}
inline void SubaccountOrderbookMetadata::_internal_set_reduce_only_limit_order_count(::uint32_t value) {
  ;
  _impl_.reduce_only_limit_order_count_ = value;
}

// string aggregate_reduce_only_quantity = 3 [json_name = "aggregateReduceOnlyQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SubaccountOrderbookMetadata::clear_aggregate_reduce_only_quantity() {
  _impl_.aggregate_reduce_only_quantity_.ClearToEmpty();
}
inline const std::string& SubaccountOrderbookMetadata::aggregate_reduce_only_quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_reduce_only_quantity)
  return _internal_aggregate_reduce_only_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrderbookMetadata::set_aggregate_reduce_only_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.aggregate_reduce_only_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_reduce_only_quantity)
}
inline std::string* SubaccountOrderbookMetadata::mutable_aggregate_reduce_only_quantity() {
  std::string* _s = _internal_mutable_aggregate_reduce_only_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_reduce_only_quantity)
  return _s;
}
inline const std::string& SubaccountOrderbookMetadata::_internal_aggregate_reduce_only_quantity() const {
  return _impl_.aggregate_reduce_only_quantity_.Get();
}
inline void SubaccountOrderbookMetadata::_internal_set_aggregate_reduce_only_quantity(const std::string& value) {
  ;


  _impl_.aggregate_reduce_only_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrderbookMetadata::_internal_mutable_aggregate_reduce_only_quantity() {
  ;
  return _impl_.aggregate_reduce_only_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrderbookMetadata::release_aggregate_reduce_only_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_reduce_only_quantity)
  return _impl_.aggregate_reduce_only_quantity_.Release();
}
inline void SubaccountOrderbookMetadata::set_allocated_aggregate_reduce_only_quantity(std::string* value) {
  _impl_.aggregate_reduce_only_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aggregate_reduce_only_quantity_.IsDefault()) {
          _impl_.aggregate_reduce_only_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_reduce_only_quantity)
}

// string aggregate_vanilla_quantity = 4 [json_name = "aggregateVanillaQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SubaccountOrderbookMetadata::clear_aggregate_vanilla_quantity() {
  _impl_.aggregate_vanilla_quantity_.ClearToEmpty();
}
inline const std::string& SubaccountOrderbookMetadata::aggregate_vanilla_quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_vanilla_quantity)
  return _internal_aggregate_vanilla_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrderbookMetadata::set_aggregate_vanilla_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.aggregate_vanilla_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_vanilla_quantity)
}
inline std::string* SubaccountOrderbookMetadata::mutable_aggregate_vanilla_quantity() {
  std::string* _s = _internal_mutable_aggregate_vanilla_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_vanilla_quantity)
  return _s;
}
inline const std::string& SubaccountOrderbookMetadata::_internal_aggregate_vanilla_quantity() const {
  return _impl_.aggregate_vanilla_quantity_.Get();
}
inline void SubaccountOrderbookMetadata::_internal_set_aggregate_vanilla_quantity(const std::string& value) {
  ;


  _impl_.aggregate_vanilla_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrderbookMetadata::_internal_mutable_aggregate_vanilla_quantity() {
  ;
  return _impl_.aggregate_vanilla_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrderbookMetadata::release_aggregate_vanilla_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_vanilla_quantity)
  return _impl_.aggregate_vanilla_quantity_.Release();
}
inline void SubaccountOrderbookMetadata::set_allocated_aggregate_vanilla_quantity(std::string* value) {
  _impl_.aggregate_vanilla_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aggregate_vanilla_quantity_.IsDefault()) {
          _impl_.aggregate_vanilla_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_vanilla_quantity)
}

// uint32 vanilla_conditional_order_count = 5 [json_name = "vanillaConditionalOrderCount"];
inline void SubaccountOrderbookMetadata::clear_vanilla_conditional_order_count() {
  _impl_.vanilla_conditional_order_count_ = 0u;
}
inline ::uint32_t SubaccountOrderbookMetadata::vanilla_conditional_order_count() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadata.vanilla_conditional_order_count)
  return _internal_vanilla_conditional_order_count();
}
inline void SubaccountOrderbookMetadata::set_vanilla_conditional_order_count(::uint32_t value) {
  _internal_set_vanilla_conditional_order_count(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderbookMetadata.vanilla_conditional_order_count)
}
inline ::uint32_t SubaccountOrderbookMetadata::_internal_vanilla_conditional_order_count() const {
  return _impl_.vanilla_conditional_order_count_;
}
inline void SubaccountOrderbookMetadata::_internal_set_vanilla_conditional_order_count(::uint32_t value) {
  ;
  _impl_.vanilla_conditional_order_count_ = value;
}

// uint32 reduce_only_conditional_order_count = 6 [json_name = "reduceOnlyConditionalOrderCount"];
inline void SubaccountOrderbookMetadata::clear_reduce_only_conditional_order_count() {
  _impl_.reduce_only_conditional_order_count_ = 0u;
}
inline ::uint32_t SubaccountOrderbookMetadata::reduce_only_conditional_order_count() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadata.reduce_only_conditional_order_count)
  return _internal_reduce_only_conditional_order_count();
}
inline void SubaccountOrderbookMetadata::set_reduce_only_conditional_order_count(::uint32_t value) {
  _internal_set_reduce_only_conditional_order_count(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderbookMetadata.reduce_only_conditional_order_count)
}
inline ::uint32_t SubaccountOrderbookMetadata::_internal_reduce_only_conditional_order_count() const {
  return _impl_.reduce_only_conditional_order_count_;
}
inline void SubaccountOrderbookMetadata::_internal_set_reduce_only_conditional_order_count(::uint32_t value) {
  ;
  _impl_.reduce_only_conditional_order_count_ = value;
}

// -------------------------------------------------------------------

// SubaccountOrder

// string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SubaccountOrder::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& SubaccountOrder::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrder.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrder::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrder.price)
}
inline std::string* SubaccountOrder::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountOrder.price)
  return _s;
}
inline const std::string& SubaccountOrder::_internal_price() const {
  return _impl_.price_.Get();
}
inline void SubaccountOrder::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrder::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrder::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountOrder.price)
  return _impl_.price_.Release();
}
inline void SubaccountOrder::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountOrder.price)
}

// string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SubaccountOrder::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& SubaccountOrder::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrder.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrder::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrder.quantity)
}
inline std::string* SubaccountOrder::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountOrder.quantity)
  return _s;
}
inline const std::string& SubaccountOrder::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void SubaccountOrder::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrder::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrder::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountOrder.quantity)
  return _impl_.quantity_.Release();
}
inline void SubaccountOrder::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountOrder.quantity)
}

// bool isReduceOnly = 3 [json_name = "isReduceOnly"];
inline void SubaccountOrder::clear_isreduceonly() {
  _impl_.isreduceonly_ = false;
}
inline bool SubaccountOrder::isreduceonly() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrder.isReduceOnly)
  return _internal_isreduceonly();
}
inline void SubaccountOrder::set_isreduceonly(bool value) {
  _internal_set_isreduceonly(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrder.isReduceOnly)
}
inline bool SubaccountOrder::_internal_isreduceonly() const {
  return _impl_.isreduceonly_;
}
inline void SubaccountOrder::_internal_set_isreduceonly(bool value) {
  ;
  _impl_.isreduceonly_ = value;
}

// -------------------------------------------------------------------

// SubaccountOrderData

// .injective.exchange.v1beta1.SubaccountOrder order = 1 [json_name = "order"];
inline bool SubaccountOrderData::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline void SubaccountOrderData::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::SubaccountOrder& SubaccountOrderData::_internal_order() const {
  const ::injective::exchange::v1beta1::SubaccountOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SubaccountOrder&>(
      ::injective::exchange::v1beta1::_SubaccountOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::SubaccountOrder& SubaccountOrderData::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderData.order)
  return _internal_order();
}
inline void SubaccountOrderData::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::SubaccountOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.SubaccountOrderData.order)
}
inline ::injective::exchange::v1beta1::SubaccountOrder* SubaccountOrderData::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SubaccountOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SubaccountOrder* SubaccountOrderData::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountOrderData.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SubaccountOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SubaccountOrder* SubaccountOrderData::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::SubaccountOrder* SubaccountOrderData::mutable_order() {
  ::injective::exchange::v1beta1::SubaccountOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountOrderData.order)
  return _msg;
}
inline void SubaccountOrderData::set_allocated_order(::injective::exchange::v1beta1::SubaccountOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountOrderData.order)
}

// bytes order_hash = 2 [json_name = "orderHash"];
inline void SubaccountOrderData::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& SubaccountOrderData::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderData.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrderData::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderData.order_hash)
}
inline std::string* SubaccountOrderData::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountOrderData.order_hash)
  return _s;
}
inline const std::string& SubaccountOrderData::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void SubaccountOrderData::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrderData::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrderData::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountOrderData.order_hash)
  return _impl_.order_hash_.Release();
}
inline void SubaccountOrderData::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountOrderData.order_hash)
}

// -------------------------------------------------------------------

// DerivativeLimitOrder

// .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
inline bool DerivativeLimitOrder::has_order_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_info_ != nullptr);
  return value;
}
inline void DerivativeLimitOrder::clear_order_info() {
  if (_impl_.order_info_ != nullptr) _impl_.order_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::OrderInfo& DerivativeLimitOrder::_internal_order_info() const {
  const ::injective::exchange::v1beta1::OrderInfo* p = _impl_.order_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::OrderInfo&>(
      ::injective::exchange::v1beta1::_OrderInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::OrderInfo& DerivativeLimitOrder::order_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeLimitOrder.order_info)
  return _internal_order_info();
}
inline void DerivativeLimitOrder::unsafe_arena_set_allocated_order_info(
    ::injective::exchange::v1beta1::OrderInfo* order_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_info_);
  }
  _impl_.order_info_ = order_info;
  if (order_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.DerivativeLimitOrder.order_info)
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeLimitOrder::release_order_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeLimitOrder::unsafe_arena_release_order_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeLimitOrder.order_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeLimitOrder::_internal_mutable_order_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::OrderInfo>(GetArenaForAllocation());
    _impl_.order_info_ = p;
  }
  return _impl_.order_info_;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeLimitOrder::mutable_order_info() {
  ::injective::exchange::v1beta1::OrderInfo* _msg = _internal_mutable_order_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeLimitOrder.order_info)
  return _msg;
}
inline void DerivativeLimitOrder::set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_info_;
  }
  if (order_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_info);
    if (message_arena != submessage_arena) {
      order_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_info_ = order_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeLimitOrder.order_info)
}

// .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
inline void DerivativeLimitOrder::clear_order_type() {
  _impl_.order_type_ = 0;
}
inline ::injective::exchange::v1beta1::OrderType DerivativeLimitOrder::order_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeLimitOrder.order_type)
  return _internal_order_type();
}
inline void DerivativeLimitOrder::set_order_type(::injective::exchange::v1beta1::OrderType value) {
   _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeLimitOrder.order_type)
}
inline ::injective::exchange::v1beta1::OrderType DerivativeLimitOrder::_internal_order_type() const {
  return static_cast<::injective::exchange::v1beta1::OrderType>(_impl_.order_type_);
}
inline void DerivativeLimitOrder::_internal_set_order_type(::injective::exchange::v1beta1::OrderType value) {
  ;
  _impl_.order_type_ = value;
}

// string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeLimitOrder::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::margin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeLimitOrder.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeLimitOrder.margin)
}
inline std::string* DerivativeLimitOrder::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeLimitOrder.margin)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void DerivativeLimitOrder::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_margin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeLimitOrder.margin)
  return _impl_.margin_.Release();
}
inline void DerivativeLimitOrder::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeLimitOrder.margin)
}

// string fillable = 4 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeLimitOrder::clear_fillable() {
  _impl_.fillable_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::fillable() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeLimitOrder.fillable)
  return _internal_fillable();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_fillable(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fillable_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeLimitOrder.fillable)
}
inline std::string* DerivativeLimitOrder::mutable_fillable() {
  std::string* _s = _internal_mutable_fillable();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeLimitOrder.fillable)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_fillable() const {
  return _impl_.fillable_.Get();
}
inline void DerivativeLimitOrder::_internal_set_fillable(const std::string& value) {
  ;


  _impl_.fillable_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_fillable() {
  ;
  return _impl_.fillable_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_fillable() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeLimitOrder.fillable)
  return _impl_.fillable_.Release();
}
inline void DerivativeLimitOrder::set_allocated_fillable(std::string* value) {
  _impl_.fillable_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fillable_.IsDefault()) {
          _impl_.fillable_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeLimitOrder.fillable)
}

// string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeLimitOrder::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeLimitOrder.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeLimitOrder.trigger_price)
}
inline std::string* DerivativeLimitOrder::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeLimitOrder.trigger_price)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void DerivativeLimitOrder::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeLimitOrder.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void DerivativeLimitOrder::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeLimitOrder.trigger_price)
}

// bytes order_hash = 6 [json_name = "orderHash"];
inline void DerivativeLimitOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeLimitOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeLimitOrder.order_hash)
}
inline std::string* DerivativeLimitOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeLimitOrder.order_hash)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void DerivativeLimitOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeLimitOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void DerivativeLimitOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeLimitOrder.order_hash)
}

// -------------------------------------------------------------------

// DerivativeMarketOrder

// .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
inline bool DerivativeMarketOrder::has_order_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_info_ != nullptr);
  return value;
}
inline void DerivativeMarketOrder::clear_order_info() {
  if (_impl_.order_info_ != nullptr) _impl_.order_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::OrderInfo& DerivativeMarketOrder::_internal_order_info() const {
  const ::injective::exchange::v1beta1::OrderInfo* p = _impl_.order_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::OrderInfo&>(
      ::injective::exchange::v1beta1::_OrderInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::OrderInfo& DerivativeMarketOrder::order_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrder.order_info)
  return _internal_order_info();
}
inline void DerivativeMarketOrder::unsafe_arena_set_allocated_order_info(
    ::injective::exchange::v1beta1::OrderInfo* order_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_info_);
  }
  _impl_.order_info_ = order_info;
  if (order_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrder.order_info)
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeMarketOrder::release_order_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeMarketOrder::unsafe_arena_release_order_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrder.order_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OrderInfo* temp = _impl_.order_info_;
  _impl_.order_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeMarketOrder::_internal_mutable_order_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::OrderInfo>(GetArenaForAllocation());
    _impl_.order_info_ = p;
  }
  return _impl_.order_info_;
}
inline ::injective::exchange::v1beta1::OrderInfo* DerivativeMarketOrder::mutable_order_info() {
  ::injective::exchange::v1beta1::OrderInfo* _msg = _internal_mutable_order_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrder.order_info)
  return _msg;
}
inline void DerivativeMarketOrder::set_allocated_order_info(::injective::exchange::v1beta1::OrderInfo* order_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_info_;
  }
  if (order_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_info);
    if (message_arena != submessage_arena) {
      order_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_info_ = order_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrder.order_info)
}

// .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
inline void DerivativeMarketOrder::clear_order_type() {
  _impl_.order_type_ = 0;
}
inline ::injective::exchange::v1beta1::OrderType DerivativeMarketOrder::order_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrder.order_type)
  return _internal_order_type();
}
inline void DerivativeMarketOrder::set_order_type(::injective::exchange::v1beta1::OrderType value) {
   _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrder.order_type)
}
inline ::injective::exchange::v1beta1::OrderType DerivativeMarketOrder::_internal_order_type() const {
  return static_cast<::injective::exchange::v1beta1::OrderType>(_impl_.order_type_);
}
inline void DerivativeMarketOrder::_internal_set_order_type(::injective::exchange::v1beta1::OrderType value) {
  ;
  _impl_.order_type_ = value;
}

// string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketOrder::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrder::margin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrder.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrder::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrder.margin)
}
inline std::string* DerivativeMarketOrder::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrder.margin)
  return _s;
}
inline const std::string& DerivativeMarketOrder::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void DerivativeMarketOrder::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrder::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrder::release_margin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrder.margin)
  return _impl_.margin_.Release();
}
inline void DerivativeMarketOrder::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrder.margin)
}

// string margin_hold = 4 [json_name = "marginHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketOrder::clear_margin_hold() {
  _impl_.margin_hold_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrder::margin_hold() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrder.margin_hold)
  return _internal_margin_hold();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrder::set_margin_hold(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_hold_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrder.margin_hold)
}
inline std::string* DerivativeMarketOrder::mutable_margin_hold() {
  std::string* _s = _internal_mutable_margin_hold();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrder.margin_hold)
  return _s;
}
inline const std::string& DerivativeMarketOrder::_internal_margin_hold() const {
  return _impl_.margin_hold_.Get();
}
inline void DerivativeMarketOrder::_internal_set_margin_hold(const std::string& value) {
  ;


  _impl_.margin_hold_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrder::_internal_mutable_margin_hold() {
  ;
  return _impl_.margin_hold_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrder::release_margin_hold() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrder.margin_hold)
  return _impl_.margin_hold_.Release();
}
inline void DerivativeMarketOrder::set_allocated_margin_hold(std::string* value) {
  _impl_.margin_hold_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_hold_.IsDefault()) {
          _impl_.margin_hold_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrder.margin_hold)
}

// string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketOrder::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrder::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrder.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrder::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrder.trigger_price)
}
inline std::string* DerivativeMarketOrder::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrder.trigger_price)
  return _s;
}
inline const std::string& DerivativeMarketOrder::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void DerivativeMarketOrder::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrder::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrder::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrder.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void DerivativeMarketOrder::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrder.trigger_price)
}

// bytes order_hash = 6 [json_name = "orderHash"];
inline void DerivativeMarketOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrder.order_hash)
}
inline std::string* DerivativeMarketOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrder.order_hash)
  return _s;
}
inline const std::string& DerivativeMarketOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void DerivativeMarketOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void DerivativeMarketOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrder.order_hash)
}

// -------------------------------------------------------------------

// Position

// bool isLong = 1 [json_name = "isLong"];
inline void Position::clear_islong() {
  _impl_.islong_ = false;
}
inline bool Position::islong() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Position.isLong)
  return _internal_islong();
}
inline void Position::set_islong(bool value) {
  _internal_set_islong(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Position.isLong)
}
inline bool Position::_internal_islong() const {
  return _impl_.islong_;
}
inline void Position::_internal_set_islong(bool value) {
  ;
  _impl_.islong_ = value;
}

// string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Position::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& Position::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Position.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Position::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Position.quantity)
}
inline std::string* Position::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Position.quantity)
  return _s;
}
inline const std::string& Position::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void Position::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* Position::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Position.quantity)
  return _impl_.quantity_.Release();
}
inline void Position::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Position.quantity)
}

// string entry_price = 3 [json_name = "entryPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Position::clear_entry_price() {
  _impl_.entry_price_.ClearToEmpty();
}
inline const std::string& Position::entry_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Position.entry_price)
  return _internal_entry_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Position::set_entry_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.entry_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Position.entry_price)
}
inline std::string* Position::mutable_entry_price() {
  std::string* _s = _internal_mutable_entry_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Position.entry_price)
  return _s;
}
inline const std::string& Position::_internal_entry_price() const {
  return _impl_.entry_price_.Get();
}
inline void Position::_internal_set_entry_price(const std::string& value) {
  ;


  _impl_.entry_price_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_entry_price() {
  ;
  return _impl_.entry_price_.Mutable( GetArenaForAllocation());
}
inline std::string* Position::release_entry_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Position.entry_price)
  return _impl_.entry_price_.Release();
}
inline void Position::set_allocated_entry_price(std::string* value) {
  _impl_.entry_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entry_price_.IsDefault()) {
          _impl_.entry_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Position.entry_price)
}

// string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Position::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& Position::margin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Position.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Position::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Position.margin)
}
inline std::string* Position::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Position.margin)
  return _s;
}
inline const std::string& Position::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void Position::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* Position::release_margin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Position.margin)
  return _impl_.margin_.Release();
}
inline void Position::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Position.margin)
}

// string cumulative_funding_entry = 5 [json_name = "cumulativeFundingEntry", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Position::clear_cumulative_funding_entry() {
  _impl_.cumulative_funding_entry_.ClearToEmpty();
}
inline const std::string& Position::cumulative_funding_entry() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Position.cumulative_funding_entry)
  return _internal_cumulative_funding_entry();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Position::set_cumulative_funding_entry(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cumulative_funding_entry_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Position.cumulative_funding_entry)
}
inline std::string* Position::mutable_cumulative_funding_entry() {
  std::string* _s = _internal_mutable_cumulative_funding_entry();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Position.cumulative_funding_entry)
  return _s;
}
inline const std::string& Position::_internal_cumulative_funding_entry() const {
  return _impl_.cumulative_funding_entry_.Get();
}
inline void Position::_internal_set_cumulative_funding_entry(const std::string& value) {
  ;


  _impl_.cumulative_funding_entry_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_cumulative_funding_entry() {
  ;
  return _impl_.cumulative_funding_entry_.Mutable( GetArenaForAllocation());
}
inline std::string* Position::release_cumulative_funding_entry() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Position.cumulative_funding_entry)
  return _impl_.cumulative_funding_entry_.Release();
}
inline void Position::set_allocated_cumulative_funding_entry(std::string* value) {
  _impl_.cumulative_funding_entry_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cumulative_funding_entry_.IsDefault()) {
          _impl_.cumulative_funding_entry_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Position.cumulative_funding_entry)
}

// -------------------------------------------------------------------

// MarketOrderIndicator

// string market_id = 1 [json_name = "marketId"];
inline void MarketOrderIndicator::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MarketOrderIndicator::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketOrderIndicator.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketOrderIndicator::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketOrderIndicator.market_id)
}
inline std::string* MarketOrderIndicator::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketOrderIndicator.market_id)
  return _s;
}
inline const std::string& MarketOrderIndicator::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MarketOrderIndicator::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketOrderIndicator::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketOrderIndicator::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketOrderIndicator.market_id)
  return _impl_.market_id_.Release();
}
inline void MarketOrderIndicator::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketOrderIndicator.market_id)
}

// bool isBuy = 2 [json_name = "isBuy"];
inline void MarketOrderIndicator::clear_isbuy() {
  _impl_.isbuy_ = false;
}
inline bool MarketOrderIndicator::isbuy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketOrderIndicator.isBuy)
  return _internal_isbuy();
}
inline void MarketOrderIndicator::set_isbuy(bool value) {
  _internal_set_isbuy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketOrderIndicator.isBuy)
}
inline bool MarketOrderIndicator::_internal_isbuy() const {
  return _impl_.isbuy_;
}
inline void MarketOrderIndicator::_internal_set_isbuy(bool value) {
  ;
  _impl_.isbuy_ = value;
}

// -------------------------------------------------------------------

// TradeLog

// string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TradeLog::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& TradeLog::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeLog.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeLog::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeLog.quantity)
}
inline std::string* TradeLog::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeLog.quantity)
  return _s;
}
inline const std::string& TradeLog::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void TradeLog::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeLog::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeLog::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeLog.quantity)
  return _impl_.quantity_.Release();
}
inline void TradeLog::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeLog.quantity)
}

// string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TradeLog::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& TradeLog::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeLog.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeLog::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeLog.price)
}
inline std::string* TradeLog::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeLog.price)
  return _s;
}
inline const std::string& TradeLog::_internal_price() const {
  return _impl_.price_.Get();
}
inline void TradeLog::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeLog::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeLog::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeLog.price)
  return _impl_.price_.Release();
}
inline void TradeLog::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeLog.price)
}

// bytes subaccount_id = 3 [json_name = "subaccountId"];
inline void TradeLog::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& TradeLog::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeLog.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeLog::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeLog.subaccount_id)
}
inline std::string* TradeLog::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeLog.subaccount_id)
  return _s;
}
inline const std::string& TradeLog::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void TradeLog::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeLog::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeLog::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeLog.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void TradeLog::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeLog.subaccount_id)
}

// string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TradeLog::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& TradeLog::fee() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeLog.fee)
  return _internal_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeLog::set_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeLog.fee)
}
inline std::string* TradeLog::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeLog.fee)
  return _s;
}
inline const std::string& TradeLog::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void TradeLog::_internal_set_fee(const std::string& value) {
  ;


  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeLog::_internal_mutable_fee() {
  ;
  return _impl_.fee_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeLog::release_fee() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeLog.fee)
  return _impl_.fee_.Release();
}
inline void TradeLog::set_allocated_fee(std::string* value) {
  _impl_.fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_.IsDefault()) {
          _impl_.fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeLog.fee)
}

// bytes order_hash = 5 [json_name = "orderHash"];
inline void TradeLog::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& TradeLog::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeLog.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeLog::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeLog.order_hash)
}
inline std::string* TradeLog::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeLog.order_hash)
  return _s;
}
inline const std::string& TradeLog::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void TradeLog::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeLog::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeLog::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeLog.order_hash)
  return _impl_.order_hash_.Release();
}
inline void TradeLog::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeLog.order_hash)
}

// bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
inline void TradeLog::clear_fee_recipient_address() {
  _impl_.fee_recipient_address_.ClearToEmpty();
}
inline const std::string& TradeLog::fee_recipient_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeLog.fee_recipient_address)
  return _internal_fee_recipient_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeLog::set_fee_recipient_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_recipient_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeLog.fee_recipient_address)
}
inline std::string* TradeLog::mutable_fee_recipient_address() {
  std::string* _s = _internal_mutable_fee_recipient_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeLog.fee_recipient_address)
  return _s;
}
inline const std::string& TradeLog::_internal_fee_recipient_address() const {
  return _impl_.fee_recipient_address_.Get();
}
inline void TradeLog::_internal_set_fee_recipient_address(const std::string& value) {
  ;


  _impl_.fee_recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeLog::_internal_mutable_fee_recipient_address() {
  ;
  return _impl_.fee_recipient_address_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeLog::release_fee_recipient_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeLog.fee_recipient_address)
  return _impl_.fee_recipient_address_.Release();
}
inline void TradeLog::set_allocated_fee_recipient_address(std::string* value) {
  _impl_.fee_recipient_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_recipient_address_.IsDefault()) {
          _impl_.fee_recipient_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeLog.fee_recipient_address)
}

// -------------------------------------------------------------------

// PositionDelta

// bool is_long = 1 [json_name = "isLong"];
inline void PositionDelta::clear_is_long() {
  _impl_.is_long_ = false;
}
inline bool PositionDelta::is_long() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PositionDelta.is_long)
  return _internal_is_long();
}
inline void PositionDelta::set_is_long(bool value) {
  _internal_set_is_long(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PositionDelta.is_long)
}
inline bool PositionDelta::_internal_is_long() const {
  return _impl_.is_long_;
}
inline void PositionDelta::_internal_set_is_long(bool value) {
  ;
  _impl_.is_long_ = value;
}

// string execution_quantity = 2 [json_name = "executionQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PositionDelta::clear_execution_quantity() {
  _impl_.execution_quantity_.ClearToEmpty();
}
inline const std::string& PositionDelta::execution_quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PositionDelta.execution_quantity)
  return _internal_execution_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionDelta::set_execution_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PositionDelta.execution_quantity)
}
inline std::string* PositionDelta::mutable_execution_quantity() {
  std::string* _s = _internal_mutable_execution_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PositionDelta.execution_quantity)
  return _s;
}
inline const std::string& PositionDelta::_internal_execution_quantity() const {
  return _impl_.execution_quantity_.Get();
}
inline void PositionDelta::_internal_set_execution_quantity(const std::string& value) {
  ;


  _impl_.execution_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionDelta::_internal_mutable_execution_quantity() {
  ;
  return _impl_.execution_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionDelta::release_execution_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PositionDelta.execution_quantity)
  return _impl_.execution_quantity_.Release();
}
inline void PositionDelta::set_allocated_execution_quantity(std::string* value) {
  _impl_.execution_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_quantity_.IsDefault()) {
          _impl_.execution_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PositionDelta.execution_quantity)
}

// string execution_margin = 3 [json_name = "executionMargin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PositionDelta::clear_execution_margin() {
  _impl_.execution_margin_.ClearToEmpty();
}
inline const std::string& PositionDelta::execution_margin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PositionDelta.execution_margin)
  return _internal_execution_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionDelta::set_execution_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PositionDelta.execution_margin)
}
inline std::string* PositionDelta::mutable_execution_margin() {
  std::string* _s = _internal_mutable_execution_margin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PositionDelta.execution_margin)
  return _s;
}
inline const std::string& PositionDelta::_internal_execution_margin() const {
  return _impl_.execution_margin_.Get();
}
inline void PositionDelta::_internal_set_execution_margin(const std::string& value) {
  ;


  _impl_.execution_margin_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionDelta::_internal_mutable_execution_margin() {
  ;
  return _impl_.execution_margin_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionDelta::release_execution_margin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PositionDelta.execution_margin)
  return _impl_.execution_margin_.Release();
}
inline void PositionDelta::set_allocated_execution_margin(std::string* value) {
  _impl_.execution_margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_margin_.IsDefault()) {
          _impl_.execution_margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PositionDelta.execution_margin)
}

// string execution_price = 4 [json_name = "executionPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PositionDelta::clear_execution_price() {
  _impl_.execution_price_.ClearToEmpty();
}
inline const std::string& PositionDelta::execution_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PositionDelta.execution_price)
  return _internal_execution_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionDelta::set_execution_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PositionDelta.execution_price)
}
inline std::string* PositionDelta::mutable_execution_price() {
  std::string* _s = _internal_mutable_execution_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PositionDelta.execution_price)
  return _s;
}
inline const std::string& PositionDelta::_internal_execution_price() const {
  return _impl_.execution_price_.Get();
}
inline void PositionDelta::_internal_set_execution_price(const std::string& value) {
  ;


  _impl_.execution_price_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionDelta::_internal_mutable_execution_price() {
  ;
  return _impl_.execution_price_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionDelta::release_execution_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PositionDelta.execution_price)
  return _impl_.execution_price_.Release();
}
inline void PositionDelta::set_allocated_execution_price(std::string* value) {
  _impl_.execution_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_price_.IsDefault()) {
          _impl_.execution_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PositionDelta.execution_price)
}

// -------------------------------------------------------------------

// DerivativeTradeLog

// bytes subaccount_id = 1 [json_name = "subaccountId"];
inline void DerivativeTradeLog::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& DerivativeTradeLog::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeTradeLog.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTradeLog::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeTradeLog.subaccount_id)
}
inline std::string* DerivativeTradeLog::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeTradeLog.subaccount_id)
  return _s;
}
inline const std::string& DerivativeTradeLog::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void DerivativeTradeLog::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeTradeLog.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void DerivativeTradeLog::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeTradeLog.subaccount_id)
}

// .injective.exchange.v1beta1.PositionDelta position_delta = 2 [json_name = "positionDelta"];
inline bool DerivativeTradeLog::has_position_delta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_delta_ != nullptr);
  return value;
}
inline void DerivativeTradeLog::clear_position_delta() {
  if (_impl_.position_delta_ != nullptr) _impl_.position_delta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::PositionDelta& DerivativeTradeLog::_internal_position_delta() const {
  const ::injective::exchange::v1beta1::PositionDelta* p = _impl_.position_delta_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PositionDelta&>(
      ::injective::exchange::v1beta1::_PositionDelta_default_instance_);
}
inline const ::injective::exchange::v1beta1::PositionDelta& DerivativeTradeLog::position_delta() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeTradeLog.position_delta)
  return _internal_position_delta();
}
inline void DerivativeTradeLog::unsafe_arena_set_allocated_position_delta(
    ::injective::exchange::v1beta1::PositionDelta* position_delta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_delta_);
  }
  _impl_.position_delta_ = position_delta;
  if (position_delta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.DerivativeTradeLog.position_delta)
}
inline ::injective::exchange::v1beta1::PositionDelta* DerivativeTradeLog::release_position_delta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PositionDelta* temp = _impl_.position_delta_;
  _impl_.position_delta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PositionDelta* DerivativeTradeLog::unsafe_arena_release_position_delta() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeTradeLog.position_delta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PositionDelta* temp = _impl_.position_delta_;
  _impl_.position_delta_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PositionDelta* DerivativeTradeLog::_internal_mutable_position_delta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_delta_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PositionDelta>(GetArenaForAllocation());
    _impl_.position_delta_ = p;
  }
  return _impl_.position_delta_;
}
inline ::injective::exchange::v1beta1::PositionDelta* DerivativeTradeLog::mutable_position_delta() {
  ::injective::exchange::v1beta1::PositionDelta* _msg = _internal_mutable_position_delta();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeTradeLog.position_delta)
  return _msg;
}
inline void DerivativeTradeLog::set_allocated_position_delta(::injective::exchange::v1beta1::PositionDelta* position_delta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_delta_;
  }
  if (position_delta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position_delta);
    if (message_arena != submessage_arena) {
      position_delta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position_delta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_delta_ = position_delta;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeTradeLog.position_delta)
}

// string payout = 3 [json_name = "payout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeTradeLog::clear_payout() {
  _impl_.payout_.ClearToEmpty();
}
inline const std::string& DerivativeTradeLog::payout() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeTradeLog.payout)
  return _internal_payout();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTradeLog::set_payout(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payout_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeTradeLog.payout)
}
inline std::string* DerivativeTradeLog::mutable_payout() {
  std::string* _s = _internal_mutable_payout();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeTradeLog.payout)
  return _s;
}
inline const std::string& DerivativeTradeLog::_internal_payout() const {
  return _impl_.payout_.Get();
}
inline void DerivativeTradeLog::_internal_set_payout(const std::string& value) {
  ;


  _impl_.payout_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::_internal_mutable_payout() {
  ;
  return _impl_.payout_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::release_payout() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeTradeLog.payout)
  return _impl_.payout_.Release();
}
inline void DerivativeTradeLog::set_allocated_payout(std::string* value) {
  _impl_.payout_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payout_.IsDefault()) {
          _impl_.payout_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeTradeLog.payout)
}

// string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeTradeLog::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& DerivativeTradeLog::fee() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeTradeLog.fee)
  return _internal_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTradeLog::set_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeTradeLog.fee)
}
inline std::string* DerivativeTradeLog::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeTradeLog.fee)
  return _s;
}
inline const std::string& DerivativeTradeLog::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void DerivativeTradeLog::_internal_set_fee(const std::string& value) {
  ;


  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::_internal_mutable_fee() {
  ;
  return _impl_.fee_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::release_fee() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeTradeLog.fee)
  return _impl_.fee_.Release();
}
inline void DerivativeTradeLog::set_allocated_fee(std::string* value) {
  _impl_.fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_.IsDefault()) {
          _impl_.fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeTradeLog.fee)
}

// bytes order_hash = 5 [json_name = "orderHash"];
inline void DerivativeTradeLog::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& DerivativeTradeLog::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeTradeLog.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTradeLog::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeTradeLog.order_hash)
}
inline std::string* DerivativeTradeLog::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeTradeLog.order_hash)
  return _s;
}
inline const std::string& DerivativeTradeLog::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void DerivativeTradeLog::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeTradeLog.order_hash)
  return _impl_.order_hash_.Release();
}
inline void DerivativeTradeLog::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeTradeLog.order_hash)
}

// bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
inline void DerivativeTradeLog::clear_fee_recipient_address() {
  _impl_.fee_recipient_address_.ClearToEmpty();
}
inline const std::string& DerivativeTradeLog::fee_recipient_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeTradeLog.fee_recipient_address)
  return _internal_fee_recipient_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTradeLog::set_fee_recipient_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_recipient_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeTradeLog.fee_recipient_address)
}
inline std::string* DerivativeTradeLog::mutable_fee_recipient_address() {
  std::string* _s = _internal_mutable_fee_recipient_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeTradeLog.fee_recipient_address)
  return _s;
}
inline const std::string& DerivativeTradeLog::_internal_fee_recipient_address() const {
  return _impl_.fee_recipient_address_.Get();
}
inline void DerivativeTradeLog::_internal_set_fee_recipient_address(const std::string& value) {
  ;


  _impl_.fee_recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::_internal_mutable_fee_recipient_address() {
  ;
  return _impl_.fee_recipient_address_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTradeLog::release_fee_recipient_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeTradeLog.fee_recipient_address)
  return _impl_.fee_recipient_address_.Release();
}
inline void DerivativeTradeLog::set_allocated_fee_recipient_address(std::string* value) {
  _impl_.fee_recipient_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_recipient_address_.IsDefault()) {
          _impl_.fee_recipient_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeTradeLog.fee_recipient_address)
}

// -------------------------------------------------------------------

// SubaccountPosition

// .injective.exchange.v1beta1.Position position = 1 [json_name = "position"];
inline bool SubaccountPosition::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void SubaccountPosition::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::Position& SubaccountPosition::_internal_position() const {
  const ::injective::exchange::v1beta1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::Position&>(
      ::injective::exchange::v1beta1::_Position_default_instance_);
}
inline const ::injective::exchange::v1beta1::Position& SubaccountPosition::position() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountPosition.position)
  return _internal_position();
}
inline void SubaccountPosition::unsafe_arena_set_allocated_position(
    ::injective::exchange::v1beta1::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.SubaccountPosition.position)
}
inline ::injective::exchange::v1beta1::Position* SubaccountPosition::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::Position* SubaccountPosition::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountPosition.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::Position* SubaccountPosition::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::injective::exchange::v1beta1::Position* SubaccountPosition::mutable_position() {
  ::injective::exchange::v1beta1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountPosition.position)
  return _msg;
}
inline void SubaccountPosition::set_allocated_position(::injective::exchange::v1beta1::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountPosition.position)
}

// bytes subaccount_id = 2 [json_name = "subaccountId"];
inline void SubaccountPosition::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountPosition::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountPosition.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountPosition::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountPosition.subaccount_id)
}
inline std::string* SubaccountPosition::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountPosition.subaccount_id)
  return _s;
}
inline const std::string& SubaccountPosition::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountPosition::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountPosition::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountPosition::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountPosition.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountPosition::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountPosition.subaccount_id)
}

// -------------------------------------------------------------------

// SubaccountDeposit

// bytes subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountDeposit::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountDeposit::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountDeposit.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountDeposit::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountDeposit.subaccount_id)
}
inline std::string* SubaccountDeposit::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountDeposit.subaccount_id)
  return _s;
}
inline const std::string& SubaccountDeposit::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountDeposit::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountDeposit::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountDeposit::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountDeposit.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountDeposit::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountDeposit.subaccount_id)
}

// .injective.exchange.v1beta1.Deposit deposit = 2 [json_name = "deposit"];
inline bool SubaccountDeposit::has_deposit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deposit_ != nullptr);
  return value;
}
inline void SubaccountDeposit::clear_deposit() {
  if (_impl_.deposit_ != nullptr) _impl_.deposit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::Deposit& SubaccountDeposit::_internal_deposit() const {
  const ::injective::exchange::v1beta1::Deposit* p = _impl_.deposit_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::Deposit&>(
      ::injective::exchange::v1beta1::_Deposit_default_instance_);
}
inline const ::injective::exchange::v1beta1::Deposit& SubaccountDeposit::deposit() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountDeposit.deposit)
  return _internal_deposit();
}
inline void SubaccountDeposit::unsafe_arena_set_allocated_deposit(
    ::injective::exchange::v1beta1::Deposit* deposit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deposit_);
  }
  _impl_.deposit_ = deposit;
  if (deposit) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.SubaccountDeposit.deposit)
}
inline ::injective::exchange::v1beta1::Deposit* SubaccountDeposit::release_deposit() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Deposit* temp = _impl_.deposit_;
  _impl_.deposit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::Deposit* SubaccountDeposit::unsafe_arena_release_deposit() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountDeposit.deposit)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Deposit* temp = _impl_.deposit_;
  _impl_.deposit_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::Deposit* SubaccountDeposit::_internal_mutable_deposit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deposit_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::Deposit>(GetArenaForAllocation());
    _impl_.deposit_ = p;
  }
  return _impl_.deposit_;
}
inline ::injective::exchange::v1beta1::Deposit* SubaccountDeposit::mutable_deposit() {
  ::injective::exchange::v1beta1::Deposit* _msg = _internal_mutable_deposit();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountDeposit.deposit)
  return _msg;
}
inline void SubaccountDeposit::set_allocated_deposit(::injective::exchange::v1beta1::Deposit* deposit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deposit_;
  }
  if (deposit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deposit);
    if (message_arena != submessage_arena) {
      deposit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deposit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deposit_ = deposit;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountDeposit.deposit)
}

// -------------------------------------------------------------------

// DepositUpdate

// string denom = 1 [json_name = "denom"];
inline void DepositUpdate::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& DepositUpdate::denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DepositUpdate.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DepositUpdate::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DepositUpdate.denom)
}
inline std::string* DepositUpdate::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DepositUpdate.denom)
  return _s;
}
inline const std::string& DepositUpdate::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void DepositUpdate::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* DepositUpdate::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* DepositUpdate::release_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DepositUpdate.denom)
  return _impl_.denom_.Release();
}
inline void DepositUpdate::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DepositUpdate.denom)
}

// repeated .injective.exchange.v1beta1.SubaccountDeposit deposits = 2 [json_name = "deposits"];
inline int DepositUpdate::_internal_deposits_size() const {
  return _impl_.deposits_.size();
}
inline int DepositUpdate::deposits_size() const {
  return _internal_deposits_size();
}
inline void DepositUpdate::clear_deposits() {
  _internal_mutable_deposits()->Clear();
}
inline ::injective::exchange::v1beta1::SubaccountDeposit* DepositUpdate::mutable_deposits(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DepositUpdate.deposits)
  return _internal_mutable_deposits()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountDeposit >*
DepositUpdate::mutable_deposits() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.DepositUpdate.deposits)
  return _internal_mutable_deposits();
}
inline const ::injective::exchange::v1beta1::SubaccountDeposit& DepositUpdate::_internal_deposits(int index) const {
  return _internal_deposits().Get(index);
}
inline const ::injective::exchange::v1beta1::SubaccountDeposit& DepositUpdate::deposits(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DepositUpdate.deposits)
  return _internal_deposits(index);
}
inline ::injective::exchange::v1beta1::SubaccountDeposit* DepositUpdate::_internal_add_deposits() {
  return _internal_mutable_deposits()->Add();
}
inline ::injective::exchange::v1beta1::SubaccountDeposit* DepositUpdate::add_deposits() {
  ::injective::exchange::v1beta1::SubaccountDeposit* _add = _internal_add_deposits();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.DepositUpdate.deposits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountDeposit >&
DepositUpdate::deposits() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.DepositUpdate.deposits)
  return _internal_deposits();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountDeposit>&
DepositUpdate::_internal_deposits() const {
  return _impl_.deposits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountDeposit>*
DepositUpdate::_internal_mutable_deposits() {
  return &_impl_.deposits_;
}

// -------------------------------------------------------------------

// PointsMultiplier

// string maker_points_multiplier = 1 [json_name = "makerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PointsMultiplier::clear_maker_points_multiplier() {
  _impl_.maker_points_multiplier_.ClearToEmpty();
}
inline const std::string& PointsMultiplier::maker_points_multiplier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PointsMultiplier.maker_points_multiplier)
  return _internal_maker_points_multiplier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PointsMultiplier::set_maker_points_multiplier(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_points_multiplier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PointsMultiplier.maker_points_multiplier)
}
inline std::string* PointsMultiplier::mutable_maker_points_multiplier() {
  std::string* _s = _internal_mutable_maker_points_multiplier();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PointsMultiplier.maker_points_multiplier)
  return _s;
}
inline const std::string& PointsMultiplier::_internal_maker_points_multiplier() const {
  return _impl_.maker_points_multiplier_.Get();
}
inline void PointsMultiplier::_internal_set_maker_points_multiplier(const std::string& value) {
  ;


  _impl_.maker_points_multiplier_.Set(value, GetArenaForAllocation());
}
inline std::string* PointsMultiplier::_internal_mutable_maker_points_multiplier() {
  ;
  return _impl_.maker_points_multiplier_.Mutable( GetArenaForAllocation());
}
inline std::string* PointsMultiplier::release_maker_points_multiplier() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PointsMultiplier.maker_points_multiplier)
  return _impl_.maker_points_multiplier_.Release();
}
inline void PointsMultiplier::set_allocated_maker_points_multiplier(std::string* value) {
  _impl_.maker_points_multiplier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_points_multiplier_.IsDefault()) {
          _impl_.maker_points_multiplier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PointsMultiplier.maker_points_multiplier)
}

// string taker_points_multiplier = 2 [json_name = "takerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PointsMultiplier::clear_taker_points_multiplier() {
  _impl_.taker_points_multiplier_.ClearToEmpty();
}
inline const std::string& PointsMultiplier::taker_points_multiplier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PointsMultiplier.taker_points_multiplier)
  return _internal_taker_points_multiplier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PointsMultiplier::set_taker_points_multiplier(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_points_multiplier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PointsMultiplier.taker_points_multiplier)
}
inline std::string* PointsMultiplier::mutable_taker_points_multiplier() {
  std::string* _s = _internal_mutable_taker_points_multiplier();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PointsMultiplier.taker_points_multiplier)
  return _s;
}
inline const std::string& PointsMultiplier::_internal_taker_points_multiplier() const {
  return _impl_.taker_points_multiplier_.Get();
}
inline void PointsMultiplier::_internal_set_taker_points_multiplier(const std::string& value) {
  ;


  _impl_.taker_points_multiplier_.Set(value, GetArenaForAllocation());
}
inline std::string* PointsMultiplier::_internal_mutable_taker_points_multiplier() {
  ;
  return _impl_.taker_points_multiplier_.Mutable( GetArenaForAllocation());
}
inline std::string* PointsMultiplier::release_taker_points_multiplier() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PointsMultiplier.taker_points_multiplier)
  return _impl_.taker_points_multiplier_.Release();
}
inline void PointsMultiplier::set_allocated_taker_points_multiplier(std::string* value) {
  _impl_.taker_points_multiplier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_points_multiplier_.IsDefault()) {
          _impl_.taker_points_multiplier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PointsMultiplier.taker_points_multiplier)
}

// -------------------------------------------------------------------

// TradingRewardCampaignBoostInfo

// repeated string boosted_spot_market_ids = 1 [json_name = "boostedSpotMarketIds"];
inline int TradingRewardCampaignBoostInfo::_internal_boosted_spot_market_ids_size() const {
  return _impl_.boosted_spot_market_ids_.size();
}
inline int TradingRewardCampaignBoostInfo::boosted_spot_market_ids_size() const {
  return _internal_boosted_spot_market_ids_size();
}
inline void TradingRewardCampaignBoostInfo::clear_boosted_spot_market_ids() {
  _internal_mutable_boosted_spot_market_ids()->Clear();
}
inline std::string* TradingRewardCampaignBoostInfo::add_boosted_spot_market_ids() {
  std::string* _s = _internal_add_boosted_spot_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
  return _s;
}
inline const std::string& TradingRewardCampaignBoostInfo::boosted_spot_market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
  return _internal_boosted_spot_market_ids(index);
}
inline std::string* TradingRewardCampaignBoostInfo::mutable_boosted_spot_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
  return _internal_mutable_boosted_spot_market_ids()->Mutable(index);
}
inline void TradingRewardCampaignBoostInfo::set_boosted_spot_market_ids(int index, const std::string& value) {
  _internal_mutable_boosted_spot_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::set_boosted_spot_market_ids(int index, std::string&& value) {
  _internal_mutable_boosted_spot_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::set_boosted_spot_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_boosted_spot_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::set_boosted_spot_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_boosted_spot_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::set_boosted_spot_market_ids(int index, absl::string_view value) {
  _internal_mutable_boosted_spot_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_spot_market_ids(const std::string& value) {
  _internal_mutable_boosted_spot_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_spot_market_ids(std::string&& value) {
  _internal_mutable_boosted_spot_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_spot_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_boosted_spot_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_spot_market_ids(const char* value, std::size_t size) {
  _internal_mutable_boosted_spot_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_spot_market_ids(absl::string_view value) {
  _internal_mutable_boosted_spot_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradingRewardCampaignBoostInfo::boosted_spot_market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
  return _internal_boosted_spot_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradingRewardCampaignBoostInfo::mutable_boosted_spot_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids)
  return _internal_mutable_boosted_spot_market_ids();
}
inline const std::string& TradingRewardCampaignBoostInfo::_internal_boosted_spot_market_ids(int index) const {
  return _internal_boosted_spot_market_ids().Get(index);
}
inline std::string* TradingRewardCampaignBoostInfo::_internal_add_boosted_spot_market_ids() {
  return _internal_mutable_boosted_spot_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradingRewardCampaignBoostInfo::_internal_boosted_spot_market_ids() const {
  return _impl_.boosted_spot_market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradingRewardCampaignBoostInfo::_internal_mutable_boosted_spot_market_ids() {
  return &_impl_.boosted_spot_market_ids_;
}

// repeated .injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2 [json_name = "spotMarketMultipliers", (.gogoproto.nullable) = false];
inline int TradingRewardCampaignBoostInfo::_internal_spot_market_multipliers_size() const {
  return _impl_.spot_market_multipliers_.size();
}
inline int TradingRewardCampaignBoostInfo::spot_market_multipliers_size() const {
  return _internal_spot_market_multipliers_size();
}
inline void TradingRewardCampaignBoostInfo::clear_spot_market_multipliers() {
  _internal_mutable_spot_market_multipliers()->Clear();
}
inline ::injective::exchange::v1beta1::PointsMultiplier* TradingRewardCampaignBoostInfo::mutable_spot_market_multipliers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.spot_market_multipliers)
  return _internal_mutable_spot_market_multipliers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier >*
TradingRewardCampaignBoostInfo::mutable_spot_market_multipliers() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.spot_market_multipliers)
  return _internal_mutable_spot_market_multipliers();
}
inline const ::injective::exchange::v1beta1::PointsMultiplier& TradingRewardCampaignBoostInfo::_internal_spot_market_multipliers(int index) const {
  return _internal_spot_market_multipliers().Get(index);
}
inline const ::injective::exchange::v1beta1::PointsMultiplier& TradingRewardCampaignBoostInfo::spot_market_multipliers(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.spot_market_multipliers)
  return _internal_spot_market_multipliers(index);
}
inline ::injective::exchange::v1beta1::PointsMultiplier* TradingRewardCampaignBoostInfo::_internal_add_spot_market_multipliers() {
  return _internal_mutable_spot_market_multipliers()->Add();
}
inline ::injective::exchange::v1beta1::PointsMultiplier* TradingRewardCampaignBoostInfo::add_spot_market_multipliers() {
  ::injective::exchange::v1beta1::PointsMultiplier* _add = _internal_add_spot_market_multipliers();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.spot_market_multipliers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier >&
TradingRewardCampaignBoostInfo::spot_market_multipliers() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.spot_market_multipliers)
  return _internal_spot_market_multipliers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PointsMultiplier>&
TradingRewardCampaignBoostInfo::_internal_spot_market_multipliers() const {
  return _impl_.spot_market_multipliers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PointsMultiplier>*
TradingRewardCampaignBoostInfo::_internal_mutable_spot_market_multipliers() {
  return &_impl_.spot_market_multipliers_;
}

// repeated string boosted_derivative_market_ids = 3 [json_name = "boostedDerivativeMarketIds"];
inline int TradingRewardCampaignBoostInfo::_internal_boosted_derivative_market_ids_size() const {
  return _impl_.boosted_derivative_market_ids_.size();
}
inline int TradingRewardCampaignBoostInfo::boosted_derivative_market_ids_size() const {
  return _internal_boosted_derivative_market_ids_size();
}
inline void TradingRewardCampaignBoostInfo::clear_boosted_derivative_market_ids() {
  _internal_mutable_boosted_derivative_market_ids()->Clear();
}
inline std::string* TradingRewardCampaignBoostInfo::add_boosted_derivative_market_ids() {
  std::string* _s = _internal_add_boosted_derivative_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
  return _s;
}
inline const std::string& TradingRewardCampaignBoostInfo::boosted_derivative_market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
  return _internal_boosted_derivative_market_ids(index);
}
inline std::string* TradingRewardCampaignBoostInfo::mutable_boosted_derivative_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
  return _internal_mutable_boosted_derivative_market_ids()->Mutable(index);
}
inline void TradingRewardCampaignBoostInfo::set_boosted_derivative_market_ids(int index, const std::string& value) {
  _internal_mutable_boosted_derivative_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::set_boosted_derivative_market_ids(int index, std::string&& value) {
  _internal_mutable_boosted_derivative_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::set_boosted_derivative_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_boosted_derivative_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::set_boosted_derivative_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_boosted_derivative_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::set_boosted_derivative_market_ids(int index, absl::string_view value) {
  _internal_mutable_boosted_derivative_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_derivative_market_ids(const std::string& value) {
  _internal_mutable_boosted_derivative_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_derivative_market_ids(std::string&& value) {
  _internal_mutable_boosted_derivative_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_derivative_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_boosted_derivative_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_derivative_market_ids(const char* value, std::size_t size) {
  _internal_mutable_boosted_derivative_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline void TradingRewardCampaignBoostInfo::add_boosted_derivative_market_ids(absl::string_view value) {
  _internal_mutable_boosted_derivative_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradingRewardCampaignBoostInfo::boosted_derivative_market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
  return _internal_boosted_derivative_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradingRewardCampaignBoostInfo::mutable_boosted_derivative_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids)
  return _internal_mutable_boosted_derivative_market_ids();
}
inline const std::string& TradingRewardCampaignBoostInfo::_internal_boosted_derivative_market_ids(int index) const {
  return _internal_boosted_derivative_market_ids().Get(index);
}
inline std::string* TradingRewardCampaignBoostInfo::_internal_add_boosted_derivative_market_ids() {
  return _internal_mutable_boosted_derivative_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradingRewardCampaignBoostInfo::_internal_boosted_derivative_market_ids() const {
  return _impl_.boosted_derivative_market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradingRewardCampaignBoostInfo::_internal_mutable_boosted_derivative_market_ids() {
  return &_impl_.boosted_derivative_market_ids_;
}

// repeated .injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4 [json_name = "derivativeMarketMultipliers", (.gogoproto.nullable) = false];
inline int TradingRewardCampaignBoostInfo::_internal_derivative_market_multipliers_size() const {
  return _impl_.derivative_market_multipliers_.size();
}
inline int TradingRewardCampaignBoostInfo::derivative_market_multipliers_size() const {
  return _internal_derivative_market_multipliers_size();
}
inline void TradingRewardCampaignBoostInfo::clear_derivative_market_multipliers() {
  _internal_mutable_derivative_market_multipliers()->Clear();
}
inline ::injective::exchange::v1beta1::PointsMultiplier* TradingRewardCampaignBoostInfo::mutable_derivative_market_multipliers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.derivative_market_multipliers)
  return _internal_mutable_derivative_market_multipliers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier >*
TradingRewardCampaignBoostInfo::mutable_derivative_market_multipliers() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.derivative_market_multipliers)
  return _internal_mutable_derivative_market_multipliers();
}
inline const ::injective::exchange::v1beta1::PointsMultiplier& TradingRewardCampaignBoostInfo::_internal_derivative_market_multipliers(int index) const {
  return _internal_derivative_market_multipliers().Get(index);
}
inline const ::injective::exchange::v1beta1::PointsMultiplier& TradingRewardCampaignBoostInfo::derivative_market_multipliers(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.derivative_market_multipliers)
  return _internal_derivative_market_multipliers(index);
}
inline ::injective::exchange::v1beta1::PointsMultiplier* TradingRewardCampaignBoostInfo::_internal_add_derivative_market_multipliers() {
  return _internal_mutable_derivative_market_multipliers()->Add();
}
inline ::injective::exchange::v1beta1::PointsMultiplier* TradingRewardCampaignBoostInfo::add_derivative_market_multipliers() {
  ::injective::exchange::v1beta1::PointsMultiplier* _add = _internal_add_derivative_market_multipliers();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.derivative_market_multipliers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PointsMultiplier >&
TradingRewardCampaignBoostInfo::derivative_market_multipliers() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.derivative_market_multipliers)
  return _internal_derivative_market_multipliers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PointsMultiplier>&
TradingRewardCampaignBoostInfo::_internal_derivative_market_multipliers() const {
  return _impl_.derivative_market_multipliers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PointsMultiplier>*
TradingRewardCampaignBoostInfo::_internal_mutable_derivative_market_multipliers() {
  return &_impl_.derivative_market_multipliers_;
}

// -------------------------------------------------------------------

// CampaignRewardPool

// int64 start_timestamp = 1 [json_name = "startTimestamp"];
inline void CampaignRewardPool::clear_start_timestamp() {
  _impl_.start_timestamp_ = ::int64_t{0};
}
inline ::int64_t CampaignRewardPool::start_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.CampaignRewardPool.start_timestamp)
  return _internal_start_timestamp();
}
inline void CampaignRewardPool::set_start_timestamp(::int64_t value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.CampaignRewardPool.start_timestamp)
}
inline ::int64_t CampaignRewardPool::_internal_start_timestamp() const {
  return _impl_.start_timestamp_;
}
inline void CampaignRewardPool::_internal_set_start_timestamp(::int64_t value) {
  ;
  _impl_.start_timestamp_ = value;
}

// repeated .cosmos.base.v1beta1.Coin max_campaign_rewards = 2 [json_name = "maxCampaignRewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
inline int CampaignRewardPool::_internal_max_campaign_rewards_size() const {
  return _impl_.max_campaign_rewards_.size();
}
inline int CampaignRewardPool::max_campaign_rewards_size() const {
  return _internal_max_campaign_rewards_size();
}
inline ::cosmos::base::v1beta1::Coin* CampaignRewardPool::mutable_max_campaign_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.CampaignRewardPool.max_campaign_rewards)
  return _internal_mutable_max_campaign_rewards()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
CampaignRewardPool::mutable_max_campaign_rewards() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.CampaignRewardPool.max_campaign_rewards)
  return _internal_mutable_max_campaign_rewards();
}
inline const ::cosmos::base::v1beta1::Coin& CampaignRewardPool::_internal_max_campaign_rewards(int index) const {
  return _internal_max_campaign_rewards().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& CampaignRewardPool::max_campaign_rewards(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.CampaignRewardPool.max_campaign_rewards)
  return _internal_max_campaign_rewards(index);
}
inline ::cosmos::base::v1beta1::Coin* CampaignRewardPool::_internal_add_max_campaign_rewards() {
  return _internal_mutable_max_campaign_rewards()->Add();
}
inline ::cosmos::base::v1beta1::Coin* CampaignRewardPool::add_max_campaign_rewards() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_max_campaign_rewards();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.CampaignRewardPool.max_campaign_rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
CampaignRewardPool::max_campaign_rewards() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.CampaignRewardPool.max_campaign_rewards)
  return _internal_max_campaign_rewards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
CampaignRewardPool::_internal_max_campaign_rewards() const {
  return _impl_.max_campaign_rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
CampaignRewardPool::_internal_mutable_max_campaign_rewards() {
  return &_impl_.max_campaign_rewards_;
}

// -------------------------------------------------------------------

// TradingRewardCampaignInfo

// int64 campaign_duration_seconds = 1 [json_name = "campaignDurationSeconds"];
inline void TradingRewardCampaignInfo::clear_campaign_duration_seconds() {
  _impl_.campaign_duration_seconds_ = ::int64_t{0};
}
inline ::int64_t TradingRewardCampaignInfo::campaign_duration_seconds() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignInfo.campaign_duration_seconds)
  return _internal_campaign_duration_seconds();
}
inline void TradingRewardCampaignInfo::set_campaign_duration_seconds(::int64_t value) {
  _internal_set_campaign_duration_seconds(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignInfo.campaign_duration_seconds)
}
inline ::int64_t TradingRewardCampaignInfo::_internal_campaign_duration_seconds() const {
  return _impl_.campaign_duration_seconds_;
}
inline void TradingRewardCampaignInfo::_internal_set_campaign_duration_seconds(::int64_t value) {
  ;
  _impl_.campaign_duration_seconds_ = value;
}

// repeated string quote_denoms = 2 [json_name = "quoteDenoms"];
inline int TradingRewardCampaignInfo::_internal_quote_denoms_size() const {
  return _impl_.quote_denoms_.size();
}
inline int TradingRewardCampaignInfo::quote_denoms_size() const {
  return _internal_quote_denoms_size();
}
inline void TradingRewardCampaignInfo::clear_quote_denoms() {
  _internal_mutable_quote_denoms()->Clear();
}
inline std::string* TradingRewardCampaignInfo::add_quote_denoms() {
  std::string* _s = _internal_add_quote_denoms();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
  return _s;
}
inline const std::string& TradingRewardCampaignInfo::quote_denoms(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
  return _internal_quote_denoms(index);
}
inline std::string* TradingRewardCampaignInfo::mutable_quote_denoms(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
  return _internal_mutable_quote_denoms()->Mutable(index);
}
inline void TradingRewardCampaignInfo::set_quote_denoms(int index, const std::string& value) {
  _internal_mutable_quote_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::set_quote_denoms(int index, std::string&& value) {
  _internal_mutable_quote_denoms()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::set_quote_denoms(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_quote_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::set_quote_denoms(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_quote_denoms()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::set_quote_denoms(int index, absl::string_view value) {
  _internal_mutable_quote_denoms()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::add_quote_denoms(const std::string& value) {
  _internal_mutable_quote_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::add_quote_denoms(std::string&& value) {
  _internal_mutable_quote_denoms()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::add_quote_denoms(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_quote_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::add_quote_denoms(const char* value, std::size_t size) {
  _internal_mutable_quote_denoms()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline void TradingRewardCampaignInfo::add_quote_denoms(absl::string_view value) {
  _internal_mutable_quote_denoms()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradingRewardCampaignInfo::quote_denoms() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
  return _internal_quote_denoms();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradingRewardCampaignInfo::mutable_quote_denoms() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms)
  return _internal_mutable_quote_denoms();
}
inline const std::string& TradingRewardCampaignInfo::_internal_quote_denoms(int index) const {
  return _internal_quote_denoms().Get(index);
}
inline std::string* TradingRewardCampaignInfo::_internal_add_quote_denoms() {
  return _internal_mutable_quote_denoms()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradingRewardCampaignInfo::_internal_quote_denoms() const {
  return _impl_.quote_denoms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradingRewardCampaignInfo::_internal_mutable_quote_denoms() {
  return &_impl_.quote_denoms_;
}

// .injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3 [json_name = "tradingRewardBoostInfo"];
inline bool TradingRewardCampaignInfo::has_trading_reward_boost_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trading_reward_boost_info_ != nullptr);
  return value;
}
inline void TradingRewardCampaignInfo::clear_trading_reward_boost_info() {
  if (_impl_.trading_reward_boost_info_ != nullptr) _impl_.trading_reward_boost_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo& TradingRewardCampaignInfo::_internal_trading_reward_boost_info() const {
  const ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* p = _impl_.trading_reward_boost_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo&>(
      ::injective::exchange::v1beta1::_TradingRewardCampaignBoostInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo& TradingRewardCampaignInfo::trading_reward_boost_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignInfo.trading_reward_boost_info)
  return _internal_trading_reward_boost_info();
}
inline void TradingRewardCampaignInfo::unsafe_arena_set_allocated_trading_reward_boost_info(
    ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* trading_reward_boost_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trading_reward_boost_info_);
  }
  _impl_.trading_reward_boost_info_ = trading_reward_boost_info;
  if (trading_reward_boost_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignInfo.trading_reward_boost_info)
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* TradingRewardCampaignInfo::release_trading_reward_boost_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* temp = _impl_.trading_reward_boost_info_;
  _impl_.trading_reward_boost_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* TradingRewardCampaignInfo::unsafe_arena_release_trading_reward_boost_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardCampaignInfo.trading_reward_boost_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* temp = _impl_.trading_reward_boost_info_;
  _impl_.trading_reward_boost_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* TradingRewardCampaignInfo::_internal_mutable_trading_reward_boost_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trading_reward_boost_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo>(GetArenaForAllocation());
    _impl_.trading_reward_boost_info_ = p;
  }
  return _impl_.trading_reward_boost_info_;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* TradingRewardCampaignInfo::mutable_trading_reward_boost_info() {
  ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* _msg = _internal_mutable_trading_reward_boost_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignInfo.trading_reward_boost_info)
  return _msg;
}
inline void TradingRewardCampaignInfo::set_allocated_trading_reward_boost_info(::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo* trading_reward_boost_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trading_reward_boost_info_;
  }
  if (trading_reward_boost_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trading_reward_boost_info);
    if (message_arena != submessage_arena) {
      trading_reward_boost_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trading_reward_boost_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trading_reward_boost_info_ = trading_reward_boost_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignInfo.trading_reward_boost_info)
}

// repeated string disqualified_market_ids = 4 [json_name = "disqualifiedMarketIds"];
inline int TradingRewardCampaignInfo::_internal_disqualified_market_ids_size() const {
  return _impl_.disqualified_market_ids_.size();
}
inline int TradingRewardCampaignInfo::disqualified_market_ids_size() const {
  return _internal_disqualified_market_ids_size();
}
inline void TradingRewardCampaignInfo::clear_disqualified_market_ids() {
  _internal_mutable_disqualified_market_ids()->Clear();
}
inline std::string* TradingRewardCampaignInfo::add_disqualified_market_ids() {
  std::string* _s = _internal_add_disqualified_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
  return _s;
}
inline const std::string& TradingRewardCampaignInfo::disqualified_market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
  return _internal_disqualified_market_ids(index);
}
inline std::string* TradingRewardCampaignInfo::mutable_disqualified_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
  return _internal_mutable_disqualified_market_ids()->Mutable(index);
}
inline void TradingRewardCampaignInfo::set_disqualified_market_ids(int index, const std::string& value) {
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::set_disqualified_market_ids(int index, std::string&& value) {
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::set_disqualified_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::set_disqualified_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::set_disqualified_market_ids(int index, absl::string_view value) {
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::add_disqualified_market_ids(const std::string& value) {
  _internal_mutable_disqualified_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::add_disqualified_market_ids(std::string&& value) {
  _internal_mutable_disqualified_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::add_disqualified_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_disqualified_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::add_disqualified_market_ids(const char* value, std::size_t size) {
  _internal_mutable_disqualified_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline void TradingRewardCampaignInfo::add_disqualified_market_ids(absl::string_view value) {
  _internal_mutable_disqualified_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradingRewardCampaignInfo::disqualified_market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
  return _internal_disqualified_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradingRewardCampaignInfo::mutable_disqualified_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids)
  return _internal_mutable_disqualified_market_ids();
}
inline const std::string& TradingRewardCampaignInfo::_internal_disqualified_market_ids(int index) const {
  return _internal_disqualified_market_ids().Get(index);
}
inline std::string* TradingRewardCampaignInfo::_internal_add_disqualified_market_ids() {
  return _internal_mutable_disqualified_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradingRewardCampaignInfo::_internal_disqualified_market_ids() const {
  return _impl_.disqualified_market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradingRewardCampaignInfo::_internal_mutable_disqualified_market_ids() {
  return &_impl_.disqualified_market_ids_;
}

// -------------------------------------------------------------------

// FeeDiscountTierInfo

// string maker_discount_rate = 1 [json_name = "makerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void FeeDiscountTierInfo::clear_maker_discount_rate() {
  _impl_.maker_discount_rate_.ClearToEmpty();
}
inline const std::string& FeeDiscountTierInfo::maker_discount_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountTierInfo.maker_discount_rate)
  return _internal_maker_discount_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeeDiscountTierInfo::set_maker_discount_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_discount_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountTierInfo.maker_discount_rate)
}
inline std::string* FeeDiscountTierInfo::mutable_maker_discount_rate() {
  std::string* _s = _internal_mutable_maker_discount_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountTierInfo.maker_discount_rate)
  return _s;
}
inline const std::string& FeeDiscountTierInfo::_internal_maker_discount_rate() const {
  return _impl_.maker_discount_rate_.Get();
}
inline void FeeDiscountTierInfo::_internal_set_maker_discount_rate(const std::string& value) {
  ;


  _impl_.maker_discount_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* FeeDiscountTierInfo::_internal_mutable_maker_discount_rate() {
  ;
  return _impl_.maker_discount_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* FeeDiscountTierInfo::release_maker_discount_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FeeDiscountTierInfo.maker_discount_rate)
  return _impl_.maker_discount_rate_.Release();
}
inline void FeeDiscountTierInfo::set_allocated_maker_discount_rate(std::string* value) {
  _impl_.maker_discount_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_discount_rate_.IsDefault()) {
          _impl_.maker_discount_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FeeDiscountTierInfo.maker_discount_rate)
}

// string taker_discount_rate = 2 [json_name = "takerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void FeeDiscountTierInfo::clear_taker_discount_rate() {
  _impl_.taker_discount_rate_.ClearToEmpty();
}
inline const std::string& FeeDiscountTierInfo::taker_discount_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountTierInfo.taker_discount_rate)
  return _internal_taker_discount_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeeDiscountTierInfo::set_taker_discount_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_discount_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountTierInfo.taker_discount_rate)
}
inline std::string* FeeDiscountTierInfo::mutable_taker_discount_rate() {
  std::string* _s = _internal_mutable_taker_discount_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountTierInfo.taker_discount_rate)
  return _s;
}
inline const std::string& FeeDiscountTierInfo::_internal_taker_discount_rate() const {
  return _impl_.taker_discount_rate_.Get();
}
inline void FeeDiscountTierInfo::_internal_set_taker_discount_rate(const std::string& value) {
  ;


  _impl_.taker_discount_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* FeeDiscountTierInfo::_internal_mutable_taker_discount_rate() {
  ;
  return _impl_.taker_discount_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* FeeDiscountTierInfo::release_taker_discount_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FeeDiscountTierInfo.taker_discount_rate)
  return _impl_.taker_discount_rate_.Release();
}
inline void FeeDiscountTierInfo::set_allocated_taker_discount_rate(std::string* value) {
  _impl_.taker_discount_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_discount_rate_.IsDefault()) {
          _impl_.taker_discount_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FeeDiscountTierInfo.taker_discount_rate)
}

// string staked_amount = 3 [json_name = "stakedAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void FeeDiscountTierInfo::clear_staked_amount() {
  _impl_.staked_amount_.ClearToEmpty();
}
inline const std::string& FeeDiscountTierInfo::staked_amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountTierInfo.staked_amount)
  return _internal_staked_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeeDiscountTierInfo::set_staked_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.staked_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountTierInfo.staked_amount)
}
inline std::string* FeeDiscountTierInfo::mutable_staked_amount() {
  std::string* _s = _internal_mutable_staked_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountTierInfo.staked_amount)
  return _s;
}
inline const std::string& FeeDiscountTierInfo::_internal_staked_amount() const {
  return _impl_.staked_amount_.Get();
}
inline void FeeDiscountTierInfo::_internal_set_staked_amount(const std::string& value) {
  ;


  _impl_.staked_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* FeeDiscountTierInfo::_internal_mutable_staked_amount() {
  ;
  return _impl_.staked_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* FeeDiscountTierInfo::release_staked_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FeeDiscountTierInfo.staked_amount)
  return _impl_.staked_amount_.Release();
}
inline void FeeDiscountTierInfo::set_allocated_staked_amount(std::string* value) {
  _impl_.staked_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.staked_amount_.IsDefault()) {
          _impl_.staked_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FeeDiscountTierInfo.staked_amount)
}

// string volume = 4 [json_name = "volume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void FeeDiscountTierInfo::clear_volume() {
  _impl_.volume_.ClearToEmpty();
}
inline const std::string& FeeDiscountTierInfo::volume() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountTierInfo.volume)
  return _internal_volume();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeeDiscountTierInfo::set_volume(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.volume_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountTierInfo.volume)
}
inline std::string* FeeDiscountTierInfo::mutable_volume() {
  std::string* _s = _internal_mutable_volume();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountTierInfo.volume)
  return _s;
}
inline const std::string& FeeDiscountTierInfo::_internal_volume() const {
  return _impl_.volume_.Get();
}
inline void FeeDiscountTierInfo::_internal_set_volume(const std::string& value) {
  ;


  _impl_.volume_.Set(value, GetArenaForAllocation());
}
inline std::string* FeeDiscountTierInfo::_internal_mutable_volume() {
  ;
  return _impl_.volume_.Mutable( GetArenaForAllocation());
}
inline std::string* FeeDiscountTierInfo::release_volume() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FeeDiscountTierInfo.volume)
  return _impl_.volume_.Release();
}
inline void FeeDiscountTierInfo::set_allocated_volume(std::string* value) {
  _impl_.volume_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_.IsDefault()) {
          _impl_.volume_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FeeDiscountTierInfo.volume)
}

// -------------------------------------------------------------------

// FeeDiscountSchedule

// uint64 bucket_count = 1 [json_name = "bucketCount"];
inline void FeeDiscountSchedule::clear_bucket_count() {
  _impl_.bucket_count_ = ::uint64_t{0u};
}
inline ::uint64_t FeeDiscountSchedule::bucket_count() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountSchedule.bucket_count)
  return _internal_bucket_count();
}
inline void FeeDiscountSchedule::set_bucket_count(::uint64_t value) {
  _internal_set_bucket_count(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountSchedule.bucket_count)
}
inline ::uint64_t FeeDiscountSchedule::_internal_bucket_count() const {
  return _impl_.bucket_count_;
}
inline void FeeDiscountSchedule::_internal_set_bucket_count(::uint64_t value) {
  ;
  _impl_.bucket_count_ = value;
}

// int64 bucket_duration = 2 [json_name = "bucketDuration"];
inline void FeeDiscountSchedule::clear_bucket_duration() {
  _impl_.bucket_duration_ = ::int64_t{0};
}
inline ::int64_t FeeDiscountSchedule::bucket_duration() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountSchedule.bucket_duration)
  return _internal_bucket_duration();
}
inline void FeeDiscountSchedule::set_bucket_duration(::int64_t value) {
  _internal_set_bucket_duration(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountSchedule.bucket_duration)
}
inline ::int64_t FeeDiscountSchedule::_internal_bucket_duration() const {
  return _impl_.bucket_duration_;
}
inline void FeeDiscountSchedule::_internal_set_bucket_duration(::int64_t value) {
  ;
  _impl_.bucket_duration_ = value;
}

// repeated string quote_denoms = 3 [json_name = "quoteDenoms"];
inline int FeeDiscountSchedule::_internal_quote_denoms_size() const {
  return _impl_.quote_denoms_.size();
}
inline int FeeDiscountSchedule::quote_denoms_size() const {
  return _internal_quote_denoms_size();
}
inline void FeeDiscountSchedule::clear_quote_denoms() {
  _internal_mutable_quote_denoms()->Clear();
}
inline std::string* FeeDiscountSchedule::add_quote_denoms() {
  std::string* _s = _internal_add_quote_denoms();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
  return _s;
}
inline const std::string& FeeDiscountSchedule::quote_denoms(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
  return _internal_quote_denoms(index);
}
inline std::string* FeeDiscountSchedule::mutable_quote_denoms(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
  return _internal_mutable_quote_denoms()->Mutable(index);
}
inline void FeeDiscountSchedule::set_quote_denoms(int index, const std::string& value) {
  _internal_mutable_quote_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::set_quote_denoms(int index, std::string&& value) {
  _internal_mutable_quote_denoms()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::set_quote_denoms(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_quote_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::set_quote_denoms(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_quote_denoms()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::set_quote_denoms(int index, absl::string_view value) {
  _internal_mutable_quote_denoms()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::add_quote_denoms(const std::string& value) {
  _internal_mutable_quote_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::add_quote_denoms(std::string&& value) {
  _internal_mutable_quote_denoms()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::add_quote_denoms(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_quote_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::add_quote_denoms(const char* value, std::size_t size) {
  _internal_mutable_quote_denoms()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline void FeeDiscountSchedule::add_quote_denoms(absl::string_view value) {
  _internal_mutable_quote_denoms()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeeDiscountSchedule::quote_denoms() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
  return _internal_quote_denoms();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* FeeDiscountSchedule::mutable_quote_denoms() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms)
  return _internal_mutable_quote_denoms();
}
inline const std::string& FeeDiscountSchedule::_internal_quote_denoms(int index) const {
  return _internal_quote_denoms().Get(index);
}
inline std::string* FeeDiscountSchedule::_internal_add_quote_denoms() {
  return _internal_mutable_quote_denoms()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeeDiscountSchedule::_internal_quote_denoms() const {
  return _impl_.quote_denoms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FeeDiscountSchedule::_internal_mutable_quote_denoms() {
  return &_impl_.quote_denoms_;
}

// repeated .injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4 [json_name = "tierInfos"];
inline int FeeDiscountSchedule::_internal_tier_infos_size() const {
  return _impl_.tier_infos_.size();
}
inline int FeeDiscountSchedule::tier_infos_size() const {
  return _internal_tier_infos_size();
}
inline void FeeDiscountSchedule::clear_tier_infos() {
  _internal_mutable_tier_infos()->Clear();
}
inline ::injective::exchange::v1beta1::FeeDiscountTierInfo* FeeDiscountSchedule::mutable_tier_infos(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountSchedule.tier_infos)
  return _internal_mutable_tier_infos()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FeeDiscountTierInfo >*
FeeDiscountSchedule::mutable_tier_infos() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.FeeDiscountSchedule.tier_infos)
  return _internal_mutable_tier_infos();
}
inline const ::injective::exchange::v1beta1::FeeDiscountTierInfo& FeeDiscountSchedule::_internal_tier_infos(int index) const {
  return _internal_tier_infos().Get(index);
}
inline const ::injective::exchange::v1beta1::FeeDiscountTierInfo& FeeDiscountSchedule::tier_infos(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountSchedule.tier_infos)
  return _internal_tier_infos(index);
}
inline ::injective::exchange::v1beta1::FeeDiscountTierInfo* FeeDiscountSchedule::_internal_add_tier_infos() {
  return _internal_mutable_tier_infos()->Add();
}
inline ::injective::exchange::v1beta1::FeeDiscountTierInfo* FeeDiscountSchedule::add_tier_infos() {
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* _add = _internal_add_tier_infos();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.FeeDiscountSchedule.tier_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FeeDiscountTierInfo >&
FeeDiscountSchedule::tier_infos() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.FeeDiscountSchedule.tier_infos)
  return _internal_tier_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FeeDiscountTierInfo>&
FeeDiscountSchedule::_internal_tier_infos() const {
  return _impl_.tier_infos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FeeDiscountTierInfo>*
FeeDiscountSchedule::_internal_mutable_tier_infos() {
  return &_impl_.tier_infos_;
}

// repeated string disqualified_market_ids = 5 [json_name = "disqualifiedMarketIds"];
inline int FeeDiscountSchedule::_internal_disqualified_market_ids_size() const {
  return _impl_.disqualified_market_ids_.size();
}
inline int FeeDiscountSchedule::disqualified_market_ids_size() const {
  return _internal_disqualified_market_ids_size();
}
inline void FeeDiscountSchedule::clear_disqualified_market_ids() {
  _internal_mutable_disqualified_market_ids()->Clear();
}
inline std::string* FeeDiscountSchedule::add_disqualified_market_ids() {
  std::string* _s = _internal_add_disqualified_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
  return _s;
}
inline const std::string& FeeDiscountSchedule::disqualified_market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
  return _internal_disqualified_market_ids(index);
}
inline std::string* FeeDiscountSchedule::mutable_disqualified_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
  return _internal_mutable_disqualified_market_ids()->Mutable(index);
}
inline void FeeDiscountSchedule::set_disqualified_market_ids(int index, const std::string& value) {
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::set_disqualified_market_ids(int index, std::string&& value) {
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::set_disqualified_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::set_disqualified_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::set_disqualified_market_ids(int index, absl::string_view value) {
  _internal_mutable_disqualified_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::add_disqualified_market_ids(const std::string& value) {
  _internal_mutable_disqualified_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::add_disqualified_market_ids(std::string&& value) {
  _internal_mutable_disqualified_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::add_disqualified_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_disqualified_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::add_disqualified_market_ids(const char* value, std::size_t size) {
  _internal_mutable_disqualified_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline void FeeDiscountSchedule::add_disqualified_market_ids(absl::string_view value) {
  _internal_mutable_disqualified_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeeDiscountSchedule::disqualified_market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
  return _internal_disqualified_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* FeeDiscountSchedule::mutable_disqualified_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids)
  return _internal_mutable_disqualified_market_ids();
}
inline const std::string& FeeDiscountSchedule::_internal_disqualified_market_ids(int index) const {
  return _internal_disqualified_market_ids().Get(index);
}
inline std::string* FeeDiscountSchedule::_internal_add_disqualified_market_ids() {
  return _internal_mutable_disqualified_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeeDiscountSchedule::_internal_disqualified_market_ids() const {
  return _impl_.disqualified_market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FeeDiscountSchedule::_internal_mutable_disqualified_market_ids() {
  return &_impl_.disqualified_market_ids_;
}

// -------------------------------------------------------------------

// FeeDiscountTierTTL

// uint64 tier = 1 [json_name = "tier"];
inline void FeeDiscountTierTTL::clear_tier() {
  _impl_.tier_ = ::uint64_t{0u};
}
inline ::uint64_t FeeDiscountTierTTL::tier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountTierTTL.tier)
  return _internal_tier();
}
inline void FeeDiscountTierTTL::set_tier(::uint64_t value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountTierTTL.tier)
}
inline ::uint64_t FeeDiscountTierTTL::_internal_tier() const {
  return _impl_.tier_;
}
inline void FeeDiscountTierTTL::_internal_set_tier(::uint64_t value) {
  ;
  _impl_.tier_ = value;
}

// int64 ttl_timestamp = 2 [json_name = "ttlTimestamp"];
inline void FeeDiscountTierTTL::clear_ttl_timestamp() {
  _impl_.ttl_timestamp_ = ::int64_t{0};
}
inline ::int64_t FeeDiscountTierTTL::ttl_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountTierTTL.ttl_timestamp)
  return _internal_ttl_timestamp();
}
inline void FeeDiscountTierTTL::set_ttl_timestamp(::int64_t value) {
  _internal_set_ttl_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountTierTTL.ttl_timestamp)
}
inline ::int64_t FeeDiscountTierTTL::_internal_ttl_timestamp() const {
  return _impl_.ttl_timestamp_;
}
inline void FeeDiscountTierTTL::_internal_set_ttl_timestamp(::int64_t value) {
  ;
  _impl_.ttl_timestamp_ = value;
}

// -------------------------------------------------------------------

// VolumeRecord

// string maker_volume = 1 [json_name = "makerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void VolumeRecord::clear_maker_volume() {
  _impl_.maker_volume_.ClearToEmpty();
}
inline const std::string& VolumeRecord::maker_volume() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.VolumeRecord.maker_volume)
  return _internal_maker_volume();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VolumeRecord::set_maker_volume(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_volume_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.VolumeRecord.maker_volume)
}
inline std::string* VolumeRecord::mutable_maker_volume() {
  std::string* _s = _internal_mutable_maker_volume();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.VolumeRecord.maker_volume)
  return _s;
}
inline const std::string& VolumeRecord::_internal_maker_volume() const {
  return _impl_.maker_volume_.Get();
}
inline void VolumeRecord::_internal_set_maker_volume(const std::string& value) {
  ;


  _impl_.maker_volume_.Set(value, GetArenaForAllocation());
}
inline std::string* VolumeRecord::_internal_mutable_maker_volume() {
  ;
  return _impl_.maker_volume_.Mutable( GetArenaForAllocation());
}
inline std::string* VolumeRecord::release_maker_volume() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.VolumeRecord.maker_volume)
  return _impl_.maker_volume_.Release();
}
inline void VolumeRecord::set_allocated_maker_volume(std::string* value) {
  _impl_.maker_volume_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_volume_.IsDefault()) {
          _impl_.maker_volume_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.VolumeRecord.maker_volume)
}

// string taker_volume = 2 [json_name = "takerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void VolumeRecord::clear_taker_volume() {
  _impl_.taker_volume_.ClearToEmpty();
}
inline const std::string& VolumeRecord::taker_volume() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.VolumeRecord.taker_volume)
  return _internal_taker_volume();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VolumeRecord::set_taker_volume(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_volume_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.VolumeRecord.taker_volume)
}
inline std::string* VolumeRecord::mutable_taker_volume() {
  std::string* _s = _internal_mutable_taker_volume();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.VolumeRecord.taker_volume)
  return _s;
}
inline const std::string& VolumeRecord::_internal_taker_volume() const {
  return _impl_.taker_volume_.Get();
}
inline void VolumeRecord::_internal_set_taker_volume(const std::string& value) {
  ;


  _impl_.taker_volume_.Set(value, GetArenaForAllocation());
}
inline std::string* VolumeRecord::_internal_mutable_taker_volume() {
  ;
  return _impl_.taker_volume_.Mutable( GetArenaForAllocation());
}
inline std::string* VolumeRecord::release_taker_volume() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.VolumeRecord.taker_volume)
  return _impl_.taker_volume_.Release();
}
inline void VolumeRecord::set_allocated_taker_volume(std::string* value) {
  _impl_.taker_volume_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_volume_.IsDefault()) {
          _impl_.taker_volume_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.VolumeRecord.taker_volume)
}

// -------------------------------------------------------------------

// AccountRewards

// string account = 1 [json_name = "account"];
inline void AccountRewards::clear_account() {
  _impl_.account_.ClearToEmpty();
}
inline const std::string& AccountRewards::account() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AccountRewards.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccountRewards::set_account(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.AccountRewards.account)
}
inline std::string* AccountRewards::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AccountRewards.account)
  return _s;
}
inline const std::string& AccountRewards::_internal_account() const {
  return _impl_.account_.Get();
}
inline void AccountRewards::_internal_set_account(const std::string& value) {
  ;


  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountRewards::_internal_mutable_account() {
  ;
  return _impl_.account_.Mutable( GetArenaForAllocation());
}
inline std::string* AccountRewards::release_account() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.AccountRewards.account)
  return _impl_.account_.Release();
}
inline void AccountRewards::set_allocated_account(std::string* value) {
  _impl_.account_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.AccountRewards.account)
}

// repeated .cosmos.base.v1beta1.Coin rewards = 2 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
inline int AccountRewards::_internal_rewards_size() const {
  return _impl_.rewards_.size();
}
inline int AccountRewards::rewards_size() const {
  return _internal_rewards_size();
}
inline ::cosmos::base::v1beta1::Coin* AccountRewards::mutable_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AccountRewards.rewards)
  return _internal_mutable_rewards()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
AccountRewards::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.AccountRewards.rewards)
  return _internal_mutable_rewards();
}
inline const ::cosmos::base::v1beta1::Coin& AccountRewards::_internal_rewards(int index) const {
  return _internal_rewards().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& AccountRewards::rewards(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AccountRewards.rewards)
  return _internal_rewards(index);
}
inline ::cosmos::base::v1beta1::Coin* AccountRewards::_internal_add_rewards() {
  return _internal_mutable_rewards()->Add();
}
inline ::cosmos::base::v1beta1::Coin* AccountRewards::add_rewards() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_rewards();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.AccountRewards.rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
AccountRewards::rewards() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.AccountRewards.rewards)
  return _internal_rewards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
AccountRewards::_internal_rewards() const {
  return _impl_.rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
AccountRewards::_internal_mutable_rewards() {
  return &_impl_.rewards_;
}

// -------------------------------------------------------------------

// TradeRecords

// string market_id = 1 [json_name = "marketId"];
inline void TradeRecords::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& TradeRecords::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeRecords.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeRecords::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeRecords.market_id)
}
inline std::string* TradeRecords::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeRecords.market_id)
  return _s;
}
inline const std::string& TradeRecords::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void TradeRecords::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeRecords::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeRecords::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeRecords.market_id)
  return _impl_.market_id_.Release();
}
inline void TradeRecords::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeRecords.market_id)
}

// repeated .injective.exchange.v1beta1.TradeRecord latest_trade_records = 2 [json_name = "latestTradeRecords"];
inline int TradeRecords::_internal_latest_trade_records_size() const {
  return _impl_.latest_trade_records_.size();
}
inline int TradeRecords::latest_trade_records_size() const {
  return _internal_latest_trade_records_size();
}
inline void TradeRecords::clear_latest_trade_records() {
  _internal_mutable_latest_trade_records()->Clear();
}
inline ::injective::exchange::v1beta1::TradeRecord* TradeRecords::mutable_latest_trade_records(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeRecords.latest_trade_records)
  return _internal_mutable_latest_trade_records()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord >*
TradeRecords::mutable_latest_trade_records() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradeRecords.latest_trade_records)
  return _internal_mutable_latest_trade_records();
}
inline const ::injective::exchange::v1beta1::TradeRecord& TradeRecords::_internal_latest_trade_records(int index) const {
  return _internal_latest_trade_records().Get(index);
}
inline const ::injective::exchange::v1beta1::TradeRecord& TradeRecords::latest_trade_records(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeRecords.latest_trade_records)
  return _internal_latest_trade_records(index);
}
inline ::injective::exchange::v1beta1::TradeRecord* TradeRecords::_internal_add_latest_trade_records() {
  return _internal_mutable_latest_trade_records()->Add();
}
inline ::injective::exchange::v1beta1::TradeRecord* TradeRecords::add_latest_trade_records() {
  ::injective::exchange::v1beta1::TradeRecord* _add = _internal_add_latest_trade_records();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradeRecords.latest_trade_records)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord >&
TradeRecords::latest_trade_records() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradeRecords.latest_trade_records)
  return _internal_latest_trade_records();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecord>&
TradeRecords::_internal_latest_trade_records() const {
  return _impl_.latest_trade_records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecord>*
TradeRecords::_internal_mutable_latest_trade_records() {
  return &_impl_.latest_trade_records_;
}

// -------------------------------------------------------------------

// SubaccountIDs

// repeated bytes subaccount_ids = 1 [json_name = "subaccountIds"];
inline int SubaccountIDs::_internal_subaccount_ids_size() const {
  return _impl_.subaccount_ids_.size();
}
inline int SubaccountIDs::subaccount_ids_size() const {
  return _internal_subaccount_ids_size();
}
inline void SubaccountIDs::clear_subaccount_ids() {
  _internal_mutable_subaccount_ids()->Clear();
}
inline std::string* SubaccountIDs::add_subaccount_ids() {
  std::string* _s = _internal_add_subaccount_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
  return _s;
}
inline const std::string& SubaccountIDs::subaccount_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
  return _internal_subaccount_ids(index);
}
inline std::string* SubaccountIDs::mutable_subaccount_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
  return _internal_mutable_subaccount_ids()->Mutable(index);
}
inline void SubaccountIDs::set_subaccount_ids(int index, const std::string& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::set_subaccount_ids(int index, std::string&& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::set_subaccount_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::set_subaccount_ids(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::set_subaccount_ids(int index, absl::string_view value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::add_subaccount_ids(const std::string& value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::add_subaccount_ids(std::string&& value) {
  _internal_mutable_subaccount_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::add_subaccount_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::add_subaccount_ids(const void* value, std::size_t size) {
  _internal_mutable_subaccount_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline void SubaccountIDs::add_subaccount_ids(absl::string_view value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubaccountIDs::subaccount_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
  return _internal_subaccount_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SubaccountIDs::mutable_subaccount_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.SubaccountIDs.subaccount_ids)
  return _internal_mutable_subaccount_ids();
}
inline const std::string& SubaccountIDs::_internal_subaccount_ids(int index) const {
  return _internal_subaccount_ids().Get(index);
}
inline std::string* SubaccountIDs::_internal_add_subaccount_ids() {
  return _internal_mutable_subaccount_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubaccountIDs::_internal_subaccount_ids() const {
  return _impl_.subaccount_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubaccountIDs::_internal_mutable_subaccount_ids() {
  return &_impl_.subaccount_ids_;
}

// -------------------------------------------------------------------

// TradeRecord

// int64 timestamp = 1 [json_name = "timestamp"];
inline void TradeRecord::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t TradeRecord::timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeRecord.timestamp)
  return _internal_timestamp();
}
inline void TradeRecord::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeRecord.timestamp)
}
inline ::int64_t TradeRecord::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void TradeRecord::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TradeRecord::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& TradeRecord::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeRecord.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeRecord::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeRecord.price)
}
inline std::string* TradeRecord::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeRecord.price)
  return _s;
}
inline const std::string& TradeRecord::_internal_price() const {
  return _impl_.price_.Get();
}
inline void TradeRecord::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeRecord::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeRecord::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeRecord.price)
  return _impl_.price_.Release();
}
inline void TradeRecord::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeRecord.price)
}

// string quantity = 3 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TradeRecord::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& TradeRecord::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeRecord.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeRecord::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeRecord.quantity)
}
inline std::string* TradeRecord::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradeRecord.quantity)
  return _s;
}
inline const std::string& TradeRecord::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void TradeRecord::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeRecord::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* TradeRecord::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradeRecord.quantity)
  return _impl_.quantity_.Release();
}
inline void TradeRecord::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradeRecord.quantity)
}

// -------------------------------------------------------------------

// Level

// string p = 1 [json_name = "p", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Level::clear_p() {
  _impl_.p_.ClearToEmpty();
}
inline const std::string& Level::p() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Level.p)
  return _internal_p();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Level::set_p(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.p_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Level.p)
}
inline std::string* Level::mutable_p() {
  std::string* _s = _internal_mutable_p();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Level.p)
  return _s;
}
inline const std::string& Level::_internal_p() const {
  return _impl_.p_.Get();
}
inline void Level::_internal_set_p(const std::string& value) {
  ;


  _impl_.p_.Set(value, GetArenaForAllocation());
}
inline std::string* Level::_internal_mutable_p() {
  ;
  return _impl_.p_.Mutable( GetArenaForAllocation());
}
inline std::string* Level::release_p() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Level.p)
  return _impl_.p_.Release();
}
inline void Level::set_allocated_p(std::string* value) {
  _impl_.p_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.p_.IsDefault()) {
          _impl_.p_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Level.p)
}

// string q = 2 [json_name = "q", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Level::clear_q() {
  _impl_.q_.ClearToEmpty();
}
inline const std::string& Level::q() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Level.q)
  return _internal_q();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Level::set_q(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.q_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Level.q)
}
inline std::string* Level::mutable_q() {
  std::string* _s = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Level.q)
  return _s;
}
inline const std::string& Level::_internal_q() const {
  return _impl_.q_.Get();
}
inline void Level::_internal_set_q(const std::string& value) {
  ;


  _impl_.q_.Set(value, GetArenaForAllocation());
}
inline std::string* Level::_internal_mutable_q() {
  ;
  return _impl_.q_.Mutable( GetArenaForAllocation());
}
inline std::string* Level::release_q() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Level.q)
  return _impl_.q_.Release();
}
inline void Level::set_allocated_q(std::string* value) {
  _impl_.q_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.q_.IsDefault()) {
          _impl_.q_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Level.q)
}

// -------------------------------------------------------------------

// AggregateSubaccountVolumeRecord

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void AggregateSubaccountVolumeRecord::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& AggregateSubaccountVolumeRecord::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggregateSubaccountVolumeRecord::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.subaccount_id)
}
inline std::string* AggregateSubaccountVolumeRecord::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.subaccount_id)
  return _s;
}
inline const std::string& AggregateSubaccountVolumeRecord::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void AggregateSubaccountVolumeRecord::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregateSubaccountVolumeRecord::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* AggregateSubaccountVolumeRecord::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void AggregateSubaccountVolumeRecord::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.subaccount_id)
}

// repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
inline int AggregateSubaccountVolumeRecord::_internal_market_volumes_size() const {
  return _impl_.market_volumes_.size();
}
inline int AggregateSubaccountVolumeRecord::market_volumes_size() const {
  return _internal_market_volumes_size();
}
inline void AggregateSubaccountVolumeRecord::clear_market_volumes() {
  _internal_mutable_market_volumes()->Clear();
}
inline ::injective::exchange::v1beta1::MarketVolume* AggregateSubaccountVolumeRecord::mutable_market_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.market_volumes)
  return _internal_mutable_market_volumes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
AggregateSubaccountVolumeRecord::mutable_market_volumes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.market_volumes)
  return _internal_mutable_market_volumes();
}
inline const ::injective::exchange::v1beta1::MarketVolume& AggregateSubaccountVolumeRecord::_internal_market_volumes(int index) const {
  return _internal_market_volumes().Get(index);
}
inline const ::injective::exchange::v1beta1::MarketVolume& AggregateSubaccountVolumeRecord::market_volumes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.market_volumes)
  return _internal_market_volumes(index);
}
inline ::injective::exchange::v1beta1::MarketVolume* AggregateSubaccountVolumeRecord::_internal_add_market_volumes() {
  return _internal_mutable_market_volumes()->Add();
}
inline ::injective::exchange::v1beta1::MarketVolume* AggregateSubaccountVolumeRecord::add_market_volumes() {
  ::injective::exchange::v1beta1::MarketVolume* _add = _internal_add_market_volumes();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.market_volumes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
AggregateSubaccountVolumeRecord::market_volumes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.market_volumes)
  return _internal_market_volumes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>&
AggregateSubaccountVolumeRecord::_internal_market_volumes() const {
  return _impl_.market_volumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>*
AggregateSubaccountVolumeRecord::_internal_mutable_market_volumes() {
  return &_impl_.market_volumes_;
}

// -------------------------------------------------------------------

// AggregateAccountVolumeRecord

// string account = 1 [json_name = "account"];
inline void AggregateAccountVolumeRecord::clear_account() {
  _impl_.account_.ClearToEmpty();
}
inline const std::string& AggregateAccountVolumeRecord::account() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AggregateAccountVolumeRecord.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggregateAccountVolumeRecord::set_account(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.AggregateAccountVolumeRecord.account)
}
inline std::string* AggregateAccountVolumeRecord::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AggregateAccountVolumeRecord.account)
  return _s;
}
inline const std::string& AggregateAccountVolumeRecord::_internal_account() const {
  return _impl_.account_.Get();
}
inline void AggregateAccountVolumeRecord::_internal_set_account(const std::string& value) {
  ;


  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregateAccountVolumeRecord::_internal_mutable_account() {
  ;
  return _impl_.account_.Mutable( GetArenaForAllocation());
}
inline std::string* AggregateAccountVolumeRecord::release_account() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.AggregateAccountVolumeRecord.account)
  return _impl_.account_.Release();
}
inline void AggregateAccountVolumeRecord::set_allocated_account(std::string* value) {
  _impl_.account_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.AggregateAccountVolumeRecord.account)
}

// repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
inline int AggregateAccountVolumeRecord::_internal_market_volumes_size() const {
  return _impl_.market_volumes_.size();
}
inline int AggregateAccountVolumeRecord::market_volumes_size() const {
  return _internal_market_volumes_size();
}
inline void AggregateAccountVolumeRecord::clear_market_volumes() {
  _internal_mutable_market_volumes()->Clear();
}
inline ::injective::exchange::v1beta1::MarketVolume* AggregateAccountVolumeRecord::mutable_market_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AggregateAccountVolumeRecord.market_volumes)
  return _internal_mutable_market_volumes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
AggregateAccountVolumeRecord::mutable_market_volumes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.AggregateAccountVolumeRecord.market_volumes)
  return _internal_mutable_market_volumes();
}
inline const ::injective::exchange::v1beta1::MarketVolume& AggregateAccountVolumeRecord::_internal_market_volumes(int index) const {
  return _internal_market_volumes().Get(index);
}
inline const ::injective::exchange::v1beta1::MarketVolume& AggregateAccountVolumeRecord::market_volumes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AggregateAccountVolumeRecord.market_volumes)
  return _internal_market_volumes(index);
}
inline ::injective::exchange::v1beta1::MarketVolume* AggregateAccountVolumeRecord::_internal_add_market_volumes() {
  return _internal_mutable_market_volumes()->Add();
}
inline ::injective::exchange::v1beta1::MarketVolume* AggregateAccountVolumeRecord::add_market_volumes() {
  ::injective::exchange::v1beta1::MarketVolume* _add = _internal_add_market_volumes();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.AggregateAccountVolumeRecord.market_volumes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
AggregateAccountVolumeRecord::market_volumes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.AggregateAccountVolumeRecord.market_volumes)
  return _internal_market_volumes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>&
AggregateAccountVolumeRecord::_internal_market_volumes() const {
  return _impl_.market_volumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>*
AggregateAccountVolumeRecord::_internal_mutable_market_volumes() {
  return &_impl_.market_volumes_;
}

// -------------------------------------------------------------------

// MarketVolume

// string market_id = 1 [json_name = "marketId"];
inline void MarketVolume::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MarketVolume::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketVolume.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketVolume::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketVolume.market_id)
}
inline std::string* MarketVolume::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketVolume.market_id)
  return _s;
}
inline const std::string& MarketVolume::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MarketVolume::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketVolume::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketVolume::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketVolume.market_id)
  return _impl_.market_id_.Release();
}
inline void MarketVolume::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketVolume.market_id)
}

// .injective.exchange.v1beta1.VolumeRecord volume = 2 [json_name = "volume", (.gogoproto.nullable) = false];
inline bool MarketVolume::has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_ != nullptr);
  return value;
}
inline void MarketVolume::clear_volume() {
  if (_impl_.volume_ != nullptr) _impl_.volume_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::VolumeRecord& MarketVolume::_internal_volume() const {
  const ::injective::exchange::v1beta1::VolumeRecord* p = _impl_.volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::VolumeRecord&>(
      ::injective::exchange::v1beta1::_VolumeRecord_default_instance_);
}
inline const ::injective::exchange::v1beta1::VolumeRecord& MarketVolume::volume() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketVolume.volume)
  return _internal_volume();
}
inline void MarketVolume::unsafe_arena_set_allocated_volume(
    ::injective::exchange::v1beta1::VolumeRecord* volume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.volume_);
  }
  _impl_.volume_ = volume;
  if (volume) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MarketVolume.volume)
}
inline ::injective::exchange::v1beta1::VolumeRecord* MarketVolume::release_volume() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::VolumeRecord* temp = _impl_.volume_;
  _impl_.volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::VolumeRecord* MarketVolume::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketVolume.volume)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::VolumeRecord* temp = _impl_.volume_;
  _impl_.volume_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::VolumeRecord* MarketVolume::_internal_mutable_volume() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::VolumeRecord>(GetArenaForAllocation());
    _impl_.volume_ = p;
  }
  return _impl_.volume_;
}
inline ::injective::exchange::v1beta1::VolumeRecord* MarketVolume::mutable_volume() {
  ::injective::exchange::v1beta1::VolumeRecord* _msg = _internal_mutable_volume();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketVolume.volume)
  return _msg;
}
inline void MarketVolume::set_allocated_volume(::injective::exchange::v1beta1::VolumeRecord* volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.volume_;
  }
  if (volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(volume);
    if (message_arena != submessage_arena) {
      volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketVolume.volume)
}

// -------------------------------------------------------------------

// DenomDecimals

// string denom = 1 [json_name = "denom"];
inline void DenomDecimals::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& DenomDecimals::denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DenomDecimals.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DenomDecimals::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DenomDecimals.denom)
}
inline std::string* DenomDecimals::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DenomDecimals.denom)
  return _s;
}
inline const std::string& DenomDecimals::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void DenomDecimals::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* DenomDecimals::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* DenomDecimals::release_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DenomDecimals.denom)
  return _impl_.denom_.Release();
}
inline void DenomDecimals::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DenomDecimals.denom)
}

// uint64 decimals = 2 [json_name = "decimals"];
inline void DenomDecimals::clear_decimals() {
  _impl_.decimals_ = ::uint64_t{0u};
}
inline ::uint64_t DenomDecimals::decimals() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DenomDecimals.decimals)
  return _internal_decimals();
}
inline void DenomDecimals::set_decimals(::uint64_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DenomDecimals.decimals)
}
inline ::uint64_t DenomDecimals::_internal_decimals() const {
  return _impl_.decimals_;
}
inline void DenomDecimals::_internal_set_decimals(::uint64_t value) {
  ;
  _impl_.decimals_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel>() {
  return ::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel_descriptor();
}
template <>
struct is_proto_enum<::injective::exchange::v1beta1::MarketStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::exchange::v1beta1::MarketStatus>() {
  return ::injective::exchange::v1beta1::MarketStatus_descriptor();
}
template <>
struct is_proto_enum<::injective::exchange::v1beta1::OrderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::exchange::v1beta1::OrderType>() {
  return ::injective::exchange::v1beta1::OrderType_descriptor();
}
template <>
struct is_proto_enum<::injective::exchange::v1beta1::ExecutionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::exchange::v1beta1::ExecutionType>() {
  return ::injective::exchange::v1beta1::ExecutionType_descriptor();
}
template <>
struct is_proto_enum<::injective::exchange::v1beta1::OrderMask> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::exchange::v1beta1::OrderMask>() {
  return ::injective::exchange::v1beta1::OrderMask_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fexchange_2eproto_2epb_2eh
