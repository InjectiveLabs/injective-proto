// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/wasmx/v1/tx.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2fwasmx_2fv1_2ftx_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2fwasmx_2fv1_2ftx_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "google/protobuf/any.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "cosmos/msg/v1/msg.pb.h"
#include "injective/wasmx/v1/wasmx.pb.h"
#include "injective/wasmx/v1/proposal.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2fwasmx_2fv1_2ftx_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2fwasmx_2fv1_2ftx_2eproto;
namespace injective {
namespace wasmx {
namespace v1 {
class MsgActivateContract;
struct MsgActivateContractDefaultTypeInternal;
extern MsgActivateContractDefaultTypeInternal _MsgActivateContract_default_instance_;
class MsgActivateContractResponse;
struct MsgActivateContractResponseDefaultTypeInternal;
extern MsgActivateContractResponseDefaultTypeInternal _MsgActivateContractResponse_default_instance_;
class MsgDeactivateContract;
struct MsgDeactivateContractDefaultTypeInternal;
extern MsgDeactivateContractDefaultTypeInternal _MsgDeactivateContract_default_instance_;
class MsgDeactivateContractResponse;
struct MsgDeactivateContractResponseDefaultTypeInternal;
extern MsgDeactivateContractResponseDefaultTypeInternal _MsgDeactivateContractResponse_default_instance_;
class MsgExecuteContractCompat;
struct MsgExecuteContractCompatDefaultTypeInternal;
extern MsgExecuteContractCompatDefaultTypeInternal _MsgExecuteContractCompat_default_instance_;
class MsgExecuteContractCompatResponse;
struct MsgExecuteContractCompatResponseDefaultTypeInternal;
extern MsgExecuteContractCompatResponseDefaultTypeInternal _MsgExecuteContractCompatResponse_default_instance_;
class MsgRegisterContract;
struct MsgRegisterContractDefaultTypeInternal;
extern MsgRegisterContractDefaultTypeInternal _MsgRegisterContract_default_instance_;
class MsgRegisterContractResponse;
struct MsgRegisterContractResponseDefaultTypeInternal;
extern MsgRegisterContractResponseDefaultTypeInternal _MsgRegisterContractResponse_default_instance_;
class MsgUpdateContract;
struct MsgUpdateContractDefaultTypeInternal;
extern MsgUpdateContractDefaultTypeInternal _MsgUpdateContract_default_instance_;
class MsgUpdateContractResponse;
struct MsgUpdateContractResponseDefaultTypeInternal;
extern MsgUpdateContractResponseDefaultTypeInternal _MsgUpdateContractResponse_default_instance_;
class MsgUpdateParams;
struct MsgUpdateParamsDefaultTypeInternal;
extern MsgUpdateParamsDefaultTypeInternal _MsgUpdateParams_default_instance_;
class MsgUpdateParamsResponse;
struct MsgUpdateParamsResponseDefaultTypeInternal;
extern MsgUpdateParamsResponseDefaultTypeInternal _MsgUpdateParamsResponse_default_instance_;
}  // namespace v1
}  // namespace wasmx
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::wasmx::v1::MsgActivateContract* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgActivateContract>(Arena*);
template <>
::injective::wasmx::v1::MsgActivateContractResponse* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgActivateContractResponse>(Arena*);
template <>
::injective::wasmx::v1::MsgDeactivateContract* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgDeactivateContract>(Arena*);
template <>
::injective::wasmx::v1::MsgDeactivateContractResponse* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgDeactivateContractResponse>(Arena*);
template <>
::injective::wasmx::v1::MsgExecuteContractCompat* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgExecuteContractCompat>(Arena*);
template <>
::injective::wasmx::v1::MsgExecuteContractCompatResponse* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgExecuteContractCompatResponse>(Arena*);
template <>
::injective::wasmx::v1::MsgRegisterContract* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgRegisterContract>(Arena*);
template <>
::injective::wasmx::v1::MsgRegisterContractResponse* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgRegisterContractResponse>(Arena*);
template <>
::injective::wasmx::v1::MsgUpdateContract* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgUpdateContract>(Arena*);
template <>
::injective::wasmx::v1::MsgUpdateContractResponse* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgUpdateContractResponse>(Arena*);
template <>
::injective::wasmx::v1::MsgUpdateParams* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgUpdateParams>(Arena*);
template <>
::injective::wasmx::v1::MsgUpdateParamsResponse* Arena::CreateMaybeMessage<::injective::wasmx::v1::MsgUpdateParamsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace wasmx {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class MsgExecuteContractCompat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgExecuteContractCompat) */ {
 public:
  inline MsgExecuteContractCompat() : MsgExecuteContractCompat(nullptr) {}
  ~MsgExecuteContractCompat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgExecuteContractCompat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgExecuteContractCompat(const MsgExecuteContractCompat& from);
  MsgExecuteContractCompat(MsgExecuteContractCompat&& from) noexcept
    : MsgExecuteContractCompat() {
    *this = ::std::move(from);
  }

  inline MsgExecuteContractCompat& operator=(const MsgExecuteContractCompat& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgExecuteContractCompat& operator=(MsgExecuteContractCompat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgExecuteContractCompat& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgExecuteContractCompat* internal_default_instance() {
    return reinterpret_cast<const MsgExecuteContractCompat*>(
               &_MsgExecuteContractCompat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgExecuteContractCompat& a, MsgExecuteContractCompat& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgExecuteContractCompat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgExecuteContractCompat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgExecuteContractCompat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgExecuteContractCompat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgExecuteContractCompat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgExecuteContractCompat& from) {
    MsgExecuteContractCompat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgExecuteContractCompat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgExecuteContractCompat";
  }
  protected:
  explicit MsgExecuteContractCompat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContractFieldNumber = 2,
    kMsgFieldNumber = 3,
    kFundsFieldNumber = 4,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string contract = 2 [json_name = "contract"];
  void clear_contract() ;
  const std::string& contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract(Arg_&& arg, Args_... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* ptr);

  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(
      const std::string& value);
  std::string* _internal_mutable_contract();

  public:
  // string msg = 3 [json_name = "msg"];
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // string funds = 4 [json_name = "funds"];
  void clear_funds() ;
  const std::string& funds() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_funds(Arg_&& arg, Args_... args);
  std::string* mutable_funds();
  PROTOBUF_NODISCARD std::string* release_funds();
  void set_allocated_funds(std::string* ptr);

  private:
  const std::string& _internal_funds() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funds(
      const std::string& value);
  std::string* _internal_mutable_funds();

  public:
  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgExecuteContractCompat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgExecuteContractCompatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgExecuteContractCompatResponse) */ {
 public:
  inline MsgExecuteContractCompatResponse() : MsgExecuteContractCompatResponse(nullptr) {}
  ~MsgExecuteContractCompatResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgExecuteContractCompatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgExecuteContractCompatResponse(const MsgExecuteContractCompatResponse& from);
  MsgExecuteContractCompatResponse(MsgExecuteContractCompatResponse&& from) noexcept
    : MsgExecuteContractCompatResponse() {
    *this = ::std::move(from);
  }

  inline MsgExecuteContractCompatResponse& operator=(const MsgExecuteContractCompatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgExecuteContractCompatResponse& operator=(MsgExecuteContractCompatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgExecuteContractCompatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgExecuteContractCompatResponse* internal_default_instance() {
    return reinterpret_cast<const MsgExecuteContractCompatResponse*>(
               &_MsgExecuteContractCompatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgExecuteContractCompatResponse& a, MsgExecuteContractCompatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgExecuteContractCompatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgExecuteContractCompatResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgExecuteContractCompatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgExecuteContractCompatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgExecuteContractCompatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgExecuteContractCompatResponse& from) {
    MsgExecuteContractCompatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgExecuteContractCompatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgExecuteContractCompatResponse";
  }
  protected:
  explicit MsgExecuteContractCompatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgExecuteContractCompatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgUpdateContract) */ {
 public:
  inline MsgUpdateContract() : MsgUpdateContract(nullptr) {}
  ~MsgUpdateContract() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateContract(const MsgUpdateContract& from);
  MsgUpdateContract(MsgUpdateContract&& from) noexcept
    : MsgUpdateContract() {
    *this = ::std::move(from);
  }

  inline MsgUpdateContract& operator=(const MsgUpdateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateContract& operator=(MsgUpdateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateContract* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateContract*>(
               &_MsgUpdateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgUpdateContract& a, MsgUpdateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateContract* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgUpdateContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgUpdateContract& from) {
    MsgUpdateContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgUpdateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgUpdateContract";
  }
  protected:
  explicit MsgUpdateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContractAddressFieldNumber = 2,
    kAdminAddressFieldNumber = 5,
    kGasLimitFieldNumber = 3,
    kGasPriceFieldNumber = 4,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string contract_address = 2 [json_name = "contractAddress"];
  void clear_contract_address() ;
  const std::string& contract_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_address(Arg_&& arg, Args_... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* ptr);

  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(
      const std::string& value);
  std::string* _internal_mutable_contract_address();

  public:
  // string admin_address = 5 [json_name = "adminAddress", (.gogoproto.nullable) = true];
  void clear_admin_address() ;
  const std::string& admin_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin_address(Arg_&& arg, Args_... args);
  std::string* mutable_admin_address();
  PROTOBUF_NODISCARD std::string* release_admin_address();
  void set_allocated_admin_address(std::string* ptr);

  private:
  const std::string& _internal_admin_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_address(
      const std::string& value);
  std::string* _internal_mutable_admin_address();

  public:
  // uint64 gas_limit = 3 [json_name = "gasLimit"];
  void clear_gas_limit() ;
  ::uint64_t gas_limit() const;
  void set_gas_limit(::uint64_t value);

  private:
  ::uint64_t _internal_gas_limit() const;
  void _internal_set_gas_limit(::uint64_t value);

  public:
  // uint64 gas_price = 4 [json_name = "gasPrice"];
  void clear_gas_price() ;
  ::uint64_t gas_price() const;
  void set_gas_price(::uint64_t value);

  private:
  ::uint64_t _internal_gas_price() const;
  void _internal_set_gas_price(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgUpdateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_address_;
    ::uint64_t gas_limit_;
    ::uint64_t gas_price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateContractResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgUpdateContractResponse) */ {
 public:
  inline MsgUpdateContractResponse() : MsgUpdateContractResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateContractResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateContractResponse(const MsgUpdateContractResponse& from);
  MsgUpdateContractResponse(MsgUpdateContractResponse&& from) noexcept
    : MsgUpdateContractResponse() {
    *this = ::std::move(from);
  }

  inline MsgUpdateContractResponse& operator=(const MsgUpdateContractResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateContractResponse& operator=(MsgUpdateContractResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateContractResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateContractResponse* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateContractResponse*>(
               &_MsgUpdateContractResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgUpdateContractResponse& a, MsgUpdateContractResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateContractResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateContractResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateContractResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateContractResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgUpdateContractResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgUpdateContractResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgUpdateContractResponse";
  }
  protected:
  explicit MsgUpdateContractResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgUpdateContractResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgActivateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgActivateContract) */ {
 public:
  inline MsgActivateContract() : MsgActivateContract(nullptr) {}
  ~MsgActivateContract() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgActivateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgActivateContract(const MsgActivateContract& from);
  MsgActivateContract(MsgActivateContract&& from) noexcept
    : MsgActivateContract() {
    *this = ::std::move(from);
  }

  inline MsgActivateContract& operator=(const MsgActivateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgActivateContract& operator=(MsgActivateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgActivateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgActivateContract* internal_default_instance() {
    return reinterpret_cast<const MsgActivateContract*>(
               &_MsgActivateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MsgActivateContract& a, MsgActivateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgActivateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgActivateContract* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgActivateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgActivateContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgActivateContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgActivateContract& from) {
    MsgActivateContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgActivateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgActivateContract";
  }
  protected:
  explicit MsgActivateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContractAddressFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string contract_address = 2 [json_name = "contractAddress"];
  void clear_contract_address() ;
  const std::string& contract_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_address(Arg_&& arg, Args_... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* ptr);

  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(
      const std::string& value);
  std::string* _internal_mutable_contract_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgActivateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgActivateContractResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgActivateContractResponse) */ {
 public:
  inline MsgActivateContractResponse() : MsgActivateContractResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgActivateContractResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgActivateContractResponse(const MsgActivateContractResponse& from);
  MsgActivateContractResponse(MsgActivateContractResponse&& from) noexcept
    : MsgActivateContractResponse() {
    *this = ::std::move(from);
  }

  inline MsgActivateContractResponse& operator=(const MsgActivateContractResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgActivateContractResponse& operator=(MsgActivateContractResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgActivateContractResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgActivateContractResponse* internal_default_instance() {
    return reinterpret_cast<const MsgActivateContractResponse*>(
               &_MsgActivateContractResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MsgActivateContractResponse& a, MsgActivateContractResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgActivateContractResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgActivateContractResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgActivateContractResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgActivateContractResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgActivateContractResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgActivateContractResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgActivateContractResponse";
  }
  protected:
  explicit MsgActivateContractResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgActivateContractResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgDeactivateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgDeactivateContract) */ {
 public:
  inline MsgDeactivateContract() : MsgDeactivateContract(nullptr) {}
  ~MsgDeactivateContract() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgDeactivateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDeactivateContract(const MsgDeactivateContract& from);
  MsgDeactivateContract(MsgDeactivateContract&& from) noexcept
    : MsgDeactivateContract() {
    *this = ::std::move(from);
  }

  inline MsgDeactivateContract& operator=(const MsgDeactivateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDeactivateContract& operator=(MsgDeactivateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgDeactivateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDeactivateContract* internal_default_instance() {
    return reinterpret_cast<const MsgDeactivateContract*>(
               &_MsgDeactivateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgDeactivateContract& a, MsgDeactivateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDeactivateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDeactivateContract* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDeactivateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDeactivateContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgDeactivateContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgDeactivateContract& from) {
    MsgDeactivateContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgDeactivateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgDeactivateContract";
  }
  protected:
  explicit MsgDeactivateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContractAddressFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string contract_address = 2 [json_name = "contractAddress"];
  void clear_contract_address() ;
  const std::string& contract_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_address(Arg_&& arg, Args_... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* ptr);

  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(
      const std::string& value);
  std::string* _internal_mutable_contract_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgDeactivateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgDeactivateContractResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgDeactivateContractResponse) */ {
 public:
  inline MsgDeactivateContractResponse() : MsgDeactivateContractResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgDeactivateContractResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDeactivateContractResponse(const MsgDeactivateContractResponse& from);
  MsgDeactivateContractResponse(MsgDeactivateContractResponse&& from) noexcept
    : MsgDeactivateContractResponse() {
    *this = ::std::move(from);
  }

  inline MsgDeactivateContractResponse& operator=(const MsgDeactivateContractResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDeactivateContractResponse& operator=(MsgDeactivateContractResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgDeactivateContractResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDeactivateContractResponse* internal_default_instance() {
    return reinterpret_cast<const MsgDeactivateContractResponse*>(
               &_MsgDeactivateContractResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MsgDeactivateContractResponse& a, MsgDeactivateContractResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDeactivateContractResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDeactivateContractResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDeactivateContractResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDeactivateContractResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgDeactivateContractResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgDeactivateContractResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgDeactivateContractResponse";
  }
  protected:
  explicit MsgDeactivateContractResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgDeactivateContractResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgUpdateParams) */ {
 public:
  inline MsgUpdateParams() : MsgUpdateParams(nullptr) {}
  ~MsgUpdateParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateParams(const MsgUpdateParams& from);
  MsgUpdateParams(MsgUpdateParams&& from) noexcept
    : MsgUpdateParams() {
    *this = ::std::move(from);
  }

  inline MsgUpdateParams& operator=(const MsgUpdateParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateParams& operator=(MsgUpdateParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateParams* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateParams*>(
               &_MsgUpdateParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MsgUpdateParams& a, MsgUpdateParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgUpdateParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgUpdateParams& from) {
    MsgUpdateParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgUpdateParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgUpdateParams";
  }
  protected:
  explicit MsgUpdateParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorityFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // string authority = 1 [json_name = "authority", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_authority() ;
  const std::string& authority() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_authority(Arg_&& arg, Args_... args);
  std::string* mutable_authority();
  PROTOBUF_NODISCARD std::string* release_authority();
  void set_allocated_authority(std::string* ptr);

  private:
  const std::string& _internal_authority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authority(
      const std::string& value);
  std::string* _internal_mutable_authority();

  public:
  // .injective.wasmx.v1.Params params = 2 [json_name = "params", (.gogoproto.nullable) = false];
  bool has_params() const;
  void clear_params() ;
  const ::injective::wasmx::v1::Params& params() const;
  PROTOBUF_NODISCARD ::injective::wasmx::v1::Params* release_params();
  ::injective::wasmx::v1::Params* mutable_params();
  void set_allocated_params(::injective::wasmx::v1::Params* params);
  private:
  const ::injective::wasmx::v1::Params& _internal_params() const;
  ::injective::wasmx::v1::Params* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::injective::wasmx::v1::Params* params);
  ::injective::wasmx::v1::Params* unsafe_arena_release_params();
  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgUpdateParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authority_;
    ::injective::wasmx::v1::Params* params_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateParamsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgUpdateParamsResponse) */ {
 public:
  inline MsgUpdateParamsResponse() : MsgUpdateParamsResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateParamsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateParamsResponse(const MsgUpdateParamsResponse& from);
  MsgUpdateParamsResponse(MsgUpdateParamsResponse&& from) noexcept
    : MsgUpdateParamsResponse() {
    *this = ::std::move(from);
  }

  inline MsgUpdateParamsResponse& operator=(const MsgUpdateParamsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateParamsResponse& operator=(MsgUpdateParamsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateParamsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateParamsResponse* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateParamsResponse*>(
               &_MsgUpdateParamsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MsgUpdateParamsResponse& a, MsgUpdateParamsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateParamsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateParamsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateParamsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateParamsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgUpdateParamsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgUpdateParamsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgUpdateParamsResponse";
  }
  protected:
  explicit MsgUpdateParamsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgUpdateParamsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRegisterContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgRegisterContract) */ {
 public:
  inline MsgRegisterContract() : MsgRegisterContract(nullptr) {}
  ~MsgRegisterContract() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRegisterContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRegisterContract(const MsgRegisterContract& from);
  MsgRegisterContract(MsgRegisterContract&& from) noexcept
    : MsgRegisterContract() {
    *this = ::std::move(from);
  }

  inline MsgRegisterContract& operator=(const MsgRegisterContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRegisterContract& operator=(MsgRegisterContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRegisterContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRegisterContract* internal_default_instance() {
    return reinterpret_cast<const MsgRegisterContract*>(
               &_MsgRegisterContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MsgRegisterContract& a, MsgRegisterContract& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRegisterContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRegisterContract* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRegisterContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRegisterContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgRegisterContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgRegisterContract& from) {
    MsgRegisterContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgRegisterContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgRegisterContract";
  }
  protected:
  explicit MsgRegisterContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContractRegistrationRequestFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .injective.wasmx.v1.ContractRegistrationRequest contract_registration_request = 2 [json_name = "contractRegistrationRequest", (.gogoproto.nullable) = false];
  bool has_contract_registration_request() const;
  void clear_contract_registration_request() ;
  const ::injective::wasmx::v1::ContractRegistrationRequest& contract_registration_request() const;
  PROTOBUF_NODISCARD ::injective::wasmx::v1::ContractRegistrationRequest* release_contract_registration_request();
  ::injective::wasmx::v1::ContractRegistrationRequest* mutable_contract_registration_request();
  void set_allocated_contract_registration_request(::injective::wasmx::v1::ContractRegistrationRequest* contract_registration_request);
  private:
  const ::injective::wasmx::v1::ContractRegistrationRequest& _internal_contract_registration_request() const;
  ::injective::wasmx::v1::ContractRegistrationRequest* _internal_mutable_contract_registration_request();
  public:
  void unsafe_arena_set_allocated_contract_registration_request(
      ::injective::wasmx::v1::ContractRegistrationRequest* contract_registration_request);
  ::injective::wasmx::v1::ContractRegistrationRequest* unsafe_arena_release_contract_registration_request();
  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgRegisterContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::injective::wasmx::v1::ContractRegistrationRequest* contract_registration_request_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRegisterContractResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.wasmx.v1.MsgRegisterContractResponse) */ {
 public:
  inline MsgRegisterContractResponse() : MsgRegisterContractResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRegisterContractResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRegisterContractResponse(const MsgRegisterContractResponse& from);
  MsgRegisterContractResponse(MsgRegisterContractResponse&& from) noexcept
    : MsgRegisterContractResponse() {
    *this = ::std::move(from);
  }

  inline MsgRegisterContractResponse& operator=(const MsgRegisterContractResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRegisterContractResponse& operator=(MsgRegisterContractResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRegisterContractResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRegisterContractResponse* internal_default_instance() {
    return reinterpret_cast<const MsgRegisterContractResponse*>(
               &_MsgRegisterContractResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MsgRegisterContractResponse& a, MsgRegisterContractResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRegisterContractResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRegisterContractResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRegisterContractResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRegisterContractResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgRegisterContractResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgRegisterContractResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.wasmx.v1.MsgRegisterContractResponse";
  }
  protected:
  explicit MsgRegisterContractResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.wasmx.v1.MsgRegisterContractResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fwasmx_2fv1_2ftx_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MsgExecuteContractCompat

// string sender = 1 [json_name = "sender"];
inline void MsgExecuteContractCompat::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgExecuteContractCompat::sender() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgExecuteContractCompat.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgExecuteContractCompat::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgExecuteContractCompat.sender)
}
inline std::string* MsgExecuteContractCompat::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgExecuteContractCompat.sender)
  return _s;
}
inline const std::string& MsgExecuteContractCompat::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgExecuteContractCompat::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompat::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompat::release_sender() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgExecuteContractCompat.sender)
  return _impl_.sender_.Release();
}
inline void MsgExecuteContractCompat::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgExecuteContractCompat.sender)
}

// string contract = 2 [json_name = "contract"];
inline void MsgExecuteContractCompat::clear_contract() {
  _impl_.contract_.ClearToEmpty();
}
inline const std::string& MsgExecuteContractCompat::contract() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgExecuteContractCompat.contract)
  return _internal_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgExecuteContractCompat::set_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgExecuteContractCompat.contract)
}
inline std::string* MsgExecuteContractCompat::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgExecuteContractCompat.contract)
  return _s;
}
inline const std::string& MsgExecuteContractCompat::_internal_contract() const {
  return _impl_.contract_.Get();
}
inline void MsgExecuteContractCompat::_internal_set_contract(const std::string& value) {
  ;


  _impl_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompat::_internal_mutable_contract() {
  ;
  return _impl_.contract_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompat::release_contract() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgExecuteContractCompat.contract)
  return _impl_.contract_.Release();
}
inline void MsgExecuteContractCompat::set_allocated_contract(std::string* value) {
  _impl_.contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_.IsDefault()) {
          _impl_.contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgExecuteContractCompat.contract)
}

// string msg = 3 [json_name = "msg"];
inline void MsgExecuteContractCompat::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& MsgExecuteContractCompat::msg() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgExecuteContractCompat.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgExecuteContractCompat::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgExecuteContractCompat.msg)
}
inline std::string* MsgExecuteContractCompat::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgExecuteContractCompat.msg)
  return _s;
}
inline const std::string& MsgExecuteContractCompat::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void MsgExecuteContractCompat::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompat::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompat::release_msg() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgExecuteContractCompat.msg)
  return _impl_.msg_.Release();
}
inline void MsgExecuteContractCompat::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgExecuteContractCompat.msg)
}

// string funds = 4 [json_name = "funds"];
inline void MsgExecuteContractCompat::clear_funds() {
  _impl_.funds_.ClearToEmpty();
}
inline const std::string& MsgExecuteContractCompat::funds() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgExecuteContractCompat.funds)
  return _internal_funds();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgExecuteContractCompat::set_funds(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.funds_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgExecuteContractCompat.funds)
}
inline std::string* MsgExecuteContractCompat::mutable_funds() {
  std::string* _s = _internal_mutable_funds();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgExecuteContractCompat.funds)
  return _s;
}
inline const std::string& MsgExecuteContractCompat::_internal_funds() const {
  return _impl_.funds_.Get();
}
inline void MsgExecuteContractCompat::_internal_set_funds(const std::string& value) {
  ;


  _impl_.funds_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompat::_internal_mutable_funds() {
  ;
  return _impl_.funds_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompat::release_funds() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgExecuteContractCompat.funds)
  return _impl_.funds_.Release();
}
inline void MsgExecuteContractCompat::set_allocated_funds(std::string* value) {
  _impl_.funds_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.funds_.IsDefault()) {
          _impl_.funds_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgExecuteContractCompat.funds)
}

// -------------------------------------------------------------------

// MsgExecuteContractCompatResponse

// bytes data = 1 [json_name = "data"];
inline void MsgExecuteContractCompatResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& MsgExecuteContractCompatResponse::data() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgExecuteContractCompatResponse.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgExecuteContractCompatResponse::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgExecuteContractCompatResponse.data)
}
inline std::string* MsgExecuteContractCompatResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgExecuteContractCompatResponse.data)
  return _s;
}
inline const std::string& MsgExecuteContractCompatResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void MsgExecuteContractCompatResponse::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompatResponse::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgExecuteContractCompatResponse::release_data() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgExecuteContractCompatResponse.data)
  return _impl_.data_.Release();
}
inline void MsgExecuteContractCompatResponse::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgExecuteContractCompatResponse.data)
}

// -------------------------------------------------------------------

// MsgUpdateContract

// string sender = 1 [json_name = "sender"];
inline void MsgUpdateContract::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgUpdateContract::sender() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgUpdateContract.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateContract::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgUpdateContract.sender)
}
inline std::string* MsgUpdateContract::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgUpdateContract.sender)
  return _s;
}
inline const std::string& MsgUpdateContract::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgUpdateContract::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateContract::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateContract::release_sender() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgUpdateContract.sender)
  return _impl_.sender_.Release();
}
inline void MsgUpdateContract::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgUpdateContract.sender)
}

// string contract_address = 2 [json_name = "contractAddress"];
inline void MsgUpdateContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& MsgUpdateContract::contract_address() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgUpdateContract.contract_address)
  return _internal_contract_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateContract::set_contract_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgUpdateContract.contract_address)
}
inline std::string* MsgUpdateContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgUpdateContract.contract_address)
  return _s;
}
inline const std::string& MsgUpdateContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void MsgUpdateContract::_internal_set_contract_address(const std::string& value) {
  ;


  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateContract::_internal_mutable_contract_address() {
  ;
  return _impl_.contract_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgUpdateContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void MsgUpdateContract::set_allocated_contract_address(std::string* value) {
  _impl_.contract_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_address_.IsDefault()) {
          _impl_.contract_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgUpdateContract.contract_address)
}

// uint64 gas_limit = 3 [json_name = "gasLimit"];
inline void MsgUpdateContract::clear_gas_limit() {
  _impl_.gas_limit_ = ::uint64_t{0u};
}
inline ::uint64_t MsgUpdateContract::gas_limit() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgUpdateContract.gas_limit)
  return _internal_gas_limit();
}
inline void MsgUpdateContract::set_gas_limit(::uint64_t value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgUpdateContract.gas_limit)
}
inline ::uint64_t MsgUpdateContract::_internal_gas_limit() const {
  return _impl_.gas_limit_;
}
inline void MsgUpdateContract::_internal_set_gas_limit(::uint64_t value) {
  ;
  _impl_.gas_limit_ = value;
}

// uint64 gas_price = 4 [json_name = "gasPrice"];
inline void MsgUpdateContract::clear_gas_price() {
  _impl_.gas_price_ = ::uint64_t{0u};
}
inline ::uint64_t MsgUpdateContract::gas_price() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgUpdateContract.gas_price)
  return _internal_gas_price();
}
inline void MsgUpdateContract::set_gas_price(::uint64_t value) {
  _internal_set_gas_price(value);
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgUpdateContract.gas_price)
}
inline ::uint64_t MsgUpdateContract::_internal_gas_price() const {
  return _impl_.gas_price_;
}
inline void MsgUpdateContract::_internal_set_gas_price(::uint64_t value) {
  ;
  _impl_.gas_price_ = value;
}

// string admin_address = 5 [json_name = "adminAddress", (.gogoproto.nullable) = true];
inline void MsgUpdateContract::clear_admin_address() {
  _impl_.admin_address_.ClearToEmpty();
}
inline const std::string& MsgUpdateContract::admin_address() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgUpdateContract.admin_address)
  return _internal_admin_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateContract::set_admin_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgUpdateContract.admin_address)
}
inline std::string* MsgUpdateContract::mutable_admin_address() {
  std::string* _s = _internal_mutable_admin_address();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgUpdateContract.admin_address)
  return _s;
}
inline const std::string& MsgUpdateContract::_internal_admin_address() const {
  return _impl_.admin_address_.Get();
}
inline void MsgUpdateContract::_internal_set_admin_address(const std::string& value) {
  ;


  _impl_.admin_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateContract::_internal_mutable_admin_address() {
  ;
  return _impl_.admin_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateContract::release_admin_address() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgUpdateContract.admin_address)
  return _impl_.admin_address_.Release();
}
inline void MsgUpdateContract::set_allocated_admin_address(std::string* value) {
  _impl_.admin_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_address_.IsDefault()) {
          _impl_.admin_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgUpdateContract.admin_address)
}

// -------------------------------------------------------------------

// MsgUpdateContractResponse

// -------------------------------------------------------------------

// MsgActivateContract

// string sender = 1 [json_name = "sender"];
inline void MsgActivateContract::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgActivateContract::sender() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgActivateContract.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgActivateContract::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgActivateContract.sender)
}
inline std::string* MsgActivateContract::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgActivateContract.sender)
  return _s;
}
inline const std::string& MsgActivateContract::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgActivateContract::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgActivateContract::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgActivateContract::release_sender() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgActivateContract.sender)
  return _impl_.sender_.Release();
}
inline void MsgActivateContract::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgActivateContract.sender)
}

// string contract_address = 2 [json_name = "contractAddress"];
inline void MsgActivateContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& MsgActivateContract::contract_address() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgActivateContract.contract_address)
  return _internal_contract_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgActivateContract::set_contract_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgActivateContract.contract_address)
}
inline std::string* MsgActivateContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgActivateContract.contract_address)
  return _s;
}
inline const std::string& MsgActivateContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void MsgActivateContract::_internal_set_contract_address(const std::string& value) {
  ;


  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgActivateContract::_internal_mutable_contract_address() {
  ;
  return _impl_.contract_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgActivateContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgActivateContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void MsgActivateContract::set_allocated_contract_address(std::string* value) {
  _impl_.contract_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_address_.IsDefault()) {
          _impl_.contract_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgActivateContract.contract_address)
}

// -------------------------------------------------------------------

// MsgActivateContractResponse

// -------------------------------------------------------------------

// MsgDeactivateContract

// string sender = 1 [json_name = "sender"];
inline void MsgDeactivateContract::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgDeactivateContract::sender() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgDeactivateContract.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgDeactivateContract::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgDeactivateContract.sender)
}
inline std::string* MsgDeactivateContract::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgDeactivateContract.sender)
  return _s;
}
inline const std::string& MsgDeactivateContract::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgDeactivateContract::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgDeactivateContract::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgDeactivateContract::release_sender() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgDeactivateContract.sender)
  return _impl_.sender_.Release();
}
inline void MsgDeactivateContract::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgDeactivateContract.sender)
}

// string contract_address = 2 [json_name = "contractAddress"];
inline void MsgDeactivateContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& MsgDeactivateContract::contract_address() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgDeactivateContract.contract_address)
  return _internal_contract_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgDeactivateContract::set_contract_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgDeactivateContract.contract_address)
}
inline std::string* MsgDeactivateContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgDeactivateContract.contract_address)
  return _s;
}
inline const std::string& MsgDeactivateContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void MsgDeactivateContract::_internal_set_contract_address(const std::string& value) {
  ;


  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgDeactivateContract::_internal_mutable_contract_address() {
  ;
  return _impl_.contract_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgDeactivateContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgDeactivateContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void MsgDeactivateContract::set_allocated_contract_address(std::string* value) {
  _impl_.contract_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_address_.IsDefault()) {
          _impl_.contract_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgDeactivateContract.contract_address)
}

// -------------------------------------------------------------------

// MsgDeactivateContractResponse

// -------------------------------------------------------------------

// MsgUpdateParams

// string authority = 1 [json_name = "authority", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void MsgUpdateParams::clear_authority() {
  _impl_.authority_.ClearToEmpty();
}
inline const std::string& MsgUpdateParams::authority() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgUpdateParams.authority)
  return _internal_authority();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateParams::set_authority(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.authority_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgUpdateParams.authority)
}
inline std::string* MsgUpdateParams::mutable_authority() {
  std::string* _s = _internal_mutable_authority();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgUpdateParams.authority)
  return _s;
}
inline const std::string& MsgUpdateParams::_internal_authority() const {
  return _impl_.authority_.Get();
}
inline void MsgUpdateParams::_internal_set_authority(const std::string& value) {
  ;


  _impl_.authority_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateParams::_internal_mutable_authority() {
  ;
  return _impl_.authority_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateParams::release_authority() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgUpdateParams.authority)
  return _impl_.authority_.Release();
}
inline void MsgUpdateParams::set_allocated_authority(std::string* value) {
  _impl_.authority_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.authority_.IsDefault()) {
          _impl_.authority_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgUpdateParams.authority)
}

// .injective.wasmx.v1.Params params = 2 [json_name = "params", (.gogoproto.nullable) = false];
inline bool MsgUpdateParams::has_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline const ::injective::wasmx::v1::Params& MsgUpdateParams::_internal_params() const {
  const ::injective::wasmx::v1::Params* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::wasmx::v1::Params&>(
      ::injective::wasmx::v1::_Params_default_instance_);
}
inline const ::injective::wasmx::v1::Params& MsgUpdateParams::params() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgUpdateParams.params)
  return _internal_params();
}
inline void MsgUpdateParams::unsafe_arena_set_allocated_params(
    ::injective::wasmx::v1::Params* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.wasmx.v1.MsgUpdateParams.params)
}
inline ::injective::wasmx::v1::Params* MsgUpdateParams::release_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::wasmx::v1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::wasmx::v1::Params* MsgUpdateParams::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgUpdateParams.params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::wasmx::v1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::injective::wasmx::v1::Params* MsgUpdateParams::_internal_mutable_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::wasmx::v1::Params>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::injective::wasmx::v1::Params* MsgUpdateParams::mutable_params() {
  ::injective::wasmx::v1::Params* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgUpdateParams.params)
  return _msg;
}
inline void MsgUpdateParams::set_allocated_params(::injective::wasmx::v1::Params* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgUpdateParams.params)
}

// -------------------------------------------------------------------

// MsgUpdateParamsResponse

// -------------------------------------------------------------------

// MsgRegisterContract

// string sender = 1 [json_name = "sender"];
inline void MsgRegisterContract::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgRegisterContract::sender() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgRegisterContract.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterContract::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.wasmx.v1.MsgRegisterContract.sender)
}
inline std::string* MsgRegisterContract::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgRegisterContract.sender)
  return _s;
}
inline const std::string& MsgRegisterContract::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgRegisterContract::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterContract::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterContract::release_sender() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgRegisterContract.sender)
  return _impl_.sender_.Release();
}
inline void MsgRegisterContract::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgRegisterContract.sender)
}

// .injective.wasmx.v1.ContractRegistrationRequest contract_registration_request = 2 [json_name = "contractRegistrationRequest", (.gogoproto.nullable) = false];
inline bool MsgRegisterContract::has_contract_registration_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contract_registration_request_ != nullptr);
  return value;
}
inline const ::injective::wasmx::v1::ContractRegistrationRequest& MsgRegisterContract::_internal_contract_registration_request() const {
  const ::injective::wasmx::v1::ContractRegistrationRequest* p = _impl_.contract_registration_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::wasmx::v1::ContractRegistrationRequest&>(
      ::injective::wasmx::v1::_ContractRegistrationRequest_default_instance_);
}
inline const ::injective::wasmx::v1::ContractRegistrationRequest& MsgRegisterContract::contract_registration_request() const {
  // @@protoc_insertion_point(field_get:injective.wasmx.v1.MsgRegisterContract.contract_registration_request)
  return _internal_contract_registration_request();
}
inline void MsgRegisterContract::unsafe_arena_set_allocated_contract_registration_request(
    ::injective::wasmx::v1::ContractRegistrationRequest* contract_registration_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_registration_request_);
  }
  _impl_.contract_registration_request_ = contract_registration_request;
  if (contract_registration_request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.wasmx.v1.MsgRegisterContract.contract_registration_request)
}
inline ::injective::wasmx::v1::ContractRegistrationRequest* MsgRegisterContract::release_contract_registration_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::wasmx::v1::ContractRegistrationRequest* temp = _impl_.contract_registration_request_;
  _impl_.contract_registration_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::wasmx::v1::ContractRegistrationRequest* MsgRegisterContract::unsafe_arena_release_contract_registration_request() {
  // @@protoc_insertion_point(field_release:injective.wasmx.v1.MsgRegisterContract.contract_registration_request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::wasmx::v1::ContractRegistrationRequest* temp = _impl_.contract_registration_request_;
  _impl_.contract_registration_request_ = nullptr;
  return temp;
}
inline ::injective::wasmx::v1::ContractRegistrationRequest* MsgRegisterContract::_internal_mutable_contract_registration_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contract_registration_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::wasmx::v1::ContractRegistrationRequest>(GetArenaForAllocation());
    _impl_.contract_registration_request_ = p;
  }
  return _impl_.contract_registration_request_;
}
inline ::injective::wasmx::v1::ContractRegistrationRequest* MsgRegisterContract::mutable_contract_registration_request() {
  ::injective::wasmx::v1::ContractRegistrationRequest* _msg = _internal_mutable_contract_registration_request();
  // @@protoc_insertion_point(field_mutable:injective.wasmx.v1.MsgRegisterContract.contract_registration_request)
  return _msg;
}
inline void MsgRegisterContract::set_allocated_contract_registration_request(::injective::wasmx::v1::ContractRegistrationRequest* contract_registration_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_registration_request_);
  }
  if (contract_registration_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contract_registration_request));
    if (message_arena != submessage_arena) {
      contract_registration_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_registration_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contract_registration_request_ = contract_registration_request;
  // @@protoc_insertion_point(field_set_allocated:injective.wasmx.v1.MsgRegisterContract.contract_registration_request)
}

// -------------------------------------------------------------------

// MsgRegisterContractResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace wasmx
}  // namespace injective


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2fwasmx_2fv1_2ftx_2eproto_2epb_2eh
