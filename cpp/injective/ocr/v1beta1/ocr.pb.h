// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/ocr/v1beta1/ocr.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2focr_2fv1beta1_2focr_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2focr_2fv1beta1_2focr_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "gogoproto/gogo.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2focr_2fv1beta1_2focr_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2focr_2fv1beta1_2focr_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto;
namespace injective {
namespace ocr {
namespace v1beta1 {
class ContractConfig;
struct ContractConfigDefaultTypeInternal;
extern ContractConfigDefaultTypeInternal _ContractConfig_default_instance_;
class EpochAndRound;
struct EpochAndRoundDefaultTypeInternal;
extern EpochAndRoundDefaultTypeInternal _EpochAndRound_default_instance_;
class EventAnswerUpdated;
struct EventAnswerUpdatedDefaultTypeInternal;
extern EventAnswerUpdatedDefaultTypeInternal _EventAnswerUpdated_default_instance_;
class EventConfigSet;
struct EventConfigSetDefaultTypeInternal;
extern EventConfigSetDefaultTypeInternal _EventConfigSet_default_instance_;
class EventNewRound;
struct EventNewRoundDefaultTypeInternal;
extern EventNewRoundDefaultTypeInternal _EventNewRound_default_instance_;
class EventNewTransmission;
struct EventNewTransmissionDefaultTypeInternal;
extern EventNewTransmissionDefaultTypeInternal _EventNewTransmission_default_instance_;
class EventOraclePaid;
struct EventOraclePaidDefaultTypeInternal;
extern EventOraclePaidDefaultTypeInternal _EventOraclePaid_default_instance_;
class EventTransmitted;
struct EventTransmittedDefaultTypeInternal;
extern EventTransmittedDefaultTypeInternal _EventTransmitted_default_instance_;
class FeedConfig;
struct FeedConfigDefaultTypeInternal;
extern FeedConfigDefaultTypeInternal _FeedConfig_default_instance_;
class FeedConfigInfo;
struct FeedConfigInfoDefaultTypeInternal;
extern FeedConfigInfoDefaultTypeInternal _FeedConfigInfo_default_instance_;
class FeedProperties;
struct FeedPropertiesDefaultTypeInternal;
extern FeedPropertiesDefaultTypeInternal _FeedProperties_default_instance_;
class GasReimbursements;
struct GasReimbursementsDefaultTypeInternal;
extern GasReimbursementsDefaultTypeInternal _GasReimbursements_default_instance_;
class ModuleParams;
struct ModuleParamsDefaultTypeInternal;
extern ModuleParamsDefaultTypeInternal _ModuleParams_default_instance_;
class OracleObservationsCounts;
struct OracleObservationsCountsDefaultTypeInternal;
extern OracleObservationsCountsDefaultTypeInternal _OracleObservationsCounts_default_instance_;
class Params;
struct ParamsDefaultTypeInternal;
extern ParamsDefaultTypeInternal _Params_default_instance_;
class Payee;
struct PayeeDefaultTypeInternal;
extern PayeeDefaultTypeInternal _Payee_default_instance_;
class Report;
struct ReportDefaultTypeInternal;
extern ReportDefaultTypeInternal _Report_default_instance_;
class ReportToSign;
struct ReportToSignDefaultTypeInternal;
extern ReportToSignDefaultTypeInternal _ReportToSign_default_instance_;
class SetBatchConfigProposal;
struct SetBatchConfigProposalDefaultTypeInternal;
extern SetBatchConfigProposalDefaultTypeInternal _SetBatchConfigProposal_default_instance_;
class SetConfigProposal;
struct SetConfigProposalDefaultTypeInternal;
extern SetConfigProposalDefaultTypeInternal _SetConfigProposal_default_instance_;
class Transmission;
struct TransmissionDefaultTypeInternal;
extern TransmissionDefaultTypeInternal _Transmission_default_instance_;
}  // namespace v1beta1
}  // namespace ocr
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::ocr::v1beta1::ContractConfig* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::ContractConfig>(Arena*);
template <>
::injective::ocr::v1beta1::EpochAndRound* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::EpochAndRound>(Arena*);
template <>
::injective::ocr::v1beta1::EventAnswerUpdated* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::EventAnswerUpdated>(Arena*);
template <>
::injective::ocr::v1beta1::EventConfigSet* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::EventConfigSet>(Arena*);
template <>
::injective::ocr::v1beta1::EventNewRound* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::EventNewRound>(Arena*);
template <>
::injective::ocr::v1beta1::EventNewTransmission* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::EventNewTransmission>(Arena*);
template <>
::injective::ocr::v1beta1::EventOraclePaid* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::EventOraclePaid>(Arena*);
template <>
::injective::ocr::v1beta1::EventTransmitted* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::EventTransmitted>(Arena*);
template <>
::injective::ocr::v1beta1::FeedConfig* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::FeedConfig>(Arena*);
template <>
::injective::ocr::v1beta1::FeedConfigInfo* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::FeedConfigInfo>(Arena*);
template <>
::injective::ocr::v1beta1::FeedProperties* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::FeedProperties>(Arena*);
template <>
::injective::ocr::v1beta1::GasReimbursements* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::GasReimbursements>(Arena*);
template <>
::injective::ocr::v1beta1::ModuleParams* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::ModuleParams>(Arena*);
template <>
::injective::ocr::v1beta1::OracleObservationsCounts* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::OracleObservationsCounts>(Arena*);
template <>
::injective::ocr::v1beta1::Params* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::Params>(Arena*);
template <>
::injective::ocr::v1beta1::Payee* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::Payee>(Arena*);
template <>
::injective::ocr::v1beta1::Report* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::Report>(Arena*);
template <>
::injective::ocr::v1beta1::ReportToSign* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::ReportToSign>(Arena*);
template <>
::injective::ocr::v1beta1::SetBatchConfigProposal* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::SetBatchConfigProposal>(Arena*);
template <>
::injective::ocr::v1beta1::SetConfigProposal* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::SetConfigProposal>(Arena*);
template <>
::injective::ocr::v1beta1::Transmission* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::Transmission>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace ocr {
namespace v1beta1 {

// ===================================================================


// -------------------------------------------------------------------

class Params final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.Params) */ {
 public:
  inline Params() : Params(nullptr) {}
  ~Params() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Params(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Params(const Params& from);
  Params(Params&& from) noexcept
    : Params() {
    *this = ::std::move(from);
  }

  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline Params& operator=(Params&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const Params* internal_default_instance() {
    return reinterpret_cast<const Params*>(
               &_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Params& a, Params& b) {
    a.Swap(&b);
  }
  inline void Swap(Params* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Params* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Params* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Params>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Params& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Params& from) {
    Params::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Params* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.Params";
  }
  protected:
  explicit Params(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkDenomFieldNumber = 1,
    kModuleAdminFieldNumber = 3,
    kPayoutBlockIntervalFieldNumber = 2,
  };
  // string link_denom = 1 [json_name = "linkDenom"];
  void clear_link_denom() ;
  const std::string& link_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_denom(Arg_&& arg, Args_... args);
  std::string* mutable_link_denom();
  PROTOBUF_NODISCARD std::string* release_link_denom();
  void set_allocated_link_denom(std::string* ptr);

  private:
  const std::string& _internal_link_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_denom(
      const std::string& value);
  std::string* _internal_mutable_link_denom();

  public:
  // string module_admin = 3 [json_name = "moduleAdmin"];
  void clear_module_admin() ;
  const std::string& module_admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_module_admin(Arg_&& arg, Args_... args);
  std::string* mutable_module_admin();
  PROTOBUF_NODISCARD std::string* release_module_admin();
  void set_allocated_module_admin(std::string* ptr);

  private:
  const std::string& _internal_module_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_admin(
      const std::string& value);
  std::string* _internal_mutable_module_admin();

  public:
  // uint64 payout_block_interval = 2 [json_name = "payoutBlockInterval"];
  void clear_payout_block_interval() ;
  ::uint64_t payout_block_interval() const;
  void set_payout_block_interval(::uint64_t value);

  private:
  ::uint64_t _internal_payout_block_interval() const;
  void _internal_set_payout_block_interval(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.Params)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_admin_;
    ::uint64_t payout_block_interval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class FeedConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.FeedConfig) */ {
 public:
  inline FeedConfig() : FeedConfig(nullptr) {}
  ~FeedConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeedConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedConfig(const FeedConfig& from);
  FeedConfig(FeedConfig&& from) noexcept
    : FeedConfig() {
    *this = ::std::move(from);
  }

  inline FeedConfig& operator=(const FeedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedConfig& operator=(FeedConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedConfig* internal_default_instance() {
    return reinterpret_cast<const FeedConfig*>(
               &_FeedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FeedConfig& a, FeedConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedConfig& from) {
    FeedConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.FeedConfig";
  }
  protected:
  explicit FeedConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignersFieldNumber = 1,
    kTransmittersFieldNumber = 2,
    kOnchainConfigFieldNumber = 4,
    kOffchainConfigFieldNumber = 6,
    kModuleParamsFieldNumber = 7,
    kOffchainConfigVersionFieldNumber = 5,
    kFFieldNumber = 3,
  };
  // repeated string signers = 1 [json_name = "signers"];
  int signers_size() const;
  private:
  int _internal_signers_size() const;

  public:
  void clear_signers() ;
  const std::string& signers(int index) const;
  std::string* mutable_signers(int index);
  void set_signers(int index, const std::string& value);
  void set_signers(int index, std::string&& value);
  void set_signers(int index, const char* value);
  void set_signers(int index, const char* value, std::size_t size);
  void set_signers(int index, absl::string_view value);
  std::string* add_signers();
  void add_signers(const std::string& value);
  void add_signers(std::string&& value);
  void add_signers(const char* value);
  void add_signers(const char* value, std::size_t size);
  void add_signers(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signers();

  private:
  const std::string& _internal_signers(int index) const;
  std::string* _internal_add_signers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_signers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_signers();

  public:
  // repeated string transmitters = 2 [json_name = "transmitters"];
  int transmitters_size() const;
  private:
  int _internal_transmitters_size() const;

  public:
  void clear_transmitters() ;
  const std::string& transmitters(int index) const;
  std::string* mutable_transmitters(int index);
  void set_transmitters(int index, const std::string& value);
  void set_transmitters(int index, std::string&& value);
  void set_transmitters(int index, const char* value);
  void set_transmitters(int index, const char* value, std::size_t size);
  void set_transmitters(int index, absl::string_view value);
  std::string* add_transmitters();
  void add_transmitters(const std::string& value);
  void add_transmitters(std::string&& value);
  void add_transmitters(const char* value);
  void add_transmitters(const char* value, std::size_t size);
  void add_transmitters(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transmitters();

  private:
  const std::string& _internal_transmitters(int index) const;
  std::string* _internal_add_transmitters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_transmitters();

  public:
  // bytes onchain_config = 4 [json_name = "onchainConfig"];
  void clear_onchain_config() ;
  const std::string& onchain_config() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_onchain_config(Arg_&& arg, Args_... args);
  std::string* mutable_onchain_config();
  PROTOBUF_NODISCARD std::string* release_onchain_config();
  void set_allocated_onchain_config(std::string* ptr);

  private:
  const std::string& _internal_onchain_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onchain_config(
      const std::string& value);
  std::string* _internal_mutable_onchain_config();

  public:
  // bytes offchain_config = 6 [json_name = "offchainConfig"];
  void clear_offchain_config() ;
  const std::string& offchain_config() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_offchain_config(Arg_&& arg, Args_... args);
  std::string* mutable_offchain_config();
  PROTOBUF_NODISCARD std::string* release_offchain_config();
  void set_allocated_offchain_config(std::string* ptr);

  private:
  const std::string& _internal_offchain_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offchain_config(
      const std::string& value);
  std::string* _internal_mutable_offchain_config();

  public:
  // .injective.ocr.v1beta1.ModuleParams module_params = 7 [json_name = "moduleParams"];
  bool has_module_params() const;
  void clear_module_params() ;
  const ::injective::ocr::v1beta1::ModuleParams& module_params() const;
  PROTOBUF_NODISCARD ::injective::ocr::v1beta1::ModuleParams* release_module_params();
  ::injective::ocr::v1beta1::ModuleParams* mutable_module_params();
  void set_allocated_module_params(::injective::ocr::v1beta1::ModuleParams* module_params);
  private:
  const ::injective::ocr::v1beta1::ModuleParams& _internal_module_params() const;
  ::injective::ocr::v1beta1::ModuleParams* _internal_mutable_module_params();
  public:
  void unsafe_arena_set_allocated_module_params(
      ::injective::ocr::v1beta1::ModuleParams* module_params);
  ::injective::ocr::v1beta1::ModuleParams* unsafe_arena_release_module_params();
  // uint64 offchain_config_version = 5 [json_name = "offchainConfigVersion"];
  void clear_offchain_config_version() ;
  ::uint64_t offchain_config_version() const;
  void set_offchain_config_version(::uint64_t value);

  private:
  ::uint64_t _internal_offchain_config_version() const;
  void _internal_set_offchain_config_version(::uint64_t value);

  public:
  // uint32 f = 3 [json_name = "f"];
  void clear_f() ;
  ::uint32_t f() const;
  void set_f(::uint32_t value);

  private:
  ::uint32_t _internal_f() const;
  void _internal_set_f(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.FeedConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transmitters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr onchain_config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offchain_config_;
    ::injective::ocr::v1beta1::ModuleParams* module_params_;
    ::uint64_t offchain_config_version_;
    ::uint32_t f_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class FeedConfigInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.FeedConfigInfo) */ {
 public:
  inline FeedConfigInfo() : FeedConfigInfo(nullptr) {}
  ~FeedConfigInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeedConfigInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedConfigInfo(const FeedConfigInfo& from);
  FeedConfigInfo(FeedConfigInfo&& from) noexcept
    : FeedConfigInfo() {
    *this = ::std::move(from);
  }

  inline FeedConfigInfo& operator=(const FeedConfigInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedConfigInfo& operator=(FeedConfigInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedConfigInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedConfigInfo* internal_default_instance() {
    return reinterpret_cast<const FeedConfigInfo*>(
               &_FeedConfigInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FeedConfigInfo& a, FeedConfigInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedConfigInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedConfigInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedConfigInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedConfigInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedConfigInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedConfigInfo& from) {
    FeedConfigInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedConfigInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.FeedConfigInfo";
  }
  protected:
  explicit FeedConfigInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestConfigDigestFieldNumber = 1,
    kFFieldNumber = 2,
    kNFieldNumber = 3,
    kConfigCountFieldNumber = 4,
    kLatestConfigBlockNumberFieldNumber = 5,
  };
  // bytes latest_config_digest = 1 [json_name = "latestConfigDigest"];
  void clear_latest_config_digest() ;
  const std::string& latest_config_digest() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_latest_config_digest(Arg_&& arg, Args_... args);
  std::string* mutable_latest_config_digest();
  PROTOBUF_NODISCARD std::string* release_latest_config_digest();
  void set_allocated_latest_config_digest(std::string* ptr);

  private:
  const std::string& _internal_latest_config_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latest_config_digest(
      const std::string& value);
  std::string* _internal_mutable_latest_config_digest();

  public:
  // uint32 f = 2 [json_name = "f"];
  void clear_f() ;
  ::uint32_t f() const;
  void set_f(::uint32_t value);

  private:
  ::uint32_t _internal_f() const;
  void _internal_set_f(::uint32_t value);

  public:
  // uint32 n = 3 [json_name = "n"];
  void clear_n() ;
  ::uint32_t n() const;
  void set_n(::uint32_t value);

  private:
  ::uint32_t _internal_n() const;
  void _internal_set_n(::uint32_t value);

  public:
  // uint64 config_count = 4 [json_name = "configCount"];
  void clear_config_count() ;
  ::uint64_t config_count() const;
  void set_config_count(::uint64_t value);

  private:
  ::uint64_t _internal_config_count() const;
  void _internal_set_config_count(::uint64_t value);

  public:
  // int64 latest_config_block_number = 5 [json_name = "latestConfigBlockNumber"];
  void clear_latest_config_block_number() ;
  ::int64_t latest_config_block_number() const;
  void set_latest_config_block_number(::int64_t value);

  private:
  ::int64_t _internal_latest_config_block_number() const;
  void _internal_set_latest_config_block_number(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.FeedConfigInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr latest_config_digest_;
    ::uint32_t f_;
    ::uint32_t n_;
    ::uint64_t config_count_;
    ::int64_t latest_config_block_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class ModuleParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.ModuleParams) */ {
 public:
  inline ModuleParams() : ModuleParams(nullptr) {}
  ~ModuleParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModuleParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleParams(const ModuleParams& from);
  ModuleParams(ModuleParams&& from) noexcept
    : ModuleParams() {
    *this = ::std::move(from);
  }

  inline ModuleParams& operator=(const ModuleParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleParams& operator=(ModuleParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleParams* internal_default_instance() {
    return reinterpret_cast<const ModuleParams*>(
               &_ModuleParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModuleParams& a, ModuleParams& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleParams& from) {
    ModuleParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.ModuleParams";
  }
  protected:
  explicit ModuleParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedIdFieldNumber = 1,
    kMinAnswerFieldNumber = 2,
    kMaxAnswerFieldNumber = 3,
    kLinkPerObservationFieldNumber = 4,
    kLinkPerTransmissionFieldNumber = 5,
    kLinkDenomFieldNumber = 6,
    kDescriptionFieldNumber = 8,
    kFeedAdminFieldNumber = 9,
    kBillingAdminFieldNumber = 10,
    kUniqueReportsFieldNumber = 7,
  };
  // string feed_id = 1 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // string min_answer = 2 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_answer() ;
  const std::string& min_answer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_answer(Arg_&& arg, Args_... args);
  std::string* mutable_min_answer();
  PROTOBUF_NODISCARD std::string* release_min_answer();
  void set_allocated_min_answer(std::string* ptr);

  private:
  const std::string& _internal_min_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_answer(
      const std::string& value);
  std::string* _internal_mutable_min_answer();

  public:
  // string max_answer = 3 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_max_answer() ;
  const std::string& max_answer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_answer(Arg_&& arg, Args_... args);
  std::string* mutable_max_answer();
  PROTOBUF_NODISCARD std::string* release_max_answer();
  void set_allocated_max_answer(std::string* ptr);

  private:
  const std::string& _internal_max_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_answer(
      const std::string& value);
  std::string* _internal_mutable_max_answer();

  public:
  // string link_per_observation = 4 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_link_per_observation() ;
  const std::string& link_per_observation() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_per_observation(Arg_&& arg, Args_... args);
  std::string* mutable_link_per_observation();
  PROTOBUF_NODISCARD std::string* release_link_per_observation();
  void set_allocated_link_per_observation(std::string* ptr);

  private:
  const std::string& _internal_link_per_observation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_per_observation(
      const std::string& value);
  std::string* _internal_mutable_link_per_observation();

  public:
  // string link_per_transmission = 5 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_link_per_transmission() ;
  const std::string& link_per_transmission() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_per_transmission(Arg_&& arg, Args_... args);
  std::string* mutable_link_per_transmission();
  PROTOBUF_NODISCARD std::string* release_link_per_transmission();
  void set_allocated_link_per_transmission(std::string* ptr);

  private:
  const std::string& _internal_link_per_transmission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_per_transmission(
      const std::string& value);
  std::string* _internal_mutable_link_per_transmission();

  public:
  // string link_denom = 6 [json_name = "linkDenom"];
  void clear_link_denom() ;
  const std::string& link_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_denom(Arg_&& arg, Args_... args);
  std::string* mutable_link_denom();
  PROTOBUF_NODISCARD std::string* release_link_denom();
  void set_allocated_link_denom(std::string* ptr);

  private:
  const std::string& _internal_link_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_denom(
      const std::string& value);
  std::string* _internal_mutable_link_denom();

  public:
  // string description = 8 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string feed_admin = 9 [json_name = "feedAdmin"];
  void clear_feed_admin() ;
  const std::string& feed_admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_admin(Arg_&& arg, Args_... args);
  std::string* mutable_feed_admin();
  PROTOBUF_NODISCARD std::string* release_feed_admin();
  void set_allocated_feed_admin(std::string* ptr);

  private:
  const std::string& _internal_feed_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_admin(
      const std::string& value);
  std::string* _internal_mutable_feed_admin();

  public:
  // string billing_admin = 10 [json_name = "billingAdmin"];
  void clear_billing_admin() ;
  const std::string& billing_admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_billing_admin(Arg_&& arg, Args_... args);
  std::string* mutable_billing_admin();
  PROTOBUF_NODISCARD std::string* release_billing_admin();
  void set_allocated_billing_admin(std::string* ptr);

  private:
  const std::string& _internal_billing_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_billing_admin(
      const std::string& value);
  std::string* _internal_mutable_billing_admin();

  public:
  // bool unique_reports = 7 [json_name = "uniqueReports"];
  void clear_unique_reports() ;
  bool unique_reports() const;
  void set_unique_reports(bool value);

  private:
  bool _internal_unique_reports() const;
  void _internal_set_unique_reports(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.ModuleParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_answer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_answer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_per_observation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_per_transmission_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr billing_admin_;
    bool unique_reports_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class ContractConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.ContractConfig) */ {
 public:
  inline ContractConfig() : ContractConfig(nullptr) {}
  ~ContractConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContractConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractConfig(const ContractConfig& from);
  ContractConfig(ContractConfig&& from) noexcept
    : ContractConfig() {
    *this = ::std::move(from);
  }

  inline ContractConfig& operator=(const ContractConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractConfig& operator=(ContractConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractConfig* internal_default_instance() {
    return reinterpret_cast<const ContractConfig*>(
               &_ContractConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ContractConfig& a, ContractConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractConfig& from) {
    ContractConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.ContractConfig";
  }
  protected:
  explicit ContractConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignersFieldNumber = 2,
    kTransmittersFieldNumber = 3,
    kOnchainConfigFieldNumber = 5,
    kOffchainConfigFieldNumber = 7,
    kConfigCountFieldNumber = 1,
    kOffchainConfigVersionFieldNumber = 6,
    kFFieldNumber = 4,
  };
  // repeated string signers = 2 [json_name = "signers"];
  int signers_size() const;
  private:
  int _internal_signers_size() const;

  public:
  void clear_signers() ;
  const std::string& signers(int index) const;
  std::string* mutable_signers(int index);
  void set_signers(int index, const std::string& value);
  void set_signers(int index, std::string&& value);
  void set_signers(int index, const char* value);
  void set_signers(int index, const char* value, std::size_t size);
  void set_signers(int index, absl::string_view value);
  std::string* add_signers();
  void add_signers(const std::string& value);
  void add_signers(std::string&& value);
  void add_signers(const char* value);
  void add_signers(const char* value, std::size_t size);
  void add_signers(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signers();

  private:
  const std::string& _internal_signers(int index) const;
  std::string* _internal_add_signers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_signers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_signers();

  public:
  // repeated string transmitters = 3 [json_name = "transmitters"];
  int transmitters_size() const;
  private:
  int _internal_transmitters_size() const;

  public:
  void clear_transmitters() ;
  const std::string& transmitters(int index) const;
  std::string* mutable_transmitters(int index);
  void set_transmitters(int index, const std::string& value);
  void set_transmitters(int index, std::string&& value);
  void set_transmitters(int index, const char* value);
  void set_transmitters(int index, const char* value, std::size_t size);
  void set_transmitters(int index, absl::string_view value);
  std::string* add_transmitters();
  void add_transmitters(const std::string& value);
  void add_transmitters(std::string&& value);
  void add_transmitters(const char* value);
  void add_transmitters(const char* value, std::size_t size);
  void add_transmitters(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transmitters();

  private:
  const std::string& _internal_transmitters(int index) const;
  std::string* _internal_add_transmitters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_transmitters();

  public:
  // bytes onchain_config = 5 [json_name = "onchainConfig"];
  void clear_onchain_config() ;
  const std::string& onchain_config() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_onchain_config(Arg_&& arg, Args_... args);
  std::string* mutable_onchain_config();
  PROTOBUF_NODISCARD std::string* release_onchain_config();
  void set_allocated_onchain_config(std::string* ptr);

  private:
  const std::string& _internal_onchain_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onchain_config(
      const std::string& value);
  std::string* _internal_mutable_onchain_config();

  public:
  // bytes offchain_config = 7 [json_name = "offchainConfig"];
  void clear_offchain_config() ;
  const std::string& offchain_config() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_offchain_config(Arg_&& arg, Args_... args);
  std::string* mutable_offchain_config();
  PROTOBUF_NODISCARD std::string* release_offchain_config();
  void set_allocated_offchain_config(std::string* ptr);

  private:
  const std::string& _internal_offchain_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offchain_config(
      const std::string& value);
  std::string* _internal_mutable_offchain_config();

  public:
  // uint64 config_count = 1 [json_name = "configCount"];
  void clear_config_count() ;
  ::uint64_t config_count() const;
  void set_config_count(::uint64_t value);

  private:
  ::uint64_t _internal_config_count() const;
  void _internal_set_config_count(::uint64_t value);

  public:
  // uint64 offchain_config_version = 6 [json_name = "offchainConfigVersion"];
  void clear_offchain_config_version() ;
  ::uint64_t offchain_config_version() const;
  void set_offchain_config_version(::uint64_t value);

  private:
  ::uint64_t _internal_offchain_config_version() const;
  void _internal_set_offchain_config_version(::uint64_t value);

  public:
  // uint32 f = 4 [json_name = "f"];
  void clear_f() ;
  ::uint32_t f() const;
  void set_f(::uint32_t value);

  private:
  ::uint32_t _internal_f() const;
  void _internal_set_f(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.ContractConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transmitters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr onchain_config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offchain_config_;
    ::uint64_t config_count_;
    ::uint64_t offchain_config_version_;
    ::uint32_t f_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class SetConfigProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.SetConfigProposal) */ {
 public:
  inline SetConfigProposal() : SetConfigProposal(nullptr) {}
  ~SetConfigProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetConfigProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConfigProposal(const SetConfigProposal& from);
  SetConfigProposal(SetConfigProposal&& from) noexcept
    : SetConfigProposal() {
    *this = ::std::move(from);
  }

  inline SetConfigProposal& operator=(const SetConfigProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConfigProposal& operator=(SetConfigProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConfigProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConfigProposal* internal_default_instance() {
    return reinterpret_cast<const SetConfigProposal*>(
               &_SetConfigProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SetConfigProposal& a, SetConfigProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConfigProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConfigProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConfigProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConfigProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetConfigProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetConfigProposal& from) {
    SetConfigProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetConfigProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.SetConfigProposal";
  }
  protected:
  explicit SetConfigProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kConfigFieldNumber = 3,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
  bool has_config() const;
  void clear_config() ;
  const ::injective::ocr::v1beta1::FeedConfig& config() const;
  PROTOBUF_NODISCARD ::injective::ocr::v1beta1::FeedConfig* release_config();
  ::injective::ocr::v1beta1::FeedConfig* mutable_config();
  void set_allocated_config(::injective::ocr::v1beta1::FeedConfig* config);
  private:
  const ::injective::ocr::v1beta1::FeedConfig& _internal_config() const;
  ::injective::ocr::v1beta1::FeedConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::injective::ocr::v1beta1::FeedConfig* config);
  ::injective::ocr::v1beta1::FeedConfig* unsafe_arena_release_config();
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.SetConfigProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::injective::ocr::v1beta1::FeedConfig* config_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class FeedProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.FeedProperties) */ {
 public:
  inline FeedProperties() : FeedProperties(nullptr) {}
  ~FeedProperties() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeedProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedProperties(const FeedProperties& from);
  FeedProperties(FeedProperties&& from) noexcept
    : FeedProperties() {
    *this = ::std::move(from);
  }

  inline FeedProperties& operator=(const FeedProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedProperties& operator=(FeedProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedProperties* internal_default_instance() {
    return reinterpret_cast<const FeedProperties*>(
               &_FeedProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FeedProperties& a, FeedProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedProperties* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedProperties& from) {
    FeedProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.FeedProperties";
  }
  protected:
  explicit FeedProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedIdFieldNumber = 1,
    kOnchainConfigFieldNumber = 3,
    kOffchainConfigFieldNumber = 5,
    kMinAnswerFieldNumber = 6,
    kMaxAnswerFieldNumber = 7,
    kLinkPerObservationFieldNumber = 8,
    kLinkPerTransmissionFieldNumber = 9,
    kDescriptionFieldNumber = 11,
    kOffchainConfigVersionFieldNumber = 4,
    kFFieldNumber = 2,
    kUniqueReportsFieldNumber = 10,
  };
  // string feed_id = 1 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // bytes onchain_config = 3 [json_name = "onchainConfig"];
  void clear_onchain_config() ;
  const std::string& onchain_config() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_onchain_config(Arg_&& arg, Args_... args);
  std::string* mutable_onchain_config();
  PROTOBUF_NODISCARD std::string* release_onchain_config();
  void set_allocated_onchain_config(std::string* ptr);

  private:
  const std::string& _internal_onchain_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onchain_config(
      const std::string& value);
  std::string* _internal_mutable_onchain_config();

  public:
  // bytes offchain_config = 5 [json_name = "offchainConfig"];
  void clear_offchain_config() ;
  const std::string& offchain_config() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_offchain_config(Arg_&& arg, Args_... args);
  std::string* mutable_offchain_config();
  PROTOBUF_NODISCARD std::string* release_offchain_config();
  void set_allocated_offchain_config(std::string* ptr);

  private:
  const std::string& _internal_offchain_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offchain_config(
      const std::string& value);
  std::string* _internal_mutable_offchain_config();

  public:
  // string min_answer = 6 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_answer() ;
  const std::string& min_answer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_answer(Arg_&& arg, Args_... args);
  std::string* mutable_min_answer();
  PROTOBUF_NODISCARD std::string* release_min_answer();
  void set_allocated_min_answer(std::string* ptr);

  private:
  const std::string& _internal_min_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_answer(
      const std::string& value);
  std::string* _internal_mutable_min_answer();

  public:
  // string max_answer = 7 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_max_answer() ;
  const std::string& max_answer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_answer(Arg_&& arg, Args_... args);
  std::string* mutable_max_answer();
  PROTOBUF_NODISCARD std::string* release_max_answer();
  void set_allocated_max_answer(std::string* ptr);

  private:
  const std::string& _internal_max_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_answer(
      const std::string& value);
  std::string* _internal_mutable_max_answer();

  public:
  // string link_per_observation = 8 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_link_per_observation() ;
  const std::string& link_per_observation() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_per_observation(Arg_&& arg, Args_... args);
  std::string* mutable_link_per_observation();
  PROTOBUF_NODISCARD std::string* release_link_per_observation();
  void set_allocated_link_per_observation(std::string* ptr);

  private:
  const std::string& _internal_link_per_observation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_per_observation(
      const std::string& value);
  std::string* _internal_mutable_link_per_observation();

  public:
  // string link_per_transmission = 9 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_link_per_transmission() ;
  const std::string& link_per_transmission() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_per_transmission(Arg_&& arg, Args_... args);
  std::string* mutable_link_per_transmission();
  PROTOBUF_NODISCARD std::string* release_link_per_transmission();
  void set_allocated_link_per_transmission(std::string* ptr);

  private:
  const std::string& _internal_link_per_transmission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_per_transmission(
      const std::string& value);
  std::string* _internal_mutable_link_per_transmission();

  public:
  // string description = 11 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // uint64 offchain_config_version = 4 [json_name = "offchainConfigVersion"];
  void clear_offchain_config_version() ;
  ::uint64_t offchain_config_version() const;
  void set_offchain_config_version(::uint64_t value);

  private:
  ::uint64_t _internal_offchain_config_version() const;
  void _internal_set_offchain_config_version(::uint64_t value);

  public:
  // uint32 f = 2 [json_name = "f"];
  void clear_f() ;
  ::uint32_t f() const;
  void set_f(::uint32_t value);

  private:
  ::uint32_t _internal_f() const;
  void _internal_set_f(::uint32_t value);

  public:
  // bool unique_reports = 10 [json_name = "uniqueReports"];
  void clear_unique_reports() ;
  bool unique_reports() const;
  void set_unique_reports(bool value);

  private:
  bool _internal_unique_reports() const;
  void _internal_set_unique_reports(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.FeedProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr onchain_config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offchain_config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_answer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_answer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_per_observation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_per_transmission_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::uint64_t offchain_config_version_;
    ::uint32_t f_;
    bool unique_reports_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class SetBatchConfigProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.SetBatchConfigProposal) */ {
 public:
  inline SetBatchConfigProposal() : SetBatchConfigProposal(nullptr) {}
  ~SetBatchConfigProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetBatchConfigProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetBatchConfigProposal(const SetBatchConfigProposal& from);
  SetBatchConfigProposal(SetBatchConfigProposal&& from) noexcept
    : SetBatchConfigProposal() {
    *this = ::std::move(from);
  }

  inline SetBatchConfigProposal& operator=(const SetBatchConfigProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetBatchConfigProposal& operator=(SetBatchConfigProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetBatchConfigProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetBatchConfigProposal* internal_default_instance() {
    return reinterpret_cast<const SetBatchConfigProposal*>(
               &_SetBatchConfigProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SetBatchConfigProposal& a, SetBatchConfigProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(SetBatchConfigProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetBatchConfigProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetBatchConfigProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetBatchConfigProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetBatchConfigProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetBatchConfigProposal& from) {
    SetBatchConfigProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetBatchConfigProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.SetBatchConfigProposal";
  }
  protected:
  explicit SetBatchConfigProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignersFieldNumber = 3,
    kTransmittersFieldNumber = 4,
    kFeedPropertiesFieldNumber = 6,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kLinkDenomFieldNumber = 5,
  };
  // repeated string signers = 3 [json_name = "signers"];
  int signers_size() const;
  private:
  int _internal_signers_size() const;

  public:
  void clear_signers() ;
  const std::string& signers(int index) const;
  std::string* mutable_signers(int index);
  void set_signers(int index, const std::string& value);
  void set_signers(int index, std::string&& value);
  void set_signers(int index, const char* value);
  void set_signers(int index, const char* value, std::size_t size);
  void set_signers(int index, absl::string_view value);
  std::string* add_signers();
  void add_signers(const std::string& value);
  void add_signers(std::string&& value);
  void add_signers(const char* value);
  void add_signers(const char* value, std::size_t size);
  void add_signers(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signers();

  private:
  const std::string& _internal_signers(int index) const;
  std::string* _internal_add_signers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_signers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_signers();

  public:
  // repeated string transmitters = 4 [json_name = "transmitters"];
  int transmitters_size() const;
  private:
  int _internal_transmitters_size() const;

  public:
  void clear_transmitters() ;
  const std::string& transmitters(int index) const;
  std::string* mutable_transmitters(int index);
  void set_transmitters(int index, const std::string& value);
  void set_transmitters(int index, std::string&& value);
  void set_transmitters(int index, const char* value);
  void set_transmitters(int index, const char* value, std::size_t size);
  void set_transmitters(int index, absl::string_view value);
  std::string* add_transmitters();
  void add_transmitters(const std::string& value);
  void add_transmitters(std::string&& value);
  void add_transmitters(const char* value);
  void add_transmitters(const char* value, std::size_t size);
  void add_transmitters(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transmitters();

  private:
  const std::string& _internal_transmitters(int index) const;
  std::string* _internal_add_transmitters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_transmitters();

  public:
  // repeated .injective.ocr.v1beta1.FeedProperties feed_properties = 6 [json_name = "feedProperties"];
  int feed_properties_size() const;
  private:
  int _internal_feed_properties_size() const;

  public:
  void clear_feed_properties() ;
  ::injective::ocr::v1beta1::FeedProperties* mutable_feed_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::ocr::v1beta1::FeedProperties >*
      mutable_feed_properties();
  private:
  const ::injective::ocr::v1beta1::FeedProperties& _internal_feed_properties(int index) const;
  ::injective::ocr::v1beta1::FeedProperties* _internal_add_feed_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::ocr::v1beta1::FeedProperties>& _internal_feed_properties() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::ocr::v1beta1::FeedProperties>* _internal_mutable_feed_properties();
  public:
  const ::injective::ocr::v1beta1::FeedProperties& feed_properties(int index) const;
  ::injective::ocr::v1beta1::FeedProperties* add_feed_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::ocr::v1beta1::FeedProperties >&
      feed_properties() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string link_denom = 5 [json_name = "linkDenom"];
  void clear_link_denom() ;
  const std::string& link_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_denom(Arg_&& arg, Args_... args);
  std::string* mutable_link_denom();
  PROTOBUF_NODISCARD std::string* release_link_denom();
  void set_allocated_link_denom(std::string* ptr);

  private:
  const std::string& _internal_link_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_denom(
      const std::string& value);
  std::string* _internal_mutable_link_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.SetBatchConfigProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transmitters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::ocr::v1beta1::FeedProperties > feed_properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class OracleObservationsCounts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.OracleObservationsCounts) */ {
 public:
  inline OracleObservationsCounts() : OracleObservationsCounts(nullptr) {}
  ~OracleObservationsCounts() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OracleObservationsCounts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OracleObservationsCounts(const OracleObservationsCounts& from);
  OracleObservationsCounts(OracleObservationsCounts&& from) noexcept
    : OracleObservationsCounts() {
    *this = ::std::move(from);
  }

  inline OracleObservationsCounts& operator=(const OracleObservationsCounts& from) {
    CopyFrom(from);
    return *this;
  }
  inline OracleObservationsCounts& operator=(OracleObservationsCounts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OracleObservationsCounts& default_instance() {
    return *internal_default_instance();
  }
  static inline const OracleObservationsCounts* internal_default_instance() {
    return reinterpret_cast<const OracleObservationsCounts*>(
               &_OracleObservationsCounts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OracleObservationsCounts& a, OracleObservationsCounts& b) {
    a.Swap(&b);
  }
  inline void Swap(OracleObservationsCounts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OracleObservationsCounts* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OracleObservationsCounts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OracleObservationsCounts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OracleObservationsCounts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OracleObservationsCounts& from) {
    OracleObservationsCounts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OracleObservationsCounts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.OracleObservationsCounts";
  }
  protected:
  explicit OracleObservationsCounts(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountsFieldNumber = 1,
  };
  // repeated uint32 counts = 1 [json_name = "counts"];
  int counts_size() const;
  private:
  int _internal_counts_size() const;

  public:
  void clear_counts() ;
  ::uint32_t counts(int index) const;
  void set_counts(int index, ::uint32_t value);
  void add_counts(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& counts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* mutable_counts();

  private:
  ::uint32_t _internal_counts(int index) const;
  void _internal_add_counts(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& _internal_counts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* _internal_mutable_counts();

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.OracleObservationsCounts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t> counts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _counts_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class GasReimbursements final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.GasReimbursements) */ {
 public:
  inline GasReimbursements() : GasReimbursements(nullptr) {}
  ~GasReimbursements() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GasReimbursements(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GasReimbursements(const GasReimbursements& from);
  GasReimbursements(GasReimbursements&& from) noexcept
    : GasReimbursements() {
    *this = ::std::move(from);
  }

  inline GasReimbursements& operator=(const GasReimbursements& from) {
    CopyFrom(from);
    return *this;
  }
  inline GasReimbursements& operator=(GasReimbursements&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GasReimbursements& default_instance() {
    return *internal_default_instance();
  }
  static inline const GasReimbursements* internal_default_instance() {
    return reinterpret_cast<const GasReimbursements*>(
               &_GasReimbursements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GasReimbursements& a, GasReimbursements& b) {
    a.Swap(&b);
  }
  inline void Swap(GasReimbursements* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GasReimbursements* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GasReimbursements* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GasReimbursements>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GasReimbursements& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GasReimbursements& from) {
    GasReimbursements::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GasReimbursements* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.GasReimbursements";
  }
  protected:
  explicit GasReimbursements(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReimbursementsFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.Coin reimbursements = 1 [json_name = "reimbursements"];
  int reimbursements_size() const;
  private:
  int _internal_reimbursements_size() const;

  public:
  void clear_reimbursements() ;
  ::cosmos::base::v1beta1::Coin* mutable_reimbursements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_reimbursements();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_reimbursements(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_reimbursements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_reimbursements() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_reimbursements();
  public:
  const ::cosmos::base::v1beta1::Coin& reimbursements(int index) const;
  ::cosmos::base::v1beta1::Coin* add_reimbursements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      reimbursements() const;
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.GasReimbursements)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > reimbursements_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class Payee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.Payee) */ {
 public:
  inline Payee() : Payee(nullptr) {}
  ~Payee() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Payee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payee(const Payee& from);
  Payee(Payee&& from) noexcept
    : Payee() {
    *this = ::std::move(from);
  }

  inline Payee& operator=(const Payee& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payee& operator=(Payee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payee& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payee* internal_default_instance() {
    return reinterpret_cast<const Payee*>(
               &_Payee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Payee& a, Payee& b) {
    a.Swap(&b);
  }
  inline void Swap(Payee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payee* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Payee& from) {
    Payee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.Payee";
  }
  protected:
  explicit Payee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransmitterAddrFieldNumber = 1,
    kPaymentAddrFieldNumber = 2,
  };
  // string transmitter_addr = 1 [json_name = "transmitterAddr"];
  void clear_transmitter_addr() ;
  const std::string& transmitter_addr() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmitter_addr(Arg_&& arg, Args_... args);
  std::string* mutable_transmitter_addr();
  PROTOBUF_NODISCARD std::string* release_transmitter_addr();
  void set_allocated_transmitter_addr(std::string* ptr);

  private:
  const std::string& _internal_transmitter_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmitter_addr(
      const std::string& value);
  std::string* _internal_mutable_transmitter_addr();

  public:
  // string payment_addr = 2 [json_name = "paymentAddr"];
  void clear_payment_addr() ;
  const std::string& payment_addr() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payment_addr(Arg_&& arg, Args_... args);
  std::string* mutable_payment_addr();
  PROTOBUF_NODISCARD std::string* release_payment_addr();
  void set_allocated_payment_addr(std::string* ptr);

  private:
  const std::string& _internal_payment_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_addr(
      const std::string& value);
  std::string* _internal_mutable_payment_addr();

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.Payee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmitter_addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_addr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class Transmission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.Transmission) */ {
 public:
  inline Transmission() : Transmission(nullptr) {}
  ~Transmission() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Transmission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transmission(const Transmission& from);
  Transmission(Transmission&& from) noexcept
    : Transmission() {
    *this = ::std::move(from);
  }

  inline Transmission& operator=(const Transmission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transmission& operator=(Transmission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transmission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transmission* internal_default_instance() {
    return reinterpret_cast<const Transmission*>(
               &_Transmission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Transmission& a, Transmission& b) {
    a.Swap(&b);
  }
  inline void Swap(Transmission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transmission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transmission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transmission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transmission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Transmission& from) {
    Transmission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transmission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.Transmission";
  }
  protected:
  explicit Transmission(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnswerFieldNumber = 1,
    kObservationsTimestampFieldNumber = 2,
    kTransmissionTimestampFieldNumber = 3,
  };
  // string answer = 1 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_answer() ;
  const std::string& answer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_answer(Arg_&& arg, Args_... args);
  std::string* mutable_answer();
  PROTOBUF_NODISCARD std::string* release_answer();
  void set_allocated_answer(std::string* ptr);

  private:
  const std::string& _internal_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer(
      const std::string& value);
  std::string* _internal_mutable_answer();

  public:
  // int64 observations_timestamp = 2 [json_name = "observationsTimestamp"];
  void clear_observations_timestamp() ;
  ::int64_t observations_timestamp() const;
  void set_observations_timestamp(::int64_t value);

  private:
  ::int64_t _internal_observations_timestamp() const;
  void _internal_set_observations_timestamp(::int64_t value);

  public:
  // int64 transmission_timestamp = 3 [json_name = "transmissionTimestamp"];
  void clear_transmission_timestamp() ;
  ::int64_t transmission_timestamp() const;
  void set_transmission_timestamp(::int64_t value);

  private:
  ::int64_t _internal_transmission_timestamp() const;
  void _internal_set_transmission_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.Transmission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr answer_;
    ::int64_t observations_timestamp_;
    ::int64_t transmission_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class EpochAndRound final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.EpochAndRound) */ {
 public:
  inline EpochAndRound() : EpochAndRound(nullptr) {}
  ~EpochAndRound() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpochAndRound(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EpochAndRound(const EpochAndRound& from);
  EpochAndRound(EpochAndRound&& from) noexcept
    : EpochAndRound() {
    *this = ::std::move(from);
  }

  inline EpochAndRound& operator=(const EpochAndRound& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpochAndRound& operator=(EpochAndRound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpochAndRound& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpochAndRound* internal_default_instance() {
    return reinterpret_cast<const EpochAndRound*>(
               &_EpochAndRound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EpochAndRound& a, EpochAndRound& b) {
    a.Swap(&b);
  }
  inline void Swap(EpochAndRound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpochAndRound* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpochAndRound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpochAndRound>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EpochAndRound& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EpochAndRound& from) {
    EpochAndRound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpochAndRound* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.EpochAndRound";
  }
  protected:
  explicit EpochAndRound(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
    kRoundFieldNumber = 2,
  };
  // uint64 epoch = 1 [json_name = "epoch"];
  void clear_epoch() ;
  ::uint64_t epoch() const;
  void set_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_epoch() const;
  void _internal_set_epoch(::uint64_t value);

  public:
  // uint64 round = 2 [json_name = "round"];
  void clear_round() ;
  ::uint64_t round() const;
  void set_round(::uint64_t value);

  private:
  ::uint64_t _internal_round() const;
  void _internal_set_round(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.EpochAndRound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t epoch_;
    ::uint64_t round_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class Report final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.Report) */ {
 public:
  inline Report() : Report(nullptr) {}
  ~Report() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Report(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Report(const Report& from);
  Report(Report&& from) noexcept
    : Report() {
    *this = ::std::move(from);
  }

  inline Report& operator=(const Report& from) {
    CopyFrom(from);
    return *this;
  }
  inline Report& operator=(Report&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Report& default_instance() {
    return *internal_default_instance();
  }
  static inline const Report* internal_default_instance() {
    return reinterpret_cast<const Report*>(
               &_Report_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Report& a, Report& b) {
    a.Swap(&b);
  }
  inline void Swap(Report* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Report* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Report* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Report>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Report& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Report& from) {
    Report::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Report* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.Report";
  }
  protected:
  explicit Report(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObservationsFieldNumber = 3,
    kObserversFieldNumber = 2,
    kObservationsTimestampFieldNumber = 1,
  };
  // repeated string observations = 3 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  int observations_size() const;
  private:
  int _internal_observations_size() const;

  public:
  void clear_observations() ;
  const std::string& observations(int index) const;
  std::string* mutable_observations(int index);
  void set_observations(int index, const std::string& value);
  void set_observations(int index, std::string&& value);
  void set_observations(int index, const char* value);
  void set_observations(int index, const char* value, std::size_t size);
  void set_observations(int index, absl::string_view value);
  std::string* add_observations();
  void add_observations(const std::string& value);
  void add_observations(std::string&& value);
  void add_observations(const char* value);
  void add_observations(const char* value, std::size_t size);
  void add_observations(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& observations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_observations();

  private:
  const std::string& _internal_observations(int index) const;
  std::string* _internal_add_observations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_observations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_observations();

  public:
  // bytes observers = 2 [json_name = "observers"];
  void clear_observers() ;
  const std::string& observers() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_observers(Arg_&& arg, Args_... args);
  std::string* mutable_observers();
  PROTOBUF_NODISCARD std::string* release_observers();
  void set_allocated_observers(std::string* ptr);

  private:
  const std::string& _internal_observers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_observers(
      const std::string& value);
  std::string* _internal_mutable_observers();

  public:
  // int64 observations_timestamp = 1 [json_name = "observationsTimestamp"];
  void clear_observations_timestamp() ;
  ::int64_t observations_timestamp() const;
  void set_observations_timestamp(::int64_t value);

  private:
  ::int64_t _internal_observations_timestamp() const;
  void _internal_set_observations_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.Report)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> observations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr observers_;
    ::int64_t observations_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class ReportToSign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.ReportToSign) */ {
 public:
  inline ReportToSign() : ReportToSign(nullptr) {}
  ~ReportToSign() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReportToSign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportToSign(const ReportToSign& from);
  ReportToSign(ReportToSign&& from) noexcept
    : ReportToSign() {
    *this = ::std::move(from);
  }

  inline ReportToSign& operator=(const ReportToSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportToSign& operator=(ReportToSign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportToSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportToSign* internal_default_instance() {
    return reinterpret_cast<const ReportToSign*>(
               &_ReportToSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReportToSign& a, ReportToSign& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportToSign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportToSign* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportToSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportToSign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReportToSign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReportToSign& from) {
    ReportToSign::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportToSign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.ReportToSign";
  }
  protected:
  explicit ReportToSign(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigDigestFieldNumber = 1,
    kExtraHashFieldNumber = 4,
    kReportFieldNumber = 5,
    kEpochFieldNumber = 2,
    kRoundFieldNumber = 3,
  };
  // bytes config_digest = 1 [json_name = "configDigest"];
  void clear_config_digest() ;
  const std::string& config_digest() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_digest(Arg_&& arg, Args_... args);
  std::string* mutable_config_digest();
  PROTOBUF_NODISCARD std::string* release_config_digest();
  void set_allocated_config_digest(std::string* ptr);

  private:
  const std::string& _internal_config_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_digest(
      const std::string& value);
  std::string* _internal_mutable_config_digest();

  public:
  // bytes extra_hash = 4 [json_name = "extraHash"];
  void clear_extra_hash() ;
  const std::string& extra_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extra_hash(Arg_&& arg, Args_... args);
  std::string* mutable_extra_hash();
  PROTOBUF_NODISCARD std::string* release_extra_hash();
  void set_allocated_extra_hash(std::string* ptr);

  private:
  const std::string& _internal_extra_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_hash(
      const std::string& value);
  std::string* _internal_mutable_extra_hash();

  public:
  // bytes report = 5 [json_name = "report"];
  void clear_report() ;
  const std::string& report() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_report(Arg_&& arg, Args_... args);
  std::string* mutable_report();
  PROTOBUF_NODISCARD std::string* release_report();
  void set_allocated_report(std::string* ptr);

  private:
  const std::string& _internal_report() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_report(
      const std::string& value);
  std::string* _internal_mutable_report();

  public:
  // uint64 epoch = 2 [json_name = "epoch"];
  void clear_epoch() ;
  ::uint64_t epoch() const;
  void set_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_epoch() const;
  void _internal_set_epoch(::uint64_t value);

  public:
  // uint64 round = 3 [json_name = "round"];
  void clear_round() ;
  ::uint64_t round() const;
  void set_round(::uint64_t value);

  private:
  ::uint64_t _internal_round() const;
  void _internal_set_round(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.ReportToSign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_digest_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr report_;
    ::uint64_t epoch_;
    ::uint64_t round_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class EventOraclePaid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.EventOraclePaid) */ {
 public:
  inline EventOraclePaid() : EventOraclePaid(nullptr) {}
  ~EventOraclePaid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventOraclePaid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventOraclePaid(const EventOraclePaid& from);
  EventOraclePaid(EventOraclePaid&& from) noexcept
    : EventOraclePaid() {
    *this = ::std::move(from);
  }

  inline EventOraclePaid& operator=(const EventOraclePaid& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventOraclePaid& operator=(EventOraclePaid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventOraclePaid& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventOraclePaid* internal_default_instance() {
    return reinterpret_cast<const EventOraclePaid*>(
               &_EventOraclePaid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EventOraclePaid& a, EventOraclePaid& b) {
    a.Swap(&b);
  }
  inline void Swap(EventOraclePaid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventOraclePaid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventOraclePaid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventOraclePaid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventOraclePaid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventOraclePaid& from) {
    EventOraclePaid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventOraclePaid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.EventOraclePaid";
  }
  protected:
  explicit EventOraclePaid(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransmitterAddrFieldNumber = 1,
    kPayeeAddrFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string transmitter_addr = 1 [json_name = "transmitterAddr"];
  void clear_transmitter_addr() ;
  const std::string& transmitter_addr() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmitter_addr(Arg_&& arg, Args_... args);
  std::string* mutable_transmitter_addr();
  PROTOBUF_NODISCARD std::string* release_transmitter_addr();
  void set_allocated_transmitter_addr(std::string* ptr);

  private:
  const std::string& _internal_transmitter_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmitter_addr(
      const std::string& value);
  std::string* _internal_mutable_transmitter_addr();

  public:
  // string payee_addr = 2 [json_name = "payeeAddr"];
  void clear_payee_addr() ;
  const std::string& payee_addr() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payee_addr(Arg_&& arg, Args_... args);
  std::string* mutable_payee_addr();
  PROTOBUF_NODISCARD std::string* release_payee_addr();
  void set_allocated_payee_addr(std::string* ptr);

  private:
  const std::string& _internal_payee_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payee_addr(
      const std::string& value);
  std::string* _internal_mutable_payee_addr();

  public:
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.EventOraclePaid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmitter_addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payee_addr_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class EventAnswerUpdated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.EventAnswerUpdated) */ {
 public:
  inline EventAnswerUpdated() : EventAnswerUpdated(nullptr) {}
  ~EventAnswerUpdated() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventAnswerUpdated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventAnswerUpdated(const EventAnswerUpdated& from);
  EventAnswerUpdated(EventAnswerUpdated&& from) noexcept
    : EventAnswerUpdated() {
    *this = ::std::move(from);
  }

  inline EventAnswerUpdated& operator=(const EventAnswerUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAnswerUpdated& operator=(EventAnswerUpdated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAnswerUpdated& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventAnswerUpdated* internal_default_instance() {
    return reinterpret_cast<const EventAnswerUpdated*>(
               &_EventAnswerUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EventAnswerUpdated& a, EventAnswerUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(EventAnswerUpdated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAnswerUpdated* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAnswerUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventAnswerUpdated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventAnswerUpdated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventAnswerUpdated& from) {
    EventAnswerUpdated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventAnswerUpdated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.EventAnswerUpdated";
  }
  protected:
  explicit EventAnswerUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 1,
    kRoundIdFieldNumber = 2,
    kUpdatedAtFieldNumber = 3,
  };
  // string current = 1 [json_name = "current", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_current() ;
  const std::string& current() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current(Arg_&& arg, Args_... args);
  std::string* mutable_current();
  PROTOBUF_NODISCARD std::string* release_current();
  void set_allocated_current(std::string* ptr);

  private:
  const std::string& _internal_current() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current(
      const std::string& value);
  std::string* _internal_mutable_current();

  public:
  // string round_id = 2 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_round_id() ;
  const std::string& round_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_round_id(Arg_&& arg, Args_... args);
  std::string* mutable_round_id();
  PROTOBUF_NODISCARD std::string* release_round_id();
  void set_allocated_round_id(std::string* ptr);

  private:
  const std::string& _internal_round_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_round_id(
      const std::string& value);
  std::string* _internal_mutable_round_id();

  public:
  // .google.protobuf.Timestamp updated_at = 3 [json_name = "updatedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.EventAnswerUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr round_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class EventNewRound final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.EventNewRound) */ {
 public:
  inline EventNewRound() : EventNewRound(nullptr) {}
  ~EventNewRound() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventNewRound(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventNewRound(const EventNewRound& from);
  EventNewRound(EventNewRound&& from) noexcept
    : EventNewRound() {
    *this = ::std::move(from);
  }

  inline EventNewRound& operator=(const EventNewRound& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventNewRound& operator=(EventNewRound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventNewRound& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventNewRound* internal_default_instance() {
    return reinterpret_cast<const EventNewRound*>(
               &_EventNewRound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EventNewRound& a, EventNewRound& b) {
    a.Swap(&b);
  }
  inline void Swap(EventNewRound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventNewRound* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventNewRound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventNewRound>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventNewRound& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventNewRound& from) {
    EventNewRound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventNewRound* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.EventNewRound";
  }
  protected:
  explicit EventNewRound(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundIdFieldNumber = 1,
    kStartedByFieldNumber = 2,
    kStartedAtFieldNumber = 3,
  };
  // string round_id = 1 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_round_id() ;
  const std::string& round_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_round_id(Arg_&& arg, Args_... args);
  std::string* mutable_round_id();
  PROTOBUF_NODISCARD std::string* release_round_id();
  void set_allocated_round_id(std::string* ptr);

  private:
  const std::string& _internal_round_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_round_id(
      const std::string& value);
  std::string* _internal_mutable_round_id();

  public:
  // string started_by = 2 [json_name = "startedBy"];
  void clear_started_by() ;
  const std::string& started_by() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_started_by(Arg_&& arg, Args_... args);
  std::string* mutable_started_by();
  PROTOBUF_NODISCARD std::string* release_started_by();
  void set_allocated_started_by(std::string* ptr);

  private:
  const std::string& _internal_started_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_started_by(
      const std::string& value);
  std::string* _internal_mutable_started_by();

  public:
  // .google.protobuf.Timestamp started_at = 3 [json_name = "startedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_started_at() const;
  void clear_started_at() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& started_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_started_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started_at();
  void set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started_at();
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.EventNewRound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr round_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr started_by_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class EventTransmitted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.EventTransmitted) */ {
 public:
  inline EventTransmitted() : EventTransmitted(nullptr) {}
  ~EventTransmitted() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventTransmitted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventTransmitted(const EventTransmitted& from);
  EventTransmitted(EventTransmitted&& from) noexcept
    : EventTransmitted() {
    *this = ::std::move(from);
  }

  inline EventTransmitted& operator=(const EventTransmitted& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventTransmitted& operator=(EventTransmitted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventTransmitted& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventTransmitted* internal_default_instance() {
    return reinterpret_cast<const EventTransmitted*>(
               &_EventTransmitted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EventTransmitted& a, EventTransmitted& b) {
    a.Swap(&b);
  }
  inline void Swap(EventTransmitted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventTransmitted* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventTransmitted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventTransmitted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventTransmitted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventTransmitted& from) {
    EventTransmitted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventTransmitted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.EventTransmitted";
  }
  protected:
  explicit EventTransmitted(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigDigestFieldNumber = 1,
    kEpochFieldNumber = 2,
  };
  // bytes config_digest = 1 [json_name = "configDigest"];
  void clear_config_digest() ;
  const std::string& config_digest() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_digest(Arg_&& arg, Args_... args);
  std::string* mutable_config_digest();
  PROTOBUF_NODISCARD std::string* release_config_digest();
  void set_allocated_config_digest(std::string* ptr);

  private:
  const std::string& _internal_config_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_digest(
      const std::string& value);
  std::string* _internal_mutable_config_digest();

  public:
  // uint64 epoch = 2 [json_name = "epoch"];
  void clear_epoch() ;
  ::uint64_t epoch() const;
  void set_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_epoch() const;
  void _internal_set_epoch(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.EventTransmitted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_digest_;
    ::uint64_t epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class EventNewTransmission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.EventNewTransmission) */ {
 public:
  inline EventNewTransmission() : EventNewTransmission(nullptr) {}
  ~EventNewTransmission() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventNewTransmission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventNewTransmission(const EventNewTransmission& from);
  EventNewTransmission(EventNewTransmission&& from) noexcept
    : EventNewTransmission() {
    *this = ::std::move(from);
  }

  inline EventNewTransmission& operator=(const EventNewTransmission& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventNewTransmission& operator=(EventNewTransmission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventNewTransmission& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventNewTransmission* internal_default_instance() {
    return reinterpret_cast<const EventNewTransmission*>(
               &_EventNewTransmission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EventNewTransmission& a, EventNewTransmission& b) {
    a.Swap(&b);
  }
  inline void Swap(EventNewTransmission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventNewTransmission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventNewTransmission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventNewTransmission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventNewTransmission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventNewTransmission& from) {
    EventNewTransmission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventNewTransmission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.EventNewTransmission";
  }
  protected:
  explicit EventNewTransmission(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObservationsFieldNumber = 6,
    kFeedIdFieldNumber = 1,
    kAnswerFieldNumber = 3,
    kTransmitterFieldNumber = 4,
    kObserversFieldNumber = 7,
    kConfigDigestFieldNumber = 8,
    kEpochAndRoundFieldNumber = 9,
    kObservationsTimestampFieldNumber = 5,
    kAggregatorRoundIdFieldNumber = 2,
  };
  // repeated string observations = 6 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  int observations_size() const;
  private:
  int _internal_observations_size() const;

  public:
  void clear_observations() ;
  const std::string& observations(int index) const;
  std::string* mutable_observations(int index);
  void set_observations(int index, const std::string& value);
  void set_observations(int index, std::string&& value);
  void set_observations(int index, const char* value);
  void set_observations(int index, const char* value, std::size_t size);
  void set_observations(int index, absl::string_view value);
  std::string* add_observations();
  void add_observations(const std::string& value);
  void add_observations(std::string&& value);
  void add_observations(const char* value);
  void add_observations(const char* value, std::size_t size);
  void add_observations(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& observations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_observations();

  private:
  const std::string& _internal_observations(int index) const;
  std::string* _internal_add_observations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_observations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_observations();

  public:
  // string feed_id = 1 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // string answer = 3 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_answer() ;
  const std::string& answer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_answer(Arg_&& arg, Args_... args);
  std::string* mutable_answer();
  PROTOBUF_NODISCARD std::string* release_answer();
  void set_allocated_answer(std::string* ptr);

  private:
  const std::string& _internal_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer(
      const std::string& value);
  std::string* _internal_mutable_answer();

  public:
  // string transmitter = 4 [json_name = "transmitter"];
  void clear_transmitter() ;
  const std::string& transmitter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmitter(Arg_&& arg, Args_... args);
  std::string* mutable_transmitter();
  PROTOBUF_NODISCARD std::string* release_transmitter();
  void set_allocated_transmitter(std::string* ptr);

  private:
  const std::string& _internal_transmitter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmitter(
      const std::string& value);
  std::string* _internal_mutable_transmitter();

  public:
  // bytes observers = 7 [json_name = "observers"];
  void clear_observers() ;
  const std::string& observers() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_observers(Arg_&& arg, Args_... args);
  std::string* mutable_observers();
  PROTOBUF_NODISCARD std::string* release_observers();
  void set_allocated_observers(std::string* ptr);

  private:
  const std::string& _internal_observers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_observers(
      const std::string& value);
  std::string* _internal_mutable_observers();

  public:
  // bytes config_digest = 8 [json_name = "configDigest"];
  void clear_config_digest() ;
  const std::string& config_digest() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_digest(Arg_&& arg, Args_... args);
  std::string* mutable_config_digest();
  PROTOBUF_NODISCARD std::string* release_config_digest();
  void set_allocated_config_digest(std::string* ptr);

  private:
  const std::string& _internal_config_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_digest(
      const std::string& value);
  std::string* _internal_mutable_config_digest();

  public:
  // .injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9 [json_name = "epochAndRound"];
  bool has_epoch_and_round() const;
  void clear_epoch_and_round() ;
  const ::injective::ocr::v1beta1::EpochAndRound& epoch_and_round() const;
  PROTOBUF_NODISCARD ::injective::ocr::v1beta1::EpochAndRound* release_epoch_and_round();
  ::injective::ocr::v1beta1::EpochAndRound* mutable_epoch_and_round();
  void set_allocated_epoch_and_round(::injective::ocr::v1beta1::EpochAndRound* epoch_and_round);
  private:
  const ::injective::ocr::v1beta1::EpochAndRound& _internal_epoch_and_round() const;
  ::injective::ocr::v1beta1::EpochAndRound* _internal_mutable_epoch_and_round();
  public:
  void unsafe_arena_set_allocated_epoch_and_round(
      ::injective::ocr::v1beta1::EpochAndRound* epoch_and_round);
  ::injective::ocr::v1beta1::EpochAndRound* unsafe_arena_release_epoch_and_round();
  // int64 observations_timestamp = 5 [json_name = "observationsTimestamp"];
  void clear_observations_timestamp() ;
  ::int64_t observations_timestamp() const;
  void set_observations_timestamp(::int64_t value);

  private:
  ::int64_t _internal_observations_timestamp() const;
  void _internal_set_observations_timestamp(::int64_t value);

  public:
  // uint32 aggregator_round_id = 2 [json_name = "aggregatorRoundId"];
  void clear_aggregator_round_id() ;
  ::uint32_t aggregator_round_id() const;
  void set_aggregator_round_id(::uint32_t value);

  private:
  ::uint32_t _internal_aggregator_round_id() const;
  void _internal_set_aggregator_round_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.EventNewTransmission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> observations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr answer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmitter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr observers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_digest_;
    ::injective::ocr::v1beta1::EpochAndRound* epoch_and_round_;
    ::int64_t observations_timestamp_;
    ::uint32_t aggregator_round_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};// -------------------------------------------------------------------

class EventConfigSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.EventConfigSet) */ {
 public:
  inline EventConfigSet() : EventConfigSet(nullptr) {}
  ~EventConfigSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventConfigSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventConfigSet(const EventConfigSet& from);
  EventConfigSet(EventConfigSet&& from) noexcept
    : EventConfigSet() {
    *this = ::std::move(from);
  }

  inline EventConfigSet& operator=(const EventConfigSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventConfigSet& operator=(EventConfigSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventConfigSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventConfigSet* internal_default_instance() {
    return reinterpret_cast<const EventConfigSet*>(
               &_EventConfigSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(EventConfigSet& a, EventConfigSet& b) {
    a.Swap(&b);
  }
  inline void Swap(EventConfigSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventConfigSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventConfigSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventConfigSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventConfigSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventConfigSet& from) {
    EventConfigSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventConfigSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.EventConfigSet";
  }
  protected:
  explicit EventConfigSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigDigestFieldNumber = 1,
    kConfigFieldNumber = 3,
    kConfigInfoFieldNumber = 4,
    kPreviousConfigBlockNumberFieldNumber = 2,
  };
  // bytes config_digest = 1 [json_name = "configDigest"];
  void clear_config_digest() ;
  const std::string& config_digest() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_digest(Arg_&& arg, Args_... args);
  std::string* mutable_config_digest();
  PROTOBUF_NODISCARD std::string* release_config_digest();
  void set_allocated_config_digest(std::string* ptr);

  private:
  const std::string& _internal_config_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_digest(
      const std::string& value);
  std::string* _internal_mutable_config_digest();

  public:
  // .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
  bool has_config() const;
  void clear_config() ;
  const ::injective::ocr::v1beta1::FeedConfig& config() const;
  PROTOBUF_NODISCARD ::injective::ocr::v1beta1::FeedConfig* release_config();
  ::injective::ocr::v1beta1::FeedConfig* mutable_config();
  void set_allocated_config(::injective::ocr::v1beta1::FeedConfig* config);
  private:
  const ::injective::ocr::v1beta1::FeedConfig& _internal_config() const;
  ::injective::ocr::v1beta1::FeedConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::injective::ocr::v1beta1::FeedConfig* config);
  ::injective::ocr::v1beta1::FeedConfig* unsafe_arena_release_config();
  // .injective.ocr.v1beta1.FeedConfigInfo config_info = 4 [json_name = "configInfo"];
  bool has_config_info() const;
  void clear_config_info() ;
  const ::injective::ocr::v1beta1::FeedConfigInfo& config_info() const;
  PROTOBUF_NODISCARD ::injective::ocr::v1beta1::FeedConfigInfo* release_config_info();
  ::injective::ocr::v1beta1::FeedConfigInfo* mutable_config_info();
  void set_allocated_config_info(::injective::ocr::v1beta1::FeedConfigInfo* config_info);
  private:
  const ::injective::ocr::v1beta1::FeedConfigInfo& _internal_config_info() const;
  ::injective::ocr::v1beta1::FeedConfigInfo* _internal_mutable_config_info();
  public:
  void unsafe_arena_set_allocated_config_info(
      ::injective::ocr::v1beta1::FeedConfigInfo* config_info);
  ::injective::ocr::v1beta1::FeedConfigInfo* unsafe_arena_release_config_info();
  // int64 previous_config_block_number = 2 [json_name = "previousConfigBlockNumber"];
  void clear_previous_config_block_number() ;
  ::int64_t previous_config_block_number() const;
  void set_previous_config_block_number(::int64_t value);

  private:
  ::int64_t _internal_previous_config_block_number() const;
  void _internal_set_previous_config_block_number(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.EventConfigSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_digest_;
    ::injective::ocr::v1beta1::FeedConfig* config_;
    ::injective::ocr::v1beta1::FeedConfigInfo* config_info_;
    ::int64_t previous_config_block_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2focr_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Params

// string link_denom = 1 [json_name = "linkDenom"];
inline void Params::clear_link_denom() {
  _impl_.link_denom_.ClearToEmpty();
}
inline const std::string& Params::link_denom() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Params.link_denom)
  return _internal_link_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_link_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Params.link_denom)
}
inline std::string* Params::mutable_link_denom() {
  std::string* _s = _internal_mutable_link_denom();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.Params.link_denom)
  return _s;
}
inline const std::string& Params::_internal_link_denom() const {
  return _impl_.link_denom_.Get();
}
inline void Params::_internal_set_link_denom(const std::string& value) {
  ;


  _impl_.link_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_link_denom() {
  ;
  return _impl_.link_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_link_denom() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.Params.link_denom)
  return _impl_.link_denom_.Release();
}
inline void Params::set_allocated_link_denom(std::string* value) {
  _impl_.link_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_denom_.IsDefault()) {
          _impl_.link_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.Params.link_denom)
}

// uint64 payout_block_interval = 2 [json_name = "payoutBlockInterval"];
inline void Params::clear_payout_block_interval() {
  _impl_.payout_block_interval_ = ::uint64_t{0u};
}
inline ::uint64_t Params::payout_block_interval() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Params.payout_block_interval)
  return _internal_payout_block_interval();
}
inline void Params::set_payout_block_interval(::uint64_t value) {
  _internal_set_payout_block_interval(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Params.payout_block_interval)
}
inline ::uint64_t Params::_internal_payout_block_interval() const {
  return _impl_.payout_block_interval_;
}
inline void Params::_internal_set_payout_block_interval(::uint64_t value) {
  ;
  _impl_.payout_block_interval_ = value;
}

// string module_admin = 3 [json_name = "moduleAdmin"];
inline void Params::clear_module_admin() {
  _impl_.module_admin_.ClearToEmpty();
}
inline const std::string& Params::module_admin() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Params.module_admin)
  return _internal_module_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_module_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.module_admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Params.module_admin)
}
inline std::string* Params::mutable_module_admin() {
  std::string* _s = _internal_mutable_module_admin();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.Params.module_admin)
  return _s;
}
inline const std::string& Params::_internal_module_admin() const {
  return _impl_.module_admin_.Get();
}
inline void Params::_internal_set_module_admin(const std::string& value) {
  ;


  _impl_.module_admin_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_module_admin() {
  ;
  return _impl_.module_admin_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_module_admin() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.Params.module_admin)
  return _impl_.module_admin_.Release();
}
inline void Params::set_allocated_module_admin(std::string* value) {
  _impl_.module_admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.module_admin_.IsDefault()) {
          _impl_.module_admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.Params.module_admin)
}

// -------------------------------------------------------------------

// FeedConfig

// repeated string signers = 1 [json_name = "signers"];
inline int FeedConfig::_internal_signers_size() const {
  return _impl_.signers_.size();
}
inline int FeedConfig::signers_size() const {
  return _internal_signers_size();
}
inline void FeedConfig::clear_signers() {
  _internal_mutable_signers()->Clear();
}
inline std::string* FeedConfig::add_signers() {
  std::string* _s = _internal_add_signers();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.FeedConfig.signers)
  return _s;
}
inline const std::string& FeedConfig::signers(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfig.signers)
  return _internal_signers(index);
}
inline std::string* FeedConfig::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedConfig.signers)
  return _internal_mutable_signers()->Mutable(index);
}
inline void FeedConfig::set_signers(int index, const std::string& value) {
  _internal_mutable_signers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::set_signers(int index, std::string&& value) {
  _internal_mutable_signers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::set_signers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::set_signers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_signers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::set_signers(int index, absl::string_view value) {
  _internal_mutable_signers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::add_signers(const std::string& value) {
  _internal_mutable_signers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::add_signers(std::string&& value) {
  _internal_mutable_signers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::add_signers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::add_signers(const char* value, std::size_t size) {
  _internal_mutable_signers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.FeedConfig.signers)
}
inline void FeedConfig::add_signers(absl::string_view value) {
  _internal_mutable_signers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.FeedConfig.signers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeedConfig::signers() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.FeedConfig.signers)
  return _internal_signers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* FeedConfig::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.FeedConfig.signers)
  return _internal_mutable_signers();
}
inline const std::string& FeedConfig::_internal_signers(int index) const {
  return _internal_signers().Get(index);
}
inline std::string* FeedConfig::_internal_add_signers() {
  return _internal_mutable_signers()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeedConfig::_internal_signers() const {
  return _impl_.signers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FeedConfig::_internal_mutable_signers() {
  return &_impl_.signers_;
}

// repeated string transmitters = 2 [json_name = "transmitters"];
inline int FeedConfig::_internal_transmitters_size() const {
  return _impl_.transmitters_.size();
}
inline int FeedConfig::transmitters_size() const {
  return _internal_transmitters_size();
}
inline void FeedConfig::clear_transmitters() {
  _internal_mutable_transmitters()->Clear();
}
inline std::string* FeedConfig::add_transmitters() {
  std::string* _s = _internal_add_transmitters();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.FeedConfig.transmitters)
  return _s;
}
inline const std::string& FeedConfig::transmitters(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfig.transmitters)
  return _internal_transmitters(index);
}
inline std::string* FeedConfig::mutable_transmitters(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedConfig.transmitters)
  return _internal_mutable_transmitters()->Mutable(index);
}
inline void FeedConfig::set_transmitters(int index, const std::string& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::set_transmitters(int index, std::string&& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::set_transmitters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::set_transmitters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transmitters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::set_transmitters(int index, absl::string_view value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::add_transmitters(const std::string& value) {
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::add_transmitters(std::string&& value) {
  _internal_mutable_transmitters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::add_transmitters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::add_transmitters(const char* value, std::size_t size) {
  _internal_mutable_transmitters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline void FeedConfig::add_transmitters(absl::string_view value) {
  _internal_mutable_transmitters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.FeedConfig.transmitters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeedConfig::transmitters() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.FeedConfig.transmitters)
  return _internal_transmitters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* FeedConfig::mutable_transmitters() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.FeedConfig.transmitters)
  return _internal_mutable_transmitters();
}
inline const std::string& FeedConfig::_internal_transmitters(int index) const {
  return _internal_transmitters().Get(index);
}
inline std::string* FeedConfig::_internal_add_transmitters() {
  return _internal_mutable_transmitters()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeedConfig::_internal_transmitters() const {
  return _impl_.transmitters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FeedConfig::_internal_mutable_transmitters() {
  return &_impl_.transmitters_;
}

// uint32 f = 3 [json_name = "f"];
inline void FeedConfig::clear_f() {
  _impl_.f_ = 0u;
}
inline ::uint32_t FeedConfig::f() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfig.f)
  return _internal_f();
}
inline void FeedConfig::set_f(::uint32_t value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfig.f)
}
inline ::uint32_t FeedConfig::_internal_f() const {
  return _impl_.f_;
}
inline void FeedConfig::_internal_set_f(::uint32_t value) {
  ;
  _impl_.f_ = value;
}

// bytes onchain_config = 4 [json_name = "onchainConfig"];
inline void FeedConfig::clear_onchain_config() {
  _impl_.onchain_config_.ClearToEmpty();
}
inline const std::string& FeedConfig::onchain_config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfig.onchain_config)
  return _internal_onchain_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedConfig::set_onchain_config(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.onchain_config_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfig.onchain_config)
}
inline std::string* FeedConfig::mutable_onchain_config() {
  std::string* _s = _internal_mutable_onchain_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedConfig.onchain_config)
  return _s;
}
inline const std::string& FeedConfig::_internal_onchain_config() const {
  return _impl_.onchain_config_.Get();
}
inline void FeedConfig::_internal_set_onchain_config(const std::string& value) {
  ;


  _impl_.onchain_config_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedConfig::_internal_mutable_onchain_config() {
  ;
  return _impl_.onchain_config_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedConfig::release_onchain_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedConfig.onchain_config)
  return _impl_.onchain_config_.Release();
}
inline void FeedConfig::set_allocated_onchain_config(std::string* value) {
  _impl_.onchain_config_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.onchain_config_.IsDefault()) {
          _impl_.onchain_config_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedConfig.onchain_config)
}

// uint64 offchain_config_version = 5 [json_name = "offchainConfigVersion"];
inline void FeedConfig::clear_offchain_config_version() {
  _impl_.offchain_config_version_ = ::uint64_t{0u};
}
inline ::uint64_t FeedConfig::offchain_config_version() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfig.offchain_config_version)
  return _internal_offchain_config_version();
}
inline void FeedConfig::set_offchain_config_version(::uint64_t value) {
  _internal_set_offchain_config_version(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfig.offchain_config_version)
}
inline ::uint64_t FeedConfig::_internal_offchain_config_version() const {
  return _impl_.offchain_config_version_;
}
inline void FeedConfig::_internal_set_offchain_config_version(::uint64_t value) {
  ;
  _impl_.offchain_config_version_ = value;
}

// bytes offchain_config = 6 [json_name = "offchainConfig"];
inline void FeedConfig::clear_offchain_config() {
  _impl_.offchain_config_.ClearToEmpty();
}
inline const std::string& FeedConfig::offchain_config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfig.offchain_config)
  return _internal_offchain_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedConfig::set_offchain_config(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.offchain_config_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfig.offchain_config)
}
inline std::string* FeedConfig::mutable_offchain_config() {
  std::string* _s = _internal_mutable_offchain_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedConfig.offchain_config)
  return _s;
}
inline const std::string& FeedConfig::_internal_offchain_config() const {
  return _impl_.offchain_config_.Get();
}
inline void FeedConfig::_internal_set_offchain_config(const std::string& value) {
  ;


  _impl_.offchain_config_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedConfig::_internal_mutable_offchain_config() {
  ;
  return _impl_.offchain_config_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedConfig::release_offchain_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedConfig.offchain_config)
  return _impl_.offchain_config_.Release();
}
inline void FeedConfig::set_allocated_offchain_config(std::string* value) {
  _impl_.offchain_config_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.offchain_config_.IsDefault()) {
          _impl_.offchain_config_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedConfig.offchain_config)
}

// .injective.ocr.v1beta1.ModuleParams module_params = 7 [json_name = "moduleParams"];
inline bool FeedConfig::has_module_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.module_params_ != nullptr);
  return value;
}
inline void FeedConfig::clear_module_params() {
  if (_impl_.module_params_ != nullptr) _impl_.module_params_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::ocr::v1beta1::ModuleParams& FeedConfig::_internal_module_params() const {
  const ::injective::ocr::v1beta1::ModuleParams* p = _impl_.module_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::ocr::v1beta1::ModuleParams&>(
      ::injective::ocr::v1beta1::_ModuleParams_default_instance_);
}
inline const ::injective::ocr::v1beta1::ModuleParams& FeedConfig::module_params() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfig.module_params)
  return _internal_module_params();
}
inline void FeedConfig::unsafe_arena_set_allocated_module_params(
    ::injective::ocr::v1beta1::ModuleParams* module_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.module_params_);
  }
  _impl_.module_params_ = module_params;
  if (module_params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.FeedConfig.module_params)
}
inline ::injective::ocr::v1beta1::ModuleParams* FeedConfig::release_module_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::ModuleParams* temp = _impl_.module_params_;
  _impl_.module_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::ocr::v1beta1::ModuleParams* FeedConfig::unsafe_arena_release_module_params() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedConfig.module_params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::ModuleParams* temp = _impl_.module_params_;
  _impl_.module_params_ = nullptr;
  return temp;
}
inline ::injective::ocr::v1beta1::ModuleParams* FeedConfig::_internal_mutable_module_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.module_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::ocr::v1beta1::ModuleParams>(GetArenaForAllocation());
    _impl_.module_params_ = p;
  }
  return _impl_.module_params_;
}
inline ::injective::ocr::v1beta1::ModuleParams* FeedConfig::mutable_module_params() {
  ::injective::ocr::v1beta1::ModuleParams* _msg = _internal_mutable_module_params();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedConfig.module_params)
  return _msg;
}
inline void FeedConfig::set_allocated_module_params(::injective::ocr::v1beta1::ModuleParams* module_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.module_params_;
  }
  if (module_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(module_params);
    if (message_arena != submessage_arena) {
      module_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module_params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.module_params_ = module_params;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedConfig.module_params)
}

// -------------------------------------------------------------------

// FeedConfigInfo

// bytes latest_config_digest = 1 [json_name = "latestConfigDigest"];
inline void FeedConfigInfo::clear_latest_config_digest() {
  _impl_.latest_config_digest_.ClearToEmpty();
}
inline const std::string& FeedConfigInfo::latest_config_digest() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfigInfo.latest_config_digest)
  return _internal_latest_config_digest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedConfigInfo::set_latest_config_digest(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.latest_config_digest_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfigInfo.latest_config_digest)
}
inline std::string* FeedConfigInfo::mutable_latest_config_digest() {
  std::string* _s = _internal_mutable_latest_config_digest();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedConfigInfo.latest_config_digest)
  return _s;
}
inline const std::string& FeedConfigInfo::_internal_latest_config_digest() const {
  return _impl_.latest_config_digest_.Get();
}
inline void FeedConfigInfo::_internal_set_latest_config_digest(const std::string& value) {
  ;


  _impl_.latest_config_digest_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedConfigInfo::_internal_mutable_latest_config_digest() {
  ;
  return _impl_.latest_config_digest_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedConfigInfo::release_latest_config_digest() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedConfigInfo.latest_config_digest)
  return _impl_.latest_config_digest_.Release();
}
inline void FeedConfigInfo::set_allocated_latest_config_digest(std::string* value) {
  _impl_.latest_config_digest_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.latest_config_digest_.IsDefault()) {
          _impl_.latest_config_digest_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedConfigInfo.latest_config_digest)
}

// uint32 f = 2 [json_name = "f"];
inline void FeedConfigInfo::clear_f() {
  _impl_.f_ = 0u;
}
inline ::uint32_t FeedConfigInfo::f() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfigInfo.f)
  return _internal_f();
}
inline void FeedConfigInfo::set_f(::uint32_t value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfigInfo.f)
}
inline ::uint32_t FeedConfigInfo::_internal_f() const {
  return _impl_.f_;
}
inline void FeedConfigInfo::_internal_set_f(::uint32_t value) {
  ;
  _impl_.f_ = value;
}

// uint32 n = 3 [json_name = "n"];
inline void FeedConfigInfo::clear_n() {
  _impl_.n_ = 0u;
}
inline ::uint32_t FeedConfigInfo::n() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfigInfo.n)
  return _internal_n();
}
inline void FeedConfigInfo::set_n(::uint32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfigInfo.n)
}
inline ::uint32_t FeedConfigInfo::_internal_n() const {
  return _impl_.n_;
}
inline void FeedConfigInfo::_internal_set_n(::uint32_t value) {
  ;
  _impl_.n_ = value;
}

// uint64 config_count = 4 [json_name = "configCount"];
inline void FeedConfigInfo::clear_config_count() {
  _impl_.config_count_ = ::uint64_t{0u};
}
inline ::uint64_t FeedConfigInfo::config_count() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfigInfo.config_count)
  return _internal_config_count();
}
inline void FeedConfigInfo::set_config_count(::uint64_t value) {
  _internal_set_config_count(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfigInfo.config_count)
}
inline ::uint64_t FeedConfigInfo::_internal_config_count() const {
  return _impl_.config_count_;
}
inline void FeedConfigInfo::_internal_set_config_count(::uint64_t value) {
  ;
  _impl_.config_count_ = value;
}

// int64 latest_config_block_number = 5 [json_name = "latestConfigBlockNumber"];
inline void FeedConfigInfo::clear_latest_config_block_number() {
  _impl_.latest_config_block_number_ = ::int64_t{0};
}
inline ::int64_t FeedConfigInfo::latest_config_block_number() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedConfigInfo.latest_config_block_number)
  return _internal_latest_config_block_number();
}
inline void FeedConfigInfo::set_latest_config_block_number(::int64_t value) {
  _internal_set_latest_config_block_number(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedConfigInfo.latest_config_block_number)
}
inline ::int64_t FeedConfigInfo::_internal_latest_config_block_number() const {
  return _impl_.latest_config_block_number_;
}
inline void FeedConfigInfo::_internal_set_latest_config_block_number(::int64_t value) {
  ;
  _impl_.latest_config_block_number_ = value;
}

// -------------------------------------------------------------------

// ModuleParams

// string feed_id = 1 [json_name = "feedId"];
inline void ModuleParams::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& ModuleParams::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.feed_id)
}
inline std::string* ModuleParams::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.feed_id)
  return _s;
}
inline const std::string& ModuleParams::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void ModuleParams::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.feed_id)
  return _impl_.feed_id_.Release();
}
inline void ModuleParams::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.feed_id)
}

// string min_answer = 2 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ModuleParams::clear_min_answer() {
  _impl_.min_answer_.ClearToEmpty();
}
inline const std::string& ModuleParams::min_answer() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.min_answer)
  return _internal_min_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_min_answer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_answer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.min_answer)
}
inline std::string* ModuleParams::mutable_min_answer() {
  std::string* _s = _internal_mutable_min_answer();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.min_answer)
  return _s;
}
inline const std::string& ModuleParams::_internal_min_answer() const {
  return _impl_.min_answer_.Get();
}
inline void ModuleParams::_internal_set_min_answer(const std::string& value) {
  ;


  _impl_.min_answer_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_min_answer() {
  ;
  return _impl_.min_answer_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_min_answer() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.min_answer)
  return _impl_.min_answer_.Release();
}
inline void ModuleParams::set_allocated_min_answer(std::string* value) {
  _impl_.min_answer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_answer_.IsDefault()) {
          _impl_.min_answer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.min_answer)
}

// string max_answer = 3 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ModuleParams::clear_max_answer() {
  _impl_.max_answer_.ClearToEmpty();
}
inline const std::string& ModuleParams::max_answer() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.max_answer)
  return _internal_max_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_max_answer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.max_answer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.max_answer)
}
inline std::string* ModuleParams::mutable_max_answer() {
  std::string* _s = _internal_mutable_max_answer();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.max_answer)
  return _s;
}
inline const std::string& ModuleParams::_internal_max_answer() const {
  return _impl_.max_answer_.Get();
}
inline void ModuleParams::_internal_set_max_answer(const std::string& value) {
  ;


  _impl_.max_answer_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_max_answer() {
  ;
  return _impl_.max_answer_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_max_answer() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.max_answer)
  return _impl_.max_answer_.Release();
}
inline void ModuleParams::set_allocated_max_answer(std::string* value) {
  _impl_.max_answer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.max_answer_.IsDefault()) {
          _impl_.max_answer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.max_answer)
}

// string link_per_observation = 4 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void ModuleParams::clear_link_per_observation() {
  _impl_.link_per_observation_.ClearToEmpty();
}
inline const std::string& ModuleParams::link_per_observation() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.link_per_observation)
  return _internal_link_per_observation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_link_per_observation(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_per_observation_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.link_per_observation)
}
inline std::string* ModuleParams::mutable_link_per_observation() {
  std::string* _s = _internal_mutable_link_per_observation();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.link_per_observation)
  return _s;
}
inline const std::string& ModuleParams::_internal_link_per_observation() const {
  return _impl_.link_per_observation_.Get();
}
inline void ModuleParams::_internal_set_link_per_observation(const std::string& value) {
  ;


  _impl_.link_per_observation_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_link_per_observation() {
  ;
  return _impl_.link_per_observation_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_link_per_observation() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.link_per_observation)
  return _impl_.link_per_observation_.Release();
}
inline void ModuleParams::set_allocated_link_per_observation(std::string* value) {
  _impl_.link_per_observation_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_per_observation_.IsDefault()) {
          _impl_.link_per_observation_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.link_per_observation)
}

// string link_per_transmission = 5 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void ModuleParams::clear_link_per_transmission() {
  _impl_.link_per_transmission_.ClearToEmpty();
}
inline const std::string& ModuleParams::link_per_transmission() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.link_per_transmission)
  return _internal_link_per_transmission();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_link_per_transmission(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_per_transmission_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.link_per_transmission)
}
inline std::string* ModuleParams::mutable_link_per_transmission() {
  std::string* _s = _internal_mutable_link_per_transmission();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.link_per_transmission)
  return _s;
}
inline const std::string& ModuleParams::_internal_link_per_transmission() const {
  return _impl_.link_per_transmission_.Get();
}
inline void ModuleParams::_internal_set_link_per_transmission(const std::string& value) {
  ;


  _impl_.link_per_transmission_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_link_per_transmission() {
  ;
  return _impl_.link_per_transmission_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_link_per_transmission() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.link_per_transmission)
  return _impl_.link_per_transmission_.Release();
}
inline void ModuleParams::set_allocated_link_per_transmission(std::string* value) {
  _impl_.link_per_transmission_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_per_transmission_.IsDefault()) {
          _impl_.link_per_transmission_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.link_per_transmission)
}

// string link_denom = 6 [json_name = "linkDenom"];
inline void ModuleParams::clear_link_denom() {
  _impl_.link_denom_.ClearToEmpty();
}
inline const std::string& ModuleParams::link_denom() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.link_denom)
  return _internal_link_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_link_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.link_denom)
}
inline std::string* ModuleParams::mutable_link_denom() {
  std::string* _s = _internal_mutable_link_denom();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.link_denom)
  return _s;
}
inline const std::string& ModuleParams::_internal_link_denom() const {
  return _impl_.link_denom_.Get();
}
inline void ModuleParams::_internal_set_link_denom(const std::string& value) {
  ;


  _impl_.link_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_link_denom() {
  ;
  return _impl_.link_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_link_denom() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.link_denom)
  return _impl_.link_denom_.Release();
}
inline void ModuleParams::set_allocated_link_denom(std::string* value) {
  _impl_.link_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_denom_.IsDefault()) {
          _impl_.link_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.link_denom)
}

// bool unique_reports = 7 [json_name = "uniqueReports"];
inline void ModuleParams::clear_unique_reports() {
  _impl_.unique_reports_ = false;
}
inline bool ModuleParams::unique_reports() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.unique_reports)
  return _internal_unique_reports();
}
inline void ModuleParams::set_unique_reports(bool value) {
  _internal_set_unique_reports(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.unique_reports)
}
inline bool ModuleParams::_internal_unique_reports() const {
  return _impl_.unique_reports_;
}
inline void ModuleParams::_internal_set_unique_reports(bool value) {
  ;
  _impl_.unique_reports_ = value;
}

// string description = 8 [json_name = "description"];
inline void ModuleParams::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModuleParams::description() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.description)
}
inline std::string* ModuleParams::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.description)
  return _s;
}
inline const std::string& ModuleParams::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModuleParams::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_description() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.description)
  return _impl_.description_.Release();
}
inline void ModuleParams::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.description)
}

// string feed_admin = 9 [json_name = "feedAdmin"];
inline void ModuleParams::clear_feed_admin() {
  _impl_.feed_admin_.ClearToEmpty();
}
inline const std::string& ModuleParams::feed_admin() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.feed_admin)
  return _internal_feed_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_feed_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.feed_admin)
}
inline std::string* ModuleParams::mutable_feed_admin() {
  std::string* _s = _internal_mutable_feed_admin();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.feed_admin)
  return _s;
}
inline const std::string& ModuleParams::_internal_feed_admin() const {
  return _impl_.feed_admin_.Get();
}
inline void ModuleParams::_internal_set_feed_admin(const std::string& value) {
  ;


  _impl_.feed_admin_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_feed_admin() {
  ;
  return _impl_.feed_admin_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_feed_admin() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.feed_admin)
  return _impl_.feed_admin_.Release();
}
inline void ModuleParams::set_allocated_feed_admin(std::string* value) {
  _impl_.feed_admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_admin_.IsDefault()) {
          _impl_.feed_admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.feed_admin)
}

// string billing_admin = 10 [json_name = "billingAdmin"];
inline void ModuleParams::clear_billing_admin() {
  _impl_.billing_admin_.ClearToEmpty();
}
inline const std::string& ModuleParams::billing_admin() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ModuleParams.billing_admin)
  return _internal_billing_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleParams::set_billing_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.billing_admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ModuleParams.billing_admin)
}
inline std::string* ModuleParams::mutable_billing_admin() {
  std::string* _s = _internal_mutable_billing_admin();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ModuleParams.billing_admin)
  return _s;
}
inline const std::string& ModuleParams::_internal_billing_admin() const {
  return _impl_.billing_admin_.Get();
}
inline void ModuleParams::_internal_set_billing_admin(const std::string& value) {
  ;


  _impl_.billing_admin_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleParams::_internal_mutable_billing_admin() {
  ;
  return _impl_.billing_admin_.Mutable( GetArenaForAllocation());
}
inline std::string* ModuleParams::release_billing_admin() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ModuleParams.billing_admin)
  return _impl_.billing_admin_.Release();
}
inline void ModuleParams::set_allocated_billing_admin(std::string* value) {
  _impl_.billing_admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.billing_admin_.IsDefault()) {
          _impl_.billing_admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ModuleParams.billing_admin)
}

// -------------------------------------------------------------------

// ContractConfig

// uint64 config_count = 1 [json_name = "configCount"];
inline void ContractConfig::clear_config_count() {
  _impl_.config_count_ = ::uint64_t{0u};
}
inline ::uint64_t ContractConfig::config_count() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ContractConfig.config_count)
  return _internal_config_count();
}
inline void ContractConfig::set_config_count(::uint64_t value) {
  _internal_set_config_count(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.config_count)
}
inline ::uint64_t ContractConfig::_internal_config_count() const {
  return _impl_.config_count_;
}
inline void ContractConfig::_internal_set_config_count(::uint64_t value) {
  ;
  _impl_.config_count_ = value;
}

// repeated string signers = 2 [json_name = "signers"];
inline int ContractConfig::_internal_signers_size() const {
  return _impl_.signers_.size();
}
inline int ContractConfig::signers_size() const {
  return _internal_signers_size();
}
inline void ContractConfig::clear_signers() {
  _internal_mutable_signers()->Clear();
}
inline std::string* ContractConfig::add_signers() {
  std::string* _s = _internal_add_signers();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.ContractConfig.signers)
  return _s;
}
inline const std::string& ContractConfig::signers(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ContractConfig.signers)
  return _internal_signers(index);
}
inline std::string* ContractConfig::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ContractConfig.signers)
  return _internal_mutable_signers()->Mutable(index);
}
inline void ContractConfig::set_signers(int index, const std::string& value) {
  _internal_mutable_signers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::set_signers(int index, std::string&& value) {
  _internal_mutable_signers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::set_signers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::set_signers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_signers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::set_signers(int index, absl::string_view value) {
  _internal_mutable_signers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::add_signers(const std::string& value) {
  _internal_mutable_signers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::add_signers(std::string&& value) {
  _internal_mutable_signers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::add_signers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::add_signers(const char* value, std::size_t size) {
  _internal_mutable_signers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.ContractConfig.signers)
}
inline void ContractConfig::add_signers(absl::string_view value) {
  _internal_mutable_signers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.ContractConfig.signers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContractConfig::signers() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.ContractConfig.signers)
  return _internal_signers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ContractConfig::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.ContractConfig.signers)
  return _internal_mutable_signers();
}
inline const std::string& ContractConfig::_internal_signers(int index) const {
  return _internal_signers().Get(index);
}
inline std::string* ContractConfig::_internal_add_signers() {
  return _internal_mutable_signers()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContractConfig::_internal_signers() const {
  return _impl_.signers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContractConfig::_internal_mutable_signers() {
  return &_impl_.signers_;
}

// repeated string transmitters = 3 [json_name = "transmitters"];
inline int ContractConfig::_internal_transmitters_size() const {
  return _impl_.transmitters_.size();
}
inline int ContractConfig::transmitters_size() const {
  return _internal_transmitters_size();
}
inline void ContractConfig::clear_transmitters() {
  _internal_mutable_transmitters()->Clear();
}
inline std::string* ContractConfig::add_transmitters() {
  std::string* _s = _internal_add_transmitters();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.ContractConfig.transmitters)
  return _s;
}
inline const std::string& ContractConfig::transmitters(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ContractConfig.transmitters)
  return _internal_transmitters(index);
}
inline std::string* ContractConfig::mutable_transmitters(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ContractConfig.transmitters)
  return _internal_mutable_transmitters()->Mutable(index);
}
inline void ContractConfig::set_transmitters(int index, const std::string& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::set_transmitters(int index, std::string&& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::set_transmitters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::set_transmitters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transmitters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::set_transmitters(int index, absl::string_view value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::add_transmitters(const std::string& value) {
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::add_transmitters(std::string&& value) {
  _internal_mutable_transmitters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::add_transmitters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::add_transmitters(const char* value, std::size_t size) {
  _internal_mutable_transmitters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline void ContractConfig::add_transmitters(absl::string_view value) {
  _internal_mutable_transmitters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.ContractConfig.transmitters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContractConfig::transmitters() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.ContractConfig.transmitters)
  return _internal_transmitters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ContractConfig::mutable_transmitters() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.ContractConfig.transmitters)
  return _internal_mutable_transmitters();
}
inline const std::string& ContractConfig::_internal_transmitters(int index) const {
  return _internal_transmitters().Get(index);
}
inline std::string* ContractConfig::_internal_add_transmitters() {
  return _internal_mutable_transmitters()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContractConfig::_internal_transmitters() const {
  return _impl_.transmitters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContractConfig::_internal_mutable_transmitters() {
  return &_impl_.transmitters_;
}

// uint32 f = 4 [json_name = "f"];
inline void ContractConfig::clear_f() {
  _impl_.f_ = 0u;
}
inline ::uint32_t ContractConfig::f() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ContractConfig.f)
  return _internal_f();
}
inline void ContractConfig::set_f(::uint32_t value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.f)
}
inline ::uint32_t ContractConfig::_internal_f() const {
  return _impl_.f_;
}
inline void ContractConfig::_internal_set_f(::uint32_t value) {
  ;
  _impl_.f_ = value;
}

// bytes onchain_config = 5 [json_name = "onchainConfig"];
inline void ContractConfig::clear_onchain_config() {
  _impl_.onchain_config_.ClearToEmpty();
}
inline const std::string& ContractConfig::onchain_config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ContractConfig.onchain_config)
  return _internal_onchain_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractConfig::set_onchain_config(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.onchain_config_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.onchain_config)
}
inline std::string* ContractConfig::mutable_onchain_config() {
  std::string* _s = _internal_mutable_onchain_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ContractConfig.onchain_config)
  return _s;
}
inline const std::string& ContractConfig::_internal_onchain_config() const {
  return _impl_.onchain_config_.Get();
}
inline void ContractConfig::_internal_set_onchain_config(const std::string& value) {
  ;


  _impl_.onchain_config_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractConfig::_internal_mutable_onchain_config() {
  ;
  return _impl_.onchain_config_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractConfig::release_onchain_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ContractConfig.onchain_config)
  return _impl_.onchain_config_.Release();
}
inline void ContractConfig::set_allocated_onchain_config(std::string* value) {
  _impl_.onchain_config_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.onchain_config_.IsDefault()) {
          _impl_.onchain_config_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ContractConfig.onchain_config)
}

// uint64 offchain_config_version = 6 [json_name = "offchainConfigVersion"];
inline void ContractConfig::clear_offchain_config_version() {
  _impl_.offchain_config_version_ = ::uint64_t{0u};
}
inline ::uint64_t ContractConfig::offchain_config_version() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ContractConfig.offchain_config_version)
  return _internal_offchain_config_version();
}
inline void ContractConfig::set_offchain_config_version(::uint64_t value) {
  _internal_set_offchain_config_version(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.offchain_config_version)
}
inline ::uint64_t ContractConfig::_internal_offchain_config_version() const {
  return _impl_.offchain_config_version_;
}
inline void ContractConfig::_internal_set_offchain_config_version(::uint64_t value) {
  ;
  _impl_.offchain_config_version_ = value;
}

// bytes offchain_config = 7 [json_name = "offchainConfig"];
inline void ContractConfig::clear_offchain_config() {
  _impl_.offchain_config_.ClearToEmpty();
}
inline const std::string& ContractConfig::offchain_config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ContractConfig.offchain_config)
  return _internal_offchain_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractConfig::set_offchain_config(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.offchain_config_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ContractConfig.offchain_config)
}
inline std::string* ContractConfig::mutable_offchain_config() {
  std::string* _s = _internal_mutable_offchain_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ContractConfig.offchain_config)
  return _s;
}
inline const std::string& ContractConfig::_internal_offchain_config() const {
  return _impl_.offchain_config_.Get();
}
inline void ContractConfig::_internal_set_offchain_config(const std::string& value) {
  ;


  _impl_.offchain_config_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractConfig::_internal_mutable_offchain_config() {
  ;
  return _impl_.offchain_config_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractConfig::release_offchain_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ContractConfig.offchain_config)
  return _impl_.offchain_config_.Release();
}
inline void ContractConfig::set_allocated_offchain_config(std::string* value) {
  _impl_.offchain_config_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.offchain_config_.IsDefault()) {
          _impl_.offchain_config_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ContractConfig.offchain_config)
}

// -------------------------------------------------------------------

// SetConfigProposal

// string title = 1 [json_name = "title"];
inline void SetConfigProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& SetConfigProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetConfigProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetConfigProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetConfigProposal.title)
}
inline std::string* SetConfigProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetConfigProposal.title)
  return _s;
}
inline const std::string& SetConfigProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SetConfigProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SetConfigProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* SetConfigProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.SetConfigProposal.title)
  return _impl_.title_.Release();
}
inline void SetConfigProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.SetConfigProposal.title)
}

// string description = 2 [json_name = "description"];
inline void SetConfigProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& SetConfigProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetConfigProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetConfigProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetConfigProposal.description)
}
inline std::string* SetConfigProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetConfigProposal.description)
  return _s;
}
inline const std::string& SetConfigProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void SetConfigProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* SetConfigProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* SetConfigProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.SetConfigProposal.description)
  return _impl_.description_.Release();
}
inline void SetConfigProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.SetConfigProposal.description)
}

// .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
inline bool SetConfigProposal::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void SetConfigProposal::clear_config() {
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::ocr::v1beta1::FeedConfig& SetConfigProposal::_internal_config() const {
  const ::injective::ocr::v1beta1::FeedConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::ocr::v1beta1::FeedConfig&>(
      ::injective::ocr::v1beta1::_FeedConfig_default_instance_);
}
inline const ::injective::ocr::v1beta1::FeedConfig& SetConfigProposal::config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetConfigProposal.config)
  return _internal_config();
}
inline void SetConfigProposal::unsafe_arena_set_allocated_config(
    ::injective::ocr::v1beta1::FeedConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.SetConfigProposal.config)
}
inline ::injective::ocr::v1beta1::FeedConfig* SetConfigProposal::release_config() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::FeedConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::ocr::v1beta1::FeedConfig* SetConfigProposal::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.SetConfigProposal.config)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::FeedConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::injective::ocr::v1beta1::FeedConfig* SetConfigProposal::_internal_mutable_config() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::ocr::v1beta1::FeedConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::injective::ocr::v1beta1::FeedConfig* SetConfigProposal::mutable_config() {
  ::injective::ocr::v1beta1::FeedConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetConfigProposal.config)
  return _msg;
}
inline void SetConfigProposal::set_allocated_config(::injective::ocr::v1beta1::FeedConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.SetConfigProposal.config)
}

// -------------------------------------------------------------------

// FeedProperties

// string feed_id = 1 [json_name = "feedId"];
inline void FeedProperties::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& FeedProperties::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedProperties::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.feed_id)
}
inline std::string* FeedProperties::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedProperties.feed_id)
  return _s;
}
inline const std::string& FeedProperties::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void FeedProperties::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedProperties::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedProperties::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedProperties.feed_id)
  return _impl_.feed_id_.Release();
}
inline void FeedProperties::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedProperties.feed_id)
}

// uint32 f = 2 [json_name = "f"];
inline void FeedProperties::clear_f() {
  _impl_.f_ = 0u;
}
inline ::uint32_t FeedProperties::f() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.f)
  return _internal_f();
}
inline void FeedProperties::set_f(::uint32_t value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.f)
}
inline ::uint32_t FeedProperties::_internal_f() const {
  return _impl_.f_;
}
inline void FeedProperties::_internal_set_f(::uint32_t value) {
  ;
  _impl_.f_ = value;
}

// bytes onchain_config = 3 [json_name = "onchainConfig"];
inline void FeedProperties::clear_onchain_config() {
  _impl_.onchain_config_.ClearToEmpty();
}
inline const std::string& FeedProperties::onchain_config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.onchain_config)
  return _internal_onchain_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedProperties::set_onchain_config(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.onchain_config_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.onchain_config)
}
inline std::string* FeedProperties::mutable_onchain_config() {
  std::string* _s = _internal_mutable_onchain_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedProperties.onchain_config)
  return _s;
}
inline const std::string& FeedProperties::_internal_onchain_config() const {
  return _impl_.onchain_config_.Get();
}
inline void FeedProperties::_internal_set_onchain_config(const std::string& value) {
  ;


  _impl_.onchain_config_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedProperties::_internal_mutable_onchain_config() {
  ;
  return _impl_.onchain_config_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedProperties::release_onchain_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedProperties.onchain_config)
  return _impl_.onchain_config_.Release();
}
inline void FeedProperties::set_allocated_onchain_config(std::string* value) {
  _impl_.onchain_config_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.onchain_config_.IsDefault()) {
          _impl_.onchain_config_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedProperties.onchain_config)
}

// uint64 offchain_config_version = 4 [json_name = "offchainConfigVersion"];
inline void FeedProperties::clear_offchain_config_version() {
  _impl_.offchain_config_version_ = ::uint64_t{0u};
}
inline ::uint64_t FeedProperties::offchain_config_version() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.offchain_config_version)
  return _internal_offchain_config_version();
}
inline void FeedProperties::set_offchain_config_version(::uint64_t value) {
  _internal_set_offchain_config_version(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.offchain_config_version)
}
inline ::uint64_t FeedProperties::_internal_offchain_config_version() const {
  return _impl_.offchain_config_version_;
}
inline void FeedProperties::_internal_set_offchain_config_version(::uint64_t value) {
  ;
  _impl_.offchain_config_version_ = value;
}

// bytes offchain_config = 5 [json_name = "offchainConfig"];
inline void FeedProperties::clear_offchain_config() {
  _impl_.offchain_config_.ClearToEmpty();
}
inline const std::string& FeedProperties::offchain_config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.offchain_config)
  return _internal_offchain_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedProperties::set_offchain_config(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.offchain_config_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.offchain_config)
}
inline std::string* FeedProperties::mutable_offchain_config() {
  std::string* _s = _internal_mutable_offchain_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedProperties.offchain_config)
  return _s;
}
inline const std::string& FeedProperties::_internal_offchain_config() const {
  return _impl_.offchain_config_.Get();
}
inline void FeedProperties::_internal_set_offchain_config(const std::string& value) {
  ;


  _impl_.offchain_config_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedProperties::_internal_mutable_offchain_config() {
  ;
  return _impl_.offchain_config_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedProperties::release_offchain_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedProperties.offchain_config)
  return _impl_.offchain_config_.Release();
}
inline void FeedProperties::set_allocated_offchain_config(std::string* value) {
  _impl_.offchain_config_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.offchain_config_.IsDefault()) {
          _impl_.offchain_config_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedProperties.offchain_config)
}

// string min_answer = 6 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void FeedProperties::clear_min_answer() {
  _impl_.min_answer_.ClearToEmpty();
}
inline const std::string& FeedProperties::min_answer() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.min_answer)
  return _internal_min_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedProperties::set_min_answer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_answer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.min_answer)
}
inline std::string* FeedProperties::mutable_min_answer() {
  std::string* _s = _internal_mutable_min_answer();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedProperties.min_answer)
  return _s;
}
inline const std::string& FeedProperties::_internal_min_answer() const {
  return _impl_.min_answer_.Get();
}
inline void FeedProperties::_internal_set_min_answer(const std::string& value) {
  ;


  _impl_.min_answer_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedProperties::_internal_mutable_min_answer() {
  ;
  return _impl_.min_answer_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedProperties::release_min_answer() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedProperties.min_answer)
  return _impl_.min_answer_.Release();
}
inline void FeedProperties::set_allocated_min_answer(std::string* value) {
  _impl_.min_answer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_answer_.IsDefault()) {
          _impl_.min_answer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedProperties.min_answer)
}

// string max_answer = 7 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void FeedProperties::clear_max_answer() {
  _impl_.max_answer_.ClearToEmpty();
}
inline const std::string& FeedProperties::max_answer() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.max_answer)
  return _internal_max_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedProperties::set_max_answer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.max_answer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.max_answer)
}
inline std::string* FeedProperties::mutable_max_answer() {
  std::string* _s = _internal_mutable_max_answer();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedProperties.max_answer)
  return _s;
}
inline const std::string& FeedProperties::_internal_max_answer() const {
  return _impl_.max_answer_.Get();
}
inline void FeedProperties::_internal_set_max_answer(const std::string& value) {
  ;


  _impl_.max_answer_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedProperties::_internal_mutable_max_answer() {
  ;
  return _impl_.max_answer_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedProperties::release_max_answer() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedProperties.max_answer)
  return _impl_.max_answer_.Release();
}
inline void FeedProperties::set_allocated_max_answer(std::string* value) {
  _impl_.max_answer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.max_answer_.IsDefault()) {
          _impl_.max_answer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedProperties.max_answer)
}

// string link_per_observation = 8 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void FeedProperties::clear_link_per_observation() {
  _impl_.link_per_observation_.ClearToEmpty();
}
inline const std::string& FeedProperties::link_per_observation() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.link_per_observation)
  return _internal_link_per_observation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedProperties::set_link_per_observation(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_per_observation_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.link_per_observation)
}
inline std::string* FeedProperties::mutable_link_per_observation() {
  std::string* _s = _internal_mutable_link_per_observation();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedProperties.link_per_observation)
  return _s;
}
inline const std::string& FeedProperties::_internal_link_per_observation() const {
  return _impl_.link_per_observation_.Get();
}
inline void FeedProperties::_internal_set_link_per_observation(const std::string& value) {
  ;


  _impl_.link_per_observation_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedProperties::_internal_mutable_link_per_observation() {
  ;
  return _impl_.link_per_observation_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedProperties::release_link_per_observation() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedProperties.link_per_observation)
  return _impl_.link_per_observation_.Release();
}
inline void FeedProperties::set_allocated_link_per_observation(std::string* value) {
  _impl_.link_per_observation_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_per_observation_.IsDefault()) {
          _impl_.link_per_observation_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedProperties.link_per_observation)
}

// string link_per_transmission = 9 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void FeedProperties::clear_link_per_transmission() {
  _impl_.link_per_transmission_.ClearToEmpty();
}
inline const std::string& FeedProperties::link_per_transmission() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.link_per_transmission)
  return _internal_link_per_transmission();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedProperties::set_link_per_transmission(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_per_transmission_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.link_per_transmission)
}
inline std::string* FeedProperties::mutable_link_per_transmission() {
  std::string* _s = _internal_mutable_link_per_transmission();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedProperties.link_per_transmission)
  return _s;
}
inline const std::string& FeedProperties::_internal_link_per_transmission() const {
  return _impl_.link_per_transmission_.Get();
}
inline void FeedProperties::_internal_set_link_per_transmission(const std::string& value) {
  ;


  _impl_.link_per_transmission_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedProperties::_internal_mutable_link_per_transmission() {
  ;
  return _impl_.link_per_transmission_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedProperties::release_link_per_transmission() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedProperties.link_per_transmission)
  return _impl_.link_per_transmission_.Release();
}
inline void FeedProperties::set_allocated_link_per_transmission(std::string* value) {
  _impl_.link_per_transmission_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_per_transmission_.IsDefault()) {
          _impl_.link_per_transmission_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedProperties.link_per_transmission)
}

// bool unique_reports = 10 [json_name = "uniqueReports"];
inline void FeedProperties::clear_unique_reports() {
  _impl_.unique_reports_ = false;
}
inline bool FeedProperties::unique_reports() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.unique_reports)
  return _internal_unique_reports();
}
inline void FeedProperties::set_unique_reports(bool value) {
  _internal_set_unique_reports(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.unique_reports)
}
inline bool FeedProperties::_internal_unique_reports() const {
  return _impl_.unique_reports_;
}
inline void FeedProperties::_internal_set_unique_reports(bool value) {
  ;
  _impl_.unique_reports_ = value;
}

// string description = 11 [json_name = "description"];
inline void FeedProperties::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& FeedProperties::description() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.FeedProperties.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedProperties::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.FeedProperties.description)
}
inline std::string* FeedProperties::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.FeedProperties.description)
  return _s;
}
inline const std::string& FeedProperties::_internal_description() const {
  return _impl_.description_.Get();
}
inline void FeedProperties::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedProperties::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedProperties::release_description() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.FeedProperties.description)
  return _impl_.description_.Release();
}
inline void FeedProperties::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.FeedProperties.description)
}

// -------------------------------------------------------------------

// SetBatchConfigProposal

// string title = 1 [json_name = "title"];
inline void SetBatchConfigProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& SetBatchConfigProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetBatchConfigProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetBatchConfigProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetBatchConfigProposal.title)
}
inline std::string* SetBatchConfigProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetBatchConfigProposal.title)
  return _s;
}
inline const std::string& SetBatchConfigProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SetBatchConfigProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SetBatchConfigProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* SetBatchConfigProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.SetBatchConfigProposal.title)
  return _impl_.title_.Release();
}
inline void SetBatchConfigProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.SetBatchConfigProposal.title)
}

// string description = 2 [json_name = "description"];
inline void SetBatchConfigProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& SetBatchConfigProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetBatchConfigProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetBatchConfigProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetBatchConfigProposal.description)
}
inline std::string* SetBatchConfigProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetBatchConfigProposal.description)
  return _s;
}
inline const std::string& SetBatchConfigProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void SetBatchConfigProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* SetBatchConfigProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* SetBatchConfigProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.SetBatchConfigProposal.description)
  return _impl_.description_.Release();
}
inline void SetBatchConfigProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.SetBatchConfigProposal.description)
}

// repeated string signers = 3 [json_name = "signers"];
inline int SetBatchConfigProposal::_internal_signers_size() const {
  return _impl_.signers_.size();
}
inline int SetBatchConfigProposal::signers_size() const {
  return _internal_signers_size();
}
inline void SetBatchConfigProposal::clear_signers() {
  _internal_mutable_signers()->Clear();
}
inline std::string* SetBatchConfigProposal::add_signers() {
  std::string* _s = _internal_add_signers();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
  return _s;
}
inline const std::string& SetBatchConfigProposal::signers(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
  return _internal_signers(index);
}
inline std::string* SetBatchConfigProposal::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
  return _internal_mutable_signers()->Mutable(index);
}
inline void SetBatchConfigProposal::set_signers(int index, const std::string& value) {
  _internal_mutable_signers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::set_signers(int index, std::string&& value) {
  _internal_mutable_signers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::set_signers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::set_signers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_signers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::set_signers(int index, absl::string_view value) {
  _internal_mutable_signers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::add_signers(const std::string& value) {
  _internal_mutable_signers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::add_signers(std::string&& value) {
  _internal_mutable_signers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::add_signers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::add_signers(const char* value, std::size_t size) {
  _internal_mutable_signers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline void SetBatchConfigProposal::add_signers(absl::string_view value) {
  _internal_mutable_signers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetBatchConfigProposal::signers() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
  return _internal_signers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SetBatchConfigProposal::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.SetBatchConfigProposal.signers)
  return _internal_mutable_signers();
}
inline const std::string& SetBatchConfigProposal::_internal_signers(int index) const {
  return _internal_signers().Get(index);
}
inline std::string* SetBatchConfigProposal::_internal_add_signers() {
  return _internal_mutable_signers()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetBatchConfigProposal::_internal_signers() const {
  return _impl_.signers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetBatchConfigProposal::_internal_mutable_signers() {
  return &_impl_.signers_;
}

// repeated string transmitters = 4 [json_name = "transmitters"];
inline int SetBatchConfigProposal::_internal_transmitters_size() const {
  return _impl_.transmitters_.size();
}
inline int SetBatchConfigProposal::transmitters_size() const {
  return _internal_transmitters_size();
}
inline void SetBatchConfigProposal::clear_transmitters() {
  _internal_mutable_transmitters()->Clear();
}
inline std::string* SetBatchConfigProposal::add_transmitters() {
  std::string* _s = _internal_add_transmitters();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
  return _s;
}
inline const std::string& SetBatchConfigProposal::transmitters(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
  return _internal_transmitters(index);
}
inline std::string* SetBatchConfigProposal::mutable_transmitters(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
  return _internal_mutable_transmitters()->Mutable(index);
}
inline void SetBatchConfigProposal::set_transmitters(int index, const std::string& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::set_transmitters(int index, std::string&& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::set_transmitters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::set_transmitters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transmitters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::set_transmitters(int index, absl::string_view value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::add_transmitters(const std::string& value) {
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::add_transmitters(std::string&& value) {
  _internal_mutable_transmitters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::add_transmitters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::add_transmitters(const char* value, std::size_t size) {
  _internal_mutable_transmitters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline void SetBatchConfigProposal::add_transmitters(absl::string_view value) {
  _internal_mutable_transmitters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetBatchConfigProposal::transmitters() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
  return _internal_transmitters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SetBatchConfigProposal::mutable_transmitters() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.SetBatchConfigProposal.transmitters)
  return _internal_mutable_transmitters();
}
inline const std::string& SetBatchConfigProposal::_internal_transmitters(int index) const {
  return _internal_transmitters().Get(index);
}
inline std::string* SetBatchConfigProposal::_internal_add_transmitters() {
  return _internal_mutable_transmitters()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetBatchConfigProposal::_internal_transmitters() const {
  return _impl_.transmitters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetBatchConfigProposal::_internal_mutable_transmitters() {
  return &_impl_.transmitters_;
}

// string link_denom = 5 [json_name = "linkDenom"];
inline void SetBatchConfigProposal::clear_link_denom() {
  _impl_.link_denom_.ClearToEmpty();
}
inline const std::string& SetBatchConfigProposal::link_denom() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetBatchConfigProposal.link_denom)
  return _internal_link_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetBatchConfigProposal::set_link_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.SetBatchConfigProposal.link_denom)
}
inline std::string* SetBatchConfigProposal::mutable_link_denom() {
  std::string* _s = _internal_mutable_link_denom();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetBatchConfigProposal.link_denom)
  return _s;
}
inline const std::string& SetBatchConfigProposal::_internal_link_denom() const {
  return _impl_.link_denom_.Get();
}
inline void SetBatchConfigProposal::_internal_set_link_denom(const std::string& value) {
  ;


  _impl_.link_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SetBatchConfigProposal::_internal_mutable_link_denom() {
  ;
  return _impl_.link_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SetBatchConfigProposal::release_link_denom() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.SetBatchConfigProposal.link_denom)
  return _impl_.link_denom_.Release();
}
inline void SetBatchConfigProposal::set_allocated_link_denom(std::string* value) {
  _impl_.link_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_denom_.IsDefault()) {
          _impl_.link_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.SetBatchConfigProposal.link_denom)
}

// repeated .injective.ocr.v1beta1.FeedProperties feed_properties = 6 [json_name = "feedProperties"];
inline int SetBatchConfigProposal::_internal_feed_properties_size() const {
  return _impl_.feed_properties_.size();
}
inline int SetBatchConfigProposal::feed_properties_size() const {
  return _internal_feed_properties_size();
}
inline void SetBatchConfigProposal::clear_feed_properties() {
  _internal_mutable_feed_properties()->Clear();
}
inline ::injective::ocr::v1beta1::FeedProperties* SetBatchConfigProposal::mutable_feed_properties(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.SetBatchConfigProposal.feed_properties)
  return _internal_mutable_feed_properties()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::ocr::v1beta1::FeedProperties >*
SetBatchConfigProposal::mutable_feed_properties() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.SetBatchConfigProposal.feed_properties)
  return _internal_mutable_feed_properties();
}
inline const ::injective::ocr::v1beta1::FeedProperties& SetBatchConfigProposal::_internal_feed_properties(int index) const {
  return _internal_feed_properties().Get(index);
}
inline const ::injective::ocr::v1beta1::FeedProperties& SetBatchConfigProposal::feed_properties(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.SetBatchConfigProposal.feed_properties)
  return _internal_feed_properties(index);
}
inline ::injective::ocr::v1beta1::FeedProperties* SetBatchConfigProposal::_internal_add_feed_properties() {
  return _internal_mutable_feed_properties()->Add();
}
inline ::injective::ocr::v1beta1::FeedProperties* SetBatchConfigProposal::add_feed_properties() {
  ::injective::ocr::v1beta1::FeedProperties* _add = _internal_add_feed_properties();
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.SetBatchConfigProposal.feed_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::ocr::v1beta1::FeedProperties >&
SetBatchConfigProposal::feed_properties() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.SetBatchConfigProposal.feed_properties)
  return _internal_feed_properties();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::ocr::v1beta1::FeedProperties>&
SetBatchConfigProposal::_internal_feed_properties() const {
  return _impl_.feed_properties_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::ocr::v1beta1::FeedProperties>*
SetBatchConfigProposal::_internal_mutable_feed_properties() {
  return &_impl_.feed_properties_;
}

// -------------------------------------------------------------------

// OracleObservationsCounts

// repeated uint32 counts = 1 [json_name = "counts"];
inline int OracleObservationsCounts::_internal_counts_size() const {
  return _impl_.counts_.size();
}
inline int OracleObservationsCounts::counts_size() const {
  return _internal_counts_size();
}
inline void OracleObservationsCounts::clear_counts() {
  _internal_mutable_counts()->Clear();
}
inline ::uint32_t OracleObservationsCounts::counts(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.OracleObservationsCounts.counts)
  return _internal_counts(index);
}
inline void OracleObservationsCounts::set_counts(int index, ::uint32_t value) {
  _internal_mutable_counts()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.OracleObservationsCounts.counts)
}
inline void OracleObservationsCounts::add_counts(::uint32_t value) {
  _internal_add_counts(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.OracleObservationsCounts.counts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& OracleObservationsCounts::counts() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.OracleObservationsCounts.counts)
  return _internal_counts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* OracleObservationsCounts::mutable_counts() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.OracleObservationsCounts.counts)
  return _internal_mutable_counts();
}

inline ::uint32_t OracleObservationsCounts::_internal_counts(int index) const {
  return _internal_counts().Get(index);
}
inline void OracleObservationsCounts::_internal_add_counts(::uint32_t value) {
  _internal_mutable_counts()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& OracleObservationsCounts::_internal_counts() const {
  return _impl_.counts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* OracleObservationsCounts::_internal_mutable_counts() {
  return &_impl_.counts_;
}

// -------------------------------------------------------------------

// GasReimbursements

// repeated .cosmos.base.v1beta1.Coin reimbursements = 1 [json_name = "reimbursements"];
inline int GasReimbursements::_internal_reimbursements_size() const {
  return _impl_.reimbursements_.size();
}
inline int GasReimbursements::reimbursements_size() const {
  return _internal_reimbursements_size();
}
inline ::cosmos::base::v1beta1::Coin* GasReimbursements::mutable_reimbursements(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.GasReimbursements.reimbursements)
  return _internal_mutable_reimbursements()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
GasReimbursements::mutable_reimbursements() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.GasReimbursements.reimbursements)
  return _internal_mutable_reimbursements();
}
inline const ::cosmos::base::v1beta1::Coin& GasReimbursements::_internal_reimbursements(int index) const {
  return _internal_reimbursements().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& GasReimbursements::reimbursements(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.GasReimbursements.reimbursements)
  return _internal_reimbursements(index);
}
inline ::cosmos::base::v1beta1::Coin* GasReimbursements::_internal_add_reimbursements() {
  return _internal_mutable_reimbursements()->Add();
}
inline ::cosmos::base::v1beta1::Coin* GasReimbursements::add_reimbursements() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_reimbursements();
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.GasReimbursements.reimbursements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
GasReimbursements::reimbursements() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.GasReimbursements.reimbursements)
  return _internal_reimbursements();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
GasReimbursements::_internal_reimbursements() const {
  return _impl_.reimbursements_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
GasReimbursements::_internal_mutable_reimbursements() {
  return &_impl_.reimbursements_;
}

// -------------------------------------------------------------------

// Payee

// string transmitter_addr = 1 [json_name = "transmitterAddr"];
inline void Payee::clear_transmitter_addr() {
  _impl_.transmitter_addr_.ClearToEmpty();
}
inline const std::string& Payee::transmitter_addr() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Payee.transmitter_addr)
  return _internal_transmitter_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Payee::set_transmitter_addr(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.transmitter_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Payee.transmitter_addr)
}
inline std::string* Payee::mutable_transmitter_addr() {
  std::string* _s = _internal_mutable_transmitter_addr();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.Payee.transmitter_addr)
  return _s;
}
inline const std::string& Payee::_internal_transmitter_addr() const {
  return _impl_.transmitter_addr_.Get();
}
inline void Payee::_internal_set_transmitter_addr(const std::string& value) {
  ;


  _impl_.transmitter_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* Payee::_internal_mutable_transmitter_addr() {
  ;
  return _impl_.transmitter_addr_.Mutable( GetArenaForAllocation());
}
inline std::string* Payee::release_transmitter_addr() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.Payee.transmitter_addr)
  return _impl_.transmitter_addr_.Release();
}
inline void Payee::set_allocated_transmitter_addr(std::string* value) {
  _impl_.transmitter_addr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmitter_addr_.IsDefault()) {
          _impl_.transmitter_addr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.Payee.transmitter_addr)
}

// string payment_addr = 2 [json_name = "paymentAddr"];
inline void Payee::clear_payment_addr() {
  _impl_.payment_addr_.ClearToEmpty();
}
inline const std::string& Payee::payment_addr() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Payee.payment_addr)
  return _internal_payment_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Payee::set_payment_addr(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payment_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Payee.payment_addr)
}
inline std::string* Payee::mutable_payment_addr() {
  std::string* _s = _internal_mutable_payment_addr();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.Payee.payment_addr)
  return _s;
}
inline const std::string& Payee::_internal_payment_addr() const {
  return _impl_.payment_addr_.Get();
}
inline void Payee::_internal_set_payment_addr(const std::string& value) {
  ;


  _impl_.payment_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* Payee::_internal_mutable_payment_addr() {
  ;
  return _impl_.payment_addr_.Mutable( GetArenaForAllocation());
}
inline std::string* Payee::release_payment_addr() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.Payee.payment_addr)
  return _impl_.payment_addr_.Release();
}
inline void Payee::set_allocated_payment_addr(std::string* value) {
  _impl_.payment_addr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payment_addr_.IsDefault()) {
          _impl_.payment_addr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.Payee.payment_addr)
}

// -------------------------------------------------------------------

// Transmission

// string answer = 1 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void Transmission::clear_answer() {
  _impl_.answer_.ClearToEmpty();
}
inline const std::string& Transmission::answer() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Transmission.answer)
  return _internal_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Transmission::set_answer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.answer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Transmission.answer)
}
inline std::string* Transmission::mutable_answer() {
  std::string* _s = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.Transmission.answer)
  return _s;
}
inline const std::string& Transmission::_internal_answer() const {
  return _impl_.answer_.Get();
}
inline void Transmission::_internal_set_answer(const std::string& value) {
  ;


  _impl_.answer_.Set(value, GetArenaForAllocation());
}
inline std::string* Transmission::_internal_mutable_answer() {
  ;
  return _impl_.answer_.Mutable( GetArenaForAllocation());
}
inline std::string* Transmission::release_answer() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.Transmission.answer)
  return _impl_.answer_.Release();
}
inline void Transmission::set_allocated_answer(std::string* value) {
  _impl_.answer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.answer_.IsDefault()) {
          _impl_.answer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.Transmission.answer)
}

// int64 observations_timestamp = 2 [json_name = "observationsTimestamp"];
inline void Transmission::clear_observations_timestamp() {
  _impl_.observations_timestamp_ = ::int64_t{0};
}
inline ::int64_t Transmission::observations_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Transmission.observations_timestamp)
  return _internal_observations_timestamp();
}
inline void Transmission::set_observations_timestamp(::int64_t value) {
  _internal_set_observations_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Transmission.observations_timestamp)
}
inline ::int64_t Transmission::_internal_observations_timestamp() const {
  return _impl_.observations_timestamp_;
}
inline void Transmission::_internal_set_observations_timestamp(::int64_t value) {
  ;
  _impl_.observations_timestamp_ = value;
}

// int64 transmission_timestamp = 3 [json_name = "transmissionTimestamp"];
inline void Transmission::clear_transmission_timestamp() {
  _impl_.transmission_timestamp_ = ::int64_t{0};
}
inline ::int64_t Transmission::transmission_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Transmission.transmission_timestamp)
  return _internal_transmission_timestamp();
}
inline void Transmission::set_transmission_timestamp(::int64_t value) {
  _internal_set_transmission_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Transmission.transmission_timestamp)
}
inline ::int64_t Transmission::_internal_transmission_timestamp() const {
  return _impl_.transmission_timestamp_;
}
inline void Transmission::_internal_set_transmission_timestamp(::int64_t value) {
  ;
  _impl_.transmission_timestamp_ = value;
}

// -------------------------------------------------------------------

// EpochAndRound

// uint64 epoch = 1 [json_name = "epoch"];
inline void EpochAndRound::clear_epoch() {
  _impl_.epoch_ = ::uint64_t{0u};
}
inline ::uint64_t EpochAndRound::epoch() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EpochAndRound.epoch)
  return _internal_epoch();
}
inline void EpochAndRound::set_epoch(::uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EpochAndRound.epoch)
}
inline ::uint64_t EpochAndRound::_internal_epoch() const {
  return _impl_.epoch_;
}
inline void EpochAndRound::_internal_set_epoch(::uint64_t value) {
  ;
  _impl_.epoch_ = value;
}

// uint64 round = 2 [json_name = "round"];
inline void EpochAndRound::clear_round() {
  _impl_.round_ = ::uint64_t{0u};
}
inline ::uint64_t EpochAndRound::round() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EpochAndRound.round)
  return _internal_round();
}
inline void EpochAndRound::set_round(::uint64_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EpochAndRound.round)
}
inline ::uint64_t EpochAndRound::_internal_round() const {
  return _impl_.round_;
}
inline void EpochAndRound::_internal_set_round(::uint64_t value) {
  ;
  _impl_.round_ = value;
}

// -------------------------------------------------------------------

// Report

// int64 observations_timestamp = 1 [json_name = "observationsTimestamp"];
inline void Report::clear_observations_timestamp() {
  _impl_.observations_timestamp_ = ::int64_t{0};
}
inline ::int64_t Report::observations_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Report.observations_timestamp)
  return _internal_observations_timestamp();
}
inline void Report::set_observations_timestamp(::int64_t value) {
  _internal_set_observations_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Report.observations_timestamp)
}
inline ::int64_t Report::_internal_observations_timestamp() const {
  return _impl_.observations_timestamp_;
}
inline void Report::_internal_set_observations_timestamp(::int64_t value) {
  ;
  _impl_.observations_timestamp_ = value;
}

// bytes observers = 2 [json_name = "observers"];
inline void Report::clear_observers() {
  _impl_.observers_.ClearToEmpty();
}
inline const std::string& Report::observers() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Report.observers)
  return _internal_observers();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Report::set_observers(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.observers_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Report.observers)
}
inline std::string* Report::mutable_observers() {
  std::string* _s = _internal_mutable_observers();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.Report.observers)
  return _s;
}
inline const std::string& Report::_internal_observers() const {
  return _impl_.observers_.Get();
}
inline void Report::_internal_set_observers(const std::string& value) {
  ;


  _impl_.observers_.Set(value, GetArenaForAllocation());
}
inline std::string* Report::_internal_mutable_observers() {
  ;
  return _impl_.observers_.Mutable( GetArenaForAllocation());
}
inline std::string* Report::release_observers() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.Report.observers)
  return _impl_.observers_.Release();
}
inline void Report::set_allocated_observers(std::string* value) {
  _impl_.observers_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.observers_.IsDefault()) {
          _impl_.observers_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.Report.observers)
}

// repeated string observations = 3 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline int Report::_internal_observations_size() const {
  return _impl_.observations_.size();
}
inline int Report::observations_size() const {
  return _internal_observations_size();
}
inline void Report::clear_observations() {
  _internal_mutable_observations()->Clear();
}
inline std::string* Report::add_observations() {
  std::string* _s = _internal_add_observations();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.Report.observations)
  return _s;
}
inline const std::string& Report::observations(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.Report.observations)
  return _internal_observations(index);
}
inline std::string* Report::mutable_observations(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.Report.observations)
  return _internal_mutable_observations()->Mutable(index);
}
inline void Report::set_observations(int index, const std::string& value) {
  _internal_mutable_observations()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Report.observations)
}
inline void Report::set_observations(int index, std::string&& value) {
  _internal_mutable_observations()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.Report.observations)
}
inline void Report::set_observations(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_observations()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.Report.observations)
}
inline void Report::set_observations(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_observations()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.Report.observations)
}
inline void Report::set_observations(int index, absl::string_view value) {
  _internal_mutable_observations()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.Report.observations)
}
inline void Report::add_observations(const std::string& value) {
  _internal_mutable_observations()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.Report.observations)
}
inline void Report::add_observations(std::string&& value) {
  _internal_mutable_observations()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.Report.observations)
}
inline void Report::add_observations(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_observations()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.Report.observations)
}
inline void Report::add_observations(const char* value, std::size_t size) {
  _internal_mutable_observations()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.Report.observations)
}
inline void Report::add_observations(absl::string_view value) {
  _internal_mutable_observations()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.Report.observations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Report::observations() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.Report.observations)
  return _internal_observations();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Report::mutable_observations() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.Report.observations)
  return _internal_mutable_observations();
}
inline const std::string& Report::_internal_observations(int index) const {
  return _internal_observations().Get(index);
}
inline std::string* Report::_internal_add_observations() {
  return _internal_mutable_observations()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Report::_internal_observations() const {
  return _impl_.observations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Report::_internal_mutable_observations() {
  return &_impl_.observations_;
}

// -------------------------------------------------------------------

// ReportToSign

// bytes config_digest = 1 [json_name = "configDigest"];
inline void ReportToSign::clear_config_digest() {
  _impl_.config_digest_.ClearToEmpty();
}
inline const std::string& ReportToSign::config_digest() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ReportToSign.config_digest)
  return _internal_config_digest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportToSign::set_config_digest(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.config_digest_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ReportToSign.config_digest)
}
inline std::string* ReportToSign::mutable_config_digest() {
  std::string* _s = _internal_mutable_config_digest();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ReportToSign.config_digest)
  return _s;
}
inline const std::string& ReportToSign::_internal_config_digest() const {
  return _impl_.config_digest_.Get();
}
inline void ReportToSign::_internal_set_config_digest(const std::string& value) {
  ;


  _impl_.config_digest_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportToSign::_internal_mutable_config_digest() {
  ;
  return _impl_.config_digest_.Mutable( GetArenaForAllocation());
}
inline std::string* ReportToSign::release_config_digest() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ReportToSign.config_digest)
  return _impl_.config_digest_.Release();
}
inline void ReportToSign::set_allocated_config_digest(std::string* value) {
  _impl_.config_digest_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.config_digest_.IsDefault()) {
          _impl_.config_digest_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ReportToSign.config_digest)
}

// uint64 epoch = 2 [json_name = "epoch"];
inline void ReportToSign::clear_epoch() {
  _impl_.epoch_ = ::uint64_t{0u};
}
inline ::uint64_t ReportToSign::epoch() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ReportToSign.epoch)
  return _internal_epoch();
}
inline void ReportToSign::set_epoch(::uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ReportToSign.epoch)
}
inline ::uint64_t ReportToSign::_internal_epoch() const {
  return _impl_.epoch_;
}
inline void ReportToSign::_internal_set_epoch(::uint64_t value) {
  ;
  _impl_.epoch_ = value;
}

// uint64 round = 3 [json_name = "round"];
inline void ReportToSign::clear_round() {
  _impl_.round_ = ::uint64_t{0u};
}
inline ::uint64_t ReportToSign::round() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ReportToSign.round)
  return _internal_round();
}
inline void ReportToSign::set_round(::uint64_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ReportToSign.round)
}
inline ::uint64_t ReportToSign::_internal_round() const {
  return _impl_.round_;
}
inline void ReportToSign::_internal_set_round(::uint64_t value) {
  ;
  _impl_.round_ = value;
}

// bytes extra_hash = 4 [json_name = "extraHash"];
inline void ReportToSign::clear_extra_hash() {
  _impl_.extra_hash_.ClearToEmpty();
}
inline const std::string& ReportToSign::extra_hash() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ReportToSign.extra_hash)
  return _internal_extra_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportToSign::set_extra_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.extra_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ReportToSign.extra_hash)
}
inline std::string* ReportToSign::mutable_extra_hash() {
  std::string* _s = _internal_mutable_extra_hash();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ReportToSign.extra_hash)
  return _s;
}
inline const std::string& ReportToSign::_internal_extra_hash() const {
  return _impl_.extra_hash_.Get();
}
inline void ReportToSign::_internal_set_extra_hash(const std::string& value) {
  ;


  _impl_.extra_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportToSign::_internal_mutable_extra_hash() {
  ;
  return _impl_.extra_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* ReportToSign::release_extra_hash() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ReportToSign.extra_hash)
  return _impl_.extra_hash_.Release();
}
inline void ReportToSign::set_allocated_extra_hash(std::string* value) {
  _impl_.extra_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extra_hash_.IsDefault()) {
          _impl_.extra_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ReportToSign.extra_hash)
}

// bytes report = 5 [json_name = "report"];
inline void ReportToSign::clear_report() {
  _impl_.report_.ClearToEmpty();
}
inline const std::string& ReportToSign::report() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.ReportToSign.report)
  return _internal_report();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportToSign::set_report(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.report_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.ReportToSign.report)
}
inline std::string* ReportToSign::mutable_report() {
  std::string* _s = _internal_mutable_report();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.ReportToSign.report)
  return _s;
}
inline const std::string& ReportToSign::_internal_report() const {
  return _impl_.report_.Get();
}
inline void ReportToSign::_internal_set_report(const std::string& value) {
  ;


  _impl_.report_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportToSign::_internal_mutable_report() {
  ;
  return _impl_.report_.Mutable( GetArenaForAllocation());
}
inline std::string* ReportToSign::release_report() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.ReportToSign.report)
  return _impl_.report_.Release();
}
inline void ReportToSign::set_allocated_report(std::string* value) {
  _impl_.report_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.report_.IsDefault()) {
          _impl_.report_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.ReportToSign.report)
}

// -------------------------------------------------------------------

// EventOraclePaid

// string transmitter_addr = 1 [json_name = "transmitterAddr"];
inline void EventOraclePaid::clear_transmitter_addr() {
  _impl_.transmitter_addr_.ClearToEmpty();
}
inline const std::string& EventOraclePaid::transmitter_addr() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventOraclePaid.transmitter_addr)
  return _internal_transmitter_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventOraclePaid::set_transmitter_addr(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.transmitter_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventOraclePaid.transmitter_addr)
}
inline std::string* EventOraclePaid::mutable_transmitter_addr() {
  std::string* _s = _internal_mutable_transmitter_addr();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventOraclePaid.transmitter_addr)
  return _s;
}
inline const std::string& EventOraclePaid::_internal_transmitter_addr() const {
  return _impl_.transmitter_addr_.Get();
}
inline void EventOraclePaid::_internal_set_transmitter_addr(const std::string& value) {
  ;


  _impl_.transmitter_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* EventOraclePaid::_internal_mutable_transmitter_addr() {
  ;
  return _impl_.transmitter_addr_.Mutable( GetArenaForAllocation());
}
inline std::string* EventOraclePaid::release_transmitter_addr() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventOraclePaid.transmitter_addr)
  return _impl_.transmitter_addr_.Release();
}
inline void EventOraclePaid::set_allocated_transmitter_addr(std::string* value) {
  _impl_.transmitter_addr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmitter_addr_.IsDefault()) {
          _impl_.transmitter_addr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventOraclePaid.transmitter_addr)
}

// string payee_addr = 2 [json_name = "payeeAddr"];
inline void EventOraclePaid::clear_payee_addr() {
  _impl_.payee_addr_.ClearToEmpty();
}
inline const std::string& EventOraclePaid::payee_addr() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventOraclePaid.payee_addr)
  return _internal_payee_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventOraclePaid::set_payee_addr(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payee_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventOraclePaid.payee_addr)
}
inline std::string* EventOraclePaid::mutable_payee_addr() {
  std::string* _s = _internal_mutable_payee_addr();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventOraclePaid.payee_addr)
  return _s;
}
inline const std::string& EventOraclePaid::_internal_payee_addr() const {
  return _impl_.payee_addr_.Get();
}
inline void EventOraclePaid::_internal_set_payee_addr(const std::string& value) {
  ;


  _impl_.payee_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* EventOraclePaid::_internal_mutable_payee_addr() {
  ;
  return _impl_.payee_addr_.Mutable( GetArenaForAllocation());
}
inline std::string* EventOraclePaid::release_payee_addr() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventOraclePaid.payee_addr)
  return _impl_.payee_addr_.Release();
}
inline void EventOraclePaid::set_allocated_payee_addr(std::string* value) {
  _impl_.payee_addr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payee_addr_.IsDefault()) {
          _impl_.payee_addr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventOraclePaid.payee_addr)
}

// .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool EventOraclePaid::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& EventOraclePaid::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& EventOraclePaid::amount() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventOraclePaid.amount)
  return _internal_amount();
}
inline void EventOraclePaid::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.EventOraclePaid.amount)
}
inline ::cosmos::base::v1beta1::Coin* EventOraclePaid::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventOraclePaid::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventOraclePaid.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventOraclePaid::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* EventOraclePaid::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventOraclePaid.amount)
  return _msg;
}
inline void EventOraclePaid::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventOraclePaid.amount)
}

// -------------------------------------------------------------------

// EventAnswerUpdated

// string current = 1 [json_name = "current", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void EventAnswerUpdated::clear_current() {
  _impl_.current_.ClearToEmpty();
}
inline const std::string& EventAnswerUpdated::current() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventAnswerUpdated.current)
  return _internal_current();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAnswerUpdated::set_current(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.current_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventAnswerUpdated.current)
}
inline std::string* EventAnswerUpdated::mutable_current() {
  std::string* _s = _internal_mutable_current();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventAnswerUpdated.current)
  return _s;
}
inline const std::string& EventAnswerUpdated::_internal_current() const {
  return _impl_.current_.Get();
}
inline void EventAnswerUpdated::_internal_set_current(const std::string& value) {
  ;


  _impl_.current_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAnswerUpdated::_internal_mutable_current() {
  ;
  return _impl_.current_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAnswerUpdated::release_current() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventAnswerUpdated.current)
  return _impl_.current_.Release();
}
inline void EventAnswerUpdated::set_allocated_current(std::string* value) {
  _impl_.current_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_.IsDefault()) {
          _impl_.current_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventAnswerUpdated.current)
}

// string round_id = 2 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void EventAnswerUpdated::clear_round_id() {
  _impl_.round_id_.ClearToEmpty();
}
inline const std::string& EventAnswerUpdated::round_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventAnswerUpdated.round_id)
  return _internal_round_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAnswerUpdated::set_round_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.round_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventAnswerUpdated.round_id)
}
inline std::string* EventAnswerUpdated::mutable_round_id() {
  std::string* _s = _internal_mutable_round_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventAnswerUpdated.round_id)
  return _s;
}
inline const std::string& EventAnswerUpdated::_internal_round_id() const {
  return _impl_.round_id_.Get();
}
inline void EventAnswerUpdated::_internal_set_round_id(const std::string& value) {
  ;


  _impl_.round_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAnswerUpdated::_internal_mutable_round_id() {
  ;
  return _impl_.round_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAnswerUpdated::release_round_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventAnswerUpdated.round_id)
  return _impl_.round_id_.Release();
}
inline void EventAnswerUpdated::set_allocated_round_id(std::string* value) {
  _impl_.round_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.round_id_.IsDefault()) {
          _impl_.round_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventAnswerUpdated.round_id)
}

// .google.protobuf.Timestamp updated_at = 3 [json_name = "updatedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool EventAnswerUpdated::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventAnswerUpdated::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventAnswerUpdated::updated_at() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventAnswerUpdated.updated_at)
  return _internal_updated_at();
}
inline void EventAnswerUpdated::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.EventAnswerUpdated.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventAnswerUpdated::release_updated_at() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventAnswerUpdated::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventAnswerUpdated.updated_at)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventAnswerUpdated::_internal_mutable_updated_at() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventAnswerUpdated::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventAnswerUpdated.updated_at)
  return _msg;
}
inline void EventAnswerUpdated::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventAnswerUpdated.updated_at)
}

// -------------------------------------------------------------------

// EventNewRound

// string round_id = 1 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void EventNewRound::clear_round_id() {
  _impl_.round_id_.ClearToEmpty();
}
inline const std::string& EventNewRound::round_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewRound.round_id)
  return _internal_round_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewRound::set_round_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.round_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewRound.round_id)
}
inline std::string* EventNewRound::mutable_round_id() {
  std::string* _s = _internal_mutable_round_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewRound.round_id)
  return _s;
}
inline const std::string& EventNewRound::_internal_round_id() const {
  return _impl_.round_id_.Get();
}
inline void EventNewRound::_internal_set_round_id(const std::string& value) {
  ;


  _impl_.round_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewRound::_internal_mutable_round_id() {
  ;
  return _impl_.round_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewRound::release_round_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewRound.round_id)
  return _impl_.round_id_.Release();
}
inline void EventNewRound::set_allocated_round_id(std::string* value) {
  _impl_.round_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.round_id_.IsDefault()) {
          _impl_.round_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewRound.round_id)
}

// string started_by = 2 [json_name = "startedBy"];
inline void EventNewRound::clear_started_by() {
  _impl_.started_by_.ClearToEmpty();
}
inline const std::string& EventNewRound::started_by() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewRound.started_by)
  return _internal_started_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewRound::set_started_by(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.started_by_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewRound.started_by)
}
inline std::string* EventNewRound::mutable_started_by() {
  std::string* _s = _internal_mutable_started_by();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewRound.started_by)
  return _s;
}
inline const std::string& EventNewRound::_internal_started_by() const {
  return _impl_.started_by_.Get();
}
inline void EventNewRound::_internal_set_started_by(const std::string& value) {
  ;


  _impl_.started_by_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewRound::_internal_mutable_started_by() {
  ;
  return _impl_.started_by_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewRound::release_started_by() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewRound.started_by)
  return _impl_.started_by_.Release();
}
inline void EventNewRound::set_allocated_started_by(std::string* value) {
  _impl_.started_by_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.started_by_.IsDefault()) {
          _impl_.started_by_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewRound.started_by)
}

// .google.protobuf.Timestamp started_at = 3 [json_name = "startedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool EventNewRound::has_started_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.started_at_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventNewRound::_internal_started_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.started_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventNewRound::started_at() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewRound.started_at)
  return _internal_started_at();
}
inline void EventNewRound::unsafe_arena_set_allocated_started_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  _impl_.started_at_ = started_at;
  if (started_at) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.EventNewRound.started_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventNewRound::release_started_at() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventNewRound::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewRound.started_at)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventNewRound::_internal_mutable_started_at() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.started_at_ = p;
  }
  return _impl_.started_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventNewRound::mutable_started_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewRound.started_at)
  return _msg;
}
inline void EventNewRound::set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewRound.started_at)
}

// -------------------------------------------------------------------

// EventTransmitted

// bytes config_digest = 1 [json_name = "configDigest"];
inline void EventTransmitted::clear_config_digest() {
  _impl_.config_digest_.ClearToEmpty();
}
inline const std::string& EventTransmitted::config_digest() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventTransmitted.config_digest)
  return _internal_config_digest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventTransmitted::set_config_digest(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.config_digest_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventTransmitted.config_digest)
}
inline std::string* EventTransmitted::mutable_config_digest() {
  std::string* _s = _internal_mutable_config_digest();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventTransmitted.config_digest)
  return _s;
}
inline const std::string& EventTransmitted::_internal_config_digest() const {
  return _impl_.config_digest_.Get();
}
inline void EventTransmitted::_internal_set_config_digest(const std::string& value) {
  ;


  _impl_.config_digest_.Set(value, GetArenaForAllocation());
}
inline std::string* EventTransmitted::_internal_mutable_config_digest() {
  ;
  return _impl_.config_digest_.Mutable( GetArenaForAllocation());
}
inline std::string* EventTransmitted::release_config_digest() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventTransmitted.config_digest)
  return _impl_.config_digest_.Release();
}
inline void EventTransmitted::set_allocated_config_digest(std::string* value) {
  _impl_.config_digest_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.config_digest_.IsDefault()) {
          _impl_.config_digest_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventTransmitted.config_digest)
}

// uint64 epoch = 2 [json_name = "epoch"];
inline void EventTransmitted::clear_epoch() {
  _impl_.epoch_ = ::uint64_t{0u};
}
inline ::uint64_t EventTransmitted::epoch() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventTransmitted.epoch)
  return _internal_epoch();
}
inline void EventTransmitted::set_epoch(::uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventTransmitted.epoch)
}
inline ::uint64_t EventTransmitted::_internal_epoch() const {
  return _impl_.epoch_;
}
inline void EventTransmitted::_internal_set_epoch(::uint64_t value) {
  ;
  _impl_.epoch_ = value;
}

// -------------------------------------------------------------------

// EventNewTransmission

// string feed_id = 1 [json_name = "feedId"];
inline void EventNewTransmission::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& EventNewTransmission::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewTransmission::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.feed_id)
}
inline std::string* EventNewTransmission::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewTransmission.feed_id)
  return _s;
}
inline const std::string& EventNewTransmission::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void EventNewTransmission::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewTransmission::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewTransmission::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewTransmission.feed_id)
  return _impl_.feed_id_.Release();
}
inline void EventNewTransmission::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewTransmission.feed_id)
}

// uint32 aggregator_round_id = 2 [json_name = "aggregatorRoundId"];
inline void EventNewTransmission::clear_aggregator_round_id() {
  _impl_.aggregator_round_id_ = 0u;
}
inline ::uint32_t EventNewTransmission::aggregator_round_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.aggregator_round_id)
  return _internal_aggregator_round_id();
}
inline void EventNewTransmission::set_aggregator_round_id(::uint32_t value) {
  _internal_set_aggregator_round_id(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.aggregator_round_id)
}
inline ::uint32_t EventNewTransmission::_internal_aggregator_round_id() const {
  return _impl_.aggregator_round_id_;
}
inline void EventNewTransmission::_internal_set_aggregator_round_id(::uint32_t value) {
  ;
  _impl_.aggregator_round_id_ = value;
}

// string answer = 3 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EventNewTransmission::clear_answer() {
  _impl_.answer_.ClearToEmpty();
}
inline const std::string& EventNewTransmission::answer() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.answer)
  return _internal_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewTransmission::set_answer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.answer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.answer)
}
inline std::string* EventNewTransmission::mutable_answer() {
  std::string* _s = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewTransmission.answer)
  return _s;
}
inline const std::string& EventNewTransmission::_internal_answer() const {
  return _impl_.answer_.Get();
}
inline void EventNewTransmission::_internal_set_answer(const std::string& value) {
  ;


  _impl_.answer_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewTransmission::_internal_mutable_answer() {
  ;
  return _impl_.answer_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewTransmission::release_answer() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewTransmission.answer)
  return _impl_.answer_.Release();
}
inline void EventNewTransmission::set_allocated_answer(std::string* value) {
  _impl_.answer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.answer_.IsDefault()) {
          _impl_.answer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewTransmission.answer)
}

// string transmitter = 4 [json_name = "transmitter"];
inline void EventNewTransmission::clear_transmitter() {
  _impl_.transmitter_.ClearToEmpty();
}
inline const std::string& EventNewTransmission::transmitter() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.transmitter)
  return _internal_transmitter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewTransmission::set_transmitter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.transmitter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.transmitter)
}
inline std::string* EventNewTransmission::mutable_transmitter() {
  std::string* _s = _internal_mutable_transmitter();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewTransmission.transmitter)
  return _s;
}
inline const std::string& EventNewTransmission::_internal_transmitter() const {
  return _impl_.transmitter_.Get();
}
inline void EventNewTransmission::_internal_set_transmitter(const std::string& value) {
  ;


  _impl_.transmitter_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewTransmission::_internal_mutable_transmitter() {
  ;
  return _impl_.transmitter_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewTransmission::release_transmitter() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewTransmission.transmitter)
  return _impl_.transmitter_.Release();
}
inline void EventNewTransmission::set_allocated_transmitter(std::string* value) {
  _impl_.transmitter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmitter_.IsDefault()) {
          _impl_.transmitter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewTransmission.transmitter)
}

// int64 observations_timestamp = 5 [json_name = "observationsTimestamp"];
inline void EventNewTransmission::clear_observations_timestamp() {
  _impl_.observations_timestamp_ = ::int64_t{0};
}
inline ::int64_t EventNewTransmission::observations_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.observations_timestamp)
  return _internal_observations_timestamp();
}
inline void EventNewTransmission::set_observations_timestamp(::int64_t value) {
  _internal_set_observations_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.observations_timestamp)
}
inline ::int64_t EventNewTransmission::_internal_observations_timestamp() const {
  return _impl_.observations_timestamp_;
}
inline void EventNewTransmission::_internal_set_observations_timestamp(::int64_t value) {
  ;
  _impl_.observations_timestamp_ = value;
}

// repeated string observations = 6 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline int EventNewTransmission::_internal_observations_size() const {
  return _impl_.observations_.size();
}
inline int EventNewTransmission::observations_size() const {
  return _internal_observations_size();
}
inline void EventNewTransmission::clear_observations() {
  _internal_mutable_observations()->Clear();
}
inline std::string* EventNewTransmission::add_observations() {
  std::string* _s = _internal_add_observations();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.EventNewTransmission.observations)
  return _s;
}
inline const std::string& EventNewTransmission::observations(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.observations)
  return _internal_observations(index);
}
inline std::string* EventNewTransmission::mutable_observations(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewTransmission.observations)
  return _internal_mutable_observations()->Mutable(index);
}
inline void EventNewTransmission::set_observations(int index, const std::string& value) {
  _internal_mutable_observations()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::set_observations(int index, std::string&& value) {
  _internal_mutable_observations()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::set_observations(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_observations()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::set_observations(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_observations()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::set_observations(int index, absl::string_view value) {
  _internal_mutable_observations()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::add_observations(const std::string& value) {
  _internal_mutable_observations()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::add_observations(std::string&& value) {
  _internal_mutable_observations()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::add_observations(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_observations()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::add_observations(const char* value, std::size_t size) {
  _internal_mutable_observations()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline void EventNewTransmission::add_observations(absl::string_view value) {
  _internal_mutable_observations()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.EventNewTransmission.observations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventNewTransmission::observations() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.EventNewTransmission.observations)
  return _internal_observations();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* EventNewTransmission::mutable_observations() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.EventNewTransmission.observations)
  return _internal_mutable_observations();
}
inline const std::string& EventNewTransmission::_internal_observations(int index) const {
  return _internal_observations().Get(index);
}
inline std::string* EventNewTransmission::_internal_add_observations() {
  return _internal_mutable_observations()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventNewTransmission::_internal_observations() const {
  return _impl_.observations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EventNewTransmission::_internal_mutable_observations() {
  return &_impl_.observations_;
}

// bytes observers = 7 [json_name = "observers"];
inline void EventNewTransmission::clear_observers() {
  _impl_.observers_.ClearToEmpty();
}
inline const std::string& EventNewTransmission::observers() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.observers)
  return _internal_observers();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewTransmission::set_observers(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.observers_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.observers)
}
inline std::string* EventNewTransmission::mutable_observers() {
  std::string* _s = _internal_mutable_observers();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewTransmission.observers)
  return _s;
}
inline const std::string& EventNewTransmission::_internal_observers() const {
  return _impl_.observers_.Get();
}
inline void EventNewTransmission::_internal_set_observers(const std::string& value) {
  ;


  _impl_.observers_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewTransmission::_internal_mutable_observers() {
  ;
  return _impl_.observers_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewTransmission::release_observers() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewTransmission.observers)
  return _impl_.observers_.Release();
}
inline void EventNewTransmission::set_allocated_observers(std::string* value) {
  _impl_.observers_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.observers_.IsDefault()) {
          _impl_.observers_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewTransmission.observers)
}

// bytes config_digest = 8 [json_name = "configDigest"];
inline void EventNewTransmission::clear_config_digest() {
  _impl_.config_digest_.ClearToEmpty();
}
inline const std::string& EventNewTransmission::config_digest() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.config_digest)
  return _internal_config_digest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewTransmission::set_config_digest(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.config_digest_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventNewTransmission.config_digest)
}
inline std::string* EventNewTransmission::mutable_config_digest() {
  std::string* _s = _internal_mutable_config_digest();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewTransmission.config_digest)
  return _s;
}
inline const std::string& EventNewTransmission::_internal_config_digest() const {
  return _impl_.config_digest_.Get();
}
inline void EventNewTransmission::_internal_set_config_digest(const std::string& value) {
  ;


  _impl_.config_digest_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewTransmission::_internal_mutable_config_digest() {
  ;
  return _impl_.config_digest_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewTransmission::release_config_digest() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewTransmission.config_digest)
  return _impl_.config_digest_.Release();
}
inline void EventNewTransmission::set_allocated_config_digest(std::string* value) {
  _impl_.config_digest_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.config_digest_.IsDefault()) {
          _impl_.config_digest_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewTransmission.config_digest)
}

// .injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9 [json_name = "epochAndRound"];
inline bool EventNewTransmission::has_epoch_and_round() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.epoch_and_round_ != nullptr);
  return value;
}
inline void EventNewTransmission::clear_epoch_and_round() {
  if (_impl_.epoch_and_round_ != nullptr) _impl_.epoch_and_round_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::ocr::v1beta1::EpochAndRound& EventNewTransmission::_internal_epoch_and_round() const {
  const ::injective::ocr::v1beta1::EpochAndRound* p = _impl_.epoch_and_round_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::ocr::v1beta1::EpochAndRound&>(
      ::injective::ocr::v1beta1::_EpochAndRound_default_instance_);
}
inline const ::injective::ocr::v1beta1::EpochAndRound& EventNewTransmission::epoch_and_round() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventNewTransmission.epoch_and_round)
  return _internal_epoch_and_round();
}
inline void EventNewTransmission::unsafe_arena_set_allocated_epoch_and_round(
    ::injective::ocr::v1beta1::EpochAndRound* epoch_and_round) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.epoch_and_round_);
  }
  _impl_.epoch_and_round_ = epoch_and_round;
  if (epoch_and_round) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.EventNewTransmission.epoch_and_round)
}
inline ::injective::ocr::v1beta1::EpochAndRound* EventNewTransmission::release_epoch_and_round() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::EpochAndRound* temp = _impl_.epoch_and_round_;
  _impl_.epoch_and_round_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::ocr::v1beta1::EpochAndRound* EventNewTransmission::unsafe_arena_release_epoch_and_round() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventNewTransmission.epoch_and_round)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::EpochAndRound* temp = _impl_.epoch_and_round_;
  _impl_.epoch_and_round_ = nullptr;
  return temp;
}
inline ::injective::ocr::v1beta1::EpochAndRound* EventNewTransmission::_internal_mutable_epoch_and_round() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.epoch_and_round_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::ocr::v1beta1::EpochAndRound>(GetArenaForAllocation());
    _impl_.epoch_and_round_ = p;
  }
  return _impl_.epoch_and_round_;
}
inline ::injective::ocr::v1beta1::EpochAndRound* EventNewTransmission::mutable_epoch_and_round() {
  ::injective::ocr::v1beta1::EpochAndRound* _msg = _internal_mutable_epoch_and_round();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventNewTransmission.epoch_and_round)
  return _msg;
}
inline void EventNewTransmission::set_allocated_epoch_and_round(::injective::ocr::v1beta1::EpochAndRound* epoch_and_round) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.epoch_and_round_;
  }
  if (epoch_and_round) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(epoch_and_round);
    if (message_arena != submessage_arena) {
      epoch_and_round = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, epoch_and_round, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.epoch_and_round_ = epoch_and_round;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventNewTransmission.epoch_and_round)
}

// -------------------------------------------------------------------

// EventConfigSet

// bytes config_digest = 1 [json_name = "configDigest"];
inline void EventConfigSet::clear_config_digest() {
  _impl_.config_digest_.ClearToEmpty();
}
inline const std::string& EventConfigSet::config_digest() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventConfigSet.config_digest)
  return _internal_config_digest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventConfigSet::set_config_digest(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.config_digest_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventConfigSet.config_digest)
}
inline std::string* EventConfigSet::mutable_config_digest() {
  std::string* _s = _internal_mutable_config_digest();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventConfigSet.config_digest)
  return _s;
}
inline const std::string& EventConfigSet::_internal_config_digest() const {
  return _impl_.config_digest_.Get();
}
inline void EventConfigSet::_internal_set_config_digest(const std::string& value) {
  ;


  _impl_.config_digest_.Set(value, GetArenaForAllocation());
}
inline std::string* EventConfigSet::_internal_mutable_config_digest() {
  ;
  return _impl_.config_digest_.Mutable( GetArenaForAllocation());
}
inline std::string* EventConfigSet::release_config_digest() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventConfigSet.config_digest)
  return _impl_.config_digest_.Release();
}
inline void EventConfigSet::set_allocated_config_digest(std::string* value) {
  _impl_.config_digest_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.config_digest_.IsDefault()) {
          _impl_.config_digest_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventConfigSet.config_digest)
}

// int64 previous_config_block_number = 2 [json_name = "previousConfigBlockNumber"];
inline void EventConfigSet::clear_previous_config_block_number() {
  _impl_.previous_config_block_number_ = ::int64_t{0};
}
inline ::int64_t EventConfigSet::previous_config_block_number() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventConfigSet.previous_config_block_number)
  return _internal_previous_config_block_number();
}
inline void EventConfigSet::set_previous_config_block_number(::int64_t value) {
  _internal_set_previous_config_block_number(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.EventConfigSet.previous_config_block_number)
}
inline ::int64_t EventConfigSet::_internal_previous_config_block_number() const {
  return _impl_.previous_config_block_number_;
}
inline void EventConfigSet::_internal_set_previous_config_block_number(::int64_t value) {
  ;
  _impl_.previous_config_block_number_ = value;
}

// .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
inline bool EventConfigSet::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void EventConfigSet::clear_config() {
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::ocr::v1beta1::FeedConfig& EventConfigSet::_internal_config() const {
  const ::injective::ocr::v1beta1::FeedConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::ocr::v1beta1::FeedConfig&>(
      ::injective::ocr::v1beta1::_FeedConfig_default_instance_);
}
inline const ::injective::ocr::v1beta1::FeedConfig& EventConfigSet::config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventConfigSet.config)
  return _internal_config();
}
inline void EventConfigSet::unsafe_arena_set_allocated_config(
    ::injective::ocr::v1beta1::FeedConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.EventConfigSet.config)
}
inline ::injective::ocr::v1beta1::FeedConfig* EventConfigSet::release_config() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::FeedConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::ocr::v1beta1::FeedConfig* EventConfigSet::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventConfigSet.config)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::FeedConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::injective::ocr::v1beta1::FeedConfig* EventConfigSet::_internal_mutable_config() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::ocr::v1beta1::FeedConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::injective::ocr::v1beta1::FeedConfig* EventConfigSet::mutable_config() {
  ::injective::ocr::v1beta1::FeedConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventConfigSet.config)
  return _msg;
}
inline void EventConfigSet::set_allocated_config(::injective::ocr::v1beta1::FeedConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventConfigSet.config)
}

// .injective.ocr.v1beta1.FeedConfigInfo config_info = 4 [json_name = "configInfo"];
inline bool EventConfigSet::has_config_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_info_ != nullptr);
  return value;
}
inline void EventConfigSet::clear_config_info() {
  if (_impl_.config_info_ != nullptr) _impl_.config_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::injective::ocr::v1beta1::FeedConfigInfo& EventConfigSet::_internal_config_info() const {
  const ::injective::ocr::v1beta1::FeedConfigInfo* p = _impl_.config_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::ocr::v1beta1::FeedConfigInfo&>(
      ::injective::ocr::v1beta1::_FeedConfigInfo_default_instance_);
}
inline const ::injective::ocr::v1beta1::FeedConfigInfo& EventConfigSet::config_info() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.EventConfigSet.config_info)
  return _internal_config_info();
}
inline void EventConfigSet::unsafe_arena_set_allocated_config_info(
    ::injective::ocr::v1beta1::FeedConfigInfo* config_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_info_);
  }
  _impl_.config_info_ = config_info;
  if (config_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.EventConfigSet.config_info)
}
inline ::injective::ocr::v1beta1::FeedConfigInfo* EventConfigSet::release_config_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::ocr::v1beta1::FeedConfigInfo* temp = _impl_.config_info_;
  _impl_.config_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::ocr::v1beta1::FeedConfigInfo* EventConfigSet::unsafe_arena_release_config_info() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.EventConfigSet.config_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::ocr::v1beta1::FeedConfigInfo* temp = _impl_.config_info_;
  _impl_.config_info_ = nullptr;
  return temp;
}
inline ::injective::ocr::v1beta1::FeedConfigInfo* EventConfigSet::_internal_mutable_config_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.config_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::ocr::v1beta1::FeedConfigInfo>(GetArenaForAllocation());
    _impl_.config_info_ = p;
  }
  return _impl_.config_info_;
}
inline ::injective::ocr::v1beta1::FeedConfigInfo* EventConfigSet::mutable_config_info() {
  ::injective::ocr::v1beta1::FeedConfigInfo* _msg = _internal_mutable_config_info();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.EventConfigSet.config_info)
  return _msg;
}
inline void EventConfigSet::set_allocated_config_info(::injective::ocr::v1beta1::FeedConfigInfo* config_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_info_;
  }
  if (config_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config_info);
    if (message_arena != submessage_arena) {
      config_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.config_info_ = config_info;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.EventConfigSet.config_info)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace ocr
}  // namespace injective


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2focr_2fv1beta1_2focr_2eproto_2epb_2eh
