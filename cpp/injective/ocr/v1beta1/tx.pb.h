// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/ocr/v1beta1/tx.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2focr_2fv1beta1_2ftx_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2focr_2fv1beta1_2ftx_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "cosmos/msg/v1/msg.pb.h"
#include "gogoproto/gogo.pb.h"
#include "injective/ocr/v1beta1/ocr.pb.h"
#include "cosmos_proto/cosmos.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2focr_2fv1beta1_2ftx_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2focr_2fv1beta1_2ftx_2eproto;
namespace injective {
namespace ocr {
namespace v1beta1 {
class MsgAcceptPayeeship;
struct MsgAcceptPayeeshipDefaultTypeInternal;
extern MsgAcceptPayeeshipDefaultTypeInternal _MsgAcceptPayeeship_default_instance_;
class MsgAcceptPayeeshipResponse;
struct MsgAcceptPayeeshipResponseDefaultTypeInternal;
extern MsgAcceptPayeeshipResponseDefaultTypeInternal _MsgAcceptPayeeshipResponse_default_instance_;
class MsgCreateFeed;
struct MsgCreateFeedDefaultTypeInternal;
extern MsgCreateFeedDefaultTypeInternal _MsgCreateFeed_default_instance_;
class MsgCreateFeedResponse;
struct MsgCreateFeedResponseDefaultTypeInternal;
extern MsgCreateFeedResponseDefaultTypeInternal _MsgCreateFeedResponse_default_instance_;
class MsgFundFeedRewardPool;
struct MsgFundFeedRewardPoolDefaultTypeInternal;
extern MsgFundFeedRewardPoolDefaultTypeInternal _MsgFundFeedRewardPool_default_instance_;
class MsgFundFeedRewardPoolResponse;
struct MsgFundFeedRewardPoolResponseDefaultTypeInternal;
extern MsgFundFeedRewardPoolResponseDefaultTypeInternal _MsgFundFeedRewardPoolResponse_default_instance_;
class MsgSetPayees;
struct MsgSetPayeesDefaultTypeInternal;
extern MsgSetPayeesDefaultTypeInternal _MsgSetPayees_default_instance_;
class MsgSetPayeesResponse;
struct MsgSetPayeesResponseDefaultTypeInternal;
extern MsgSetPayeesResponseDefaultTypeInternal _MsgSetPayeesResponse_default_instance_;
class MsgTransferPayeeship;
struct MsgTransferPayeeshipDefaultTypeInternal;
extern MsgTransferPayeeshipDefaultTypeInternal _MsgTransferPayeeship_default_instance_;
class MsgTransferPayeeshipResponse;
struct MsgTransferPayeeshipResponseDefaultTypeInternal;
extern MsgTransferPayeeshipResponseDefaultTypeInternal _MsgTransferPayeeshipResponse_default_instance_;
class MsgTransmit;
struct MsgTransmitDefaultTypeInternal;
extern MsgTransmitDefaultTypeInternal _MsgTransmit_default_instance_;
class MsgTransmitResponse;
struct MsgTransmitResponseDefaultTypeInternal;
extern MsgTransmitResponseDefaultTypeInternal _MsgTransmitResponse_default_instance_;
class MsgUpdateFeed;
struct MsgUpdateFeedDefaultTypeInternal;
extern MsgUpdateFeedDefaultTypeInternal _MsgUpdateFeed_default_instance_;
class MsgUpdateFeedResponse;
struct MsgUpdateFeedResponseDefaultTypeInternal;
extern MsgUpdateFeedResponseDefaultTypeInternal _MsgUpdateFeedResponse_default_instance_;
class MsgUpdateParams;
struct MsgUpdateParamsDefaultTypeInternal;
extern MsgUpdateParamsDefaultTypeInternal _MsgUpdateParams_default_instance_;
class MsgUpdateParamsResponse;
struct MsgUpdateParamsResponseDefaultTypeInternal;
extern MsgUpdateParamsResponseDefaultTypeInternal _MsgUpdateParamsResponse_default_instance_;
class MsgWithdrawFeedRewardPool;
struct MsgWithdrawFeedRewardPoolDefaultTypeInternal;
extern MsgWithdrawFeedRewardPoolDefaultTypeInternal _MsgWithdrawFeedRewardPool_default_instance_;
class MsgWithdrawFeedRewardPoolResponse;
struct MsgWithdrawFeedRewardPoolResponseDefaultTypeInternal;
extern MsgWithdrawFeedRewardPoolResponseDefaultTypeInternal _MsgWithdrawFeedRewardPoolResponse_default_instance_;
}  // namespace v1beta1
}  // namespace ocr
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::ocr::v1beta1::MsgAcceptPayeeship* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgAcceptPayeeship>(Arena*);
template <>
::injective::ocr::v1beta1::MsgAcceptPayeeshipResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgAcceptPayeeshipResponse>(Arena*);
template <>
::injective::ocr::v1beta1::MsgCreateFeed* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgCreateFeed>(Arena*);
template <>
::injective::ocr::v1beta1::MsgCreateFeedResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgCreateFeedResponse>(Arena*);
template <>
::injective::ocr::v1beta1::MsgFundFeedRewardPool* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgFundFeedRewardPool>(Arena*);
template <>
::injective::ocr::v1beta1::MsgFundFeedRewardPoolResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgFundFeedRewardPoolResponse>(Arena*);
template <>
::injective::ocr::v1beta1::MsgSetPayees* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgSetPayees>(Arena*);
template <>
::injective::ocr::v1beta1::MsgSetPayeesResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgSetPayeesResponse>(Arena*);
template <>
::injective::ocr::v1beta1::MsgTransferPayeeship* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgTransferPayeeship>(Arena*);
template <>
::injective::ocr::v1beta1::MsgTransferPayeeshipResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgTransferPayeeshipResponse>(Arena*);
template <>
::injective::ocr::v1beta1::MsgTransmit* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgTransmit>(Arena*);
template <>
::injective::ocr::v1beta1::MsgTransmitResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgTransmitResponse>(Arena*);
template <>
::injective::ocr::v1beta1::MsgUpdateFeed* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgUpdateFeed>(Arena*);
template <>
::injective::ocr::v1beta1::MsgUpdateFeedResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgUpdateFeedResponse>(Arena*);
template <>
::injective::ocr::v1beta1::MsgUpdateParams* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgUpdateParams>(Arena*);
template <>
::injective::ocr::v1beta1::MsgUpdateParamsResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgUpdateParamsResponse>(Arena*);
template <>
::injective::ocr::v1beta1::MsgWithdrawFeedRewardPool* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgWithdrawFeedRewardPool>(Arena*);
template <>
::injective::ocr::v1beta1::MsgWithdrawFeedRewardPoolResponse* Arena::CreateMaybeMessage<::injective::ocr::v1beta1::MsgWithdrawFeedRewardPoolResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace ocr {
namespace v1beta1 {

// ===================================================================


// -------------------------------------------------------------------

class MsgCreateFeed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgCreateFeed) */ {
 public:
  inline MsgCreateFeed() : MsgCreateFeed(nullptr) {}
  ~MsgCreateFeed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateFeed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateFeed(const MsgCreateFeed& from);
  MsgCreateFeed(MsgCreateFeed&& from) noexcept
    : MsgCreateFeed() {
    *this = ::std::move(from);
  }

  inline MsgCreateFeed& operator=(const MsgCreateFeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateFeed& operator=(MsgCreateFeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateFeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateFeed* internal_default_instance() {
    return reinterpret_cast<const MsgCreateFeed*>(
               &_MsgCreateFeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgCreateFeed& a, MsgCreateFeed& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateFeed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateFeed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateFeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateFeed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateFeed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateFeed& from) {
    MsgCreateFeed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateFeed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgCreateFeed";
  }
  protected:
  explicit MsgCreateFeed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .injective.ocr.v1beta1.FeedConfig config = 2 [json_name = "config"];
  bool has_config() const;
  void clear_config() ;
  const ::injective::ocr::v1beta1::FeedConfig& config() const;
  PROTOBUF_NODISCARD ::injective::ocr::v1beta1::FeedConfig* release_config();
  ::injective::ocr::v1beta1::FeedConfig* mutable_config();
  void set_allocated_config(::injective::ocr::v1beta1::FeedConfig* config);
  private:
  const ::injective::ocr::v1beta1::FeedConfig& _internal_config() const;
  ::injective::ocr::v1beta1::FeedConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::injective::ocr::v1beta1::FeedConfig* config);
  ::injective::ocr::v1beta1::FeedConfig* unsafe_arena_release_config();
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgCreateFeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::injective::ocr::v1beta1::FeedConfig* config_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateFeedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgCreateFeedResponse) */ {
 public:
  inline MsgCreateFeedResponse() : MsgCreateFeedResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateFeedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateFeedResponse(const MsgCreateFeedResponse& from);
  MsgCreateFeedResponse(MsgCreateFeedResponse&& from) noexcept
    : MsgCreateFeedResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateFeedResponse& operator=(const MsgCreateFeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateFeedResponse& operator=(MsgCreateFeedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateFeedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateFeedResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateFeedResponse*>(
               &_MsgCreateFeedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgCreateFeedResponse& a, MsgCreateFeedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateFeedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateFeedResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateFeedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateFeedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgCreateFeedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgCreateFeedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgCreateFeedResponse";
  }
  protected:
  explicit MsgCreateFeedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgCreateFeedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateFeed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgUpdateFeed) */ {
 public:
  inline MsgUpdateFeed() : MsgUpdateFeed(nullptr) {}
  ~MsgUpdateFeed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateFeed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateFeed(const MsgUpdateFeed& from);
  MsgUpdateFeed(MsgUpdateFeed&& from) noexcept
    : MsgUpdateFeed() {
    *this = ::std::move(from);
  }

  inline MsgUpdateFeed& operator=(const MsgUpdateFeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateFeed& operator=(MsgUpdateFeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateFeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateFeed* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateFeed*>(
               &_MsgUpdateFeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgUpdateFeed& a, MsgUpdateFeed& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateFeed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateFeed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateFeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateFeed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgUpdateFeed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgUpdateFeed& from) {
    MsgUpdateFeed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgUpdateFeed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgUpdateFeed";
  }
  protected:
  explicit MsgUpdateFeed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignersFieldNumber = 3,
    kTransmittersFieldNumber = 4,
    kSenderFieldNumber = 1,
    kFeedIdFieldNumber = 2,
    kLinkPerObservationFieldNumber = 5,
    kLinkPerTransmissionFieldNumber = 6,
    kLinkDenomFieldNumber = 7,
    kFeedAdminFieldNumber = 8,
    kBillingAdminFieldNumber = 9,
  };
  // repeated string signers = 3 [json_name = "signers"];
  int signers_size() const;
  private:
  int _internal_signers_size() const;

  public:
  void clear_signers() ;
  const std::string& signers(int index) const;
  std::string* mutable_signers(int index);
  void set_signers(int index, const std::string& value);
  void set_signers(int index, std::string&& value);
  void set_signers(int index, const char* value);
  void set_signers(int index, const char* value, std::size_t size);
  void set_signers(int index, absl::string_view value);
  std::string* add_signers();
  void add_signers(const std::string& value);
  void add_signers(std::string&& value);
  void add_signers(const char* value);
  void add_signers(const char* value, std::size_t size);
  void add_signers(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signers();

  private:
  const std::string& _internal_signers(int index) const;
  std::string* _internal_add_signers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_signers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_signers();

  public:
  // repeated string transmitters = 4 [json_name = "transmitters"];
  int transmitters_size() const;
  private:
  int _internal_transmitters_size() const;

  public:
  void clear_transmitters() ;
  const std::string& transmitters(int index) const;
  std::string* mutable_transmitters(int index);
  void set_transmitters(int index, const std::string& value);
  void set_transmitters(int index, std::string&& value);
  void set_transmitters(int index, const char* value);
  void set_transmitters(int index, const char* value, std::size_t size);
  void set_transmitters(int index, absl::string_view value);
  std::string* add_transmitters();
  void add_transmitters(const std::string& value);
  void add_transmitters(std::string&& value);
  void add_transmitters(const char* value);
  void add_transmitters(const char* value, std::size_t size);
  void add_transmitters(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transmitters();

  private:
  const std::string& _internal_transmitters(int index) const;
  std::string* _internal_add_transmitters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_transmitters();

  public:
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string feed_id = 2 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // string link_per_observation = 5 [json_name = "linkPerObservation", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_link_per_observation() ;
  const std::string& link_per_observation() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_per_observation(Arg_&& arg, Args_... args);
  std::string* mutable_link_per_observation();
  PROTOBUF_NODISCARD std::string* release_link_per_observation();
  void set_allocated_link_per_observation(std::string* ptr);

  private:
  const std::string& _internal_link_per_observation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_per_observation(
      const std::string& value);
  std::string* _internal_mutable_link_per_observation();

  public:
  // string link_per_transmission = 6 [json_name = "linkPerTransmission", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_link_per_transmission() ;
  const std::string& link_per_transmission() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_per_transmission(Arg_&& arg, Args_... args);
  std::string* mutable_link_per_transmission();
  PROTOBUF_NODISCARD std::string* release_link_per_transmission();
  void set_allocated_link_per_transmission(std::string* ptr);

  private:
  const std::string& _internal_link_per_transmission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_per_transmission(
      const std::string& value);
  std::string* _internal_mutable_link_per_transmission();

  public:
  // string link_denom = 7 [json_name = "linkDenom"];
  void clear_link_denom() ;
  const std::string& link_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_denom(Arg_&& arg, Args_... args);
  std::string* mutable_link_denom();
  PROTOBUF_NODISCARD std::string* release_link_denom();
  void set_allocated_link_denom(std::string* ptr);

  private:
  const std::string& _internal_link_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_denom(
      const std::string& value);
  std::string* _internal_mutable_link_denom();

  public:
  // string feed_admin = 8 [json_name = "feedAdmin"];
  void clear_feed_admin() ;
  const std::string& feed_admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_admin(Arg_&& arg, Args_... args);
  std::string* mutable_feed_admin();
  PROTOBUF_NODISCARD std::string* release_feed_admin();
  void set_allocated_feed_admin(std::string* ptr);

  private:
  const std::string& _internal_feed_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_admin(
      const std::string& value);
  std::string* _internal_mutable_feed_admin();

  public:
  // string billing_admin = 9 [json_name = "billingAdmin"];
  void clear_billing_admin() ;
  const std::string& billing_admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_billing_admin(Arg_&& arg, Args_... args);
  std::string* mutable_billing_admin();
  PROTOBUF_NODISCARD std::string* release_billing_admin();
  void set_allocated_billing_admin(std::string* ptr);

  private:
  const std::string& _internal_billing_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_billing_admin(
      const std::string& value);
  std::string* _internal_mutable_billing_admin();

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgUpdateFeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transmitters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_per_observation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_per_transmission_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr billing_admin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateFeedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgUpdateFeedResponse) */ {
 public:
  inline MsgUpdateFeedResponse() : MsgUpdateFeedResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateFeedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateFeedResponse(const MsgUpdateFeedResponse& from);
  MsgUpdateFeedResponse(MsgUpdateFeedResponse&& from) noexcept
    : MsgUpdateFeedResponse() {
    *this = ::std::move(from);
  }

  inline MsgUpdateFeedResponse& operator=(const MsgUpdateFeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateFeedResponse& operator=(MsgUpdateFeedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateFeedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateFeedResponse* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateFeedResponse*>(
               &_MsgUpdateFeedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgUpdateFeedResponse& a, MsgUpdateFeedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateFeedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateFeedResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateFeedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateFeedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgUpdateFeedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgUpdateFeedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgUpdateFeedResponse";
  }
  protected:
  explicit MsgUpdateFeedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgUpdateFeedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgTransmit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgTransmit) */ {
 public:
  inline MsgTransmit() : MsgTransmit(nullptr) {}
  ~MsgTransmit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgTransmit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgTransmit(const MsgTransmit& from);
  MsgTransmit(MsgTransmit&& from) noexcept
    : MsgTransmit() {
    *this = ::std::move(from);
  }

  inline MsgTransmit& operator=(const MsgTransmit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgTransmit& operator=(MsgTransmit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgTransmit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgTransmit* internal_default_instance() {
    return reinterpret_cast<const MsgTransmit*>(
               &_MsgTransmit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MsgTransmit& a, MsgTransmit& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgTransmit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgTransmit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgTransmit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgTransmit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgTransmit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgTransmit& from) {
    MsgTransmit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgTransmit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgTransmit";
  }
  protected:
  explicit MsgTransmit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignaturesFieldNumber = 8,
    kTransmitterFieldNumber = 1,
    kConfigDigestFieldNumber = 2,
    kFeedIdFieldNumber = 3,
    kExtraHashFieldNumber = 6,
    kReportFieldNumber = 7,
    kEpochFieldNumber = 4,
    kRoundFieldNumber = 5,
  };
  // repeated bytes signatures = 8 [json_name = "signatures"];
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;

  public:
  void clear_signatures() ;
  const std::string& signatures(int index) const;
  std::string* mutable_signatures(int index);
  void set_signatures(int index, const std::string& value);
  void set_signatures(int index, std::string&& value);
  void set_signatures(int index, const char* value);
  void set_signatures(int index, const void* value, std::size_t size);
  void set_signatures(int index, absl::string_view value);
  std::string* add_signatures();
  void add_signatures(const std::string& value);
  void add_signatures(std::string&& value);
  void add_signatures(const char* value);
  void add_signatures(const void* value, std::size_t size);
  void add_signatures(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signatures();

  private:
  const std::string& _internal_signatures(int index) const;
  std::string* _internal_add_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_signatures();

  public:
  // string transmitter = 1 [json_name = "transmitter"];
  void clear_transmitter() ;
  const std::string& transmitter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmitter(Arg_&& arg, Args_... args);
  std::string* mutable_transmitter();
  PROTOBUF_NODISCARD std::string* release_transmitter();
  void set_allocated_transmitter(std::string* ptr);

  private:
  const std::string& _internal_transmitter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmitter(
      const std::string& value);
  std::string* _internal_mutable_transmitter();

  public:
  // bytes config_digest = 2 [json_name = "configDigest"];
  void clear_config_digest() ;
  const std::string& config_digest() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_digest(Arg_&& arg, Args_... args);
  std::string* mutable_config_digest();
  PROTOBUF_NODISCARD std::string* release_config_digest();
  void set_allocated_config_digest(std::string* ptr);

  private:
  const std::string& _internal_config_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_digest(
      const std::string& value);
  std::string* _internal_mutable_config_digest();

  public:
  // string feed_id = 3 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // bytes extra_hash = 6 [json_name = "extraHash"];
  void clear_extra_hash() ;
  const std::string& extra_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extra_hash(Arg_&& arg, Args_... args);
  std::string* mutable_extra_hash();
  PROTOBUF_NODISCARD std::string* release_extra_hash();
  void set_allocated_extra_hash(std::string* ptr);

  private:
  const std::string& _internal_extra_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_hash(
      const std::string& value);
  std::string* _internal_mutable_extra_hash();

  public:
  // .injective.ocr.v1beta1.Report report = 7 [json_name = "report"];
  bool has_report() const;
  void clear_report() ;
  const ::injective::ocr::v1beta1::Report& report() const;
  PROTOBUF_NODISCARD ::injective::ocr::v1beta1::Report* release_report();
  ::injective::ocr::v1beta1::Report* mutable_report();
  void set_allocated_report(::injective::ocr::v1beta1::Report* report);
  private:
  const ::injective::ocr::v1beta1::Report& _internal_report() const;
  ::injective::ocr::v1beta1::Report* _internal_mutable_report();
  public:
  void unsafe_arena_set_allocated_report(
      ::injective::ocr::v1beta1::Report* report);
  ::injective::ocr::v1beta1::Report* unsafe_arena_release_report();
  // uint64 epoch = 4 [json_name = "epoch"];
  void clear_epoch() ;
  ::uint64_t epoch() const;
  void set_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_epoch() const;
  void _internal_set_epoch(::uint64_t value);

  public:
  // uint64 round = 5 [json_name = "round"];
  void clear_round() ;
  ::uint64_t round() const;
  void set_round(::uint64_t value);

  private:
  ::uint64_t _internal_round() const;
  void _internal_set_round(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgTransmit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signatures_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmitter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_digest_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_hash_;
    ::injective::ocr::v1beta1::Report* report_;
    ::uint64_t epoch_;
    ::uint64_t round_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgTransmitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgTransmitResponse) */ {
 public:
  inline MsgTransmitResponse() : MsgTransmitResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgTransmitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgTransmitResponse(const MsgTransmitResponse& from);
  MsgTransmitResponse(MsgTransmitResponse&& from) noexcept
    : MsgTransmitResponse() {
    *this = ::std::move(from);
  }

  inline MsgTransmitResponse& operator=(const MsgTransmitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgTransmitResponse& operator=(MsgTransmitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgTransmitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgTransmitResponse* internal_default_instance() {
    return reinterpret_cast<const MsgTransmitResponse*>(
               &_MsgTransmitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MsgTransmitResponse& a, MsgTransmitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgTransmitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgTransmitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgTransmitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgTransmitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgTransmitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgTransmitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgTransmitResponse";
  }
  protected:
  explicit MsgTransmitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgTransmitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgFundFeedRewardPool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgFundFeedRewardPool) */ {
 public:
  inline MsgFundFeedRewardPool() : MsgFundFeedRewardPool(nullptr) {}
  ~MsgFundFeedRewardPool() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgFundFeedRewardPool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgFundFeedRewardPool(const MsgFundFeedRewardPool& from);
  MsgFundFeedRewardPool(MsgFundFeedRewardPool&& from) noexcept
    : MsgFundFeedRewardPool() {
    *this = ::std::move(from);
  }

  inline MsgFundFeedRewardPool& operator=(const MsgFundFeedRewardPool& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgFundFeedRewardPool& operator=(MsgFundFeedRewardPool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgFundFeedRewardPool& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgFundFeedRewardPool* internal_default_instance() {
    return reinterpret_cast<const MsgFundFeedRewardPool*>(
               &_MsgFundFeedRewardPool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgFundFeedRewardPool& a, MsgFundFeedRewardPool& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgFundFeedRewardPool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgFundFeedRewardPool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgFundFeedRewardPool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgFundFeedRewardPool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgFundFeedRewardPool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgFundFeedRewardPool& from) {
    MsgFundFeedRewardPool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgFundFeedRewardPool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgFundFeedRewardPool";
  }
  protected:
  explicit MsgFundFeedRewardPool(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kFeedIdFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string feed_id = 2 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgFundFeedRewardPool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgFundFeedRewardPoolResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgFundFeedRewardPoolResponse) */ {
 public:
  inline MsgFundFeedRewardPoolResponse() : MsgFundFeedRewardPoolResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgFundFeedRewardPoolResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgFundFeedRewardPoolResponse(const MsgFundFeedRewardPoolResponse& from);
  MsgFundFeedRewardPoolResponse(MsgFundFeedRewardPoolResponse&& from) noexcept
    : MsgFundFeedRewardPoolResponse() {
    *this = ::std::move(from);
  }

  inline MsgFundFeedRewardPoolResponse& operator=(const MsgFundFeedRewardPoolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgFundFeedRewardPoolResponse& operator=(MsgFundFeedRewardPoolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgFundFeedRewardPoolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgFundFeedRewardPoolResponse* internal_default_instance() {
    return reinterpret_cast<const MsgFundFeedRewardPoolResponse*>(
               &_MsgFundFeedRewardPoolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MsgFundFeedRewardPoolResponse& a, MsgFundFeedRewardPoolResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgFundFeedRewardPoolResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgFundFeedRewardPoolResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgFundFeedRewardPoolResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgFundFeedRewardPoolResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgFundFeedRewardPoolResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgFundFeedRewardPoolResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgFundFeedRewardPoolResponse";
  }
  protected:
  explicit MsgFundFeedRewardPoolResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgFundFeedRewardPoolResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgWithdrawFeedRewardPool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool) */ {
 public:
  inline MsgWithdrawFeedRewardPool() : MsgWithdrawFeedRewardPool(nullptr) {}
  ~MsgWithdrawFeedRewardPool() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgWithdrawFeedRewardPool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgWithdrawFeedRewardPool(const MsgWithdrawFeedRewardPool& from);
  MsgWithdrawFeedRewardPool(MsgWithdrawFeedRewardPool&& from) noexcept
    : MsgWithdrawFeedRewardPool() {
    *this = ::std::move(from);
  }

  inline MsgWithdrawFeedRewardPool& operator=(const MsgWithdrawFeedRewardPool& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgWithdrawFeedRewardPool& operator=(MsgWithdrawFeedRewardPool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgWithdrawFeedRewardPool& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgWithdrawFeedRewardPool* internal_default_instance() {
    return reinterpret_cast<const MsgWithdrawFeedRewardPool*>(
               &_MsgWithdrawFeedRewardPool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MsgWithdrawFeedRewardPool& a, MsgWithdrawFeedRewardPool& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgWithdrawFeedRewardPool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgWithdrawFeedRewardPool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgWithdrawFeedRewardPool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgWithdrawFeedRewardPool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgWithdrawFeedRewardPool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgWithdrawFeedRewardPool& from) {
    MsgWithdrawFeedRewardPool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgWithdrawFeedRewardPool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgWithdrawFeedRewardPool";
  }
  protected:
  explicit MsgWithdrawFeedRewardPool(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kFeedIdFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string feed_id = 2 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgWithdrawFeedRewardPoolResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgWithdrawFeedRewardPoolResponse) */ {
 public:
  inline MsgWithdrawFeedRewardPoolResponse() : MsgWithdrawFeedRewardPoolResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgWithdrawFeedRewardPoolResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgWithdrawFeedRewardPoolResponse(const MsgWithdrawFeedRewardPoolResponse& from);
  MsgWithdrawFeedRewardPoolResponse(MsgWithdrawFeedRewardPoolResponse&& from) noexcept
    : MsgWithdrawFeedRewardPoolResponse() {
    *this = ::std::move(from);
  }

  inline MsgWithdrawFeedRewardPoolResponse& operator=(const MsgWithdrawFeedRewardPoolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgWithdrawFeedRewardPoolResponse& operator=(MsgWithdrawFeedRewardPoolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgWithdrawFeedRewardPoolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgWithdrawFeedRewardPoolResponse* internal_default_instance() {
    return reinterpret_cast<const MsgWithdrawFeedRewardPoolResponse*>(
               &_MsgWithdrawFeedRewardPoolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MsgWithdrawFeedRewardPoolResponse& a, MsgWithdrawFeedRewardPoolResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgWithdrawFeedRewardPoolResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgWithdrawFeedRewardPoolResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgWithdrawFeedRewardPoolResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgWithdrawFeedRewardPoolResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgWithdrawFeedRewardPoolResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgWithdrawFeedRewardPoolResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgWithdrawFeedRewardPoolResponse";
  }
  protected:
  explicit MsgWithdrawFeedRewardPoolResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgWithdrawFeedRewardPoolResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgSetPayees final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgSetPayees) */ {
 public:
  inline MsgSetPayees() : MsgSetPayees(nullptr) {}
  ~MsgSetPayees() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgSetPayees(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSetPayees(const MsgSetPayees& from);
  MsgSetPayees(MsgSetPayees&& from) noexcept
    : MsgSetPayees() {
    *this = ::std::move(from);
  }

  inline MsgSetPayees& operator=(const MsgSetPayees& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSetPayees& operator=(MsgSetPayees&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSetPayees& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSetPayees* internal_default_instance() {
    return reinterpret_cast<const MsgSetPayees*>(
               &_MsgSetPayees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MsgSetPayees& a, MsgSetPayees& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSetPayees* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSetPayees* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSetPayees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSetPayees>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgSetPayees& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgSetPayees& from) {
    MsgSetPayees::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgSetPayees* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgSetPayees";
  }
  protected:
  explicit MsgSetPayees(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransmittersFieldNumber = 3,
    kPayeesFieldNumber = 4,
    kSenderFieldNumber = 1,
    kFeedIdFieldNumber = 2,
  };
  // repeated string transmitters = 3 [json_name = "transmitters"];
  int transmitters_size() const;
  private:
  int _internal_transmitters_size() const;

  public:
  void clear_transmitters() ;
  const std::string& transmitters(int index) const;
  std::string* mutable_transmitters(int index);
  void set_transmitters(int index, const std::string& value);
  void set_transmitters(int index, std::string&& value);
  void set_transmitters(int index, const char* value);
  void set_transmitters(int index, const char* value, std::size_t size);
  void set_transmitters(int index, absl::string_view value);
  std::string* add_transmitters();
  void add_transmitters(const std::string& value);
  void add_transmitters(std::string&& value);
  void add_transmitters(const char* value);
  void add_transmitters(const char* value, std::size_t size);
  void add_transmitters(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transmitters();

  private:
  const std::string& _internal_transmitters(int index) const;
  std::string* _internal_add_transmitters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_transmitters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_transmitters();

  public:
  // repeated string payees = 4 [json_name = "payees"];
  int payees_size() const;
  private:
  int _internal_payees_size() const;

  public:
  void clear_payees() ;
  const std::string& payees(int index) const;
  std::string* mutable_payees(int index);
  void set_payees(int index, const std::string& value);
  void set_payees(int index, std::string&& value);
  void set_payees(int index, const char* value);
  void set_payees(int index, const char* value, std::size_t size);
  void set_payees(int index, absl::string_view value);
  std::string* add_payees();
  void add_payees(const std::string& value);
  void add_payees(std::string&& value);
  void add_payees(const char* value);
  void add_payees(const char* value, std::size_t size);
  void add_payees(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& payees() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_payees();

  private:
  const std::string& _internal_payees(int index) const;
  std::string* _internal_add_payees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_payees() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_payees();

  public:
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string feed_id = 2 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgSetPayees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transmitters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> payees_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgSetPayeesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgSetPayeesResponse) */ {
 public:
  inline MsgSetPayeesResponse() : MsgSetPayeesResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgSetPayeesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSetPayeesResponse(const MsgSetPayeesResponse& from);
  MsgSetPayeesResponse(MsgSetPayeesResponse&& from) noexcept
    : MsgSetPayeesResponse() {
    *this = ::std::move(from);
  }

  inline MsgSetPayeesResponse& operator=(const MsgSetPayeesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSetPayeesResponse& operator=(MsgSetPayeesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSetPayeesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSetPayeesResponse* internal_default_instance() {
    return reinterpret_cast<const MsgSetPayeesResponse*>(
               &_MsgSetPayeesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MsgSetPayeesResponse& a, MsgSetPayeesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSetPayeesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSetPayeesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSetPayeesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSetPayeesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgSetPayeesResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgSetPayeesResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgSetPayeesResponse";
  }
  protected:
  explicit MsgSetPayeesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgSetPayeesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgTransferPayeeship final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgTransferPayeeship) */ {
 public:
  inline MsgTransferPayeeship() : MsgTransferPayeeship(nullptr) {}
  ~MsgTransferPayeeship() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgTransferPayeeship(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgTransferPayeeship(const MsgTransferPayeeship& from);
  MsgTransferPayeeship(MsgTransferPayeeship&& from) noexcept
    : MsgTransferPayeeship() {
    *this = ::std::move(from);
  }

  inline MsgTransferPayeeship& operator=(const MsgTransferPayeeship& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgTransferPayeeship& operator=(MsgTransferPayeeship&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgTransferPayeeship& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgTransferPayeeship* internal_default_instance() {
    return reinterpret_cast<const MsgTransferPayeeship*>(
               &_MsgTransferPayeeship_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MsgTransferPayeeship& a, MsgTransferPayeeship& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgTransferPayeeship* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgTransferPayeeship* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgTransferPayeeship* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgTransferPayeeship>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgTransferPayeeship& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgTransferPayeeship& from) {
    MsgTransferPayeeship::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgTransferPayeeship* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgTransferPayeeship";
  }
  protected:
  explicit MsgTransferPayeeship(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kTransmitterFieldNumber = 2,
    kFeedIdFieldNumber = 3,
    kProposedFieldNumber = 4,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string transmitter = 2 [json_name = "transmitter"];
  void clear_transmitter() ;
  const std::string& transmitter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmitter(Arg_&& arg, Args_... args);
  std::string* mutable_transmitter();
  PROTOBUF_NODISCARD std::string* release_transmitter();
  void set_allocated_transmitter(std::string* ptr);

  private:
  const std::string& _internal_transmitter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmitter(
      const std::string& value);
  std::string* _internal_mutable_transmitter();

  public:
  // string feed_id = 3 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // string proposed = 4 [json_name = "proposed"];
  void clear_proposed() ;
  const std::string& proposed() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proposed(Arg_&& arg, Args_... args);
  std::string* mutable_proposed();
  PROTOBUF_NODISCARD std::string* release_proposed();
  void set_allocated_proposed(std::string* ptr);

  private:
  const std::string& _internal_proposed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposed(
      const std::string& value);
  std::string* _internal_mutable_proposed();

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgTransferPayeeship)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmitter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgTransferPayeeshipResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgTransferPayeeshipResponse) */ {
 public:
  inline MsgTransferPayeeshipResponse() : MsgTransferPayeeshipResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgTransferPayeeshipResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgTransferPayeeshipResponse(const MsgTransferPayeeshipResponse& from);
  MsgTransferPayeeshipResponse(MsgTransferPayeeshipResponse&& from) noexcept
    : MsgTransferPayeeshipResponse() {
    *this = ::std::move(from);
  }

  inline MsgTransferPayeeshipResponse& operator=(const MsgTransferPayeeshipResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgTransferPayeeshipResponse& operator=(MsgTransferPayeeshipResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgTransferPayeeshipResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgTransferPayeeshipResponse* internal_default_instance() {
    return reinterpret_cast<const MsgTransferPayeeshipResponse*>(
               &_MsgTransferPayeeshipResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MsgTransferPayeeshipResponse& a, MsgTransferPayeeshipResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgTransferPayeeshipResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgTransferPayeeshipResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgTransferPayeeshipResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgTransferPayeeshipResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgTransferPayeeshipResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgTransferPayeeshipResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgTransferPayeeshipResponse";
  }
  protected:
  explicit MsgTransferPayeeshipResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgTransferPayeeshipResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgAcceptPayeeship final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgAcceptPayeeship) */ {
 public:
  inline MsgAcceptPayeeship() : MsgAcceptPayeeship(nullptr) {}
  ~MsgAcceptPayeeship() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgAcceptPayeeship(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgAcceptPayeeship(const MsgAcceptPayeeship& from);
  MsgAcceptPayeeship(MsgAcceptPayeeship&& from) noexcept
    : MsgAcceptPayeeship() {
    *this = ::std::move(from);
  }

  inline MsgAcceptPayeeship& operator=(const MsgAcceptPayeeship& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgAcceptPayeeship& operator=(MsgAcceptPayeeship&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgAcceptPayeeship& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgAcceptPayeeship* internal_default_instance() {
    return reinterpret_cast<const MsgAcceptPayeeship*>(
               &_MsgAcceptPayeeship_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MsgAcceptPayeeship& a, MsgAcceptPayeeship& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgAcceptPayeeship* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgAcceptPayeeship* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgAcceptPayeeship* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgAcceptPayeeship>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgAcceptPayeeship& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgAcceptPayeeship& from) {
    MsgAcceptPayeeship::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgAcceptPayeeship* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgAcceptPayeeship";
  }
  protected:
  explicit MsgAcceptPayeeship(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayeeFieldNumber = 1,
    kTransmitterFieldNumber = 2,
    kFeedIdFieldNumber = 3,
  };
  // string payee = 1 [json_name = "payee"];
  void clear_payee() ;
  const std::string& payee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payee(Arg_&& arg, Args_... args);
  std::string* mutable_payee();
  PROTOBUF_NODISCARD std::string* release_payee();
  void set_allocated_payee(std::string* ptr);

  private:
  const std::string& _internal_payee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payee(
      const std::string& value);
  std::string* _internal_mutable_payee();

  public:
  // string transmitter = 2 [json_name = "transmitter"];
  void clear_transmitter() ;
  const std::string& transmitter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmitter(Arg_&& arg, Args_... args);
  std::string* mutable_transmitter();
  PROTOBUF_NODISCARD std::string* release_transmitter();
  void set_allocated_transmitter(std::string* ptr);

  private:
  const std::string& _internal_transmitter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmitter(
      const std::string& value);
  std::string* _internal_mutable_transmitter();

  public:
  // string feed_id = 3 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgAcceptPayeeship)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmitter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgAcceptPayeeshipResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgAcceptPayeeshipResponse) */ {
 public:
  inline MsgAcceptPayeeshipResponse() : MsgAcceptPayeeshipResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgAcceptPayeeshipResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgAcceptPayeeshipResponse(const MsgAcceptPayeeshipResponse& from);
  MsgAcceptPayeeshipResponse(MsgAcceptPayeeshipResponse&& from) noexcept
    : MsgAcceptPayeeshipResponse() {
    *this = ::std::move(from);
  }

  inline MsgAcceptPayeeshipResponse& operator=(const MsgAcceptPayeeshipResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgAcceptPayeeshipResponse& operator=(MsgAcceptPayeeshipResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgAcceptPayeeshipResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgAcceptPayeeshipResponse* internal_default_instance() {
    return reinterpret_cast<const MsgAcceptPayeeshipResponse*>(
               &_MsgAcceptPayeeshipResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MsgAcceptPayeeshipResponse& a, MsgAcceptPayeeshipResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgAcceptPayeeshipResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgAcceptPayeeshipResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgAcceptPayeeshipResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgAcceptPayeeshipResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgAcceptPayeeshipResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgAcceptPayeeshipResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgAcceptPayeeshipResponse";
  }
  protected:
  explicit MsgAcceptPayeeshipResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgAcceptPayeeshipResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgUpdateParams) */ {
 public:
  inline MsgUpdateParams() : MsgUpdateParams(nullptr) {}
  ~MsgUpdateParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateParams(const MsgUpdateParams& from);
  MsgUpdateParams(MsgUpdateParams&& from) noexcept
    : MsgUpdateParams() {
    *this = ::std::move(from);
  }

  inline MsgUpdateParams& operator=(const MsgUpdateParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateParams& operator=(MsgUpdateParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateParams* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateParams*>(
               &_MsgUpdateParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MsgUpdateParams& a, MsgUpdateParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgUpdateParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgUpdateParams& from) {
    MsgUpdateParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgUpdateParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgUpdateParams";
  }
  protected:
  explicit MsgUpdateParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorityFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // string authority = 1 [json_name = "authority", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_authority() ;
  const std::string& authority() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_authority(Arg_&& arg, Args_... args);
  std::string* mutable_authority();
  PROTOBUF_NODISCARD std::string* release_authority();
  void set_allocated_authority(std::string* ptr);

  private:
  const std::string& _internal_authority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authority(
      const std::string& value);
  std::string* _internal_mutable_authority();

  public:
  // .injective.ocr.v1beta1.Params params = 2 [json_name = "params", (.gogoproto.nullable) = false];
  bool has_params() const;
  void clear_params() ;
  const ::injective::ocr::v1beta1::Params& params() const;
  PROTOBUF_NODISCARD ::injective::ocr::v1beta1::Params* release_params();
  ::injective::ocr::v1beta1::Params* mutable_params();
  void set_allocated_params(::injective::ocr::v1beta1::Params* params);
  private:
  const ::injective::ocr::v1beta1::Params& _internal_params() const;
  ::injective::ocr::v1beta1::Params* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::injective::ocr::v1beta1::Params* params);
  ::injective::ocr::v1beta1::Params* unsafe_arena_release_params();
  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgUpdateParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authority_;
    ::injective::ocr::v1beta1::Params* params_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateParamsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.ocr.v1beta1.MsgUpdateParamsResponse) */ {
 public:
  inline MsgUpdateParamsResponse() : MsgUpdateParamsResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateParamsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateParamsResponse(const MsgUpdateParamsResponse& from);
  MsgUpdateParamsResponse(MsgUpdateParamsResponse&& from) noexcept
    : MsgUpdateParamsResponse() {
    *this = ::std::move(from);
  }

  inline MsgUpdateParamsResponse& operator=(const MsgUpdateParamsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateParamsResponse& operator=(MsgUpdateParamsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateParamsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateParamsResponse* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateParamsResponse*>(
               &_MsgUpdateParamsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MsgUpdateParamsResponse& a, MsgUpdateParamsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateParamsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateParamsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateParamsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateParamsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgUpdateParamsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgUpdateParamsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.ocr.v1beta1.MsgUpdateParamsResponse";
  }
  protected:
  explicit MsgUpdateParamsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.ocr.v1beta1.MsgUpdateParamsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2focr_2fv1beta1_2ftx_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MsgCreateFeed

// string sender = 1 [json_name = "sender"];
inline void MsgCreateFeed::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCreateFeed::sender() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgCreateFeed.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateFeed::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgCreateFeed.sender)
}
inline std::string* MsgCreateFeed::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgCreateFeed.sender)
  return _s;
}
inline const std::string& MsgCreateFeed::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCreateFeed::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateFeed::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateFeed::release_sender() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgCreateFeed.sender)
  return _impl_.sender_.Release();
}
inline void MsgCreateFeed::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgCreateFeed.sender)
}

// .injective.ocr.v1beta1.FeedConfig config = 2 [json_name = "config"];
inline bool MsgCreateFeed::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline const ::injective::ocr::v1beta1::FeedConfig& MsgCreateFeed::_internal_config() const {
  const ::injective::ocr::v1beta1::FeedConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::ocr::v1beta1::FeedConfig&>(
      ::injective::ocr::v1beta1::_FeedConfig_default_instance_);
}
inline const ::injective::ocr::v1beta1::FeedConfig& MsgCreateFeed::config() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgCreateFeed.config)
  return _internal_config();
}
inline void MsgCreateFeed::unsafe_arena_set_allocated_config(
    ::injective::ocr::v1beta1::FeedConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.MsgCreateFeed.config)
}
inline ::injective::ocr::v1beta1::FeedConfig* MsgCreateFeed::release_config() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::FeedConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::ocr::v1beta1::FeedConfig* MsgCreateFeed::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgCreateFeed.config)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::FeedConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::injective::ocr::v1beta1::FeedConfig* MsgCreateFeed::_internal_mutable_config() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::ocr::v1beta1::FeedConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::injective::ocr::v1beta1::FeedConfig* MsgCreateFeed::mutable_config() {
  ::injective::ocr::v1beta1::FeedConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgCreateFeed.config)
  return _msg;
}
inline void MsgCreateFeed::set_allocated_config(::injective::ocr::v1beta1::FeedConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgCreateFeed.config)
}

// -------------------------------------------------------------------

// MsgCreateFeedResponse

// -------------------------------------------------------------------

// MsgUpdateFeed

// string sender = 1 [json_name = "sender"];
inline void MsgUpdateFeed::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgUpdateFeed::sender() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateFeed::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.sender)
}
inline std::string* MsgUpdateFeed::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.sender)
  return _s;
}
inline const std::string& MsgUpdateFeed::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgUpdateFeed::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::release_sender() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateFeed.sender)
  return _impl_.sender_.Release();
}
inline void MsgUpdateFeed::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateFeed.sender)
}

// string feed_id = 2 [json_name = "feedId"];
inline void MsgUpdateFeed::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& MsgUpdateFeed::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateFeed::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.feed_id)
}
inline std::string* MsgUpdateFeed::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.feed_id)
  return _s;
}
inline const std::string& MsgUpdateFeed::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void MsgUpdateFeed::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateFeed.feed_id)
  return _impl_.feed_id_.Release();
}
inline void MsgUpdateFeed::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateFeed.feed_id)
}

// repeated string signers = 3 [json_name = "signers"];
inline int MsgUpdateFeed::_internal_signers_size() const {
  return _impl_.signers_.size();
}
inline int MsgUpdateFeed::signers_size() const {
  return _internal_signers_size();
}
inline void MsgUpdateFeed::clear_signers() {
  _internal_mutable_signers()->Clear();
}
inline std::string* MsgUpdateFeed::add_signers() {
  std::string* _s = _internal_add_signers();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.MsgUpdateFeed.signers)
  return _s;
}
inline const std::string& MsgUpdateFeed::signers(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.signers)
  return _internal_signers(index);
}
inline std::string* MsgUpdateFeed::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.signers)
  return _internal_mutable_signers()->Mutable(index);
}
inline void MsgUpdateFeed::set_signers(int index, const std::string& value) {
  _internal_mutable_signers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::set_signers(int index, std::string&& value) {
  _internal_mutable_signers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::set_signers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::set_signers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_signers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::set_signers(int index, absl::string_view value) {
  _internal_mutable_signers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::add_signers(const std::string& value) {
  _internal_mutable_signers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::add_signers(std::string&& value) {
  _internal_mutable_signers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::add_signers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::add_signers(const char* value, std::size_t size) {
  _internal_mutable_signers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline void MsgUpdateFeed::add_signers(absl::string_view value) {
  _internal_mutable_signers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.MsgUpdateFeed.signers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgUpdateFeed::signers() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.MsgUpdateFeed.signers)
  return _internal_signers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgUpdateFeed::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.MsgUpdateFeed.signers)
  return _internal_mutable_signers();
}
inline const std::string& MsgUpdateFeed::_internal_signers(int index) const {
  return _internal_signers().Get(index);
}
inline std::string* MsgUpdateFeed::_internal_add_signers() {
  return _internal_mutable_signers()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgUpdateFeed::_internal_signers() const {
  return _impl_.signers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgUpdateFeed::_internal_mutable_signers() {
  return &_impl_.signers_;
}

// repeated string transmitters = 4 [json_name = "transmitters"];
inline int MsgUpdateFeed::_internal_transmitters_size() const {
  return _impl_.transmitters_.size();
}
inline int MsgUpdateFeed::transmitters_size() const {
  return _internal_transmitters_size();
}
inline void MsgUpdateFeed::clear_transmitters() {
  _internal_mutable_transmitters()->Clear();
}
inline std::string* MsgUpdateFeed::add_transmitters() {
  std::string* _s = _internal_add_transmitters();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
  return _s;
}
inline const std::string& MsgUpdateFeed::transmitters(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
  return _internal_transmitters(index);
}
inline std::string* MsgUpdateFeed::mutable_transmitters(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
  return _internal_mutable_transmitters()->Mutable(index);
}
inline void MsgUpdateFeed::set_transmitters(int index, const std::string& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::set_transmitters(int index, std::string&& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::set_transmitters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::set_transmitters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transmitters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::set_transmitters(int index, absl::string_view value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::add_transmitters(const std::string& value) {
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::add_transmitters(std::string&& value) {
  _internal_mutable_transmitters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::add_transmitters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::add_transmitters(const char* value, std::size_t size) {
  _internal_mutable_transmitters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline void MsgUpdateFeed::add_transmitters(absl::string_view value) {
  _internal_mutable_transmitters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgUpdateFeed::transmitters() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
  return _internal_transmitters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgUpdateFeed::mutable_transmitters() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.MsgUpdateFeed.transmitters)
  return _internal_mutable_transmitters();
}
inline const std::string& MsgUpdateFeed::_internal_transmitters(int index) const {
  return _internal_transmitters().Get(index);
}
inline std::string* MsgUpdateFeed::_internal_add_transmitters() {
  return _internal_mutable_transmitters()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgUpdateFeed::_internal_transmitters() const {
  return _impl_.transmitters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgUpdateFeed::_internal_mutable_transmitters() {
  return &_impl_.transmitters_;
}

// string link_per_observation = 5 [json_name = "linkPerObservation", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void MsgUpdateFeed::clear_link_per_observation() {
  _impl_.link_per_observation_.ClearToEmpty();
}
inline const std::string& MsgUpdateFeed::link_per_observation() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.link_per_observation)
  return _internal_link_per_observation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateFeed::set_link_per_observation(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_per_observation_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.link_per_observation)
}
inline std::string* MsgUpdateFeed::mutable_link_per_observation() {
  std::string* _s = _internal_mutable_link_per_observation();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.link_per_observation)
  return _s;
}
inline const std::string& MsgUpdateFeed::_internal_link_per_observation() const {
  return _impl_.link_per_observation_.Get();
}
inline void MsgUpdateFeed::_internal_set_link_per_observation(const std::string& value) {
  ;


  _impl_.link_per_observation_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::_internal_mutable_link_per_observation() {
  ;
  return _impl_.link_per_observation_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::release_link_per_observation() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateFeed.link_per_observation)
  return _impl_.link_per_observation_.Release();
}
inline void MsgUpdateFeed::set_allocated_link_per_observation(std::string* value) {
  _impl_.link_per_observation_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_per_observation_.IsDefault()) {
          _impl_.link_per_observation_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateFeed.link_per_observation)
}

// string link_per_transmission = 6 [json_name = "linkPerTransmission", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void MsgUpdateFeed::clear_link_per_transmission() {
  _impl_.link_per_transmission_.ClearToEmpty();
}
inline const std::string& MsgUpdateFeed::link_per_transmission() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.link_per_transmission)
  return _internal_link_per_transmission();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateFeed::set_link_per_transmission(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_per_transmission_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.link_per_transmission)
}
inline std::string* MsgUpdateFeed::mutable_link_per_transmission() {
  std::string* _s = _internal_mutable_link_per_transmission();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.link_per_transmission)
  return _s;
}
inline const std::string& MsgUpdateFeed::_internal_link_per_transmission() const {
  return _impl_.link_per_transmission_.Get();
}
inline void MsgUpdateFeed::_internal_set_link_per_transmission(const std::string& value) {
  ;


  _impl_.link_per_transmission_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::_internal_mutable_link_per_transmission() {
  ;
  return _impl_.link_per_transmission_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::release_link_per_transmission() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateFeed.link_per_transmission)
  return _impl_.link_per_transmission_.Release();
}
inline void MsgUpdateFeed::set_allocated_link_per_transmission(std::string* value) {
  _impl_.link_per_transmission_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_per_transmission_.IsDefault()) {
          _impl_.link_per_transmission_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateFeed.link_per_transmission)
}

// string link_denom = 7 [json_name = "linkDenom"];
inline void MsgUpdateFeed::clear_link_denom() {
  _impl_.link_denom_.ClearToEmpty();
}
inline const std::string& MsgUpdateFeed::link_denom() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.link_denom)
  return _internal_link_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateFeed::set_link_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.link_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.link_denom)
}
inline std::string* MsgUpdateFeed::mutable_link_denom() {
  std::string* _s = _internal_mutable_link_denom();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.link_denom)
  return _s;
}
inline const std::string& MsgUpdateFeed::_internal_link_denom() const {
  return _impl_.link_denom_.Get();
}
inline void MsgUpdateFeed::_internal_set_link_denom(const std::string& value) {
  ;


  _impl_.link_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::_internal_mutable_link_denom() {
  ;
  return _impl_.link_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::release_link_denom() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateFeed.link_denom)
  return _impl_.link_denom_.Release();
}
inline void MsgUpdateFeed::set_allocated_link_denom(std::string* value) {
  _impl_.link_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_denom_.IsDefault()) {
          _impl_.link_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateFeed.link_denom)
}

// string feed_admin = 8 [json_name = "feedAdmin"];
inline void MsgUpdateFeed::clear_feed_admin() {
  _impl_.feed_admin_.ClearToEmpty();
}
inline const std::string& MsgUpdateFeed::feed_admin() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.feed_admin)
  return _internal_feed_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateFeed::set_feed_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.feed_admin)
}
inline std::string* MsgUpdateFeed::mutable_feed_admin() {
  std::string* _s = _internal_mutable_feed_admin();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.feed_admin)
  return _s;
}
inline const std::string& MsgUpdateFeed::_internal_feed_admin() const {
  return _impl_.feed_admin_.Get();
}
inline void MsgUpdateFeed::_internal_set_feed_admin(const std::string& value) {
  ;


  _impl_.feed_admin_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::_internal_mutable_feed_admin() {
  ;
  return _impl_.feed_admin_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::release_feed_admin() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateFeed.feed_admin)
  return _impl_.feed_admin_.Release();
}
inline void MsgUpdateFeed::set_allocated_feed_admin(std::string* value) {
  _impl_.feed_admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_admin_.IsDefault()) {
          _impl_.feed_admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateFeed.feed_admin)
}

// string billing_admin = 9 [json_name = "billingAdmin"];
inline void MsgUpdateFeed::clear_billing_admin() {
  _impl_.billing_admin_.ClearToEmpty();
}
inline const std::string& MsgUpdateFeed::billing_admin() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateFeed.billing_admin)
  return _internal_billing_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateFeed::set_billing_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.billing_admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateFeed.billing_admin)
}
inline std::string* MsgUpdateFeed::mutable_billing_admin() {
  std::string* _s = _internal_mutable_billing_admin();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateFeed.billing_admin)
  return _s;
}
inline const std::string& MsgUpdateFeed::_internal_billing_admin() const {
  return _impl_.billing_admin_.Get();
}
inline void MsgUpdateFeed::_internal_set_billing_admin(const std::string& value) {
  ;


  _impl_.billing_admin_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::_internal_mutable_billing_admin() {
  ;
  return _impl_.billing_admin_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateFeed::release_billing_admin() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateFeed.billing_admin)
  return _impl_.billing_admin_.Release();
}
inline void MsgUpdateFeed::set_allocated_billing_admin(std::string* value) {
  _impl_.billing_admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.billing_admin_.IsDefault()) {
          _impl_.billing_admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateFeed.billing_admin)
}

// -------------------------------------------------------------------

// MsgUpdateFeedResponse

// -------------------------------------------------------------------

// MsgTransmit

// string transmitter = 1 [json_name = "transmitter"];
inline void MsgTransmit::clear_transmitter() {
  _impl_.transmitter_.ClearToEmpty();
}
inline const std::string& MsgTransmit::transmitter() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransmit.transmitter)
  return _internal_transmitter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTransmit::set_transmitter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.transmitter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransmit.transmitter)
}
inline std::string* MsgTransmit::mutable_transmitter() {
  std::string* _s = _internal_mutable_transmitter();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransmit.transmitter)
  return _s;
}
inline const std::string& MsgTransmit::_internal_transmitter() const {
  return _impl_.transmitter_.Get();
}
inline void MsgTransmit::_internal_set_transmitter(const std::string& value) {
  ;


  _impl_.transmitter_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTransmit::_internal_mutable_transmitter() {
  ;
  return _impl_.transmitter_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTransmit::release_transmitter() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransmit.transmitter)
  return _impl_.transmitter_.Release();
}
inline void MsgTransmit::set_allocated_transmitter(std::string* value) {
  _impl_.transmitter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmitter_.IsDefault()) {
          _impl_.transmitter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransmit.transmitter)
}

// bytes config_digest = 2 [json_name = "configDigest"];
inline void MsgTransmit::clear_config_digest() {
  _impl_.config_digest_.ClearToEmpty();
}
inline const std::string& MsgTransmit::config_digest() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransmit.config_digest)
  return _internal_config_digest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTransmit::set_config_digest(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.config_digest_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransmit.config_digest)
}
inline std::string* MsgTransmit::mutable_config_digest() {
  std::string* _s = _internal_mutable_config_digest();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransmit.config_digest)
  return _s;
}
inline const std::string& MsgTransmit::_internal_config_digest() const {
  return _impl_.config_digest_.Get();
}
inline void MsgTransmit::_internal_set_config_digest(const std::string& value) {
  ;


  _impl_.config_digest_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTransmit::_internal_mutable_config_digest() {
  ;
  return _impl_.config_digest_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTransmit::release_config_digest() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransmit.config_digest)
  return _impl_.config_digest_.Release();
}
inline void MsgTransmit::set_allocated_config_digest(std::string* value) {
  _impl_.config_digest_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.config_digest_.IsDefault()) {
          _impl_.config_digest_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransmit.config_digest)
}

// string feed_id = 3 [json_name = "feedId"];
inline void MsgTransmit::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& MsgTransmit::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransmit.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTransmit::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransmit.feed_id)
}
inline std::string* MsgTransmit::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransmit.feed_id)
  return _s;
}
inline const std::string& MsgTransmit::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void MsgTransmit::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTransmit::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTransmit::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransmit.feed_id)
  return _impl_.feed_id_.Release();
}
inline void MsgTransmit::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransmit.feed_id)
}

// uint64 epoch = 4 [json_name = "epoch"];
inline void MsgTransmit::clear_epoch() {
  _impl_.epoch_ = ::uint64_t{0u};
}
inline ::uint64_t MsgTransmit::epoch() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransmit.epoch)
  return _internal_epoch();
}
inline void MsgTransmit::set_epoch(::uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransmit.epoch)
}
inline ::uint64_t MsgTransmit::_internal_epoch() const {
  return _impl_.epoch_;
}
inline void MsgTransmit::_internal_set_epoch(::uint64_t value) {
  ;
  _impl_.epoch_ = value;
}

// uint64 round = 5 [json_name = "round"];
inline void MsgTransmit::clear_round() {
  _impl_.round_ = ::uint64_t{0u};
}
inline ::uint64_t MsgTransmit::round() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransmit.round)
  return _internal_round();
}
inline void MsgTransmit::set_round(::uint64_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransmit.round)
}
inline ::uint64_t MsgTransmit::_internal_round() const {
  return _impl_.round_;
}
inline void MsgTransmit::_internal_set_round(::uint64_t value) {
  ;
  _impl_.round_ = value;
}

// bytes extra_hash = 6 [json_name = "extraHash"];
inline void MsgTransmit::clear_extra_hash() {
  _impl_.extra_hash_.ClearToEmpty();
}
inline const std::string& MsgTransmit::extra_hash() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransmit.extra_hash)
  return _internal_extra_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTransmit::set_extra_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.extra_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransmit.extra_hash)
}
inline std::string* MsgTransmit::mutable_extra_hash() {
  std::string* _s = _internal_mutable_extra_hash();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransmit.extra_hash)
  return _s;
}
inline const std::string& MsgTransmit::_internal_extra_hash() const {
  return _impl_.extra_hash_.Get();
}
inline void MsgTransmit::_internal_set_extra_hash(const std::string& value) {
  ;


  _impl_.extra_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTransmit::_internal_mutable_extra_hash() {
  ;
  return _impl_.extra_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTransmit::release_extra_hash() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransmit.extra_hash)
  return _impl_.extra_hash_.Release();
}
inline void MsgTransmit::set_allocated_extra_hash(std::string* value) {
  _impl_.extra_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extra_hash_.IsDefault()) {
          _impl_.extra_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransmit.extra_hash)
}

// .injective.ocr.v1beta1.Report report = 7 [json_name = "report"];
inline bool MsgTransmit::has_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.report_ != nullptr);
  return value;
}
inline const ::injective::ocr::v1beta1::Report& MsgTransmit::_internal_report() const {
  const ::injective::ocr::v1beta1::Report* p = _impl_.report_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::ocr::v1beta1::Report&>(
      ::injective::ocr::v1beta1::_Report_default_instance_);
}
inline const ::injective::ocr::v1beta1::Report& MsgTransmit::report() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransmit.report)
  return _internal_report();
}
inline void MsgTransmit::unsafe_arena_set_allocated_report(
    ::injective::ocr::v1beta1::Report* report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_);
  }
  _impl_.report_ = report;
  if (report) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.MsgTransmit.report)
}
inline ::injective::ocr::v1beta1::Report* MsgTransmit::release_report() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::Report* temp = _impl_.report_;
  _impl_.report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::ocr::v1beta1::Report* MsgTransmit::unsafe_arena_release_report() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransmit.report)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::Report* temp = _impl_.report_;
  _impl_.report_ = nullptr;
  return temp;
}
inline ::injective::ocr::v1beta1::Report* MsgTransmit::_internal_mutable_report() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.report_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::ocr::v1beta1::Report>(GetArenaForAllocation());
    _impl_.report_ = p;
  }
  return _impl_.report_;
}
inline ::injective::ocr::v1beta1::Report* MsgTransmit::mutable_report() {
  ::injective::ocr::v1beta1::Report* _msg = _internal_mutable_report();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransmit.report)
  return _msg;
}
inline void MsgTransmit::set_allocated_report(::injective::ocr::v1beta1::Report* report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_);
  }
  if (report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report));
    if (message_arena != submessage_arena) {
      report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.report_ = report;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransmit.report)
}

// repeated bytes signatures = 8 [json_name = "signatures"];
inline int MsgTransmit::_internal_signatures_size() const {
  return _impl_.signatures_.size();
}
inline int MsgTransmit::signatures_size() const {
  return _internal_signatures_size();
}
inline void MsgTransmit::clear_signatures() {
  _internal_mutable_signatures()->Clear();
}
inline std::string* MsgTransmit::add_signatures() {
  std::string* _s = _internal_add_signatures();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.MsgTransmit.signatures)
  return _s;
}
inline const std::string& MsgTransmit::signatures(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransmit.signatures)
  return _internal_signatures(index);
}
inline std::string* MsgTransmit::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransmit.signatures)
  return _internal_mutable_signatures()->Mutable(index);
}
inline void MsgTransmit::set_signatures(int index, const std::string& value) {
  _internal_mutable_signatures()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::set_signatures(int index, std::string&& value) {
  _internal_mutable_signatures()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::set_signatures(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signatures()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::set_signatures(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_signatures()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::set_signatures(int index, absl::string_view value) {
  _internal_mutable_signatures()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::add_signatures(const std::string& value) {
  _internal_mutable_signatures()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::add_signatures(std::string&& value) {
  _internal_mutable_signatures()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::add_signatures(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_signatures()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::add_signatures(const void* value, std::size_t size) {
  _internal_mutable_signatures()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline void MsgTransmit::add_signatures(absl::string_view value) {
  _internal_mutable_signatures()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.MsgTransmit.signatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgTransmit::signatures() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.MsgTransmit.signatures)
  return _internal_signatures();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgTransmit::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.MsgTransmit.signatures)
  return _internal_mutable_signatures();
}
inline const std::string& MsgTransmit::_internal_signatures(int index) const {
  return _internal_signatures().Get(index);
}
inline std::string* MsgTransmit::_internal_add_signatures() {
  return _internal_mutable_signatures()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgTransmit::_internal_signatures() const {
  return _impl_.signatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgTransmit::_internal_mutable_signatures() {
  return &_impl_.signatures_;
}

// -------------------------------------------------------------------

// MsgTransmitResponse

// -------------------------------------------------------------------

// MsgFundFeedRewardPool

// string sender = 1 [json_name = "sender"];
inline void MsgFundFeedRewardPool::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgFundFeedRewardPool::sender() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgFundFeedRewardPool.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgFundFeedRewardPool::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgFundFeedRewardPool.sender)
}
inline std::string* MsgFundFeedRewardPool::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgFundFeedRewardPool.sender)
  return _s;
}
inline const std::string& MsgFundFeedRewardPool::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgFundFeedRewardPool::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgFundFeedRewardPool::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgFundFeedRewardPool::release_sender() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgFundFeedRewardPool.sender)
  return _impl_.sender_.Release();
}
inline void MsgFundFeedRewardPool::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgFundFeedRewardPool.sender)
}

// string feed_id = 2 [json_name = "feedId"];
inline void MsgFundFeedRewardPool::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& MsgFundFeedRewardPool::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgFundFeedRewardPool.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgFundFeedRewardPool::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgFundFeedRewardPool.feed_id)
}
inline std::string* MsgFundFeedRewardPool::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgFundFeedRewardPool.feed_id)
  return _s;
}
inline const std::string& MsgFundFeedRewardPool::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void MsgFundFeedRewardPool::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgFundFeedRewardPool::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgFundFeedRewardPool::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgFundFeedRewardPool.feed_id)
  return _impl_.feed_id_.Release();
}
inline void MsgFundFeedRewardPool::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgFundFeedRewardPool.feed_id)
}

// .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool MsgFundFeedRewardPool::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& MsgFundFeedRewardPool::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& MsgFundFeedRewardPool::amount() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgFundFeedRewardPool.amount)
  return _internal_amount();
}
inline void MsgFundFeedRewardPool::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.MsgFundFeedRewardPool.amount)
}
inline ::cosmos::base::v1beta1::Coin* MsgFundFeedRewardPool::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgFundFeedRewardPool::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgFundFeedRewardPool.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgFundFeedRewardPool::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* MsgFundFeedRewardPool::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgFundFeedRewardPool.amount)
  return _msg;
}
inline void MsgFundFeedRewardPool::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgFundFeedRewardPool.amount)
}

// -------------------------------------------------------------------

// MsgFundFeedRewardPoolResponse

// -------------------------------------------------------------------

// MsgWithdrawFeedRewardPool

// string sender = 1 [json_name = "sender"];
inline void MsgWithdrawFeedRewardPool::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgWithdrawFeedRewardPool::sender() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgWithdrawFeedRewardPool::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.sender)
}
inline std::string* MsgWithdrawFeedRewardPool::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.sender)
  return _s;
}
inline const std::string& MsgWithdrawFeedRewardPool::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgWithdrawFeedRewardPool::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgWithdrawFeedRewardPool::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgWithdrawFeedRewardPool::release_sender() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.sender)
  return _impl_.sender_.Release();
}
inline void MsgWithdrawFeedRewardPool::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.sender)
}

// string feed_id = 2 [json_name = "feedId"];
inline void MsgWithdrawFeedRewardPool::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& MsgWithdrawFeedRewardPool::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgWithdrawFeedRewardPool::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.feed_id)
}
inline std::string* MsgWithdrawFeedRewardPool::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.feed_id)
  return _s;
}
inline const std::string& MsgWithdrawFeedRewardPool::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void MsgWithdrawFeedRewardPool::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgWithdrawFeedRewardPool::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgWithdrawFeedRewardPool::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.feed_id)
  return _impl_.feed_id_.Release();
}
inline void MsgWithdrawFeedRewardPool::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.feed_id)
}

// .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool MsgWithdrawFeedRewardPool::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& MsgWithdrawFeedRewardPool::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& MsgWithdrawFeedRewardPool::amount() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.amount)
  return _internal_amount();
}
inline void MsgWithdrawFeedRewardPool::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.amount)
}
inline ::cosmos::base::v1beta1::Coin* MsgWithdrawFeedRewardPool::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgWithdrawFeedRewardPool::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgWithdrawFeedRewardPool::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* MsgWithdrawFeedRewardPool::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.amount)
  return _msg;
}
inline void MsgWithdrawFeedRewardPool::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgWithdrawFeedRewardPool.amount)
}

// -------------------------------------------------------------------

// MsgWithdrawFeedRewardPoolResponse

// -------------------------------------------------------------------

// MsgSetPayees

// string sender = 1 [json_name = "sender"];
inline void MsgSetPayees::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgSetPayees::sender() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgSetPayees.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSetPayees::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgSetPayees.sender)
}
inline std::string* MsgSetPayees::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgSetPayees.sender)
  return _s;
}
inline const std::string& MsgSetPayees::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgSetPayees::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSetPayees::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSetPayees::release_sender() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgSetPayees.sender)
  return _impl_.sender_.Release();
}
inline void MsgSetPayees::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgSetPayees.sender)
}

// string feed_id = 2 [json_name = "feedId"];
inline void MsgSetPayees::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& MsgSetPayees::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgSetPayees.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSetPayees::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgSetPayees.feed_id)
}
inline std::string* MsgSetPayees::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgSetPayees.feed_id)
  return _s;
}
inline const std::string& MsgSetPayees::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void MsgSetPayees::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSetPayees::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSetPayees::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgSetPayees.feed_id)
  return _impl_.feed_id_.Release();
}
inline void MsgSetPayees::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgSetPayees.feed_id)
}

// repeated string transmitters = 3 [json_name = "transmitters"];
inline int MsgSetPayees::_internal_transmitters_size() const {
  return _impl_.transmitters_.size();
}
inline int MsgSetPayees::transmitters_size() const {
  return _internal_transmitters_size();
}
inline void MsgSetPayees::clear_transmitters() {
  _internal_mutable_transmitters()->Clear();
}
inline std::string* MsgSetPayees::add_transmitters() {
  std::string* _s = _internal_add_transmitters();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.MsgSetPayees.transmitters)
  return _s;
}
inline const std::string& MsgSetPayees::transmitters(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgSetPayees.transmitters)
  return _internal_transmitters(index);
}
inline std::string* MsgSetPayees::mutable_transmitters(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgSetPayees.transmitters)
  return _internal_mutable_transmitters()->Mutable(index);
}
inline void MsgSetPayees::set_transmitters(int index, const std::string& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::set_transmitters(int index, std::string&& value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::set_transmitters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::set_transmitters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transmitters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::set_transmitters(int index, absl::string_view value) {
  _internal_mutable_transmitters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::add_transmitters(const std::string& value) {
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::add_transmitters(std::string&& value) {
  _internal_mutable_transmitters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::add_transmitters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transmitters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::add_transmitters(const char* value, std::size_t size) {
  _internal_mutable_transmitters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline void MsgSetPayees::add_transmitters(absl::string_view value) {
  _internal_mutable_transmitters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.MsgSetPayees.transmitters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgSetPayees::transmitters() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.MsgSetPayees.transmitters)
  return _internal_transmitters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgSetPayees::mutable_transmitters() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.MsgSetPayees.transmitters)
  return _internal_mutable_transmitters();
}
inline const std::string& MsgSetPayees::_internal_transmitters(int index) const {
  return _internal_transmitters().Get(index);
}
inline std::string* MsgSetPayees::_internal_add_transmitters() {
  return _internal_mutable_transmitters()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgSetPayees::_internal_transmitters() const {
  return _impl_.transmitters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgSetPayees::_internal_mutable_transmitters() {
  return &_impl_.transmitters_;
}

// repeated string payees = 4 [json_name = "payees"];
inline int MsgSetPayees::_internal_payees_size() const {
  return _impl_.payees_.size();
}
inline int MsgSetPayees::payees_size() const {
  return _internal_payees_size();
}
inline void MsgSetPayees::clear_payees() {
  _internal_mutable_payees()->Clear();
}
inline std::string* MsgSetPayees::add_payees() {
  std::string* _s = _internal_add_payees();
  // @@protoc_insertion_point(field_add_mutable:injective.ocr.v1beta1.MsgSetPayees.payees)
  return _s;
}
inline const std::string& MsgSetPayees::payees(int index) const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgSetPayees.payees)
  return _internal_payees(index);
}
inline std::string* MsgSetPayees::mutable_payees(int index) {
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgSetPayees.payees)
  return _internal_mutable_payees()->Mutable(index);
}
inline void MsgSetPayees::set_payees(int index, const std::string& value) {
  _internal_mutable_payees()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::set_payees(int index, std::string&& value) {
  _internal_mutable_payees()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::set_payees(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_payees()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::set_payees(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_payees()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::set_payees(int index, absl::string_view value) {
  _internal_mutable_payees()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::add_payees(const std::string& value) {
  _internal_mutable_payees()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::add_payees(std::string&& value) {
  _internal_mutable_payees()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::add_payees(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_payees()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::add_payees(const char* value, std::size_t size) {
  _internal_mutable_payees()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline void MsgSetPayees::add_payees(absl::string_view value) {
  _internal_mutable_payees()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.ocr.v1beta1.MsgSetPayees.payees)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgSetPayees::payees() const {
  // @@protoc_insertion_point(field_list:injective.ocr.v1beta1.MsgSetPayees.payees)
  return _internal_payees();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgSetPayees::mutable_payees() {
  // @@protoc_insertion_point(field_mutable_list:injective.ocr.v1beta1.MsgSetPayees.payees)
  return _internal_mutable_payees();
}
inline const std::string& MsgSetPayees::_internal_payees(int index) const {
  return _internal_payees().Get(index);
}
inline std::string* MsgSetPayees::_internal_add_payees() {
  return _internal_mutable_payees()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgSetPayees::_internal_payees() const {
  return _impl_.payees_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgSetPayees::_internal_mutable_payees() {
  return &_impl_.payees_;
}

// -------------------------------------------------------------------

// MsgSetPayeesResponse

// -------------------------------------------------------------------

// MsgTransferPayeeship

// string sender = 1 [json_name = "sender"];
inline void MsgTransferPayeeship::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgTransferPayeeship::sender() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransferPayeeship.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTransferPayeeship::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransferPayeeship.sender)
}
inline std::string* MsgTransferPayeeship::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransferPayeeship.sender)
  return _s;
}
inline const std::string& MsgTransferPayeeship::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgTransferPayeeship::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTransferPayeeship::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTransferPayeeship::release_sender() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransferPayeeship.sender)
  return _impl_.sender_.Release();
}
inline void MsgTransferPayeeship::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransferPayeeship.sender)
}

// string transmitter = 2 [json_name = "transmitter"];
inline void MsgTransferPayeeship::clear_transmitter() {
  _impl_.transmitter_.ClearToEmpty();
}
inline const std::string& MsgTransferPayeeship::transmitter() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransferPayeeship.transmitter)
  return _internal_transmitter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTransferPayeeship::set_transmitter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.transmitter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransferPayeeship.transmitter)
}
inline std::string* MsgTransferPayeeship::mutable_transmitter() {
  std::string* _s = _internal_mutable_transmitter();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransferPayeeship.transmitter)
  return _s;
}
inline const std::string& MsgTransferPayeeship::_internal_transmitter() const {
  return _impl_.transmitter_.Get();
}
inline void MsgTransferPayeeship::_internal_set_transmitter(const std::string& value) {
  ;


  _impl_.transmitter_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTransferPayeeship::_internal_mutable_transmitter() {
  ;
  return _impl_.transmitter_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTransferPayeeship::release_transmitter() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransferPayeeship.transmitter)
  return _impl_.transmitter_.Release();
}
inline void MsgTransferPayeeship::set_allocated_transmitter(std::string* value) {
  _impl_.transmitter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmitter_.IsDefault()) {
          _impl_.transmitter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransferPayeeship.transmitter)
}

// string feed_id = 3 [json_name = "feedId"];
inline void MsgTransferPayeeship::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& MsgTransferPayeeship::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransferPayeeship.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTransferPayeeship::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransferPayeeship.feed_id)
}
inline std::string* MsgTransferPayeeship::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransferPayeeship.feed_id)
  return _s;
}
inline const std::string& MsgTransferPayeeship::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void MsgTransferPayeeship::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTransferPayeeship::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTransferPayeeship::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransferPayeeship.feed_id)
  return _impl_.feed_id_.Release();
}
inline void MsgTransferPayeeship::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransferPayeeship.feed_id)
}

// string proposed = 4 [json_name = "proposed"];
inline void MsgTransferPayeeship::clear_proposed() {
  _impl_.proposed_.ClearToEmpty();
}
inline const std::string& MsgTransferPayeeship::proposed() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgTransferPayeeship.proposed)
  return _internal_proposed();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTransferPayeeship::set_proposed(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proposed_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgTransferPayeeship.proposed)
}
inline std::string* MsgTransferPayeeship::mutable_proposed() {
  std::string* _s = _internal_mutable_proposed();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgTransferPayeeship.proposed)
  return _s;
}
inline const std::string& MsgTransferPayeeship::_internal_proposed() const {
  return _impl_.proposed_.Get();
}
inline void MsgTransferPayeeship::_internal_set_proposed(const std::string& value) {
  ;


  _impl_.proposed_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTransferPayeeship::_internal_mutable_proposed() {
  ;
  return _impl_.proposed_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTransferPayeeship::release_proposed() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgTransferPayeeship.proposed)
  return _impl_.proposed_.Release();
}
inline void MsgTransferPayeeship::set_allocated_proposed(std::string* value) {
  _impl_.proposed_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proposed_.IsDefault()) {
          _impl_.proposed_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgTransferPayeeship.proposed)
}

// -------------------------------------------------------------------

// MsgTransferPayeeshipResponse

// -------------------------------------------------------------------

// MsgAcceptPayeeship

// string payee = 1 [json_name = "payee"];
inline void MsgAcceptPayeeship::clear_payee() {
  _impl_.payee_.ClearToEmpty();
}
inline const std::string& MsgAcceptPayeeship::payee() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgAcceptPayeeship.payee)
  return _internal_payee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAcceptPayeeship::set_payee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgAcceptPayeeship.payee)
}
inline std::string* MsgAcceptPayeeship::mutable_payee() {
  std::string* _s = _internal_mutable_payee();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgAcceptPayeeship.payee)
  return _s;
}
inline const std::string& MsgAcceptPayeeship::_internal_payee() const {
  return _impl_.payee_.Get();
}
inline void MsgAcceptPayeeship::_internal_set_payee(const std::string& value) {
  ;


  _impl_.payee_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAcceptPayeeship::_internal_mutable_payee() {
  ;
  return _impl_.payee_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAcceptPayeeship::release_payee() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgAcceptPayeeship.payee)
  return _impl_.payee_.Release();
}
inline void MsgAcceptPayeeship::set_allocated_payee(std::string* value) {
  _impl_.payee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payee_.IsDefault()) {
          _impl_.payee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgAcceptPayeeship.payee)
}

// string transmitter = 2 [json_name = "transmitter"];
inline void MsgAcceptPayeeship::clear_transmitter() {
  _impl_.transmitter_.ClearToEmpty();
}
inline const std::string& MsgAcceptPayeeship::transmitter() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgAcceptPayeeship.transmitter)
  return _internal_transmitter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAcceptPayeeship::set_transmitter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.transmitter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgAcceptPayeeship.transmitter)
}
inline std::string* MsgAcceptPayeeship::mutable_transmitter() {
  std::string* _s = _internal_mutable_transmitter();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgAcceptPayeeship.transmitter)
  return _s;
}
inline const std::string& MsgAcceptPayeeship::_internal_transmitter() const {
  return _impl_.transmitter_.Get();
}
inline void MsgAcceptPayeeship::_internal_set_transmitter(const std::string& value) {
  ;


  _impl_.transmitter_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAcceptPayeeship::_internal_mutable_transmitter() {
  ;
  return _impl_.transmitter_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAcceptPayeeship::release_transmitter() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgAcceptPayeeship.transmitter)
  return _impl_.transmitter_.Release();
}
inline void MsgAcceptPayeeship::set_allocated_transmitter(std::string* value) {
  _impl_.transmitter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmitter_.IsDefault()) {
          _impl_.transmitter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgAcceptPayeeship.transmitter)
}

// string feed_id = 3 [json_name = "feedId"];
inline void MsgAcceptPayeeship::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& MsgAcceptPayeeship::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgAcceptPayeeship.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAcceptPayeeship::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgAcceptPayeeship.feed_id)
}
inline std::string* MsgAcceptPayeeship::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgAcceptPayeeship.feed_id)
  return _s;
}
inline const std::string& MsgAcceptPayeeship::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void MsgAcceptPayeeship::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAcceptPayeeship::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAcceptPayeeship::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgAcceptPayeeship.feed_id)
  return _impl_.feed_id_.Release();
}
inline void MsgAcceptPayeeship::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgAcceptPayeeship.feed_id)
}

// -------------------------------------------------------------------

// MsgAcceptPayeeshipResponse

// -------------------------------------------------------------------

// MsgUpdateParams

// string authority = 1 [json_name = "authority", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void MsgUpdateParams::clear_authority() {
  _impl_.authority_.ClearToEmpty();
}
inline const std::string& MsgUpdateParams::authority() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateParams.authority)
  return _internal_authority();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateParams::set_authority(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.authority_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.ocr.v1beta1.MsgUpdateParams.authority)
}
inline std::string* MsgUpdateParams::mutable_authority() {
  std::string* _s = _internal_mutable_authority();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateParams.authority)
  return _s;
}
inline const std::string& MsgUpdateParams::_internal_authority() const {
  return _impl_.authority_.Get();
}
inline void MsgUpdateParams::_internal_set_authority(const std::string& value) {
  ;


  _impl_.authority_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateParams::_internal_mutable_authority() {
  ;
  return _impl_.authority_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateParams::release_authority() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateParams.authority)
  return _impl_.authority_.Release();
}
inline void MsgUpdateParams::set_allocated_authority(std::string* value) {
  _impl_.authority_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.authority_.IsDefault()) {
          _impl_.authority_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateParams.authority)
}

// .injective.ocr.v1beta1.Params params = 2 [json_name = "params", (.gogoproto.nullable) = false];
inline bool MsgUpdateParams::has_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline const ::injective::ocr::v1beta1::Params& MsgUpdateParams::_internal_params() const {
  const ::injective::ocr::v1beta1::Params* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::ocr::v1beta1::Params&>(
      ::injective::ocr::v1beta1::_Params_default_instance_);
}
inline const ::injective::ocr::v1beta1::Params& MsgUpdateParams::params() const {
  // @@protoc_insertion_point(field_get:injective.ocr.v1beta1.MsgUpdateParams.params)
  return _internal_params();
}
inline void MsgUpdateParams::unsafe_arena_set_allocated_params(
    ::injective::ocr::v1beta1::Params* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.ocr.v1beta1.MsgUpdateParams.params)
}
inline ::injective::ocr::v1beta1::Params* MsgUpdateParams::release_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::ocr::v1beta1::Params* MsgUpdateParams::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:injective.ocr.v1beta1.MsgUpdateParams.params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::ocr::v1beta1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::injective::ocr::v1beta1::Params* MsgUpdateParams::_internal_mutable_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::ocr::v1beta1::Params>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::injective::ocr::v1beta1::Params* MsgUpdateParams::mutable_params() {
  ::injective::ocr::v1beta1::Params* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:injective.ocr.v1beta1.MsgUpdateParams.params)
  return _msg;
}
inline void MsgUpdateParams::set_allocated_params(::injective::ocr::v1beta1::Params* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:injective.ocr.v1beta1.MsgUpdateParams.params)
}

// -------------------------------------------------------------------

// MsgUpdateParamsResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace ocr
}  // namespace injective


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2focr_2fv1beta1_2ftx_2eproto_2epb_2eh
