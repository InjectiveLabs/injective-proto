// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/ocr/v1beta1/ocr.proto

#include "injective/ocr/v1beta1/ocr.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace injective {
namespace ocr {
namespace v1beta1 {
template <typename>
PROTOBUF_CONSTEXPR Params::Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.link_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.module_admin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.payout_block_interval_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParamsDefaultTypeInternal() {}
  union {
    Params _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParamsDefaultTypeInternal _Params_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeedConfig::FeedConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signers_)*/{}
  , /*decltype(_impl_.transmitters_)*/{}
  , /*decltype(_impl_.onchain_config_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.offchain_config_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.module_params_)*/nullptr
  , /*decltype(_impl_.offchain_config_version_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.f_)*/ 0u
} {}
struct FeedConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeedConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeedConfigDefaultTypeInternal() {}
  union {
    FeedConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeedConfigDefaultTypeInternal _FeedConfig_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeedConfigInfo::FeedConfigInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.latest_config_digest_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.f_)*/ 0u

  , /*decltype(_impl_.n_)*/ 0u

  , /*decltype(_impl_.config_count_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.latest_config_block_number_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeedConfigInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeedConfigInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeedConfigInfoDefaultTypeInternal() {}
  union {
    FeedConfigInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeedConfigInfoDefaultTypeInternal _FeedConfigInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ModuleParams::ModuleParams(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.feed_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_answer_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.max_answer_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.link_per_observation_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.link_per_transmission_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.link_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.description_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.feed_admin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.billing_admin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.unique_reports_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleParamsDefaultTypeInternal() {}
  union {
    ModuleParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleParamsDefaultTypeInternal _ModuleParams_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ContractConfig::ContractConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signers_)*/{}
  , /*decltype(_impl_.transmitters_)*/{}
  , /*decltype(_impl_.onchain_config_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.offchain_config_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.config_count_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.offchain_config_version_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.f_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContractConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractConfigDefaultTypeInternal() {}
  union {
    ContractConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractConfigDefaultTypeInternal _ContractConfig_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetConfigProposal::SetConfigProposal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.title_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.description_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.config_)*/nullptr} {}
struct SetConfigProposalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetConfigProposalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetConfigProposalDefaultTypeInternal() {}
  union {
    SetConfigProposal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetConfigProposalDefaultTypeInternal _SetConfigProposal_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeedProperties::FeedProperties(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.feed_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.onchain_config_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.offchain_config_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_answer_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.max_answer_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.link_per_observation_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.link_per_transmission_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.description_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.offchain_config_version_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.f_)*/ 0u

  , /*decltype(_impl_.unique_reports_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeedPropertiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeedPropertiesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeedPropertiesDefaultTypeInternal() {}
  union {
    FeedProperties _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeedPropertiesDefaultTypeInternal _FeedProperties_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetBatchConfigProposal::SetBatchConfigProposal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signers_)*/{}
  , /*decltype(_impl_.transmitters_)*/{}
  , /*decltype(_impl_.feed_properties_)*/{}
  , /*decltype(_impl_.title_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.description_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.link_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetBatchConfigProposalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetBatchConfigProposalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetBatchConfigProposalDefaultTypeInternal() {}
  union {
    SetBatchConfigProposal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetBatchConfigProposalDefaultTypeInternal _SetBatchConfigProposal_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OracleObservationsCounts::OracleObservationsCounts(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.counts_)*/ {}
  ,/* _impl_._counts_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OracleObservationsCountsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OracleObservationsCountsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OracleObservationsCountsDefaultTypeInternal() {}
  union {
    OracleObservationsCounts _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OracleObservationsCountsDefaultTypeInternal _OracleObservationsCounts_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GasReimbursements::GasReimbursements(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.reimbursements_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GasReimbursementsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GasReimbursementsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GasReimbursementsDefaultTypeInternal() {}
  union {
    GasReimbursements _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GasReimbursementsDefaultTypeInternal _GasReimbursements_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Payee::Payee(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transmitter_addr_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.payment_addr_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PayeeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PayeeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PayeeDefaultTypeInternal() {}
  union {
    Payee _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PayeeDefaultTypeInternal _Payee_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Transmission::Transmission(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.answer_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.observations_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.transmission_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransmissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransmissionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransmissionDefaultTypeInternal() {}
  union {
    Transmission _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransmissionDefaultTypeInternal _Transmission_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EpochAndRound::EpochAndRound(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.epoch_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.round_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EpochAndRoundDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EpochAndRoundDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EpochAndRoundDefaultTypeInternal() {}
  union {
    EpochAndRound _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EpochAndRoundDefaultTypeInternal _EpochAndRound_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Report::Report(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.observations_)*/{}
  , /*decltype(_impl_.observers_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.observations_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReportDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReportDefaultTypeInternal() {}
  union {
    Report _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReportDefaultTypeInternal _Report_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ReportToSign::ReportToSign(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.config_digest_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.extra_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.report_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.epoch_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.round_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReportToSignDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReportToSignDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReportToSignDefaultTypeInternal() {}
  union {
    ReportToSign _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReportToSignDefaultTypeInternal _ReportToSign_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventOraclePaid::EventOraclePaid(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transmitter_addr_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.payee_addr_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.amount_)*/nullptr} {}
struct EventOraclePaidDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventOraclePaidDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventOraclePaidDefaultTypeInternal() {}
  union {
    EventOraclePaid _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventOraclePaidDefaultTypeInternal _EventOraclePaid_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventAnswerUpdated::EventAnswerUpdated(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.current_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.round_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.updated_at_)*/nullptr} {}
struct EventAnswerUpdatedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventAnswerUpdatedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventAnswerUpdatedDefaultTypeInternal() {}
  union {
    EventAnswerUpdated _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventAnswerUpdatedDefaultTypeInternal _EventAnswerUpdated_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventNewRound::EventNewRound(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.round_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.started_by_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.started_at_)*/nullptr} {}
struct EventNewRoundDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventNewRoundDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventNewRoundDefaultTypeInternal() {}
  union {
    EventNewRound _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventNewRoundDefaultTypeInternal _EventNewRound_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventTransmitted::EventTransmitted(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.config_digest_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.epoch_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventTransmittedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventTransmittedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventTransmittedDefaultTypeInternal() {}
  union {
    EventTransmitted _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventTransmittedDefaultTypeInternal _EventTransmitted_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventNewTransmission::EventNewTransmission(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.observations_)*/{}
  , /*decltype(_impl_.feed_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.answer_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.transmitter_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.observers_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.config_digest_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.epoch_and_round_)*/nullptr
  , /*decltype(_impl_.observations_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.aggregator_round_id_)*/ 0u
} {}
struct EventNewTransmissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventNewTransmissionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventNewTransmissionDefaultTypeInternal() {}
  union {
    EventNewTransmission _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventNewTransmissionDefaultTypeInternal _EventNewTransmission_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventConfigSet::EventConfigSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.config_digest_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.config_)*/nullptr
  , /*decltype(_impl_.config_info_)*/nullptr
  , /*decltype(_impl_.previous_config_block_number_)*/ ::int64_t{0}
} {}
struct EventConfigSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventConfigSetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventConfigSetDefaultTypeInternal() {}
  union {
    EventConfigSet _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventConfigSetDefaultTypeInternal _EventConfigSet_default_instance_;
}  // namespace v1beta1
}  // namespace ocr
}  // namespace injective
static ::_pb::Metadata file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[21];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_injective_2focr_2fv1beta1_2focr_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_injective_2focr_2fv1beta1_2focr_2eproto = nullptr;
const ::uint32_t TableStruct_injective_2focr_2fv1beta1_2focr_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Params, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Params, _impl_.link_denom_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Params, _impl_.payout_block_interval_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Params, _impl_.module_admin_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _impl_.signers_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _impl_.transmitters_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _impl_.f_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _impl_.onchain_config_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _impl_.offchain_config_version_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _impl_.offchain_config_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfig, _impl_.module_params_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfigInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfigInfo, _impl_.latest_config_digest_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfigInfo, _impl_.f_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfigInfo, _impl_.n_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfigInfo, _impl_.config_count_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedConfigInfo, _impl_.latest_config_block_number_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.feed_id_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.min_answer_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.max_answer_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.link_per_observation_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.link_per_transmission_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.link_denom_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.unique_reports_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.feed_admin_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ModuleParams, _impl_.billing_admin_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ContractConfig, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ContractConfig, _impl_.config_count_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ContractConfig, _impl_.signers_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ContractConfig, _impl_.transmitters_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ContractConfig, _impl_.f_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ContractConfig, _impl_.onchain_config_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ContractConfig, _impl_.offchain_config_version_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ContractConfig, _impl_.offchain_config_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetConfigProposal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetConfigProposal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetConfigProposal, _impl_.title_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetConfigProposal, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetConfigProposal, _impl_.config_),
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.feed_id_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.f_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.onchain_config_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.offchain_config_version_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.offchain_config_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.min_answer_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.max_answer_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.link_per_observation_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.link_per_transmission_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.unique_reports_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::FeedProperties, _impl_.description_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetBatchConfigProposal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetBatchConfigProposal, _impl_.title_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetBatchConfigProposal, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetBatchConfigProposal, _impl_.signers_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetBatchConfigProposal, _impl_.transmitters_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetBatchConfigProposal, _impl_.link_denom_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::SetBatchConfigProposal, _impl_.feed_properties_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::OracleObservationsCounts, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::OracleObservationsCounts, _impl_.counts_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::GasReimbursements, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::GasReimbursements, _impl_.reimbursements_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Payee, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Payee, _impl_.transmitter_addr_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Payee, _impl_.payment_addr_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Transmission, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Transmission, _impl_.answer_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Transmission, _impl_.observations_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Transmission, _impl_.transmission_timestamp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EpochAndRound, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EpochAndRound, _impl_.epoch_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EpochAndRound, _impl_.round_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Report, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Report, _impl_.observations_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Report, _impl_.observers_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::Report, _impl_.observations_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ReportToSign, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ReportToSign, _impl_.config_digest_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ReportToSign, _impl_.epoch_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ReportToSign, _impl_.round_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ReportToSign, _impl_.extra_hash_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::ReportToSign, _impl_.report_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventOraclePaid, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventOraclePaid, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventOraclePaid, _impl_.transmitter_addr_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventOraclePaid, _impl_.payee_addr_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventOraclePaid, _impl_.amount_),
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventAnswerUpdated, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventAnswerUpdated, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventAnswerUpdated, _impl_.current_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventAnswerUpdated, _impl_.round_id_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventAnswerUpdated, _impl_.updated_at_),
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewRound, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewRound, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewRound, _impl_.round_id_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewRound, _impl_.started_by_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewRound, _impl_.started_at_),
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventTransmitted, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventTransmitted, _impl_.config_digest_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventTransmitted, _impl_.epoch_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.feed_id_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.aggregator_round_id_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.answer_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.transmitter_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.observations_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.observations_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.observers_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.config_digest_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventNewTransmission, _impl_.epoch_and_round_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventConfigSet, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventConfigSet, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventConfigSet, _impl_.config_digest_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventConfigSet, _impl_.previous_config_block_number_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventConfigSet, _impl_.config_),
    PROTOBUF_FIELD_OFFSET(::injective::ocr::v1beta1::EventConfigSet, _impl_.config_info_),
    ~0u,
    ~0u,
    0,
    1,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::injective::ocr::v1beta1::Params)},
        { 11, 26, -1, sizeof(::injective::ocr::v1beta1::FeedConfig)},
        { 33, -1, -1, sizeof(::injective::ocr::v1beta1::FeedConfigInfo)},
        { 46, -1, -1, sizeof(::injective::ocr::v1beta1::ModuleParams)},
        { 64, -1, -1, sizeof(::injective::ocr::v1beta1::ContractConfig)},
        { 79, 90, -1, sizeof(::injective::ocr::v1beta1::SetConfigProposal)},
        { 93, -1, -1, sizeof(::injective::ocr::v1beta1::FeedProperties)},
        { 112, -1, -1, sizeof(::injective::ocr::v1beta1::SetBatchConfigProposal)},
        { 126, -1, -1, sizeof(::injective::ocr::v1beta1::OracleObservationsCounts)},
        { 135, -1, -1, sizeof(::injective::ocr::v1beta1::GasReimbursements)},
        { 144, -1, -1, sizeof(::injective::ocr::v1beta1::Payee)},
        { 154, -1, -1, sizeof(::injective::ocr::v1beta1::Transmission)},
        { 165, -1, -1, sizeof(::injective::ocr::v1beta1::EpochAndRound)},
        { 175, -1, -1, sizeof(::injective::ocr::v1beta1::Report)},
        { 186, -1, -1, sizeof(::injective::ocr::v1beta1::ReportToSign)},
        { 199, 210, -1, sizeof(::injective::ocr::v1beta1::EventOraclePaid)},
        { 213, 224, -1, sizeof(::injective::ocr::v1beta1::EventAnswerUpdated)},
        { 227, 238, -1, sizeof(::injective::ocr::v1beta1::EventNewRound)},
        { 241, -1, -1, sizeof(::injective::ocr::v1beta1::EventTransmitted)},
        { 251, 268, -1, sizeof(::injective::ocr::v1beta1::EventNewTransmission)},
        { 277, 289, -1, sizeof(::injective::ocr::v1beta1::EventConfigSet)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::injective::ocr::v1beta1::_Params_default_instance_._instance,
    &::injective::ocr::v1beta1::_FeedConfig_default_instance_._instance,
    &::injective::ocr::v1beta1::_FeedConfigInfo_default_instance_._instance,
    &::injective::ocr::v1beta1::_ModuleParams_default_instance_._instance,
    &::injective::ocr::v1beta1::_ContractConfig_default_instance_._instance,
    &::injective::ocr::v1beta1::_SetConfigProposal_default_instance_._instance,
    &::injective::ocr::v1beta1::_FeedProperties_default_instance_._instance,
    &::injective::ocr::v1beta1::_SetBatchConfigProposal_default_instance_._instance,
    &::injective::ocr::v1beta1::_OracleObservationsCounts_default_instance_._instance,
    &::injective::ocr::v1beta1::_GasReimbursements_default_instance_._instance,
    &::injective::ocr::v1beta1::_Payee_default_instance_._instance,
    &::injective::ocr::v1beta1::_Transmission_default_instance_._instance,
    &::injective::ocr::v1beta1::_EpochAndRound_default_instance_._instance,
    &::injective::ocr::v1beta1::_Report_default_instance_._instance,
    &::injective::ocr::v1beta1::_ReportToSign_default_instance_._instance,
    &::injective::ocr::v1beta1::_EventOraclePaid_default_instance_._instance,
    &::injective::ocr::v1beta1::_EventAnswerUpdated_default_instance_._instance,
    &::injective::ocr::v1beta1::_EventNewRound_default_instance_._instance,
    &::injective::ocr::v1beta1::_EventTransmitted_default_instance_._instance,
    &::injective::ocr::v1beta1::_EventNewTransmission_default_instance_._instance,
    &::injective::ocr::v1beta1::_EventConfigSet_default_instance_._instance,
};
const char descriptor_table_protodef_injective_2focr_2fv1beta1_2focr_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\037injective/ocr/v1beta1/ocr.proto\022\025injec"
    "tive.ocr.v1beta1\032\036cosmos/base/v1beta1/co"
    "in.proto\032\031cosmos_proto/cosmos.proto\032\024gog"
    "oproto/gogo.proto\032\037google/protobuf/times"
    "tamp.proto\"\204\001\n\006Params\022\035\n\nlink_denom\030\001 \001("
    "\tR\tlinkDenom\0222\n\025payout_block_interval\030\002 "
    "\001(\004R\023payoutBlockInterval\022!\n\014module_admin"
    "\030\003 \001(\tR\013moduleAdmin:\004\350\240\037\001\"\252\002\n\nFeedConfig"
    "\022\030\n\007signers\030\001 \003(\tR\007signers\022\"\n\014transmitte"
    "rs\030\002 \003(\tR\014transmitters\022\014\n\001f\030\003 \001(\rR\001f\022%\n\016"
    "onchain_config\030\004 \001(\014R\ronchainConfig\0226\n\027o"
    "ffchain_config_version\030\005 \001(\004R\025offchainCo"
    "nfigVersion\022\'\n\017offchain_config\030\006 \001(\014R\016of"
    "fchainConfig\022H\n\rmodule_params\030\007 \001(\0132#.in"
    "jective.ocr.v1beta1.ModuleParamsR\014module"
    "Params\"\276\001\n\016FeedConfigInfo\0220\n\024latest_conf"
    "ig_digest\030\001 \001(\014R\022latestConfigDigest\022\014\n\001f"
    "\030\002 \001(\rR\001f\022\014\n\001n\030\003 \001(\rR\001n\022!\n\014config_count\030"
    "\004 \001(\004R\013configCount\022;\n\032latest_config_bloc"
    "k_number\030\005 \001(\003R\027latestConfigBlockNumber\""
    "\267\004\n\014ModuleParams\022\027\n\007feed_id\030\001 \001(\tR\006feedI"
    "d\022M\n\nmin_answer\030\002 \001(\tB.\310\336\037\000\332\336\037&github.co"
    "m/cosmos/cosmos-sdk/types.DecR\tminAnswer"
    "\022M\n\nmax_answer\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com"
    "/cosmos/cosmos-sdk/types.DecR\tmaxAnswer\022"
    "`\n\024link_per_observation\030\004 \001(\tB.\310\336\037\000\332\336\037&g"
    "ithub.com/cosmos/cosmos-sdk/types.IntR\022l"
    "inkPerObservation\022b\n\025link_per_transmissi"
    "on\030\005 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosm"
    "os-sdk/types.IntR\023linkPerTransmission\022\035\n"
    "\nlink_denom\030\006 \001(\tR\tlinkDenom\022%\n\016unique_r"
    "eports\030\007 \001(\010R\runiqueReports\022 \n\013descripti"
    "on\030\010 \001(\tR\013description\022\035\n\nfeed_admin\030\t \001("
    "\tR\tfeedAdmin\022#\n\rbilling_admin\030\n \001(\tR\014bil"
    "lingAdmin\"\207\002\n\016ContractConfig\022!\n\014config_c"
    "ount\030\001 \001(\004R\013configCount\022\030\n\007signers\030\002 \003(\t"
    "R\007signers\022\"\n\014transmitters\030\003 \003(\tR\014transmi"
    "tters\022\014\n\001f\030\004 \001(\rR\001f\022%\n\016onchain_config\030\005 "
    "\001(\014R\ronchainConfig\0226\n\027offchain_config_ve"
    "rsion\030\006 \001(\004R\025offchainConfigVersion\022\'\n\017of"
    "fchain_config\030\007 \001(\014R\016offchainConfig\"\256\001\n\021"
    "SetConfigProposal\022\024\n\005title\030\001 \001(\tR\005title\022"
    " \n\013description\030\002 \001(\tR\013description\0229\n\006con"
    "fig\030\003 \001(\0132!.injective.ocr.v1beta1.FeedCo"
    "nfigR\006config:&\210\240\037\000\350\240\037\000\312\264-\032cosmos.gov.v1b"
    "eta1.Content\"\354\004\n\016FeedProperties\022\027\n\007feed_"
    "id\030\001 \001(\tR\006feedId\022\014\n\001f\030\002 \001(\rR\001f\022%\n\016onchai"
    "n_config\030\003 \001(\014R\ronchainConfig\0226\n\027offchai"
    "n_config_version\030\004 \001(\004R\025offchainConfigVe"
    "rsion\022\'\n\017offchain_config\030\005 \001(\014R\016offchain"
    "Config\022M\n\nmin_answer\030\006 \001(\tB.\310\336\037\000\332\336\037&gith"
    "ub.com/cosmos/cosmos-sdk/types.DecR\tminA"
    "nswer\022M\n\nmax_answer\030\007 \001(\tB.\310\336\037\000\332\336\037&githu"
    "b.com/cosmos/cosmos-sdk/types.DecR\tmaxAn"
    "swer\022`\n\024link_per_observation\030\010 \001(\tB.\310\336\037\000"
    "\332\336\037&github.com/cosmos/cosmos-sdk/types.I"
    "ntR\022linkPerObservation\022b\n\025link_per_trans"
    "mission\030\t \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos"
    "/cosmos-sdk/types.IntR\023linkPerTransmissi"
    "on\022%\n\016unique_reports\030\n \001(\010R\runiqueReport"
    "s\022 \n\013description\030\013 \001(\tR\013description\"\245\002\n\026"
    "SetBatchConfigProposal\022\024\n\005title\030\001 \001(\tR\005t"
    "itle\022 \n\013description\030\002 \001(\tR\013description\022\030"
    "\n\007signers\030\003 \003(\tR\007signers\022\"\n\014transmitters"
    "\030\004 \003(\tR\014transmitters\022\035\n\nlink_denom\030\005 \001(\t"
    "R\tlinkDenom\022N\n\017feed_properties\030\006 \003(\0132%.i"
    "njective.ocr.v1beta1.FeedPropertiesR\016fee"
    "dProperties:&\210\240\037\000\350\240\037\000\312\264-\032cosmos.gov.v1be"
    "ta1.Content\"2\n\030OracleObservationsCounts\022"
    "\026\n\006counts\030\001 \003(\rR\006counts\"V\n\021GasReimbursem"
    "ents\022A\n\016reimbursements\030\001 \003(\0132\031.cosmos.ba"
    "se.v1beta1.CoinR\016reimbursements\"U\n\005Payee"
    "\022)\n\020transmitter_addr\030\001 \001(\tR\017transmitterA"
    "ddr\022!\n\014payment_addr\030\002 \001(\tR\013paymentAddr\"\304"
    "\001\n\014Transmission\022F\n\006answer\030\001 \001(\tB.\310\336\037\000\332\336\037"
    "&github.com/cosmos/cosmos-sdk/types.DecR"
    "\006answer\0225\n\026observations_timestamp\030\002 \001(\003R"
    "\025observationsTimestamp\0225\n\026transmission_t"
    "imestamp\030\003 \001(\003R\025transmissionTimestamp\";\n"
    "\rEpochAndRound\022\024\n\005epoch\030\001 \001(\004R\005epoch\022\024\n\005"
    "round\030\002 \001(\004R\005round\"\261\001\n\006Report\0225\n\026observa"
    "tions_timestamp\030\001 \001(\003R\025observationsTimes"
    "tamp\022\034\n\tobservers\030\002 \001(\014R\tobservers\022R\n\014ob"
    "servations\030\003 \003(\tB.\310\336\037\000\332\336\037&github.com/cos"
    "mos/cosmos-sdk/types.DecR\014observations\"\226"
    "\001\n\014ReportToSign\022#\n\rconfig_digest\030\001 \001(\014R\014"
    "configDigest\022\024\n\005epoch\030\002 \001(\004R\005epoch\022\024\n\005ro"
    "und\030\003 \001(\004R\005round\022\035\n\nextra_hash\030\004 \001(\014R\tex"
    "traHash\022\026\n\006report\030\005 \001(\014R\006report\"\224\001\n\017Even"
    "tOraclePaid\022)\n\020transmitter_addr\030\001 \001(\tR\017t"
    "ransmitterAddr\022\035\n\npayee_addr\030\002 \001(\tR\tpaye"
    "eAddr\0227\n\006amount\030\003 \001(\0132\031.cosmos.base.v1be"
    "ta1.CoinB\004\310\336\037\000R\006amount\"\356\001\n\022EventAnswerUp"
    "dated\022H\n\007current\030\001 \001(\tB.\310\336\037\000\332\336\037&github.c"
    "om/cosmos/cosmos-sdk/types.IntR\007current\022"
    "I\n\010round_id\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/co"
    "smos/cosmos-sdk/types.IntR\007roundId\022C\n\nup"
    "dated_at\030\003 \001(\0132\032.google.protobuf.Timesta"
    "mpB\010\310\336\037\000\220\337\037\001R\tupdatedAt\"\276\001\n\rEventNewRoun"
    "d\022I\n\010round_id\030\001 \001(\tB.\310\336\037\000\332\336\037&github.com/"
    "cosmos/cosmos-sdk/types.IntR\007roundId\022\035\n\n"
    "started_by\030\002 \001(\tR\tstartedBy\022C\n\nstarted_a"
    "t\030\003 \001(\0132\032.google.protobuf.TimestampB\010\310\336\037"
    "\000\220\337\037\001R\tstartedAt\"M\n\020EventTransmitted\022#\n\r"
    "config_digest\030\001 \001(\014R\014configDigest\022\024\n\005epo"
    "ch\030\002 \001(\004R\005epoch\"\345\003\n\024EventNewTransmission"
    "\022\027\n\007feed_id\030\001 \001(\tR\006feedId\022.\n\023aggregator_"
    "round_id\030\002 \001(\rR\021aggregatorRoundId\022F\n\006ans"
    "wer\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cos"
    "mos-sdk/types.DecR\006answer\022 \n\013transmitter"
    "\030\004 \001(\tR\013transmitter\0225\n\026observations_time"
    "stamp\030\005 \001(\003R\025observationsTimestamp\022R\n\014ob"
    "servations\030\006 \003(\tB.\310\336\037\000\332\336\037&github.com/cos"
    "mos/cosmos-sdk/types.DecR\014observations\022\034"
    "\n\tobservers\030\007 \001(\014R\tobservers\022#\n\rconfig_d"
    "igest\030\010 \001(\014R\014configDigest\022L\n\017epoch_and_r"
    "ound\030\t \001(\0132$.injective.ocr.v1beta1.Epoch"
    "AndRoundR\repochAndRound\"\371\001\n\016EventConfigS"
    "et\022#\n\rconfig_digest\030\001 \001(\014R\014configDigest\022"
    "\?\n\034previous_config_block_number\030\002 \001(\003R\031p"
    "reviousConfigBlockNumber\0229\n\006config\030\003 \001(\013"
    "2!.injective.ocr.v1beta1.FeedConfigR\006con"
    "fig\022F\n\013config_info\030\004 \001(\0132%.injective.ocr"
    ".v1beta1.FeedConfigInfoR\nconfigInfoB\346\001\n\031"
    "com.injective.ocr.v1beta1B\010OcrProtoP\001ZIg"
    "ithub.com/InjectiveLabs/injective-core/i"
    "njective-chain/modules/ocr/types\242\002\003IOX\252\002"
    "\025Injective.Ocr.V1beta1\312\002\025Injective\\Ocr\\V"
    "1beta1\342\002!Injective\\Ocr\\V1beta1\\GPBMetada"
    "ta\352\002\027Injective::Ocr::V1beta1b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_deps[4] =
    {
        &::descriptor_table_cosmos_2fbase_2fv1beta1_2fcoin_2eproto,
        &::descriptor_table_cosmos_5fproto_2fcosmos_2eproto,
        &::descriptor_table_gogoproto_2fgogo_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::absl::once_flag descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto = {
    false,
    false,
    5196,
    descriptor_table_protodef_injective_2focr_2fv1beta1_2focr_2eproto,
    "injective/ocr/v1beta1/ocr.proto",
    &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
    descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_deps,
    4,
    21,
    schemas,
    file_default_instances,
    TableStruct_injective_2focr_2fv1beta1_2focr_2eproto::offsets,
    file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto,
    file_level_enum_descriptors_injective_2focr_2fv1beta1_2focr_2eproto,
    file_level_service_descriptors_injective_2focr_2fv1beta1_2focr_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter() {
  return &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_injective_2focr_2fv1beta1_2focr_2eproto(&descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto);
namespace injective {
namespace ocr {
namespace v1beta1 {
// ===================================================================

class Params::_Internal {
 public:
};

Params::Params(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.Params)
}
Params::Params(const Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.link_denom_) {}

    , decltype(_impl_.module_admin_) {}

    , decltype(_impl_.payout_block_interval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.link_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_link_denom().empty()) {
    _this->_impl_.link_denom_.Set(from._internal_link_denom(), _this->GetArenaForAllocation());
  }
  _impl_.module_admin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.module_admin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_module_admin().empty()) {
    _this->_impl_.module_admin_.Set(from._internal_module_admin(), _this->GetArenaForAllocation());
  }
  _this->_impl_.payout_block_interval_ = from._impl_.payout_block_interval_;
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.Params)
}

inline void Params::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.link_denom_) {}

    , decltype(_impl_.module_admin_) {}

    , decltype(_impl_.payout_block_interval_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.link_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.module_admin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.module_admin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Params::~Params() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Params::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.link_denom_.Destroy();
  _impl_.module_admin_.Destroy();
}

void Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Params::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.Params)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.link_denom_.ClearToEmpty();
  _impl_.module_admin_.ClearToEmpty();
  _impl_.payout_block_interval_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string link_denom = 1 [json_name = "linkDenom"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_link_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.Params.link_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 payout_block_interval = 2 [json_name = "payoutBlockInterval"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.payout_block_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string module_admin = 3 [json_name = "moduleAdmin"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_module_admin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.Params.module_admin"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Params::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.Params)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string link_denom = 1 [json_name = "linkDenom"];
  if (!this->_internal_link_denom().empty()) {
    const std::string& _s = this->_internal_link_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.Params.link_denom");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint64 payout_block_interval = 2 [json_name = "payoutBlockInterval"];
  if (this->_internal_payout_block_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_payout_block_interval(), target);
  }

  // string module_admin = 3 [json_name = "moduleAdmin"];
  if (!this->_internal_module_admin().empty()) {
    const std::string& _s = this->_internal_module_admin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.Params.module_admin");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.Params)
  return target;
}

::size_t Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.Params)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string link_denom = 1 [json_name = "linkDenom"];
  if (!this->_internal_link_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_link_denom());
  }

  // string module_admin = 3 [json_name = "moduleAdmin"];
  if (!this->_internal_module_admin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_module_admin());
  }

  // uint64 payout_block_interval = 2 [json_name = "payoutBlockInterval"];
  if (this->_internal_payout_block_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_payout_block_interval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Params::GetClassData() const { return &_class_data_; }


void Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Params*>(&to_msg);
  auto& from = static_cast<const Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.Params)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_link_denom().empty()) {
    _this->_internal_set_link_denom(from._internal_link_denom());
  }
  if (!from._internal_module_admin().empty()) {
    _this->_internal_set_module_admin(from._internal_module_admin());
  }
  if (from._internal_payout_block_interval() != 0) {
    _this->_internal_set_payout_block_interval(from._internal_payout_block_interval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Params::CopyFrom(const Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Params::IsInitialized() const {
  return true;
}

void Params::InternalSwap(Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_denom_, lhs_arena,
                                       &other->_impl_.link_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.module_admin_, lhs_arena,
                                       &other->_impl_.module_admin_, rhs_arena);

  swap(_impl_.payout_block_interval_, other->_impl_.payout_block_interval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[0]);
}
// ===================================================================

class FeedConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<FeedConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FeedConfig, _impl_._has_bits_);
  static const ::injective::ocr::v1beta1::ModuleParams& module_params(const FeedConfig* msg);
  static void set_has_module_params(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::ocr::v1beta1::ModuleParams&
FeedConfig::_Internal::module_params(const FeedConfig* msg) {
  return *msg->_impl_.module_params_;
}
FeedConfig::FeedConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.FeedConfig)
}
FeedConfig::FeedConfig(const FeedConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeedConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signers_){from._impl_.signers_}
    , decltype(_impl_.transmitters_){from._impl_.transmitters_}
    , decltype(_impl_.onchain_config_) {}

    , decltype(_impl_.offchain_config_) {}

    , decltype(_impl_.module_params_){nullptr}
    , decltype(_impl_.offchain_config_version_) {}

    , decltype(_impl_.f_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.onchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.onchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_onchain_config().empty()) {
    _this->_impl_.onchain_config_.Set(from._internal_onchain_config(), _this->GetArenaForAllocation());
  }
  _impl_.offchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.offchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_offchain_config().empty()) {
    _this->_impl_.offchain_config_.Set(from._internal_offchain_config(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.module_params_ = new ::injective::ocr::v1beta1::ModuleParams(*from._impl_.module_params_);
  }
  ::memcpy(&_impl_.offchain_config_version_, &from._impl_.offchain_config_version_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.f_) -
    reinterpret_cast<char*>(&_impl_.offchain_config_version_)) + sizeof(_impl_.f_));
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.FeedConfig)
}

inline void FeedConfig::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signers_){arena}
    , decltype(_impl_.transmitters_){arena}
    , decltype(_impl_.onchain_config_) {}

    , decltype(_impl_.offchain_config_) {}

    , decltype(_impl_.module_params_){nullptr}
    , decltype(_impl_.offchain_config_version_) { ::uint64_t{0u} }

    , decltype(_impl_.f_) { 0u }

  };
  _impl_.onchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.onchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.offchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.offchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FeedConfig::~FeedConfig() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.FeedConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeedConfig::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_signers()->~RepeatedPtrField();
  _internal_mutable_transmitters()->~RepeatedPtrField();
  _impl_.onchain_config_.Destroy();
  _impl_.offchain_config_.Destroy();
  if (this != internal_default_instance()) delete _impl_.module_params_;
}

void FeedConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeedConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.FeedConfig)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_signers()->Clear();
  _internal_mutable_transmitters()->Clear();
  _impl_.onchain_config_.ClearToEmpty();
  _impl_.offchain_config_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.module_params_ != nullptr);
    _impl_.module_params_->Clear();
  }
  ::memset(&_impl_.offchain_config_version_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.f_) -
      reinterpret_cast<char*>(&_impl_.offchain_config_version_)) + sizeof(_impl_.f_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeedConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string signers = 1 [json_name = "signers"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.FeedConfig.signers"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string transmitters = 2 [json_name = "transmitters"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_transmitters();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.FeedConfig.transmitters"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 f = 3 [json_name = "f"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.f_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes onchain_config = 4 [json_name = "onchainConfig"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_onchain_config();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 offchain_config_version = 5 [json_name = "offchainConfigVersion"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.offchain_config_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes offchain_config = 6 [json_name = "offchainConfig"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_offchain_config();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.ocr.v1beta1.ModuleParams module_params = 7 [json_name = "moduleParams"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_module_params(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeedConfig::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.FeedConfig)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string signers = 1 [json_name = "signers"];
  for (int i = 0, n = this->_internal_signers_size(); i < n; ++i) {
    const auto& s = this->_internal_signers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.FeedConfig.signers");
    target = stream->WriteString(1, s, target);
  }

  // repeated string transmitters = 2 [json_name = "transmitters"];
  for (int i = 0, n = this->_internal_transmitters_size(); i < n; ++i) {
    const auto& s = this->_internal_transmitters(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.FeedConfig.transmitters");
    target = stream->WriteString(2, s, target);
  }

  // uint32 f = 3 [json_name = "f"];
  if (this->_internal_f() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_f(), target);
  }

  // bytes onchain_config = 4 [json_name = "onchainConfig"];
  if (!this->_internal_onchain_config().empty()) {
    const std::string& _s = this->_internal_onchain_config();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  // uint64 offchain_config_version = 5 [json_name = "offchainConfigVersion"];
  if (this->_internal_offchain_config_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_offchain_config_version(), target);
  }

  // bytes offchain_config = 6 [json_name = "offchainConfig"];
  if (!this->_internal_offchain_config().empty()) {
    const std::string& _s = this->_internal_offchain_config();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.ocr.v1beta1.ModuleParams module_params = 7 [json_name = "moduleParams"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::module_params(this),
        _Internal::module_params(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.FeedConfig)
  return target;
}

::size_t FeedConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.FeedConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signers = 1 [json_name = "signers"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_signers().size());
  for (int i = 0, n = _internal_signers().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_signers().Get(i));
  }

  // repeated string transmitters = 2 [json_name = "transmitters"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_transmitters().size());
  for (int i = 0, n = _internal_transmitters().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_transmitters().Get(i));
  }

  // bytes onchain_config = 4 [json_name = "onchainConfig"];
  if (!this->_internal_onchain_config().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_onchain_config());
  }

  // bytes offchain_config = 6 [json_name = "offchainConfig"];
  if (!this->_internal_offchain_config().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_offchain_config());
  }

  // .injective.ocr.v1beta1.ModuleParams module_params = 7 [json_name = "moduleParams"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.module_params_);
  }

  // uint64 offchain_config_version = 5 [json_name = "offchainConfigVersion"];
  if (this->_internal_offchain_config_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_offchain_config_version());
  }

  // uint32 f = 3 [json_name = "f"];
  if (this->_internal_f() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_f());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeedConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeedConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeedConfig::GetClassData() const { return &_class_data_; }


void FeedConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeedConfig*>(&to_msg);
  auto& from = static_cast<const FeedConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.FeedConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_signers()->MergeFrom(from._internal_signers());
  _this->_internal_mutable_transmitters()->MergeFrom(from._internal_transmitters());
  if (!from._internal_onchain_config().empty()) {
    _this->_internal_set_onchain_config(from._internal_onchain_config());
  }
  if (!from._internal_offchain_config().empty()) {
    _this->_internal_set_offchain_config(from._internal_offchain_config());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_module_params()->::injective::ocr::v1beta1::ModuleParams::MergeFrom(
        from._internal_module_params());
  }
  if (from._internal_offchain_config_version() != 0) {
    _this->_internal_set_offchain_config_version(from._internal_offchain_config_version());
  }
  if (from._internal_f() != 0) {
    _this->_internal_set_f(from._internal_f());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeedConfig::CopyFrom(const FeedConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.FeedConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeedConfig::IsInitialized() const {
  return true;
}

void FeedConfig::InternalSwap(FeedConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_signers()->InternalSwap(
      other->_internal_mutable_signers());
  _internal_mutable_transmitters()->InternalSwap(
      other->_internal_mutable_transmitters());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.onchain_config_, lhs_arena,
                                       &other->_impl_.onchain_config_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.offchain_config_, lhs_arena,
                                       &other->_impl_.offchain_config_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeedConfig, _impl_.f_)
      + sizeof(FeedConfig::_impl_.f_)
      - PROTOBUF_FIELD_OFFSET(FeedConfig, _impl_.module_params_)>(
          reinterpret_cast<char*>(&_impl_.module_params_),
          reinterpret_cast<char*>(&other->_impl_.module_params_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeedConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[1]);
}
// ===================================================================

class FeedConfigInfo::_Internal {
 public:
};

FeedConfigInfo::FeedConfigInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.FeedConfigInfo)
}
FeedConfigInfo::FeedConfigInfo(const FeedConfigInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeedConfigInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_config_digest_) {}

    , decltype(_impl_.f_) {}

    , decltype(_impl_.n_) {}

    , decltype(_impl_.config_count_) {}

    , decltype(_impl_.latest_config_block_number_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.latest_config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.latest_config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_latest_config_digest().empty()) {
    _this->_impl_.latest_config_digest_.Set(from._internal_latest_config_digest(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.f_, &from._impl_.f_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.latest_config_block_number_) -
    reinterpret_cast<char*>(&_impl_.f_)) + sizeof(_impl_.latest_config_block_number_));
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.FeedConfigInfo)
}

inline void FeedConfigInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_config_digest_) {}

    , decltype(_impl_.f_) { 0u }

    , decltype(_impl_.n_) { 0u }

    , decltype(_impl_.config_count_) { ::uint64_t{0u} }

    , decltype(_impl_.latest_config_block_number_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.latest_config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.latest_config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FeedConfigInfo::~FeedConfigInfo() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.FeedConfigInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeedConfigInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.latest_config_digest_.Destroy();
}

void FeedConfigInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeedConfigInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.FeedConfigInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.latest_config_digest_.ClearToEmpty();
  ::memset(&_impl_.f_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.latest_config_block_number_) -
      reinterpret_cast<char*>(&_impl_.f_)) + sizeof(_impl_.latest_config_block_number_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeedConfigInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes latest_config_digest = 1 [json_name = "latestConfigDigest"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_latest_config_digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 f = 2 [json_name = "f"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.f_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 n = 3 [json_name = "n"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.n_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 config_count = 4 [json_name = "configCount"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.config_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 latest_config_block_number = 5 [json_name = "latestConfigBlockNumber"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.latest_config_block_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeedConfigInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.FeedConfigInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes latest_config_digest = 1 [json_name = "latestConfigDigest"];
  if (!this->_internal_latest_config_digest().empty()) {
    const std::string& _s = this->_internal_latest_config_digest();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // uint32 f = 2 [json_name = "f"];
  if (this->_internal_f() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_f(), target);
  }

  // uint32 n = 3 [json_name = "n"];
  if (this->_internal_n() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_n(), target);
  }

  // uint64 config_count = 4 [json_name = "configCount"];
  if (this->_internal_config_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_config_count(), target);
  }

  // int64 latest_config_block_number = 5 [json_name = "latestConfigBlockNumber"];
  if (this->_internal_latest_config_block_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_latest_config_block_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.FeedConfigInfo)
  return target;
}

::size_t FeedConfigInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.FeedConfigInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes latest_config_digest = 1 [json_name = "latestConfigDigest"];
  if (!this->_internal_latest_config_digest().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_latest_config_digest());
  }

  // uint32 f = 2 [json_name = "f"];
  if (this->_internal_f() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_f());
  }

  // uint32 n = 3 [json_name = "n"];
  if (this->_internal_n() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_n());
  }

  // uint64 config_count = 4 [json_name = "configCount"];
  if (this->_internal_config_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_config_count());
  }

  // int64 latest_config_block_number = 5 [json_name = "latestConfigBlockNumber"];
  if (this->_internal_latest_config_block_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_latest_config_block_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeedConfigInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeedConfigInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeedConfigInfo::GetClassData() const { return &_class_data_; }


void FeedConfigInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeedConfigInfo*>(&to_msg);
  auto& from = static_cast<const FeedConfigInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.FeedConfigInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_latest_config_digest().empty()) {
    _this->_internal_set_latest_config_digest(from._internal_latest_config_digest());
  }
  if (from._internal_f() != 0) {
    _this->_internal_set_f(from._internal_f());
  }
  if (from._internal_n() != 0) {
    _this->_internal_set_n(from._internal_n());
  }
  if (from._internal_config_count() != 0) {
    _this->_internal_set_config_count(from._internal_config_count());
  }
  if (from._internal_latest_config_block_number() != 0) {
    _this->_internal_set_latest_config_block_number(from._internal_latest_config_block_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeedConfigInfo::CopyFrom(const FeedConfigInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.FeedConfigInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeedConfigInfo::IsInitialized() const {
  return true;
}

void FeedConfigInfo::InternalSwap(FeedConfigInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.latest_config_digest_, lhs_arena,
                                       &other->_impl_.latest_config_digest_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeedConfigInfo, _impl_.latest_config_block_number_)
      + sizeof(FeedConfigInfo::_impl_.latest_config_block_number_)
      - PROTOBUF_FIELD_OFFSET(FeedConfigInfo, _impl_.f_)>(
          reinterpret_cast<char*>(&_impl_.f_),
          reinterpret_cast<char*>(&other->_impl_.f_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeedConfigInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[2]);
}
// ===================================================================

class ModuleParams::_Internal {
 public:
};

ModuleParams::ModuleParams(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.ModuleParams)
}
ModuleParams::ModuleParams(const ModuleParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleParams* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.feed_id_) {}

    , decltype(_impl_.min_answer_) {}

    , decltype(_impl_.max_answer_) {}

    , decltype(_impl_.link_per_observation_) {}

    , decltype(_impl_.link_per_transmission_) {}

    , decltype(_impl_.link_denom_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.feed_admin_) {}

    , decltype(_impl_.billing_admin_) {}

    , decltype(_impl_.unique_reports_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.feed_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_feed_id().empty()) {
    _this->_impl_.feed_id_.Set(from._internal_feed_id(), _this->GetArenaForAllocation());
  }
  _impl_.min_answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_answer().empty()) {
    _this->_impl_.min_answer_.Set(from._internal_min_answer(), _this->GetArenaForAllocation());
  }
  _impl_.max_answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.max_answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_max_answer().empty()) {
    _this->_impl_.max_answer_.Set(from._internal_max_answer(), _this->GetArenaForAllocation());
  }
  _impl_.link_per_observation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_per_observation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_link_per_observation().empty()) {
    _this->_impl_.link_per_observation_.Set(from._internal_link_per_observation(), _this->GetArenaForAllocation());
  }
  _impl_.link_per_transmission_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_per_transmission_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_link_per_transmission().empty()) {
    _this->_impl_.link_per_transmission_.Set(from._internal_link_per_transmission(), _this->GetArenaForAllocation());
  }
  _impl_.link_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_link_denom().empty()) {
    _this->_impl_.link_denom_.Set(from._internal_link_denom(), _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  _impl_.feed_admin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_admin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_feed_admin().empty()) {
    _this->_impl_.feed_admin_.Set(from._internal_feed_admin(), _this->GetArenaForAllocation());
  }
  _impl_.billing_admin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.billing_admin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_billing_admin().empty()) {
    _this->_impl_.billing_admin_.Set(from._internal_billing_admin(), _this->GetArenaForAllocation());
  }
  _this->_impl_.unique_reports_ = from._impl_.unique_reports_;
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.ModuleParams)
}

inline void ModuleParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.feed_id_) {}

    , decltype(_impl_.min_answer_) {}

    , decltype(_impl_.max_answer_) {}

    , decltype(_impl_.link_per_observation_) {}

    , decltype(_impl_.link_per_transmission_) {}

    , decltype(_impl_.link_denom_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.feed_admin_) {}

    , decltype(_impl_.billing_admin_) {}

    , decltype(_impl_.unique_reports_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.feed_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.max_answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.max_answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.link_per_observation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_per_observation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.link_per_transmission_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_per_transmission_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.link_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.feed_admin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_admin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.billing_admin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.billing_admin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModuleParams::~ModuleParams() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.ModuleParams)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.feed_id_.Destroy();
  _impl_.min_answer_.Destroy();
  _impl_.max_answer_.Destroy();
  _impl_.link_per_observation_.Destroy();
  _impl_.link_per_transmission_.Destroy();
  _impl_.link_denom_.Destroy();
  _impl_.description_.Destroy();
  _impl_.feed_admin_.Destroy();
  _impl_.billing_admin_.Destroy();
}

void ModuleParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleParams::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.ModuleParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.feed_id_.ClearToEmpty();
  _impl_.min_answer_.ClearToEmpty();
  _impl_.max_answer_.ClearToEmpty();
  _impl_.link_per_observation_.ClearToEmpty();
  _impl_.link_per_transmission_.ClearToEmpty();
  _impl_.link_denom_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.feed_admin_.ClearToEmpty();
  _impl_.billing_admin_.ClearToEmpty();
  _impl_.unique_reports_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string feed_id = 1 [json_name = "feedId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_feed_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.feed_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_answer = 2 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_min_answer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.min_answer"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string max_answer = 3 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_max_answer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.max_answer"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string link_per_observation = 4 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_link_per_observation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.link_per_observation"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string link_per_transmission = 5 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_link_per_transmission();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.link_per_transmission"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string link_denom = 6 [json_name = "linkDenom"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_link_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.link_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool unique_reports = 7 [json_name = "uniqueReports"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.unique_reports_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string description = 8 [json_name = "description"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.description"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string feed_admin = 9 [json_name = "feedAdmin"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_feed_admin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.feed_admin"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string billing_admin = 10 [json_name = "billingAdmin"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_billing_admin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ModuleParams.billing_admin"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ModuleParams::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.ModuleParams)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string feed_id = 1 [json_name = "feedId"];
  if (!this->_internal_feed_id().empty()) {
    const std::string& _s = this->_internal_feed_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.feed_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string min_answer = 2 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_answer().empty()) {
    const std::string& _s = this->_internal_min_answer();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.min_answer");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string max_answer = 3 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_max_answer().empty()) {
    const std::string& _s = this->_internal_max_answer();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.max_answer");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string link_per_observation = 4 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_link_per_observation().empty()) {
    const std::string& _s = this->_internal_link_per_observation();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.link_per_observation");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string link_per_transmission = 5 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_link_per_transmission().empty()) {
    const std::string& _s = this->_internal_link_per_transmission();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.link_per_transmission");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // string link_denom = 6 [json_name = "linkDenom"];
  if (!this->_internal_link_denom().empty()) {
    const std::string& _s = this->_internal_link_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.link_denom");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // bool unique_reports = 7 [json_name = "uniqueReports"];
  if (this->_internal_unique_reports() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_unique_reports(), target);
  }

  // string description = 8 [json_name = "description"];
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.description");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // string feed_admin = 9 [json_name = "feedAdmin"];
  if (!this->_internal_feed_admin().empty()) {
    const std::string& _s = this->_internal_feed_admin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.feed_admin");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // string billing_admin = 10 [json_name = "billingAdmin"];
  if (!this->_internal_billing_admin().empty()) {
    const std::string& _s = this->_internal_billing_admin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ModuleParams.billing_admin");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.ModuleParams)
  return target;
}

::size_t ModuleParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.ModuleParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string feed_id = 1 [json_name = "feedId"];
  if (!this->_internal_feed_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_feed_id());
  }

  // string min_answer = 2 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_answer().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_answer());
  }

  // string max_answer = 3 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_max_answer().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_max_answer());
  }

  // string link_per_observation = 4 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_link_per_observation().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_link_per_observation());
  }

  // string link_per_transmission = 5 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_link_per_transmission().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_link_per_transmission());
  }

  // string link_denom = 6 [json_name = "linkDenom"];
  if (!this->_internal_link_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_link_denom());
  }

  // string description = 8 [json_name = "description"];
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  // string feed_admin = 9 [json_name = "feedAdmin"];
  if (!this->_internal_feed_admin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_feed_admin());
  }

  // string billing_admin = 10 [json_name = "billingAdmin"];
  if (!this->_internal_billing_admin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_billing_admin());
  }

  // bool unique_reports = 7 [json_name = "uniqueReports"];
  if (this->_internal_unique_reports() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleParams::GetClassData() const { return &_class_data_; }


void ModuleParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleParams*>(&to_msg);
  auto& from = static_cast<const ModuleParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.ModuleParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_feed_id().empty()) {
    _this->_internal_set_feed_id(from._internal_feed_id());
  }
  if (!from._internal_min_answer().empty()) {
    _this->_internal_set_min_answer(from._internal_min_answer());
  }
  if (!from._internal_max_answer().empty()) {
    _this->_internal_set_max_answer(from._internal_max_answer());
  }
  if (!from._internal_link_per_observation().empty()) {
    _this->_internal_set_link_per_observation(from._internal_link_per_observation());
  }
  if (!from._internal_link_per_transmission().empty()) {
    _this->_internal_set_link_per_transmission(from._internal_link_per_transmission());
  }
  if (!from._internal_link_denom().empty()) {
    _this->_internal_set_link_denom(from._internal_link_denom());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_feed_admin().empty()) {
    _this->_internal_set_feed_admin(from._internal_feed_admin());
  }
  if (!from._internal_billing_admin().empty()) {
    _this->_internal_set_billing_admin(from._internal_billing_admin());
  }
  if (from._internal_unique_reports() != 0) {
    _this->_internal_set_unique_reports(from._internal_unique_reports());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleParams::CopyFrom(const ModuleParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.ModuleParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleParams::IsInitialized() const {
  return true;
}

void ModuleParams::InternalSwap(ModuleParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.feed_id_, lhs_arena,
                                       &other->_impl_.feed_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_answer_, lhs_arena,
                                       &other->_impl_.min_answer_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.max_answer_, lhs_arena,
                                       &other->_impl_.max_answer_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_per_observation_, lhs_arena,
                                       &other->_impl_.link_per_observation_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_per_transmission_, lhs_arena,
                                       &other->_impl_.link_per_transmission_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_denom_, lhs_arena,
                                       &other->_impl_.link_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.feed_admin_, lhs_arena,
                                       &other->_impl_.feed_admin_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.billing_admin_, lhs_arena,
                                       &other->_impl_.billing_admin_, rhs_arena);

  swap(_impl_.unique_reports_, other->_impl_.unique_reports_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[3]);
}
// ===================================================================

class ContractConfig::_Internal {
 public:
};

ContractConfig::ContractConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.ContractConfig)
}
ContractConfig::ContractConfig(const ContractConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContractConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signers_){from._impl_.signers_}
    , decltype(_impl_.transmitters_){from._impl_.transmitters_}
    , decltype(_impl_.onchain_config_) {}

    , decltype(_impl_.offchain_config_) {}

    , decltype(_impl_.config_count_) {}

    , decltype(_impl_.offchain_config_version_) {}

    , decltype(_impl_.f_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.onchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.onchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_onchain_config().empty()) {
    _this->_impl_.onchain_config_.Set(from._internal_onchain_config(), _this->GetArenaForAllocation());
  }
  _impl_.offchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.offchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_offchain_config().empty()) {
    _this->_impl_.offchain_config_.Set(from._internal_offchain_config(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.config_count_, &from._impl_.config_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.f_) -
    reinterpret_cast<char*>(&_impl_.config_count_)) + sizeof(_impl_.f_));
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.ContractConfig)
}

inline void ContractConfig::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.signers_){arena}
    , decltype(_impl_.transmitters_){arena}
    , decltype(_impl_.onchain_config_) {}

    , decltype(_impl_.offchain_config_) {}

    , decltype(_impl_.config_count_) { ::uint64_t{0u} }

    , decltype(_impl_.offchain_config_version_) { ::uint64_t{0u} }

    , decltype(_impl_.f_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.onchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.onchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.offchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.offchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContractConfig::~ContractConfig() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.ContractConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractConfig::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_signers()->~RepeatedPtrField();
  _internal_mutable_transmitters()->~RepeatedPtrField();
  _impl_.onchain_config_.Destroy();
  _impl_.offchain_config_.Destroy();
}

void ContractConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContractConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.ContractConfig)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_signers()->Clear();
  _internal_mutable_transmitters()->Clear();
  _impl_.onchain_config_.ClearToEmpty();
  _impl_.offchain_config_.ClearToEmpty();
  ::memset(&_impl_.config_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.f_) -
      reinterpret_cast<char*>(&_impl_.config_count_)) + sizeof(_impl_.f_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 config_count = 1 [json_name = "configCount"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.config_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string signers = 2 [json_name = "signers"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ContractConfig.signers"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string transmitters = 3 [json_name = "transmitters"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_transmitters();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.ContractConfig.transmitters"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 f = 4 [json_name = "f"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.f_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes onchain_config = 5 [json_name = "onchainConfig"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_onchain_config();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 offchain_config_version = 6 [json_name = "offchainConfigVersion"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.offchain_config_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes offchain_config = 7 [json_name = "offchainConfig"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_offchain_config();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ContractConfig::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.ContractConfig)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 config_count = 1 [json_name = "configCount"];
  if (this->_internal_config_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_config_count(), target);
  }

  // repeated string signers = 2 [json_name = "signers"];
  for (int i = 0, n = this->_internal_signers_size(); i < n; ++i) {
    const auto& s = this->_internal_signers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ContractConfig.signers");
    target = stream->WriteString(2, s, target);
  }

  // repeated string transmitters = 3 [json_name = "transmitters"];
  for (int i = 0, n = this->_internal_transmitters_size(); i < n; ++i) {
    const auto& s = this->_internal_transmitters(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.ContractConfig.transmitters");
    target = stream->WriteString(3, s, target);
  }

  // uint32 f = 4 [json_name = "f"];
  if (this->_internal_f() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_f(), target);
  }

  // bytes onchain_config = 5 [json_name = "onchainConfig"];
  if (!this->_internal_onchain_config().empty()) {
    const std::string& _s = this->_internal_onchain_config();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  // uint64 offchain_config_version = 6 [json_name = "offchainConfigVersion"];
  if (this->_internal_offchain_config_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_offchain_config_version(), target);
  }

  // bytes offchain_config = 7 [json_name = "offchainConfig"];
  if (!this->_internal_offchain_config().empty()) {
    const std::string& _s = this->_internal_offchain_config();
    target = stream->WriteBytesMaybeAliased(7, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.ContractConfig)
  return target;
}

::size_t ContractConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.ContractConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signers = 2 [json_name = "signers"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_signers().size());
  for (int i = 0, n = _internal_signers().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_signers().Get(i));
  }

  // repeated string transmitters = 3 [json_name = "transmitters"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_transmitters().size());
  for (int i = 0, n = _internal_transmitters().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_transmitters().Get(i));
  }

  // bytes onchain_config = 5 [json_name = "onchainConfig"];
  if (!this->_internal_onchain_config().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_onchain_config());
  }

  // bytes offchain_config = 7 [json_name = "offchainConfig"];
  if (!this->_internal_offchain_config().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_offchain_config());
  }

  // uint64 config_count = 1 [json_name = "configCount"];
  if (this->_internal_config_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_config_count());
  }

  // uint64 offchain_config_version = 6 [json_name = "offchainConfigVersion"];
  if (this->_internal_offchain_config_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_offchain_config_version());
  }

  // uint32 f = 4 [json_name = "f"];
  if (this->_internal_f() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_f());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContractConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractConfig::GetClassData() const { return &_class_data_; }


void ContractConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContractConfig*>(&to_msg);
  auto& from = static_cast<const ContractConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.ContractConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_signers()->MergeFrom(from._internal_signers());
  _this->_internal_mutable_transmitters()->MergeFrom(from._internal_transmitters());
  if (!from._internal_onchain_config().empty()) {
    _this->_internal_set_onchain_config(from._internal_onchain_config());
  }
  if (!from._internal_offchain_config().empty()) {
    _this->_internal_set_offchain_config(from._internal_offchain_config());
  }
  if (from._internal_config_count() != 0) {
    _this->_internal_set_config_count(from._internal_config_count());
  }
  if (from._internal_offchain_config_version() != 0) {
    _this->_internal_set_offchain_config_version(from._internal_offchain_config_version());
  }
  if (from._internal_f() != 0) {
    _this->_internal_set_f(from._internal_f());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractConfig::CopyFrom(const ContractConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.ContractConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractConfig::IsInitialized() const {
  return true;
}

void ContractConfig::InternalSwap(ContractConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_signers()->InternalSwap(
      other->_internal_mutable_signers());
  _internal_mutable_transmitters()->InternalSwap(
      other->_internal_mutable_transmitters());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.onchain_config_, lhs_arena,
                                       &other->_impl_.onchain_config_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.offchain_config_, lhs_arena,
                                       &other->_impl_.offchain_config_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractConfig, _impl_.f_)
      + sizeof(ContractConfig::_impl_.f_)
      - PROTOBUF_FIELD_OFFSET(ContractConfig, _impl_.config_count_)>(
          reinterpret_cast<char*>(&_impl_.config_count_),
          reinterpret_cast<char*>(&other->_impl_.config_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[4]);
}
// ===================================================================

class SetConfigProposal::_Internal {
 public:
  using HasBits = decltype(std::declval<SetConfigProposal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SetConfigProposal, _impl_._has_bits_);
  static const ::injective::ocr::v1beta1::FeedConfig& config(const SetConfigProposal* msg);
  static void set_has_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::ocr::v1beta1::FeedConfig&
SetConfigProposal::_Internal::config(const SetConfigProposal* msg) {
  return *msg->_impl_.config_;
}
SetConfigProposal::SetConfigProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.SetConfigProposal)
}
SetConfigProposal::SetConfigProposal(const SetConfigProposal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetConfigProposal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.config_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.title_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.config_ = new ::injective::ocr::v1beta1::FeedConfig(*from._impl_.config_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.SetConfigProposal)
}

inline void SetConfigProposal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.config_){nullptr}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.title_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetConfigProposal::~SetConfigProposal() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.SetConfigProposal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetConfigProposal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.title_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.config_;
}

void SetConfigProposal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetConfigProposal::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.SetConfigProposal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.title_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.config_ != nullptr);
    _impl_.config_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetConfigProposal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string title = 1 [json_name = "title"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.SetConfigProposal.title"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string description = 2 [json_name = "description"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.SetConfigProposal.description"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetConfigProposal::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.SetConfigProposal)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string title = 1 [json_name = "title"];
  if (!this->_internal_title().empty()) {
    const std::string& _s = this->_internal_title();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.SetConfigProposal.title");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string description = 2 [json_name = "description"];
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.SetConfigProposal.description");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.SetConfigProposal)
  return target;
}

::size_t SetConfigProposal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.SetConfigProposal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string title = 1 [json_name = "title"];
  if (!this->_internal_title().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_title());
  }

  // string description = 2 [json_name = "description"];
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  // .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.config_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetConfigProposal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetConfigProposal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetConfigProposal::GetClassData() const { return &_class_data_; }


void SetConfigProposal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetConfigProposal*>(&to_msg);
  auto& from = static_cast<const SetConfigProposal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.SetConfigProposal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_config()->::injective::ocr::v1beta1::FeedConfig::MergeFrom(
        from._internal_config());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetConfigProposal::CopyFrom(const SetConfigProposal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.SetConfigProposal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetConfigProposal::IsInitialized() const {
  return true;
}

void SetConfigProposal::InternalSwap(SetConfigProposal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena,
                                       &other->_impl_.title_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
  swap(_impl_.config_, other->_impl_.config_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetConfigProposal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[5]);
}
// ===================================================================

class FeedProperties::_Internal {
 public:
};

FeedProperties::FeedProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.FeedProperties)
}
FeedProperties::FeedProperties(const FeedProperties& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeedProperties* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.feed_id_) {}

    , decltype(_impl_.onchain_config_) {}

    , decltype(_impl_.offchain_config_) {}

    , decltype(_impl_.min_answer_) {}

    , decltype(_impl_.max_answer_) {}

    , decltype(_impl_.link_per_observation_) {}

    , decltype(_impl_.link_per_transmission_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.offchain_config_version_) {}

    , decltype(_impl_.f_) {}

    , decltype(_impl_.unique_reports_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.feed_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_feed_id().empty()) {
    _this->_impl_.feed_id_.Set(from._internal_feed_id(), _this->GetArenaForAllocation());
  }
  _impl_.onchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.onchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_onchain_config().empty()) {
    _this->_impl_.onchain_config_.Set(from._internal_onchain_config(), _this->GetArenaForAllocation());
  }
  _impl_.offchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.offchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_offchain_config().empty()) {
    _this->_impl_.offchain_config_.Set(from._internal_offchain_config(), _this->GetArenaForAllocation());
  }
  _impl_.min_answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_answer().empty()) {
    _this->_impl_.min_answer_.Set(from._internal_min_answer(), _this->GetArenaForAllocation());
  }
  _impl_.max_answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.max_answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_max_answer().empty()) {
    _this->_impl_.max_answer_.Set(from._internal_max_answer(), _this->GetArenaForAllocation());
  }
  _impl_.link_per_observation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_per_observation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_link_per_observation().empty()) {
    _this->_impl_.link_per_observation_.Set(from._internal_link_per_observation(), _this->GetArenaForAllocation());
  }
  _impl_.link_per_transmission_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_per_transmission_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_link_per_transmission().empty()) {
    _this->_impl_.link_per_transmission_.Set(from._internal_link_per_transmission(), _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.offchain_config_version_, &from._impl_.offchain_config_version_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.unique_reports_) -
    reinterpret_cast<char*>(&_impl_.offchain_config_version_)) + sizeof(_impl_.unique_reports_));
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.FeedProperties)
}

inline void FeedProperties::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.feed_id_) {}

    , decltype(_impl_.onchain_config_) {}

    , decltype(_impl_.offchain_config_) {}

    , decltype(_impl_.min_answer_) {}

    , decltype(_impl_.max_answer_) {}

    , decltype(_impl_.link_per_observation_) {}

    , decltype(_impl_.link_per_transmission_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.offchain_config_version_) { ::uint64_t{0u} }

    , decltype(_impl_.f_) { 0u }

    , decltype(_impl_.unique_reports_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.feed_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.onchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.onchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.offchain_config_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.offchain_config_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.max_answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.max_answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.link_per_observation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_per_observation_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.link_per_transmission_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_per_transmission_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FeedProperties::~FeedProperties() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.FeedProperties)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeedProperties::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.feed_id_.Destroy();
  _impl_.onchain_config_.Destroy();
  _impl_.offchain_config_.Destroy();
  _impl_.min_answer_.Destroy();
  _impl_.max_answer_.Destroy();
  _impl_.link_per_observation_.Destroy();
  _impl_.link_per_transmission_.Destroy();
  _impl_.description_.Destroy();
}

void FeedProperties::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeedProperties::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.FeedProperties)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.feed_id_.ClearToEmpty();
  _impl_.onchain_config_.ClearToEmpty();
  _impl_.offchain_config_.ClearToEmpty();
  _impl_.min_answer_.ClearToEmpty();
  _impl_.max_answer_.ClearToEmpty();
  _impl_.link_per_observation_.ClearToEmpty();
  _impl_.link_per_transmission_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  ::memset(&_impl_.offchain_config_version_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.unique_reports_) -
      reinterpret_cast<char*>(&_impl_.offchain_config_version_)) + sizeof(_impl_.unique_reports_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeedProperties::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string feed_id = 1 [json_name = "feedId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_feed_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.FeedProperties.feed_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 f = 2 [json_name = "f"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.f_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes onchain_config = 3 [json_name = "onchainConfig"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_onchain_config();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 offchain_config_version = 4 [json_name = "offchainConfigVersion"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.offchain_config_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes offchain_config = 5 [json_name = "offchainConfig"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_offchain_config();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_answer = 6 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_min_answer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.FeedProperties.min_answer"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string max_answer = 7 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_max_answer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.FeedProperties.max_answer"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string link_per_observation = 8 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_link_per_observation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.FeedProperties.link_per_observation"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string link_per_transmission = 9 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_link_per_transmission();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.FeedProperties.link_per_transmission"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool unique_reports = 10 [json_name = "uniqueReports"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.unique_reports_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string description = 11 [json_name = "description"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.FeedProperties.description"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeedProperties::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.FeedProperties)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string feed_id = 1 [json_name = "feedId"];
  if (!this->_internal_feed_id().empty()) {
    const std::string& _s = this->_internal_feed_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.FeedProperties.feed_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint32 f = 2 [json_name = "f"];
  if (this->_internal_f() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_f(), target);
  }

  // bytes onchain_config = 3 [json_name = "onchainConfig"];
  if (!this->_internal_onchain_config().empty()) {
    const std::string& _s = this->_internal_onchain_config();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // uint64 offchain_config_version = 4 [json_name = "offchainConfigVersion"];
  if (this->_internal_offchain_config_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_offchain_config_version(), target);
  }

  // bytes offchain_config = 5 [json_name = "offchainConfig"];
  if (!this->_internal_offchain_config().empty()) {
    const std::string& _s = this->_internal_offchain_config();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  // string min_answer = 6 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_answer().empty()) {
    const std::string& _s = this->_internal_min_answer();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.FeedProperties.min_answer");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // string max_answer = 7 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_max_answer().empty()) {
    const std::string& _s = this->_internal_max_answer();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.FeedProperties.max_answer");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // string link_per_observation = 8 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_link_per_observation().empty()) {
    const std::string& _s = this->_internal_link_per_observation();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.FeedProperties.link_per_observation");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // string link_per_transmission = 9 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_link_per_transmission().empty()) {
    const std::string& _s = this->_internal_link_per_transmission();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.FeedProperties.link_per_transmission");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // bool unique_reports = 10 [json_name = "uniqueReports"];
  if (this->_internal_unique_reports() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_unique_reports(), target);
  }

  // string description = 11 [json_name = "description"];
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.FeedProperties.description");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.FeedProperties)
  return target;
}

::size_t FeedProperties::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.FeedProperties)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string feed_id = 1 [json_name = "feedId"];
  if (!this->_internal_feed_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_feed_id());
  }

  // bytes onchain_config = 3 [json_name = "onchainConfig"];
  if (!this->_internal_onchain_config().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_onchain_config());
  }

  // bytes offchain_config = 5 [json_name = "offchainConfig"];
  if (!this->_internal_offchain_config().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_offchain_config());
  }

  // string min_answer = 6 [json_name = "minAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_answer().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_answer());
  }

  // string max_answer = 7 [json_name = "maxAnswer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_max_answer().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_max_answer());
  }

  // string link_per_observation = 8 [json_name = "linkPerObservation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_link_per_observation().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_link_per_observation());
  }

  // string link_per_transmission = 9 [json_name = "linkPerTransmission", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_link_per_transmission().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_link_per_transmission());
  }

  // string description = 11 [json_name = "description"];
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  // uint64 offchain_config_version = 4 [json_name = "offchainConfigVersion"];
  if (this->_internal_offchain_config_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_offchain_config_version());
  }

  // uint32 f = 2 [json_name = "f"];
  if (this->_internal_f() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_f());
  }

  // bool unique_reports = 10 [json_name = "uniqueReports"];
  if (this->_internal_unique_reports() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeedProperties::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeedProperties::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeedProperties::GetClassData() const { return &_class_data_; }


void FeedProperties::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeedProperties*>(&to_msg);
  auto& from = static_cast<const FeedProperties&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.FeedProperties)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_feed_id().empty()) {
    _this->_internal_set_feed_id(from._internal_feed_id());
  }
  if (!from._internal_onchain_config().empty()) {
    _this->_internal_set_onchain_config(from._internal_onchain_config());
  }
  if (!from._internal_offchain_config().empty()) {
    _this->_internal_set_offchain_config(from._internal_offchain_config());
  }
  if (!from._internal_min_answer().empty()) {
    _this->_internal_set_min_answer(from._internal_min_answer());
  }
  if (!from._internal_max_answer().empty()) {
    _this->_internal_set_max_answer(from._internal_max_answer());
  }
  if (!from._internal_link_per_observation().empty()) {
    _this->_internal_set_link_per_observation(from._internal_link_per_observation());
  }
  if (!from._internal_link_per_transmission().empty()) {
    _this->_internal_set_link_per_transmission(from._internal_link_per_transmission());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_offchain_config_version() != 0) {
    _this->_internal_set_offchain_config_version(from._internal_offchain_config_version());
  }
  if (from._internal_f() != 0) {
    _this->_internal_set_f(from._internal_f());
  }
  if (from._internal_unique_reports() != 0) {
    _this->_internal_set_unique_reports(from._internal_unique_reports());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeedProperties::CopyFrom(const FeedProperties& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.FeedProperties)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeedProperties::IsInitialized() const {
  return true;
}

void FeedProperties::InternalSwap(FeedProperties* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.feed_id_, lhs_arena,
                                       &other->_impl_.feed_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.onchain_config_, lhs_arena,
                                       &other->_impl_.onchain_config_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.offchain_config_, lhs_arena,
                                       &other->_impl_.offchain_config_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_answer_, lhs_arena,
                                       &other->_impl_.min_answer_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.max_answer_, lhs_arena,
                                       &other->_impl_.max_answer_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_per_observation_, lhs_arena,
                                       &other->_impl_.link_per_observation_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_per_transmission_, lhs_arena,
                                       &other->_impl_.link_per_transmission_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeedProperties, _impl_.unique_reports_)
      + sizeof(FeedProperties::_impl_.unique_reports_)
      - PROTOBUF_FIELD_OFFSET(FeedProperties, _impl_.offchain_config_version_)>(
          reinterpret_cast<char*>(&_impl_.offchain_config_version_),
          reinterpret_cast<char*>(&other->_impl_.offchain_config_version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeedProperties::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[6]);
}
// ===================================================================

class SetBatchConfigProposal::_Internal {
 public:
};

SetBatchConfigProposal::SetBatchConfigProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.SetBatchConfigProposal)
}
SetBatchConfigProposal::SetBatchConfigProposal(const SetBatchConfigProposal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetBatchConfigProposal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signers_){from._impl_.signers_}
    , decltype(_impl_.transmitters_){from._impl_.transmitters_}
    , decltype(_impl_.feed_properties_){from._impl_.feed_properties_}
    , decltype(_impl_.title_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.link_denom_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.title_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  _impl_.link_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_link_denom().empty()) {
    _this->_impl_.link_denom_.Set(from._internal_link_denom(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.SetBatchConfigProposal)
}

inline void SetBatchConfigProposal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.signers_){arena}
    , decltype(_impl_.transmitters_){arena}
    , decltype(_impl_.feed_properties_){arena}
    , decltype(_impl_.title_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.link_denom_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.title_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.link_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.link_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetBatchConfigProposal::~SetBatchConfigProposal() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.SetBatchConfigProposal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetBatchConfigProposal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_signers()->~RepeatedPtrField();
  _internal_mutable_transmitters()->~RepeatedPtrField();
  _internal_mutable_feed_properties()->~RepeatedPtrField();
  _impl_.title_.Destroy();
  _impl_.description_.Destroy();
  _impl_.link_denom_.Destroy();
}

void SetBatchConfigProposal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetBatchConfigProposal::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.SetBatchConfigProposal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_signers()->Clear();
  _internal_mutable_transmitters()->Clear();
  _internal_mutable_feed_properties()->Clear();
  _impl_.title_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.link_denom_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetBatchConfigProposal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string title = 1 [json_name = "title"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.SetBatchConfigProposal.title"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string description = 2 [json_name = "description"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.SetBatchConfigProposal.description"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string signers = 3 [json_name = "signers"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.SetBatchConfigProposal.signers"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string transmitters = 4 [json_name = "transmitters"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_transmitters();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.SetBatchConfigProposal.transmitters"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string link_denom = 5 [json_name = "linkDenom"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_link_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.SetBatchConfigProposal.link_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.ocr.v1beta1.FeedProperties feed_properties = 6 [json_name = "feedProperties"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_feed_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetBatchConfigProposal::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.SetBatchConfigProposal)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string title = 1 [json_name = "title"];
  if (!this->_internal_title().empty()) {
    const std::string& _s = this->_internal_title();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.SetBatchConfigProposal.title");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string description = 2 [json_name = "description"];
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.SetBatchConfigProposal.description");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated string signers = 3 [json_name = "signers"];
  for (int i = 0, n = this->_internal_signers_size(); i < n; ++i) {
    const auto& s = this->_internal_signers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.SetBatchConfigProposal.signers");
    target = stream->WriteString(3, s, target);
  }

  // repeated string transmitters = 4 [json_name = "transmitters"];
  for (int i = 0, n = this->_internal_transmitters_size(); i < n; ++i) {
    const auto& s = this->_internal_transmitters(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.SetBatchConfigProposal.transmitters");
    target = stream->WriteString(4, s, target);
  }

  // string link_denom = 5 [json_name = "linkDenom"];
  if (!this->_internal_link_denom().empty()) {
    const std::string& _s = this->_internal_link_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.SetBatchConfigProposal.link_denom");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // repeated .injective.ocr.v1beta1.FeedProperties feed_properties = 6 [json_name = "feedProperties"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_feed_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_feed_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.SetBatchConfigProposal)
  return target;
}

::size_t SetBatchConfigProposal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.SetBatchConfigProposal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string signers = 3 [json_name = "signers"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_signers().size());
  for (int i = 0, n = _internal_signers().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_signers().Get(i));
  }

  // repeated string transmitters = 4 [json_name = "transmitters"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_transmitters().size());
  for (int i = 0, n = _internal_transmitters().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_transmitters().Get(i));
  }

  // repeated .injective.ocr.v1beta1.FeedProperties feed_properties = 6 [json_name = "feedProperties"];
  total_size += 1UL * this->_internal_feed_properties_size();
  for (const auto& msg : this->_internal_feed_properties()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string title = 1 [json_name = "title"];
  if (!this->_internal_title().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_title());
  }

  // string description = 2 [json_name = "description"];
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  // string link_denom = 5 [json_name = "linkDenom"];
  if (!this->_internal_link_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_link_denom());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetBatchConfigProposal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetBatchConfigProposal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetBatchConfigProposal::GetClassData() const { return &_class_data_; }


void SetBatchConfigProposal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetBatchConfigProposal*>(&to_msg);
  auto& from = static_cast<const SetBatchConfigProposal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.SetBatchConfigProposal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_signers()->MergeFrom(from._internal_signers());
  _this->_internal_mutable_transmitters()->MergeFrom(from._internal_transmitters());
  _this->_internal_mutable_feed_properties()->MergeFrom(from._internal_feed_properties());
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_link_denom().empty()) {
    _this->_internal_set_link_denom(from._internal_link_denom());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetBatchConfigProposal::CopyFrom(const SetBatchConfigProposal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.SetBatchConfigProposal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetBatchConfigProposal::IsInitialized() const {
  return true;
}

void SetBatchConfigProposal::InternalSwap(SetBatchConfigProposal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_signers()->InternalSwap(
      other->_internal_mutable_signers());
  _internal_mutable_transmitters()->InternalSwap(
      other->_internal_mutable_transmitters());
  _internal_mutable_feed_properties()->InternalSwap(other->_internal_mutable_feed_properties());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena,
                                       &other->_impl_.title_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_denom_, lhs_arena,
                                       &other->_impl_.link_denom_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetBatchConfigProposal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[7]);
}
// ===================================================================

class OracleObservationsCounts::_Internal {
 public:
};

OracleObservationsCounts::OracleObservationsCounts(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.OracleObservationsCounts)
}
OracleObservationsCounts::OracleObservationsCounts(const OracleObservationsCounts& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OracleObservationsCounts* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.counts_) { from._impl_.counts_ }
    ,/* _impl_._counts_cached_byte_size_ = */ { 0 }

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.OracleObservationsCounts)
}

inline void OracleObservationsCounts::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.counts_) { arena }
    ,/* _impl_._counts_cached_byte_size_ = */ { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OracleObservationsCounts::~OracleObservationsCounts() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.OracleObservationsCounts)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OracleObservationsCounts::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.counts_.~RepeatedField();
}

void OracleObservationsCounts::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OracleObservationsCounts::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.OracleObservationsCounts)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_counts()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OracleObservationsCounts::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 counts = 1 [json_name = "counts"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_counts(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 8) {
          _internal_add_counts(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OracleObservationsCounts::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.OracleObservationsCounts)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 counts = 1 [json_name = "counts"];
  {
    int byte_size = _impl_._counts_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(1, _internal_counts(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.OracleObservationsCounts)
  return target;
}

::size_t OracleObservationsCounts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.OracleObservationsCounts)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 counts = 1 [json_name = "counts"];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_counts())
    ;
    _impl_._counts_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OracleObservationsCounts::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OracleObservationsCounts::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OracleObservationsCounts::GetClassData() const { return &_class_data_; }


void OracleObservationsCounts::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OracleObservationsCounts*>(&to_msg);
  auto& from = static_cast<const OracleObservationsCounts&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.OracleObservationsCounts)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.counts_.MergeFrom(from._impl_.counts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OracleObservationsCounts::CopyFrom(const OracleObservationsCounts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.OracleObservationsCounts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OracleObservationsCounts::IsInitialized() const {
  return true;
}

void OracleObservationsCounts::InternalSwap(OracleObservationsCounts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.counts_.InternalSwap(&other->_impl_.counts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OracleObservationsCounts::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[8]);
}
// ===================================================================

class GasReimbursements::_Internal {
 public:
};

void GasReimbursements::clear_reimbursements() {
  _internal_mutable_reimbursements()->Clear();
}
GasReimbursements::GasReimbursements(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.GasReimbursements)
}
GasReimbursements::GasReimbursements(const GasReimbursements& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GasReimbursements* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.reimbursements_){from._impl_.reimbursements_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.GasReimbursements)
}

inline void GasReimbursements::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.reimbursements_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GasReimbursements::~GasReimbursements() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.GasReimbursements)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GasReimbursements::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_reimbursements()->~RepeatedPtrField();
}

void GasReimbursements::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GasReimbursements::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.GasReimbursements)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_reimbursements()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GasReimbursements::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cosmos.base.v1beta1.Coin reimbursements = 1 [json_name = "reimbursements"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_reimbursements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GasReimbursements::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.GasReimbursements)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cosmos.base.v1beta1.Coin reimbursements = 1 [json_name = "reimbursements"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_reimbursements_size()); i < n; i++) {
    const auto& repfield = this->_internal_reimbursements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.GasReimbursements)
  return target;
}

::size_t GasReimbursements::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.GasReimbursements)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.base.v1beta1.Coin reimbursements = 1 [json_name = "reimbursements"];
  total_size += 1UL * this->_internal_reimbursements_size();
  for (const auto& msg : this->_internal_reimbursements()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GasReimbursements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GasReimbursements::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GasReimbursements::GetClassData() const { return &_class_data_; }


void GasReimbursements::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GasReimbursements*>(&to_msg);
  auto& from = static_cast<const GasReimbursements&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.GasReimbursements)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_reimbursements()->MergeFrom(from._internal_reimbursements());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GasReimbursements::CopyFrom(const GasReimbursements& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.GasReimbursements)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GasReimbursements::IsInitialized() const {
  return true;
}

void GasReimbursements::InternalSwap(GasReimbursements* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_reimbursements()->InternalSwap(other->_internal_mutable_reimbursements());
}

::PROTOBUF_NAMESPACE_ID::Metadata GasReimbursements::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[9]);
}
// ===================================================================

class Payee::_Internal {
 public:
};

Payee::Payee(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.Payee)
}
Payee::Payee(const Payee& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Payee* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transmitter_addr_) {}

    , decltype(_impl_.payment_addr_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transmitter_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transmitter_addr_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transmitter_addr().empty()) {
    _this->_impl_.transmitter_addr_.Set(from._internal_transmitter_addr(), _this->GetArenaForAllocation());
  }
  _impl_.payment_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payment_addr_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payment_addr().empty()) {
    _this->_impl_.payment_addr_.Set(from._internal_payment_addr(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.Payee)
}

inline void Payee::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.transmitter_addr_) {}

    , decltype(_impl_.payment_addr_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transmitter_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transmitter_addr_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payment_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payment_addr_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Payee::~Payee() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.Payee)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Payee::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transmitter_addr_.Destroy();
  _impl_.payment_addr_.Destroy();
}

void Payee::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Payee::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.Payee)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transmitter_addr_.ClearToEmpty();
  _impl_.payment_addr_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Payee::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transmitter_addr = 1 [json_name = "transmitterAddr"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transmitter_addr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.Payee.transmitter_addr"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string payment_addr = 2 [json_name = "paymentAddr"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payment_addr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.Payee.payment_addr"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Payee::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.Payee)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transmitter_addr = 1 [json_name = "transmitterAddr"];
  if (!this->_internal_transmitter_addr().empty()) {
    const std::string& _s = this->_internal_transmitter_addr();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.Payee.transmitter_addr");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string payment_addr = 2 [json_name = "paymentAddr"];
  if (!this->_internal_payment_addr().empty()) {
    const std::string& _s = this->_internal_payment_addr();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.Payee.payment_addr");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.Payee)
  return target;
}

::size_t Payee::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.Payee)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string transmitter_addr = 1 [json_name = "transmitterAddr"];
  if (!this->_internal_transmitter_addr().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_transmitter_addr());
  }

  // string payment_addr = 2 [json_name = "paymentAddr"];
  if (!this->_internal_payment_addr().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_payment_addr());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Payee::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Payee::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Payee::GetClassData() const { return &_class_data_; }


void Payee::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Payee*>(&to_msg);
  auto& from = static_cast<const Payee&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.Payee)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_transmitter_addr().empty()) {
    _this->_internal_set_transmitter_addr(from._internal_transmitter_addr());
  }
  if (!from._internal_payment_addr().empty()) {
    _this->_internal_set_payment_addr(from._internal_payment_addr());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Payee::CopyFrom(const Payee& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.Payee)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Payee::IsInitialized() const {
  return true;
}

void Payee::InternalSwap(Payee* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transmitter_addr_, lhs_arena,
                                       &other->_impl_.transmitter_addr_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payment_addr_, lhs_arena,
                                       &other->_impl_.payment_addr_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Payee::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[10]);
}
// ===================================================================

class Transmission::_Internal {
 public:
};

Transmission::Transmission(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.Transmission)
}
Transmission::Transmission(const Transmission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Transmission* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.answer_) {}

    , decltype(_impl_.observations_timestamp_) {}

    , decltype(_impl_.transmission_timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_answer().empty()) {
    _this->_impl_.answer_.Set(from._internal_answer(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.observations_timestamp_, &from._impl_.observations_timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.transmission_timestamp_) -
    reinterpret_cast<char*>(&_impl_.observations_timestamp_)) + sizeof(_impl_.transmission_timestamp_));
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.Transmission)
}

inline void Transmission::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.answer_) {}

    , decltype(_impl_.observations_timestamp_) { ::int64_t{0} }

    , decltype(_impl_.transmission_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Transmission::~Transmission() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.Transmission)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Transmission::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.answer_.Destroy();
}

void Transmission::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Transmission::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.Transmission)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.answer_.ClearToEmpty();
  ::memset(&_impl_.observations_timestamp_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.transmission_timestamp_) -
      reinterpret_cast<char*>(&_impl_.observations_timestamp_)) + sizeof(_impl_.transmission_timestamp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Transmission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string answer = 1 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_answer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.Transmission.answer"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 observations_timestamp = 2 [json_name = "observationsTimestamp"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.observations_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 transmission_timestamp = 3 [json_name = "transmissionTimestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.transmission_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Transmission::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.Transmission)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string answer = 1 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_answer().empty()) {
    const std::string& _s = this->_internal_answer();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.Transmission.answer");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // int64 observations_timestamp = 2 [json_name = "observationsTimestamp"];
  if (this->_internal_observations_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_observations_timestamp(), target);
  }

  // int64 transmission_timestamp = 3 [json_name = "transmissionTimestamp"];
  if (this->_internal_transmission_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_transmission_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.Transmission)
  return target;
}

::size_t Transmission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.Transmission)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string answer = 1 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_answer().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_answer());
  }

  // int64 observations_timestamp = 2 [json_name = "observationsTimestamp"];
  if (this->_internal_observations_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_observations_timestamp());
  }

  // int64 transmission_timestamp = 3 [json_name = "transmissionTimestamp"];
  if (this->_internal_transmission_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_transmission_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Transmission::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Transmission::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Transmission::GetClassData() const { return &_class_data_; }


void Transmission::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Transmission*>(&to_msg);
  auto& from = static_cast<const Transmission&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.Transmission)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_answer().empty()) {
    _this->_internal_set_answer(from._internal_answer());
  }
  if (from._internal_observations_timestamp() != 0) {
    _this->_internal_set_observations_timestamp(from._internal_observations_timestamp());
  }
  if (from._internal_transmission_timestamp() != 0) {
    _this->_internal_set_transmission_timestamp(from._internal_transmission_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Transmission::CopyFrom(const Transmission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.Transmission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission::IsInitialized() const {
  return true;
}

void Transmission::InternalSwap(Transmission* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.answer_, lhs_arena,
                                       &other->_impl_.answer_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Transmission, _impl_.transmission_timestamp_)
      + sizeof(Transmission::_impl_.transmission_timestamp_)
      - PROTOBUF_FIELD_OFFSET(Transmission, _impl_.observations_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.observations_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.observations_timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Transmission::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[11]);
}
// ===================================================================

class EpochAndRound::_Internal {
 public:
};

EpochAndRound::EpochAndRound(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.EpochAndRound)
}
EpochAndRound::EpochAndRound(const EpochAndRound& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.EpochAndRound)
}

inline void EpochAndRound::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.epoch_) { ::uint64_t{0u} }

    , decltype(_impl_.round_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EpochAndRound::~EpochAndRound() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.EpochAndRound)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EpochAndRound::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void EpochAndRound::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EpochAndRound::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.EpochAndRound)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.epoch_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.round_) -
      reinterpret_cast<char*>(&_impl_.epoch_)) + sizeof(_impl_.round_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EpochAndRound::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 epoch = 1 [json_name = "epoch"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 round = 2 [json_name = "round"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.round_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EpochAndRound::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.EpochAndRound)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 epoch = 1 [json_name = "epoch"];
  if (this->_internal_epoch() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_epoch(), target);
  }

  // uint64 round = 2 [json_name = "round"];
  if (this->_internal_round() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_round(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.EpochAndRound)
  return target;
}

::size_t EpochAndRound::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.EpochAndRound)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 epoch = 1 [json_name = "epoch"];
  if (this->_internal_epoch() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_epoch());
  }

  // uint64 round = 2 [json_name = "round"];
  if (this->_internal_round() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_round());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EpochAndRound::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EpochAndRound::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EpochAndRound::GetClassData() const { return &_class_data_; }


void EpochAndRound::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EpochAndRound*>(&to_msg);
  auto& from = static_cast<const EpochAndRound&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.EpochAndRound)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_epoch() != 0) {
    _this->_internal_set_epoch(from._internal_epoch());
  }
  if (from._internal_round() != 0) {
    _this->_internal_set_round(from._internal_round());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EpochAndRound::CopyFrom(const EpochAndRound& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.EpochAndRound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EpochAndRound::IsInitialized() const {
  return true;
}

void EpochAndRound::InternalSwap(EpochAndRound* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EpochAndRound, _impl_.round_)
      + sizeof(EpochAndRound::_impl_.round_)
      - PROTOBUF_FIELD_OFFSET(EpochAndRound, _impl_.epoch_)>(
          reinterpret_cast<char*>(&_impl_.epoch_),
          reinterpret_cast<char*>(&other->_impl_.epoch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EpochAndRound::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[12]);
}
// ===================================================================

class Report::_Internal {
 public:
};

Report::Report(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.Report)
}
Report::Report(const Report& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Report* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.observations_){from._impl_.observations_}
    , decltype(_impl_.observers_) {}

    , decltype(_impl_.observations_timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.observers_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.observers_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_observers().empty()) {
    _this->_impl_.observers_.Set(from._internal_observers(), _this->GetArenaForAllocation());
  }
  _this->_impl_.observations_timestamp_ = from._impl_.observations_timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.Report)
}

inline void Report::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.observations_){arena}
    , decltype(_impl_.observers_) {}

    , decltype(_impl_.observations_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.observers_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.observers_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Report::~Report() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.Report)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Report::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_observations()->~RepeatedPtrField();
  _impl_.observers_.Destroy();
}

void Report::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Report::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.Report)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_observations()->Clear();
  _impl_.observers_.ClearToEmpty();
  _impl_.observations_timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Report::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 observations_timestamp = 1 [json_name = "observationsTimestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.observations_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes observers = 2 [json_name = "observers"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_observers();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string observations = 3 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_observations();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.Report.observations"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Report::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.Report)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 observations_timestamp = 1 [json_name = "observationsTimestamp"];
  if (this->_internal_observations_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_observations_timestamp(), target);
  }

  // bytes observers = 2 [json_name = "observers"];
  if (!this->_internal_observers().empty()) {
    const std::string& _s = this->_internal_observers();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // repeated string observations = 3 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  for (int i = 0, n = this->_internal_observations_size(); i < n; ++i) {
    const auto& s = this->_internal_observations(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.Report.observations");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.Report)
  return target;
}

::size_t Report::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.Report)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string observations = 3 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_observations().size());
  for (int i = 0, n = _internal_observations().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_observations().Get(i));
  }

  // bytes observers = 2 [json_name = "observers"];
  if (!this->_internal_observers().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_observers());
  }

  // int64 observations_timestamp = 1 [json_name = "observationsTimestamp"];
  if (this->_internal_observations_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_observations_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Report::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Report::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Report::GetClassData() const { return &_class_data_; }


void Report::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Report*>(&to_msg);
  auto& from = static_cast<const Report&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.Report)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_observations()->MergeFrom(from._internal_observations());
  if (!from._internal_observers().empty()) {
    _this->_internal_set_observers(from._internal_observers());
  }
  if (from._internal_observations_timestamp() != 0) {
    _this->_internal_set_observations_timestamp(from._internal_observations_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Report::CopyFrom(const Report& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.Report)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Report::IsInitialized() const {
  return true;
}

void Report::InternalSwap(Report* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_observations()->InternalSwap(
      other->_internal_mutable_observations());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.observers_, lhs_arena,
                                       &other->_impl_.observers_, rhs_arena);

  swap(_impl_.observations_timestamp_, other->_impl_.observations_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Report::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[13]);
}
// ===================================================================

class ReportToSign::_Internal {
 public:
};

ReportToSign::ReportToSign(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.ReportToSign)
}
ReportToSign::ReportToSign(const ReportToSign& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReportToSign* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.config_digest_) {}

    , decltype(_impl_.extra_hash_) {}

    , decltype(_impl_.report_) {}

    , decltype(_impl_.epoch_) {}

    , decltype(_impl_.round_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_config_digest().empty()) {
    _this->_impl_.config_digest_.Set(from._internal_config_digest(), _this->GetArenaForAllocation());
  }
  _impl_.extra_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.extra_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_extra_hash().empty()) {
    _this->_impl_.extra_hash_.Set(from._internal_extra_hash(), _this->GetArenaForAllocation());
  }
  _impl_.report_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.report_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_report().empty()) {
    _this->_impl_.report_.Set(from._internal_report(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.epoch_, &from._impl_.epoch_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.round_) -
    reinterpret_cast<char*>(&_impl_.epoch_)) + sizeof(_impl_.round_));
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.ReportToSign)
}

inline void ReportToSign::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.config_digest_) {}

    , decltype(_impl_.extra_hash_) {}

    , decltype(_impl_.report_) {}

    , decltype(_impl_.epoch_) { ::uint64_t{0u} }

    , decltype(_impl_.round_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extra_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.extra_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.report_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.report_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReportToSign::~ReportToSign() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.ReportToSign)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReportToSign::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.config_digest_.Destroy();
  _impl_.extra_hash_.Destroy();
  _impl_.report_.Destroy();
}

void ReportToSign::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReportToSign::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.ReportToSign)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.config_digest_.ClearToEmpty();
  _impl_.extra_hash_.ClearToEmpty();
  _impl_.report_.ClearToEmpty();
  ::memset(&_impl_.epoch_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.round_) -
      reinterpret_cast<char*>(&_impl_.epoch_)) + sizeof(_impl_.round_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReportToSign::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes config_digest = 1 [json_name = "configDigest"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_config_digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 epoch = 2 [json_name = "epoch"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 round = 3 [json_name = "round"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.round_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes extra_hash = 4 [json_name = "extraHash"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_extra_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes report = 5 [json_name = "report"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_report();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReportToSign::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.ReportToSign)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes config_digest = 1 [json_name = "configDigest"];
  if (!this->_internal_config_digest().empty()) {
    const std::string& _s = this->_internal_config_digest();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // uint64 epoch = 2 [json_name = "epoch"];
  if (this->_internal_epoch() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_epoch(), target);
  }

  // uint64 round = 3 [json_name = "round"];
  if (this->_internal_round() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_round(), target);
  }

  // bytes extra_hash = 4 [json_name = "extraHash"];
  if (!this->_internal_extra_hash().empty()) {
    const std::string& _s = this->_internal_extra_hash();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  // bytes report = 5 [json_name = "report"];
  if (!this->_internal_report().empty()) {
    const std::string& _s = this->_internal_report();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.ReportToSign)
  return target;
}

::size_t ReportToSign::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.ReportToSign)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes config_digest = 1 [json_name = "configDigest"];
  if (!this->_internal_config_digest().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_config_digest());
  }

  // bytes extra_hash = 4 [json_name = "extraHash"];
  if (!this->_internal_extra_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_extra_hash());
  }

  // bytes report = 5 [json_name = "report"];
  if (!this->_internal_report().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_report());
  }

  // uint64 epoch = 2 [json_name = "epoch"];
  if (this->_internal_epoch() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_epoch());
  }

  // uint64 round = 3 [json_name = "round"];
  if (this->_internal_round() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_round());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReportToSign::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReportToSign::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReportToSign::GetClassData() const { return &_class_data_; }


void ReportToSign::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReportToSign*>(&to_msg);
  auto& from = static_cast<const ReportToSign&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.ReportToSign)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_config_digest().empty()) {
    _this->_internal_set_config_digest(from._internal_config_digest());
  }
  if (!from._internal_extra_hash().empty()) {
    _this->_internal_set_extra_hash(from._internal_extra_hash());
  }
  if (!from._internal_report().empty()) {
    _this->_internal_set_report(from._internal_report());
  }
  if (from._internal_epoch() != 0) {
    _this->_internal_set_epoch(from._internal_epoch());
  }
  if (from._internal_round() != 0) {
    _this->_internal_set_round(from._internal_round());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReportToSign::CopyFrom(const ReportToSign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.ReportToSign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReportToSign::IsInitialized() const {
  return true;
}

void ReportToSign::InternalSwap(ReportToSign* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.config_digest_, lhs_arena,
                                       &other->_impl_.config_digest_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.extra_hash_, lhs_arena,
                                       &other->_impl_.extra_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.report_, lhs_arena,
                                       &other->_impl_.report_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReportToSign, _impl_.round_)
      + sizeof(ReportToSign::_impl_.round_)
      - PROTOBUF_FIELD_OFFSET(ReportToSign, _impl_.epoch_)>(
          reinterpret_cast<char*>(&_impl_.epoch_),
          reinterpret_cast<char*>(&other->_impl_.epoch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReportToSign::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[14]);
}
// ===================================================================

class EventOraclePaid::_Internal {
 public:
  using HasBits = decltype(std::declval<EventOraclePaid>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventOraclePaid, _impl_._has_bits_);
  static const ::cosmos::base::v1beta1::Coin& amount(const EventOraclePaid* msg);
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cosmos::base::v1beta1::Coin&
EventOraclePaid::_Internal::amount(const EventOraclePaid* msg) {
  return *msg->_impl_.amount_;
}
void EventOraclePaid::clear_amount() {
  if (_impl_.amount_ != nullptr) _impl_.amount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventOraclePaid::EventOraclePaid(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.EventOraclePaid)
}
EventOraclePaid::EventOraclePaid(const EventOraclePaid& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventOraclePaid* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transmitter_addr_) {}

    , decltype(_impl_.payee_addr_) {}

    , decltype(_impl_.amount_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transmitter_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transmitter_addr_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transmitter_addr().empty()) {
    _this->_impl_.transmitter_addr_.Set(from._internal_transmitter_addr(), _this->GetArenaForAllocation());
  }
  _impl_.payee_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payee_addr_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payee_addr().empty()) {
    _this->_impl_.payee_addr_.Set(from._internal_payee_addr(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.amount_ = new ::cosmos::base::v1beta1::Coin(*from._impl_.amount_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.EventOraclePaid)
}

inline void EventOraclePaid::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transmitter_addr_) {}

    , decltype(_impl_.payee_addr_) {}

    , decltype(_impl_.amount_){nullptr}
  };
  _impl_.transmitter_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transmitter_addr_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payee_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payee_addr_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventOraclePaid::~EventOraclePaid() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.EventOraclePaid)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventOraclePaid::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transmitter_addr_.Destroy();
  _impl_.payee_addr_.Destroy();
  if (this != internal_default_instance()) delete _impl_.amount_;
}

void EventOraclePaid::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventOraclePaid::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.EventOraclePaid)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transmitter_addr_.ClearToEmpty();
  _impl_.payee_addr_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.amount_ != nullptr);
    _impl_.amount_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventOraclePaid::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transmitter_addr = 1 [json_name = "transmitterAddr"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transmitter_addr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventOraclePaid.transmitter_addr"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string payee_addr = 2 [json_name = "payeeAddr"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payee_addr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventOraclePaid.payee_addr"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_amount(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventOraclePaid::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.EventOraclePaid)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transmitter_addr = 1 [json_name = "transmitterAddr"];
  if (!this->_internal_transmitter_addr().empty()) {
    const std::string& _s = this->_internal_transmitter_addr();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventOraclePaid.transmitter_addr");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string payee_addr = 2 [json_name = "payeeAddr"];
  if (!this->_internal_payee_addr().empty()) {
    const std::string& _s = this->_internal_payee_addr();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventOraclePaid.payee_addr");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::amount(this),
        _Internal::amount(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.EventOraclePaid)
  return target;
}

::size_t EventOraclePaid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.EventOraclePaid)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string transmitter_addr = 1 [json_name = "transmitterAddr"];
  if (!this->_internal_transmitter_addr().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_transmitter_addr());
  }

  // string payee_addr = 2 [json_name = "payeeAddr"];
  if (!this->_internal_payee_addr().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_payee_addr());
  }

  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.amount_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventOraclePaid::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventOraclePaid::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventOraclePaid::GetClassData() const { return &_class_data_; }


void EventOraclePaid::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventOraclePaid*>(&to_msg);
  auto& from = static_cast<const EventOraclePaid&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.EventOraclePaid)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_transmitter_addr().empty()) {
    _this->_internal_set_transmitter_addr(from._internal_transmitter_addr());
  }
  if (!from._internal_payee_addr().empty()) {
    _this->_internal_set_payee_addr(from._internal_payee_addr());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_amount()->::cosmos::base::v1beta1::Coin::MergeFrom(
        from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventOraclePaid::CopyFrom(const EventOraclePaid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.EventOraclePaid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventOraclePaid::IsInitialized() const {
  return true;
}

void EventOraclePaid::InternalSwap(EventOraclePaid* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transmitter_addr_, lhs_arena,
                                       &other->_impl_.transmitter_addr_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payee_addr_, lhs_arena,
                                       &other->_impl_.payee_addr_, rhs_arena);
  swap(_impl_.amount_, other->_impl_.amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventOraclePaid::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[15]);
}
// ===================================================================

class EventAnswerUpdated::_Internal {
 public:
  using HasBits = decltype(std::declval<EventAnswerUpdated>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventAnswerUpdated, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at(const EventAnswerUpdated* msg);
  static void set_has_updated_at(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
EventAnswerUpdated::_Internal::updated_at(const EventAnswerUpdated* msg) {
  return *msg->_impl_.updated_at_;
}
void EventAnswerUpdated::clear_updated_at() {
  if (_impl_.updated_at_ != nullptr) _impl_.updated_at_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventAnswerUpdated::EventAnswerUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.EventAnswerUpdated)
}
EventAnswerUpdated::EventAnswerUpdated(const EventAnswerUpdated& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventAnswerUpdated* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.current_) {}

    , decltype(_impl_.round_id_) {}

    , decltype(_impl_.updated_at_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.current_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.current_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_current().empty()) {
    _this->_impl_.current_.Set(from._internal_current(), _this->GetArenaForAllocation());
  }
  _impl_.round_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.round_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_round_id().empty()) {
    _this->_impl_.round_id_.Set(from._internal_round_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.updated_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.updated_at_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.EventAnswerUpdated)
}

inline void EventAnswerUpdated::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.current_) {}

    , decltype(_impl_.round_id_) {}

    , decltype(_impl_.updated_at_){nullptr}
  };
  _impl_.current_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.current_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.round_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.round_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventAnswerUpdated::~EventAnswerUpdated() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.EventAnswerUpdated)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventAnswerUpdated::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.current_.Destroy();
  _impl_.round_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.updated_at_;
}

void EventAnswerUpdated::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventAnswerUpdated::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.EventAnswerUpdated)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.current_.ClearToEmpty();
  _impl_.round_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.updated_at_ != nullptr);
    _impl_.updated_at_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventAnswerUpdated::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string current = 1 [json_name = "current", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_current();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventAnswerUpdated.current"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string round_id = 2 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_round_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventAnswerUpdated.round_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp updated_at = 3 [json_name = "updatedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_updated_at(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventAnswerUpdated::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.EventAnswerUpdated)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string current = 1 [json_name = "current", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_current().empty()) {
    const std::string& _s = this->_internal_current();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventAnswerUpdated.current");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string round_id = 2 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_round_id().empty()) {
    const std::string& _s = this->_internal_round_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventAnswerUpdated.round_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Timestamp updated_at = 3 [json_name = "updatedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::updated_at(this),
        _Internal::updated_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.EventAnswerUpdated)
  return target;
}

::size_t EventAnswerUpdated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.EventAnswerUpdated)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string current = 1 [json_name = "current", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_current().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_current());
  }

  // string round_id = 2 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_round_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_round_id());
  }

  // .google.protobuf.Timestamp updated_at = 3 [json_name = "updatedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.updated_at_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventAnswerUpdated::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventAnswerUpdated::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventAnswerUpdated::GetClassData() const { return &_class_data_; }


void EventAnswerUpdated::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventAnswerUpdated*>(&to_msg);
  auto& from = static_cast<const EventAnswerUpdated&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.EventAnswerUpdated)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_current().empty()) {
    _this->_internal_set_current(from._internal_current());
  }
  if (!from._internal_round_id().empty()) {
    _this->_internal_set_round_id(from._internal_round_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_updated_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_updated_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventAnswerUpdated::CopyFrom(const EventAnswerUpdated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.EventAnswerUpdated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventAnswerUpdated::IsInitialized() const {
  return true;
}

void EventAnswerUpdated::InternalSwap(EventAnswerUpdated* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.current_, lhs_arena,
                                       &other->_impl_.current_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.round_id_, lhs_arena,
                                       &other->_impl_.round_id_, rhs_arena);
  swap(_impl_.updated_at_, other->_impl_.updated_at_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventAnswerUpdated::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[16]);
}
// ===================================================================

class EventNewRound::_Internal {
 public:
  using HasBits = decltype(std::declval<EventNewRound>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventNewRound, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& started_at(const EventNewRound* msg);
  static void set_has_started_at(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
EventNewRound::_Internal::started_at(const EventNewRound* msg) {
  return *msg->_impl_.started_at_;
}
void EventNewRound::clear_started_at() {
  if (_impl_.started_at_ != nullptr) _impl_.started_at_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventNewRound::EventNewRound(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.EventNewRound)
}
EventNewRound::EventNewRound(const EventNewRound& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventNewRound* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.round_id_) {}

    , decltype(_impl_.started_by_) {}

    , decltype(_impl_.started_at_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.round_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.round_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_round_id().empty()) {
    _this->_impl_.round_id_.Set(from._internal_round_id(), _this->GetArenaForAllocation());
  }
  _impl_.started_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.started_by_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_started_by().empty()) {
    _this->_impl_.started_by_.Set(from._internal_started_by(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.started_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.started_at_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.EventNewRound)
}

inline void EventNewRound::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.round_id_) {}

    , decltype(_impl_.started_by_) {}

    , decltype(_impl_.started_at_){nullptr}
  };
  _impl_.round_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.round_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.started_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.started_by_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventNewRound::~EventNewRound() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.EventNewRound)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventNewRound::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.round_id_.Destroy();
  _impl_.started_by_.Destroy();
  if (this != internal_default_instance()) delete _impl_.started_at_;
}

void EventNewRound::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventNewRound::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.EventNewRound)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.round_id_.ClearToEmpty();
  _impl_.started_by_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.started_at_ != nullptr);
    _impl_.started_at_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventNewRound::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string round_id = 1 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_round_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventNewRound.round_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string started_by = 2 [json_name = "startedBy"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_started_by();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventNewRound.started_by"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp started_at = 3 [json_name = "startedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_started_at(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventNewRound::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.EventNewRound)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string round_id = 1 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_round_id().empty()) {
    const std::string& _s = this->_internal_round_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventNewRound.round_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string started_by = 2 [json_name = "startedBy"];
  if (!this->_internal_started_by().empty()) {
    const std::string& _s = this->_internal_started_by();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventNewRound.started_by");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Timestamp started_at = 3 [json_name = "startedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::started_at(this),
        _Internal::started_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.EventNewRound)
  return target;
}

::size_t EventNewRound::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.EventNewRound)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string round_id = 1 [json_name = "roundId", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_round_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_round_id());
  }

  // string started_by = 2 [json_name = "startedBy"];
  if (!this->_internal_started_by().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_started_by());
  }

  // .google.protobuf.Timestamp started_at = 3 [json_name = "startedAt", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.started_at_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventNewRound::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventNewRound::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventNewRound::GetClassData() const { return &_class_data_; }


void EventNewRound::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventNewRound*>(&to_msg);
  auto& from = static_cast<const EventNewRound&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.EventNewRound)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_round_id().empty()) {
    _this->_internal_set_round_id(from._internal_round_id());
  }
  if (!from._internal_started_by().empty()) {
    _this->_internal_set_started_by(from._internal_started_by());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_started_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_started_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventNewRound::CopyFrom(const EventNewRound& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.EventNewRound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventNewRound::IsInitialized() const {
  return true;
}

void EventNewRound::InternalSwap(EventNewRound* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.round_id_, lhs_arena,
                                       &other->_impl_.round_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.started_by_, lhs_arena,
                                       &other->_impl_.started_by_, rhs_arena);
  swap(_impl_.started_at_, other->_impl_.started_at_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventNewRound::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[17]);
}
// ===================================================================

class EventTransmitted::_Internal {
 public:
};

EventTransmitted::EventTransmitted(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.EventTransmitted)
}
EventTransmitted::EventTransmitted(const EventTransmitted& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventTransmitted* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.config_digest_) {}

    , decltype(_impl_.epoch_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_config_digest().empty()) {
    _this->_impl_.config_digest_.Set(from._internal_config_digest(), _this->GetArenaForAllocation());
  }
  _this->_impl_.epoch_ = from._impl_.epoch_;
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.EventTransmitted)
}

inline void EventTransmitted::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.config_digest_) {}

    , decltype(_impl_.epoch_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventTransmitted::~EventTransmitted() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.EventTransmitted)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventTransmitted::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.config_digest_.Destroy();
}

void EventTransmitted::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventTransmitted::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.EventTransmitted)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.config_digest_.ClearToEmpty();
  _impl_.epoch_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventTransmitted::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes config_digest = 1 [json_name = "configDigest"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_config_digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 epoch = 2 [json_name = "epoch"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventTransmitted::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.EventTransmitted)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes config_digest = 1 [json_name = "configDigest"];
  if (!this->_internal_config_digest().empty()) {
    const std::string& _s = this->_internal_config_digest();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // uint64 epoch = 2 [json_name = "epoch"];
  if (this->_internal_epoch() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_epoch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.EventTransmitted)
  return target;
}

::size_t EventTransmitted::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.EventTransmitted)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes config_digest = 1 [json_name = "configDigest"];
  if (!this->_internal_config_digest().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_config_digest());
  }

  // uint64 epoch = 2 [json_name = "epoch"];
  if (this->_internal_epoch() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_epoch());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventTransmitted::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventTransmitted::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventTransmitted::GetClassData() const { return &_class_data_; }


void EventTransmitted::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventTransmitted*>(&to_msg);
  auto& from = static_cast<const EventTransmitted&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.EventTransmitted)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_config_digest().empty()) {
    _this->_internal_set_config_digest(from._internal_config_digest());
  }
  if (from._internal_epoch() != 0) {
    _this->_internal_set_epoch(from._internal_epoch());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventTransmitted::CopyFrom(const EventTransmitted& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.EventTransmitted)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventTransmitted::IsInitialized() const {
  return true;
}

void EventTransmitted::InternalSwap(EventTransmitted* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.config_digest_, lhs_arena,
                                       &other->_impl_.config_digest_, rhs_arena);

  swap(_impl_.epoch_, other->_impl_.epoch_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventTransmitted::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[18]);
}
// ===================================================================

class EventNewTransmission::_Internal {
 public:
  using HasBits = decltype(std::declval<EventNewTransmission>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventNewTransmission, _impl_._has_bits_);
  static const ::injective::ocr::v1beta1::EpochAndRound& epoch_and_round(const EventNewTransmission* msg);
  static void set_has_epoch_and_round(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::ocr::v1beta1::EpochAndRound&
EventNewTransmission::_Internal::epoch_and_round(const EventNewTransmission* msg) {
  return *msg->_impl_.epoch_and_round_;
}
EventNewTransmission::EventNewTransmission(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.EventNewTransmission)
}
EventNewTransmission::EventNewTransmission(const EventNewTransmission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventNewTransmission* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.observations_){from._impl_.observations_}
    , decltype(_impl_.feed_id_) {}

    , decltype(_impl_.answer_) {}

    , decltype(_impl_.transmitter_) {}

    , decltype(_impl_.observers_) {}

    , decltype(_impl_.config_digest_) {}

    , decltype(_impl_.epoch_and_round_){nullptr}
    , decltype(_impl_.observations_timestamp_) {}

    , decltype(_impl_.aggregator_round_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.feed_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_feed_id().empty()) {
    _this->_impl_.feed_id_.Set(from._internal_feed_id(), _this->GetArenaForAllocation());
  }
  _impl_.answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_answer().empty()) {
    _this->_impl_.answer_.Set(from._internal_answer(), _this->GetArenaForAllocation());
  }
  _impl_.transmitter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transmitter_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transmitter().empty()) {
    _this->_impl_.transmitter_.Set(from._internal_transmitter(), _this->GetArenaForAllocation());
  }
  _impl_.observers_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.observers_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_observers().empty()) {
    _this->_impl_.observers_.Set(from._internal_observers(), _this->GetArenaForAllocation());
  }
  _impl_.config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_config_digest().empty()) {
    _this->_impl_.config_digest_.Set(from._internal_config_digest(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.epoch_and_round_ = new ::injective::ocr::v1beta1::EpochAndRound(*from._impl_.epoch_and_round_);
  }
  ::memcpy(&_impl_.observations_timestamp_, &from._impl_.observations_timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.aggregator_round_id_) -
    reinterpret_cast<char*>(&_impl_.observations_timestamp_)) + sizeof(_impl_.aggregator_round_id_));
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.EventNewTransmission)
}

inline void EventNewTransmission::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.observations_){arena}
    , decltype(_impl_.feed_id_) {}

    , decltype(_impl_.answer_) {}

    , decltype(_impl_.transmitter_) {}

    , decltype(_impl_.observers_) {}

    , decltype(_impl_.config_digest_) {}

    , decltype(_impl_.epoch_and_round_){nullptr}
    , decltype(_impl_.observations_timestamp_) { ::int64_t{0} }

    , decltype(_impl_.aggregator_round_id_) { 0u }

  };
  _impl_.feed_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transmitter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transmitter_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.observers_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.observers_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventNewTransmission::~EventNewTransmission() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.EventNewTransmission)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventNewTransmission::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_observations()->~RepeatedPtrField();
  _impl_.feed_id_.Destroy();
  _impl_.answer_.Destroy();
  _impl_.transmitter_.Destroy();
  _impl_.observers_.Destroy();
  _impl_.config_digest_.Destroy();
  if (this != internal_default_instance()) delete _impl_.epoch_and_round_;
}

void EventNewTransmission::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventNewTransmission::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.EventNewTransmission)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_observations()->Clear();
  _impl_.feed_id_.ClearToEmpty();
  _impl_.answer_.ClearToEmpty();
  _impl_.transmitter_.ClearToEmpty();
  _impl_.observers_.ClearToEmpty();
  _impl_.config_digest_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.epoch_and_round_ != nullptr);
    _impl_.epoch_and_round_->Clear();
  }
  ::memset(&_impl_.observations_timestamp_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.aggregator_round_id_) -
      reinterpret_cast<char*>(&_impl_.observations_timestamp_)) + sizeof(_impl_.aggregator_round_id_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventNewTransmission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string feed_id = 1 [json_name = "feedId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_feed_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventNewTransmission.feed_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 aggregator_round_id = 2 [json_name = "aggregatorRoundId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.aggregator_round_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string answer = 3 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_answer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventNewTransmission.answer"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string transmitter = 4 [json_name = "transmitter"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_transmitter();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventNewTransmission.transmitter"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 observations_timestamp = 5 [json_name = "observationsTimestamp"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.observations_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string observations = 6 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_observations();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.ocr.v1beta1.EventNewTransmission.observations"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes observers = 7 [json_name = "observers"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_observers();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes config_digest = 8 [json_name = "configDigest"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_config_digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9 [json_name = "epochAndRound"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_epoch_and_round(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventNewTransmission::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.EventNewTransmission)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string feed_id = 1 [json_name = "feedId"];
  if (!this->_internal_feed_id().empty()) {
    const std::string& _s = this->_internal_feed_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventNewTransmission.feed_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint32 aggregator_round_id = 2 [json_name = "aggregatorRoundId"];
  if (this->_internal_aggregator_round_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_aggregator_round_id(), target);
  }

  // string answer = 3 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_answer().empty()) {
    const std::string& _s = this->_internal_answer();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventNewTransmission.answer");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string transmitter = 4 [json_name = "transmitter"];
  if (!this->_internal_transmitter().empty()) {
    const std::string& _s = this->_internal_transmitter();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventNewTransmission.transmitter");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // int64 observations_timestamp = 5 [json_name = "observationsTimestamp"];
  if (this->_internal_observations_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_observations_timestamp(), target);
  }

  // repeated string observations = 6 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  for (int i = 0, n = this->_internal_observations_size(); i < n; ++i) {
    const auto& s = this->_internal_observations(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.ocr.v1beta1.EventNewTransmission.observations");
    target = stream->WriteString(6, s, target);
  }

  // bytes observers = 7 [json_name = "observers"];
  if (!this->_internal_observers().empty()) {
    const std::string& _s = this->_internal_observers();
    target = stream->WriteBytesMaybeAliased(7, _s, target);
  }

  // bytes config_digest = 8 [json_name = "configDigest"];
  if (!this->_internal_config_digest().empty()) {
    const std::string& _s = this->_internal_config_digest();
    target = stream->WriteBytesMaybeAliased(8, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9 [json_name = "epochAndRound"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::epoch_and_round(this),
        _Internal::epoch_and_round(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.EventNewTransmission)
  return target;
}

::size_t EventNewTransmission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.EventNewTransmission)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string observations = 6 [json_name = "observations", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_observations().size());
  for (int i = 0, n = _internal_observations().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_observations().Get(i));
  }

  // string feed_id = 1 [json_name = "feedId"];
  if (!this->_internal_feed_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_feed_id());
  }

  // string answer = 3 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_answer().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_answer());
  }

  // string transmitter = 4 [json_name = "transmitter"];
  if (!this->_internal_transmitter().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_transmitter());
  }

  // bytes observers = 7 [json_name = "observers"];
  if (!this->_internal_observers().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_observers());
  }

  // bytes config_digest = 8 [json_name = "configDigest"];
  if (!this->_internal_config_digest().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_config_digest());
  }

  // .injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9 [json_name = "epochAndRound"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.epoch_and_round_);
  }

  // int64 observations_timestamp = 5 [json_name = "observationsTimestamp"];
  if (this->_internal_observations_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_observations_timestamp());
  }

  // uint32 aggregator_round_id = 2 [json_name = "aggregatorRoundId"];
  if (this->_internal_aggregator_round_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_aggregator_round_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventNewTransmission::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventNewTransmission::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventNewTransmission::GetClassData() const { return &_class_data_; }


void EventNewTransmission::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventNewTransmission*>(&to_msg);
  auto& from = static_cast<const EventNewTransmission&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.EventNewTransmission)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_observations()->MergeFrom(from._internal_observations());
  if (!from._internal_feed_id().empty()) {
    _this->_internal_set_feed_id(from._internal_feed_id());
  }
  if (!from._internal_answer().empty()) {
    _this->_internal_set_answer(from._internal_answer());
  }
  if (!from._internal_transmitter().empty()) {
    _this->_internal_set_transmitter(from._internal_transmitter());
  }
  if (!from._internal_observers().empty()) {
    _this->_internal_set_observers(from._internal_observers());
  }
  if (!from._internal_config_digest().empty()) {
    _this->_internal_set_config_digest(from._internal_config_digest());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_epoch_and_round()->::injective::ocr::v1beta1::EpochAndRound::MergeFrom(
        from._internal_epoch_and_round());
  }
  if (from._internal_observations_timestamp() != 0) {
    _this->_internal_set_observations_timestamp(from._internal_observations_timestamp());
  }
  if (from._internal_aggregator_round_id() != 0) {
    _this->_internal_set_aggregator_round_id(from._internal_aggregator_round_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventNewTransmission::CopyFrom(const EventNewTransmission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.EventNewTransmission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventNewTransmission::IsInitialized() const {
  return true;
}

void EventNewTransmission::InternalSwap(EventNewTransmission* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_observations()->InternalSwap(
      other->_internal_mutable_observations());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.feed_id_, lhs_arena,
                                       &other->_impl_.feed_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.answer_, lhs_arena,
                                       &other->_impl_.answer_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transmitter_, lhs_arena,
                                       &other->_impl_.transmitter_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.observers_, lhs_arena,
                                       &other->_impl_.observers_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.config_digest_, lhs_arena,
                                       &other->_impl_.config_digest_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventNewTransmission, _impl_.aggregator_round_id_)
      + sizeof(EventNewTransmission::_impl_.aggregator_round_id_)
      - PROTOBUF_FIELD_OFFSET(EventNewTransmission, _impl_.epoch_and_round_)>(
          reinterpret_cast<char*>(&_impl_.epoch_and_round_),
          reinterpret_cast<char*>(&other->_impl_.epoch_and_round_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventNewTransmission::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[19]);
}
// ===================================================================

class EventConfigSet::_Internal {
 public:
  using HasBits = decltype(std::declval<EventConfigSet>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventConfigSet, _impl_._has_bits_);
  static const ::injective::ocr::v1beta1::FeedConfig& config(const EventConfigSet* msg);
  static void set_has_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::injective::ocr::v1beta1::FeedConfigInfo& config_info(const EventConfigSet* msg);
  static void set_has_config_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::injective::ocr::v1beta1::FeedConfig&
EventConfigSet::_Internal::config(const EventConfigSet* msg) {
  return *msg->_impl_.config_;
}
const ::injective::ocr::v1beta1::FeedConfigInfo&
EventConfigSet::_Internal::config_info(const EventConfigSet* msg) {
  return *msg->_impl_.config_info_;
}
EventConfigSet::EventConfigSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.ocr.v1beta1.EventConfigSet)
}
EventConfigSet::EventConfigSet(const EventConfigSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventConfigSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.config_digest_) {}

    , decltype(_impl_.config_){nullptr}
    , decltype(_impl_.config_info_){nullptr}
    , decltype(_impl_.previous_config_block_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_config_digest().empty()) {
    _this->_impl_.config_digest_.Set(from._internal_config_digest(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.config_ = new ::injective::ocr::v1beta1::FeedConfig(*from._impl_.config_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.config_info_ = new ::injective::ocr::v1beta1::FeedConfigInfo(*from._impl_.config_info_);
  }
  _this->_impl_.previous_config_block_number_ = from._impl_.previous_config_block_number_;
  // @@protoc_insertion_point(copy_constructor:injective.ocr.v1beta1.EventConfigSet)
}

inline void EventConfigSet::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.config_digest_) {}

    , decltype(_impl_.config_){nullptr}
    , decltype(_impl_.config_info_){nullptr}
    , decltype(_impl_.previous_config_block_number_) { ::int64_t{0} }

  };
  _impl_.config_digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.config_digest_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventConfigSet::~EventConfigSet() {
  // @@protoc_insertion_point(destructor:injective.ocr.v1beta1.EventConfigSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventConfigSet::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.config_digest_.Destroy();
  if (this != internal_default_instance()) delete _impl_.config_;
  if (this != internal_default_instance()) delete _impl_.config_info_;
}

void EventConfigSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventConfigSet::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.ocr.v1beta1.EventConfigSet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.config_digest_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.config_ != nullptr);
      _impl_.config_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.config_info_ != nullptr);
      _impl_.config_info_->Clear();
    }
  }
  _impl_.previous_config_block_number_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventConfigSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes config_digest = 1 [json_name = "configDigest"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_config_digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 previous_config_block_number = 2 [json_name = "previousConfigBlockNumber"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.previous_config_block_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.ocr.v1beta1.FeedConfigInfo config_info = 4 [json_name = "configInfo"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_config_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventConfigSet::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.ocr.v1beta1.EventConfigSet)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes config_digest = 1 [json_name = "configDigest"];
  if (!this->_internal_config_digest().empty()) {
    const std::string& _s = this->_internal_config_digest();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // int64 previous_config_block_number = 2 [json_name = "previousConfigBlockNumber"];
  if (this->_internal_previous_config_block_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_previous_config_block_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  // .injective.ocr.v1beta1.FeedConfigInfo config_info = 4 [json_name = "configInfo"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::config_info(this),
        _Internal::config_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.ocr.v1beta1.EventConfigSet)
  return target;
}

::size_t EventConfigSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.ocr.v1beta1.EventConfigSet)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes config_digest = 1 [json_name = "configDigest"];
  if (!this->_internal_config_digest().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_config_digest());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .injective.ocr.v1beta1.FeedConfig config = 3 [json_name = "config"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_);
    }

    // .injective.ocr.v1beta1.FeedConfigInfo config_info = 4 [json_name = "configInfo"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_info_);
    }

  }
  // int64 previous_config_block_number = 2 [json_name = "previousConfigBlockNumber"];
  if (this->_internal_previous_config_block_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_previous_config_block_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventConfigSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventConfigSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventConfigSet::GetClassData() const { return &_class_data_; }


void EventConfigSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventConfigSet*>(&to_msg);
  auto& from = static_cast<const EventConfigSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.ocr.v1beta1.EventConfigSet)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_config_digest().empty()) {
    _this->_internal_set_config_digest(from._internal_config_digest());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_config()->::injective::ocr::v1beta1::FeedConfig::MergeFrom(
          from._internal_config());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_config_info()->::injective::ocr::v1beta1::FeedConfigInfo::MergeFrom(
          from._internal_config_info());
    }
  }
  if (from._internal_previous_config_block_number() != 0) {
    _this->_internal_set_previous_config_block_number(from._internal_previous_config_block_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventConfigSet::CopyFrom(const EventConfigSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.ocr.v1beta1.EventConfigSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventConfigSet::IsInitialized() const {
  return true;
}

void EventConfigSet::InternalSwap(EventConfigSet* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.config_digest_, lhs_arena,
                                       &other->_impl_.config_digest_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventConfigSet, _impl_.previous_config_block_number_)
      + sizeof(EventConfigSet::_impl_.previous_config_block_number_)
      - PROTOBUF_FIELD_OFFSET(EventConfigSet, _impl_.config_)>(
          reinterpret_cast<char*>(&_impl_.config_),
          reinterpret_cast<char*>(&other->_impl_.config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventConfigSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_getter, &descriptor_table_injective_2focr_2fv1beta1_2focr_2eproto_once,
      file_level_metadata_injective_2focr_2fv1beta1_2focr_2eproto[20]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace ocr
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::Params*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::Params >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::FeedConfig*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::FeedConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::FeedConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::FeedConfigInfo*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::FeedConfigInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::FeedConfigInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::ModuleParams*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::ModuleParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::ModuleParams >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::ContractConfig*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::ContractConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::ContractConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::SetConfigProposal*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::SetConfigProposal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::SetConfigProposal >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::FeedProperties*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::FeedProperties >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::FeedProperties >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::SetBatchConfigProposal*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::SetBatchConfigProposal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::SetBatchConfigProposal >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::OracleObservationsCounts*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::OracleObservationsCounts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::OracleObservationsCounts >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::GasReimbursements*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::GasReimbursements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::GasReimbursements >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::Payee*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::Payee >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::Payee >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::Transmission*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::Transmission >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::Transmission >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::EpochAndRound*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::EpochAndRound >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::EpochAndRound >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::Report*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::Report >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::Report >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::ReportToSign*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::ReportToSign >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::ReportToSign >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::EventOraclePaid*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::EventOraclePaid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::EventOraclePaid >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::EventAnswerUpdated*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::EventAnswerUpdated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::EventAnswerUpdated >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::EventNewRound*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::EventNewRound >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::EventNewRound >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::EventTransmitted*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::EventTransmitted >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::EventTransmitted >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::EventNewTransmission*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::EventNewTransmission >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::EventNewTransmission >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::ocr::v1beta1::EventConfigSet*
Arena::CreateMaybeMessage< ::injective::ocr::v1beta1::EventConfigSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::ocr::v1beta1::EventConfigSet >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
