// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/insurance/v1beta1/insurance.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2finsurance_2fv1beta1_2finsurance_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2finsurance_2fv1beta1_2finsurance_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "injective/oracle/v1beta1/oracle.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2finsurance_2fv1beta1_2finsurance_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2finsurance_2fv1beta1_2finsurance_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2finsurance_2fv1beta1_2finsurance_2eproto;
namespace injective {
namespace insurance {
namespace v1beta1 {
class EventInsuranceFundUpdate;
struct EventInsuranceFundUpdateDefaultTypeInternal;
extern EventInsuranceFundUpdateDefaultTypeInternal _EventInsuranceFundUpdate_default_instance_;
class EventRequestRedemption;
struct EventRequestRedemptionDefaultTypeInternal;
extern EventRequestRedemptionDefaultTypeInternal _EventRequestRedemption_default_instance_;
class EventUnderwrite;
struct EventUnderwriteDefaultTypeInternal;
extern EventUnderwriteDefaultTypeInternal _EventUnderwrite_default_instance_;
class EventWithdrawRedemption;
struct EventWithdrawRedemptionDefaultTypeInternal;
extern EventWithdrawRedemptionDefaultTypeInternal _EventWithdrawRedemption_default_instance_;
class InsuranceFund;
struct InsuranceFundDefaultTypeInternal;
extern InsuranceFundDefaultTypeInternal _InsuranceFund_default_instance_;
class Params;
struct ParamsDefaultTypeInternal;
extern ParamsDefaultTypeInternal _Params_default_instance_;
class RedemptionSchedule;
struct RedemptionScheduleDefaultTypeInternal;
extern RedemptionScheduleDefaultTypeInternal _RedemptionSchedule_default_instance_;
}  // namespace v1beta1
}  // namespace insurance
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::insurance::v1beta1::EventInsuranceFundUpdate* Arena::CreateMaybeMessage<::injective::insurance::v1beta1::EventInsuranceFundUpdate>(Arena*);
template <>
::injective::insurance::v1beta1::EventRequestRedemption* Arena::CreateMaybeMessage<::injective::insurance::v1beta1::EventRequestRedemption>(Arena*);
template <>
::injective::insurance::v1beta1::EventUnderwrite* Arena::CreateMaybeMessage<::injective::insurance::v1beta1::EventUnderwrite>(Arena*);
template <>
::injective::insurance::v1beta1::EventWithdrawRedemption* Arena::CreateMaybeMessage<::injective::insurance::v1beta1::EventWithdrawRedemption>(Arena*);
template <>
::injective::insurance::v1beta1::InsuranceFund* Arena::CreateMaybeMessage<::injective::insurance::v1beta1::InsuranceFund>(Arena*);
template <>
::injective::insurance::v1beta1::Params* Arena::CreateMaybeMessage<::injective::insurance::v1beta1::Params>(Arena*);
template <>
::injective::insurance::v1beta1::RedemptionSchedule* Arena::CreateMaybeMessage<::injective::insurance::v1beta1::RedemptionSchedule>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace insurance {
namespace v1beta1 {

// ===================================================================


// -------------------------------------------------------------------

class Params final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.insurance.v1beta1.Params) */ {
 public:
  inline Params() : Params(nullptr) {}
  ~Params() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Params(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Params(const Params& from);
  Params(Params&& from) noexcept
    : Params() {
    *this = ::std::move(from);
  }

  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline Params& operator=(Params&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const Params* internal_default_instance() {
    return reinterpret_cast<const Params*>(
               &_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Params& a, Params& b) {
    a.Swap(&b);
  }
  inline void Swap(Params* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Params* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Params* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Params>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Params& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Params& from) {
    Params::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Params* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.insurance.v1beta1.Params";
  }
  protected:
  explicit Params(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultRedemptionNoticePeriodDurationFieldNumber = 1,
  };
  // .google.protobuf.Duration default_redemption_notice_period_duration = 1 [json_name = "defaultRedemptionNoticePeriodDuration", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"default_redemption_notice_period_duration\"", (.gogoproto.stdduration) = true];
  bool has_default_redemption_notice_period_duration() const;
  void clear_default_redemption_notice_period_duration() ;
  const ::PROTOBUF_NAMESPACE_ID::Duration& default_redemption_notice_period_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_default_redemption_notice_period_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_default_redemption_notice_period_duration();
  void set_allocated_default_redemption_notice_period_duration(::PROTOBUF_NAMESPACE_ID::Duration* default_redemption_notice_period_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_default_redemption_notice_period_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_default_redemption_notice_period_duration();
  public:
  void unsafe_arena_set_allocated_default_redemption_notice_period_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* default_redemption_notice_period_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_default_redemption_notice_period_duration();
  // @@protoc_insertion_point(class_scope:injective.insurance.v1beta1.Params)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Duration* default_redemption_notice_period_duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2finsurance_2fv1beta1_2finsurance_2eproto;
};// -------------------------------------------------------------------

class InsuranceFund final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.insurance.v1beta1.InsuranceFund) */ {
 public:
  inline InsuranceFund() : InsuranceFund(nullptr) {}
  ~InsuranceFund() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InsuranceFund(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsuranceFund(const InsuranceFund& from);
  InsuranceFund(InsuranceFund&& from) noexcept
    : InsuranceFund() {
    *this = ::std::move(from);
  }

  inline InsuranceFund& operator=(const InsuranceFund& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsuranceFund& operator=(InsuranceFund&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsuranceFund& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsuranceFund* internal_default_instance() {
    return reinterpret_cast<const InsuranceFund*>(
               &_InsuranceFund_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InsuranceFund& a, InsuranceFund& b) {
    a.Swap(&b);
  }
  inline void Swap(InsuranceFund* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsuranceFund* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsuranceFund* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsuranceFund>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsuranceFund& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsuranceFund& from) {
    InsuranceFund::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsuranceFund* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.insurance.v1beta1.InsuranceFund";
  }
  protected:
  explicit InsuranceFund(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepositDenomFieldNumber = 1,
    kInsurancePoolTokenDenomFieldNumber = 2,
    kBalanceFieldNumber = 4,
    kTotalShareFieldNumber = 5,
    kMarketIdFieldNumber = 6,
    kMarketTickerFieldNumber = 7,
    kOracleBaseFieldNumber = 8,
    kOracleQuoteFieldNumber = 9,
    kRedemptionNoticePeriodDurationFieldNumber = 3,
    kExpiryFieldNumber = 11,
    kOracleTypeFieldNumber = 10,
  };
  // string deposit_denom = 1 [json_name = "depositDenom"];
  void clear_deposit_denom() ;
  const std::string& deposit_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deposit_denom(Arg_&& arg, Args_... args);
  std::string* mutable_deposit_denom();
  PROTOBUF_NODISCARD std::string* release_deposit_denom();
  void set_allocated_deposit_denom(std::string* ptr);

  private:
  const std::string& _internal_deposit_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deposit_denom(
      const std::string& value);
  std::string* _internal_mutable_deposit_denom();

  public:
  // string insurance_pool_token_denom = 2 [json_name = "insurancePoolTokenDenom"];
  void clear_insurance_pool_token_denom() ;
  const std::string& insurance_pool_token_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_insurance_pool_token_denom(Arg_&& arg, Args_... args);
  std::string* mutable_insurance_pool_token_denom();
  PROTOBUF_NODISCARD std::string* release_insurance_pool_token_denom();
  void set_allocated_insurance_pool_token_denom(std::string* ptr);

  private:
  const std::string& _internal_insurance_pool_token_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_insurance_pool_token_denom(
      const std::string& value);
  std::string* _internal_mutable_insurance_pool_token_denom();

  public:
  // string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_balance() ;
  const std::string& balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* ptr);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // string total_share = 5 [json_name = "totalShare", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_total_share() ;
  const std::string& total_share() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total_share(Arg_&& arg, Args_... args);
  std::string* mutable_total_share();
  PROTOBUF_NODISCARD std::string* release_total_share();
  void set_allocated_total_share(std::string* ptr);

  private:
  const std::string& _internal_total_share() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_share(
      const std::string& value);
  std::string* _internal_mutable_total_share();

  public:
  // string market_id = 6 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string market_ticker = 7 [json_name = "marketTicker"];
  void clear_market_ticker() ;
  const std::string& market_ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_market_ticker();
  PROTOBUF_NODISCARD std::string* release_market_ticker();
  void set_allocated_market_ticker(std::string* ptr);

  private:
  const std::string& _internal_market_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_ticker(
      const std::string& value);
  std::string* _internal_mutable_market_ticker();

  public:
  // string oracle_base = 8 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 9 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // .google.protobuf.Duration redemption_notice_period_duration = 3 [json_name = "redemptionNoticePeriodDuration", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"redemption_notice_period_duration\"", (.gogoproto.stdduration) = true];
  bool has_redemption_notice_period_duration() const;
  void clear_redemption_notice_period_duration() ;
  const ::PROTOBUF_NAMESPACE_ID::Duration& redemption_notice_period_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_redemption_notice_period_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_redemption_notice_period_duration();
  void set_allocated_redemption_notice_period_duration(::PROTOBUF_NAMESPACE_ID::Duration* redemption_notice_period_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_redemption_notice_period_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_redemption_notice_period_duration();
  public:
  void unsafe_arena_set_allocated_redemption_notice_period_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* redemption_notice_period_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_redemption_notice_period_duration();
  // int64 expiry = 11 [json_name = "expiry"];
  void clear_expiry() ;
  ::int64_t expiry() const;
  void set_expiry(::int64_t value);

  private:
  ::int64_t _internal_expiry() const;
  void _internal_set_expiry(::int64_t value);

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 10 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.insurance.v1beta1.InsuranceFund)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deposit_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr insurance_pool_token_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_share_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::PROTOBUF_NAMESPACE_ID::Duration* redemption_notice_period_duration_;
    ::int64_t expiry_;
    int oracle_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2finsurance_2fv1beta1_2finsurance_2eproto;
};// -------------------------------------------------------------------

class RedemptionSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.insurance.v1beta1.RedemptionSchedule) */ {
 public:
  inline RedemptionSchedule() : RedemptionSchedule(nullptr) {}
  ~RedemptionSchedule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RedemptionSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedemptionSchedule(const RedemptionSchedule& from);
  RedemptionSchedule(RedemptionSchedule&& from) noexcept
    : RedemptionSchedule() {
    *this = ::std::move(from);
  }

  inline RedemptionSchedule& operator=(const RedemptionSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedemptionSchedule& operator=(RedemptionSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedemptionSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedemptionSchedule* internal_default_instance() {
    return reinterpret_cast<const RedemptionSchedule*>(
               &_RedemptionSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RedemptionSchedule& a, RedemptionSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(RedemptionSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedemptionSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedemptionSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedemptionSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedemptionSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedemptionSchedule& from) {
    RedemptionSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedemptionSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.insurance.v1beta1.RedemptionSchedule";
  }
  protected:
  explicit RedemptionSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 2,
    kRedeemerFieldNumber = 3,
    kClaimableRedemptionTimeFieldNumber = 4,
    kRedemptionAmountFieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // string marketId = 2 [json_name = "marketId"];
  void clear_marketid() ;
  const std::string& marketid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_marketid(Arg_&& arg, Args_... args);
  std::string* mutable_marketid();
  PROTOBUF_NODISCARD std::string* release_marketid();
  void set_allocated_marketid(std::string* ptr);

  private:
  const std::string& _internal_marketid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketid(
      const std::string& value);
  std::string* _internal_mutable_marketid();

  public:
  // string redeemer = 3 [json_name = "redeemer"];
  void clear_redeemer() ;
  const std::string& redeemer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redeemer(Arg_&& arg, Args_... args);
  std::string* mutable_redeemer();
  PROTOBUF_NODISCARD std::string* release_redeemer();
  void set_allocated_redeemer(std::string* ptr);

  private:
  const std::string& _internal_redeemer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redeemer(
      const std::string& value);
  std::string* _internal_mutable_redeemer();

  public:
  // .google.protobuf.Timestamp claimable_redemption_time = 4 [json_name = "claimableRedemptionTime", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"claimable_redemption_time\"", (.gogoproto.stdtime) = true];
  bool has_claimable_redemption_time() const;
  void clear_claimable_redemption_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& claimable_redemption_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_claimable_redemption_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_claimable_redemption_time();
  void set_allocated_claimable_redemption_time(::PROTOBUF_NAMESPACE_ID::Timestamp* claimable_redemption_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_claimable_redemption_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_claimable_redemption_time();
  public:
  void unsafe_arena_set_allocated_claimable_redemption_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* claimable_redemption_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_claimable_redemption_time();
  // .cosmos.base.v1beta1.Coin redemption_amount = 5 [json_name = "redemptionAmount", (.gogoproto.nullable) = false];
  bool has_redemption_amount() const;
  void clear_redemption_amount() ;
  const ::cosmos::base::v1beta1::Coin& redemption_amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_redemption_amount();
  ::cosmos::base::v1beta1::Coin* mutable_redemption_amount();
  void set_allocated_redemption_amount(::cosmos::base::v1beta1::Coin* redemption_amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_redemption_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_redemption_amount();
  public:
  void unsafe_arena_set_allocated_redemption_amount(
      ::cosmos::base::v1beta1::Coin* redemption_amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_redemption_amount();
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.insurance.v1beta1.RedemptionSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marketid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redeemer_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* claimable_redemption_time_;
    ::cosmos::base::v1beta1::Coin* redemption_amount_;
    ::uint64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2finsurance_2fv1beta1_2finsurance_2eproto;
};// -------------------------------------------------------------------

class EventInsuranceFundUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.insurance.v1beta1.EventInsuranceFundUpdate) */ {
 public:
  inline EventInsuranceFundUpdate() : EventInsuranceFundUpdate(nullptr) {}
  ~EventInsuranceFundUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventInsuranceFundUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventInsuranceFundUpdate(const EventInsuranceFundUpdate& from);
  EventInsuranceFundUpdate(EventInsuranceFundUpdate&& from) noexcept
    : EventInsuranceFundUpdate() {
    *this = ::std::move(from);
  }

  inline EventInsuranceFundUpdate& operator=(const EventInsuranceFundUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventInsuranceFundUpdate& operator=(EventInsuranceFundUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventInsuranceFundUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventInsuranceFundUpdate* internal_default_instance() {
    return reinterpret_cast<const EventInsuranceFundUpdate*>(
               &_EventInsuranceFundUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EventInsuranceFundUpdate& a, EventInsuranceFundUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventInsuranceFundUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventInsuranceFundUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventInsuranceFundUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventInsuranceFundUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventInsuranceFundUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventInsuranceFundUpdate& from) {
    EventInsuranceFundUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventInsuranceFundUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.insurance.v1beta1.EventInsuranceFundUpdate";
  }
  protected:
  explicit EventInsuranceFundUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundFieldNumber = 1,
  };
  // .injective.insurance.v1beta1.InsuranceFund fund = 1 [json_name = "fund"];
  bool has_fund() const;
  void clear_fund() ;
  const ::injective::insurance::v1beta1::InsuranceFund& fund() const;
  PROTOBUF_NODISCARD ::injective::insurance::v1beta1::InsuranceFund* release_fund();
  ::injective::insurance::v1beta1::InsuranceFund* mutable_fund();
  void set_allocated_fund(::injective::insurance::v1beta1::InsuranceFund* fund);
  private:
  const ::injective::insurance::v1beta1::InsuranceFund& _internal_fund() const;
  ::injective::insurance::v1beta1::InsuranceFund* _internal_mutable_fund();
  public:
  void unsafe_arena_set_allocated_fund(
      ::injective::insurance::v1beta1::InsuranceFund* fund);
  ::injective::insurance::v1beta1::InsuranceFund* unsafe_arena_release_fund();
  // @@protoc_insertion_point(class_scope:injective.insurance.v1beta1.EventInsuranceFundUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::insurance::v1beta1::InsuranceFund* fund_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2finsurance_2fv1beta1_2finsurance_2eproto;
};// -------------------------------------------------------------------

class EventRequestRedemption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.insurance.v1beta1.EventRequestRedemption) */ {
 public:
  inline EventRequestRedemption() : EventRequestRedemption(nullptr) {}
  ~EventRequestRedemption() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventRequestRedemption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventRequestRedemption(const EventRequestRedemption& from);
  EventRequestRedemption(EventRequestRedemption&& from) noexcept
    : EventRequestRedemption() {
    *this = ::std::move(from);
  }

  inline EventRequestRedemption& operator=(const EventRequestRedemption& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventRequestRedemption& operator=(EventRequestRedemption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventRequestRedemption& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventRequestRedemption* internal_default_instance() {
    return reinterpret_cast<const EventRequestRedemption*>(
               &_EventRequestRedemption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EventRequestRedemption& a, EventRequestRedemption& b) {
    a.Swap(&b);
  }
  inline void Swap(EventRequestRedemption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventRequestRedemption* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventRequestRedemption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventRequestRedemption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventRequestRedemption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventRequestRedemption& from) {
    EventRequestRedemption::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventRequestRedemption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.insurance.v1beta1.EventRequestRedemption";
  }
  protected:
  explicit EventRequestRedemption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleFieldNumber = 1,
  };
  // .injective.insurance.v1beta1.RedemptionSchedule schedule = 1 [json_name = "schedule"];
  bool has_schedule() const;
  void clear_schedule() ;
  const ::injective::insurance::v1beta1::RedemptionSchedule& schedule() const;
  PROTOBUF_NODISCARD ::injective::insurance::v1beta1::RedemptionSchedule* release_schedule();
  ::injective::insurance::v1beta1::RedemptionSchedule* mutable_schedule();
  void set_allocated_schedule(::injective::insurance::v1beta1::RedemptionSchedule* schedule);
  private:
  const ::injective::insurance::v1beta1::RedemptionSchedule& _internal_schedule() const;
  ::injective::insurance::v1beta1::RedemptionSchedule* _internal_mutable_schedule();
  public:
  void unsafe_arena_set_allocated_schedule(
      ::injective::insurance::v1beta1::RedemptionSchedule* schedule);
  ::injective::insurance::v1beta1::RedemptionSchedule* unsafe_arena_release_schedule();
  // @@protoc_insertion_point(class_scope:injective.insurance.v1beta1.EventRequestRedemption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::insurance::v1beta1::RedemptionSchedule* schedule_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2finsurance_2fv1beta1_2finsurance_2eproto;
};// -------------------------------------------------------------------

class EventWithdrawRedemption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.insurance.v1beta1.EventWithdrawRedemption) */ {
 public:
  inline EventWithdrawRedemption() : EventWithdrawRedemption(nullptr) {}
  ~EventWithdrawRedemption() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventWithdrawRedemption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventWithdrawRedemption(const EventWithdrawRedemption& from);
  EventWithdrawRedemption(EventWithdrawRedemption&& from) noexcept
    : EventWithdrawRedemption() {
    *this = ::std::move(from);
  }

  inline EventWithdrawRedemption& operator=(const EventWithdrawRedemption& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventWithdrawRedemption& operator=(EventWithdrawRedemption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventWithdrawRedemption& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventWithdrawRedemption* internal_default_instance() {
    return reinterpret_cast<const EventWithdrawRedemption*>(
               &_EventWithdrawRedemption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EventWithdrawRedemption& a, EventWithdrawRedemption& b) {
    a.Swap(&b);
  }
  inline void Swap(EventWithdrawRedemption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventWithdrawRedemption* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventWithdrawRedemption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventWithdrawRedemption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventWithdrawRedemption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventWithdrawRedemption& from) {
    EventWithdrawRedemption::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventWithdrawRedemption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.insurance.v1beta1.EventWithdrawRedemption";
  }
  protected:
  explicit EventWithdrawRedemption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleFieldNumber = 1,
    kRedeemCoinFieldNumber = 2,
  };
  // .injective.insurance.v1beta1.RedemptionSchedule schedule = 1 [json_name = "schedule"];
  bool has_schedule() const;
  void clear_schedule() ;
  const ::injective::insurance::v1beta1::RedemptionSchedule& schedule() const;
  PROTOBUF_NODISCARD ::injective::insurance::v1beta1::RedemptionSchedule* release_schedule();
  ::injective::insurance::v1beta1::RedemptionSchedule* mutable_schedule();
  void set_allocated_schedule(::injective::insurance::v1beta1::RedemptionSchedule* schedule);
  private:
  const ::injective::insurance::v1beta1::RedemptionSchedule& _internal_schedule() const;
  ::injective::insurance::v1beta1::RedemptionSchedule* _internal_mutable_schedule();
  public:
  void unsafe_arena_set_allocated_schedule(
      ::injective::insurance::v1beta1::RedemptionSchedule* schedule);
  ::injective::insurance::v1beta1::RedemptionSchedule* unsafe_arena_release_schedule();
  // .cosmos.base.v1beta1.Coin redeem_coin = 2 [json_name = "redeemCoin", (.gogoproto.nullable) = false];
  bool has_redeem_coin() const;
  void clear_redeem_coin() ;
  const ::cosmos::base::v1beta1::Coin& redeem_coin() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_redeem_coin();
  ::cosmos::base::v1beta1::Coin* mutable_redeem_coin();
  void set_allocated_redeem_coin(::cosmos::base::v1beta1::Coin* redeem_coin);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_redeem_coin() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_redeem_coin();
  public:
  void unsafe_arena_set_allocated_redeem_coin(
      ::cosmos::base::v1beta1::Coin* redeem_coin);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_redeem_coin();
  // @@protoc_insertion_point(class_scope:injective.insurance.v1beta1.EventWithdrawRedemption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::insurance::v1beta1::RedemptionSchedule* schedule_;
    ::cosmos::base::v1beta1::Coin* redeem_coin_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2finsurance_2fv1beta1_2finsurance_2eproto;
};// -------------------------------------------------------------------

class EventUnderwrite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.insurance.v1beta1.EventUnderwrite) */ {
 public:
  inline EventUnderwrite() : EventUnderwrite(nullptr) {}
  ~EventUnderwrite() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventUnderwrite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventUnderwrite(const EventUnderwrite& from);
  EventUnderwrite(EventUnderwrite&& from) noexcept
    : EventUnderwrite() {
    *this = ::std::move(from);
  }

  inline EventUnderwrite& operator=(const EventUnderwrite& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventUnderwrite& operator=(EventUnderwrite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventUnderwrite& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventUnderwrite* internal_default_instance() {
    return reinterpret_cast<const EventUnderwrite*>(
               &_EventUnderwrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EventUnderwrite& a, EventUnderwrite& b) {
    a.Swap(&b);
  }
  inline void Swap(EventUnderwrite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventUnderwrite* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventUnderwrite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventUnderwrite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventUnderwrite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventUnderwrite& from) {
    EventUnderwrite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventUnderwrite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.insurance.v1beta1.EventUnderwrite";
  }
  protected:
  explicit EventUnderwrite(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnderwriterFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kDepositFieldNumber = 3,
    kSharesFieldNumber = 4,
  };
  // string underwriter = 1 [json_name = "underwriter"];
  void clear_underwriter() ;
  const std::string& underwriter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_underwriter(Arg_&& arg, Args_... args);
  std::string* mutable_underwriter();
  PROTOBUF_NODISCARD std::string* release_underwriter();
  void set_allocated_underwriter(std::string* ptr);

  private:
  const std::string& _internal_underwriter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_underwriter(
      const std::string& value);
  std::string* _internal_mutable_underwriter();

  public:
  // string marketId = 2 [json_name = "marketId"];
  void clear_marketid() ;
  const std::string& marketid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_marketid(Arg_&& arg, Args_... args);
  std::string* mutable_marketid();
  PROTOBUF_NODISCARD std::string* release_marketid();
  void set_allocated_marketid(std::string* ptr);

  private:
  const std::string& _internal_marketid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketid(
      const std::string& value);
  std::string* _internal_mutable_marketid();

  public:
  // .cosmos.base.v1beta1.Coin deposit = 3 [json_name = "deposit", (.gogoproto.nullable) = false];
  bool has_deposit() const;
  void clear_deposit() ;
  const ::cosmos::base::v1beta1::Coin& deposit() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_deposit();
  ::cosmos::base::v1beta1::Coin* mutable_deposit();
  void set_allocated_deposit(::cosmos::base::v1beta1::Coin* deposit);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_deposit() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_deposit();
  public:
  void unsafe_arena_set_allocated_deposit(
      ::cosmos::base::v1beta1::Coin* deposit);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_deposit();
  // .cosmos.base.v1beta1.Coin shares = 4 [json_name = "shares", (.gogoproto.nullable) = false];
  bool has_shares() const;
  void clear_shares() ;
  const ::cosmos::base::v1beta1::Coin& shares() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_shares();
  ::cosmos::base::v1beta1::Coin* mutable_shares();
  void set_allocated_shares(::cosmos::base::v1beta1::Coin* shares);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_shares() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_shares();
  public:
  void unsafe_arena_set_allocated_shares(
      ::cosmos::base::v1beta1::Coin* shares);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_shares();
  // @@protoc_insertion_point(class_scope:injective.insurance.v1beta1.EventUnderwrite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr underwriter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marketid_;
    ::cosmos::base::v1beta1::Coin* deposit_;
    ::cosmos::base::v1beta1::Coin* shares_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2finsurance_2fv1beta1_2finsurance_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Params

// .google.protobuf.Duration default_redemption_notice_period_duration = 1 [json_name = "defaultRedemptionNoticePeriodDuration", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"default_redemption_notice_period_duration\"", (.gogoproto.stdduration) = true];
inline bool Params::has_default_redemption_notice_period_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.default_redemption_notice_period_duration_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Params::_internal_default_redemption_notice_period_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.default_redemption_notice_period_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Params::default_redemption_notice_period_duration() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.Params.default_redemption_notice_period_duration)
  return _internal_default_redemption_notice_period_duration();
}
inline void Params::unsafe_arena_set_allocated_default_redemption_notice_period_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* default_redemption_notice_period_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_redemption_notice_period_duration_);
  }
  _impl_.default_redemption_notice_period_duration_ = default_redemption_notice_period_duration;
  if (default_redemption_notice_period_duration) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.Params.default_redemption_notice_period_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Params::release_default_redemption_notice_period_duration() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.default_redemption_notice_period_duration_;
  _impl_.default_redemption_notice_period_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Params::unsafe_arena_release_default_redemption_notice_period_duration() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.Params.default_redemption_notice_period_duration)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.default_redemption_notice_period_duration_;
  _impl_.default_redemption_notice_period_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Params::_internal_mutable_default_redemption_notice_period_duration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.default_redemption_notice_period_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.default_redemption_notice_period_duration_ = p;
  }
  return _impl_.default_redemption_notice_period_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Params::mutable_default_redemption_notice_period_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_default_redemption_notice_period_duration();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.Params.default_redemption_notice_period_duration)
  return _msg;
}
inline void Params::set_allocated_default_redemption_notice_period_duration(::PROTOBUF_NAMESPACE_ID::Duration* default_redemption_notice_period_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_redemption_notice_period_duration_);
  }
  if (default_redemption_notice_period_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_redemption_notice_period_duration));
    if (message_arena != submessage_arena) {
      default_redemption_notice_period_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_redemption_notice_period_duration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.default_redemption_notice_period_duration_ = default_redemption_notice_period_duration;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.Params.default_redemption_notice_period_duration)
}

// -------------------------------------------------------------------

// InsuranceFund

// string deposit_denom = 1 [json_name = "depositDenom"];
inline void InsuranceFund::clear_deposit_denom() {
  _impl_.deposit_denom_.ClearToEmpty();
}
inline const std::string& InsuranceFund::deposit_denom() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.deposit_denom)
  return _internal_deposit_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_deposit_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.deposit_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.deposit_denom)
}
inline std::string* InsuranceFund::mutable_deposit_denom() {
  std::string* _s = _internal_mutable_deposit_denom();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.deposit_denom)
  return _s;
}
inline const std::string& InsuranceFund::_internal_deposit_denom() const {
  return _impl_.deposit_denom_.Get();
}
inline void InsuranceFund::_internal_set_deposit_denom(const std::string& value) {
  ;


  _impl_.deposit_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_deposit_denom() {
  ;
  return _impl_.deposit_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_deposit_denom() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.deposit_denom)
  return _impl_.deposit_denom_.Release();
}
inline void InsuranceFund::set_allocated_deposit_denom(std::string* value) {
  _impl_.deposit_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deposit_denom_.IsDefault()) {
          _impl_.deposit_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.deposit_denom)
}

// string insurance_pool_token_denom = 2 [json_name = "insurancePoolTokenDenom"];
inline void InsuranceFund::clear_insurance_pool_token_denom() {
  _impl_.insurance_pool_token_denom_.ClearToEmpty();
}
inline const std::string& InsuranceFund::insurance_pool_token_denom() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.insurance_pool_token_denom)
  return _internal_insurance_pool_token_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_insurance_pool_token_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.insurance_pool_token_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.insurance_pool_token_denom)
}
inline std::string* InsuranceFund::mutable_insurance_pool_token_denom() {
  std::string* _s = _internal_mutable_insurance_pool_token_denom();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.insurance_pool_token_denom)
  return _s;
}
inline const std::string& InsuranceFund::_internal_insurance_pool_token_denom() const {
  return _impl_.insurance_pool_token_denom_.Get();
}
inline void InsuranceFund::_internal_set_insurance_pool_token_denom(const std::string& value) {
  ;


  _impl_.insurance_pool_token_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_insurance_pool_token_denom() {
  ;
  return _impl_.insurance_pool_token_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_insurance_pool_token_denom() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.insurance_pool_token_denom)
  return _impl_.insurance_pool_token_denom_.Release();
}
inline void InsuranceFund::set_allocated_insurance_pool_token_denom(std::string* value) {
  _impl_.insurance_pool_token_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.insurance_pool_token_denom_.IsDefault()) {
          _impl_.insurance_pool_token_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.insurance_pool_token_denom)
}

// .google.protobuf.Duration redemption_notice_period_duration = 3 [json_name = "redemptionNoticePeriodDuration", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"redemption_notice_period_duration\"", (.gogoproto.stdduration) = true];
inline bool InsuranceFund::has_redemption_notice_period_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redemption_notice_period_duration_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& InsuranceFund::_internal_redemption_notice_period_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.redemption_notice_period_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& InsuranceFund::redemption_notice_period_duration() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.redemption_notice_period_duration)
  return _internal_redemption_notice_period_duration();
}
inline void InsuranceFund::unsafe_arena_set_allocated_redemption_notice_period_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* redemption_notice_period_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redemption_notice_period_duration_);
  }
  _impl_.redemption_notice_period_duration_ = redemption_notice_period_duration;
  if (redemption_notice_period_duration) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.InsuranceFund.redemption_notice_period_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* InsuranceFund::release_redemption_notice_period_duration() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.redemption_notice_period_duration_;
  _impl_.redemption_notice_period_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* InsuranceFund::unsafe_arena_release_redemption_notice_period_duration() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.redemption_notice_period_duration)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.redemption_notice_period_duration_;
  _impl_.redemption_notice_period_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* InsuranceFund::_internal_mutable_redemption_notice_period_duration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.redemption_notice_period_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.redemption_notice_period_duration_ = p;
  }
  return _impl_.redemption_notice_period_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* InsuranceFund::mutable_redemption_notice_period_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_redemption_notice_period_duration();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.redemption_notice_period_duration)
  return _msg;
}
inline void InsuranceFund::set_allocated_redemption_notice_period_duration(::PROTOBUF_NAMESPACE_ID::Duration* redemption_notice_period_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redemption_notice_period_duration_);
  }
  if (redemption_notice_period_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(redemption_notice_period_duration));
    if (message_arena != submessage_arena) {
      redemption_notice_period_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redemption_notice_period_duration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.redemption_notice_period_duration_ = redemption_notice_period_duration;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.redemption_notice_period_duration)
}

// string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void InsuranceFund::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& InsuranceFund::balance() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.balance)
}
inline std::string* InsuranceFund::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.balance)
  return _s;
}
inline const std::string& InsuranceFund::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void InsuranceFund::_internal_set_balance(const std::string& value) {
  ;


  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_balance() {
  ;
  return _impl_.balance_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_balance() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.balance)
  return _impl_.balance_.Release();
}
inline void InsuranceFund::set_allocated_balance(std::string* value) {
  _impl_.balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_.IsDefault()) {
          _impl_.balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.balance)
}

// string total_share = 5 [json_name = "totalShare", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void InsuranceFund::clear_total_share() {
  _impl_.total_share_.ClearToEmpty();
}
inline const std::string& InsuranceFund::total_share() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.total_share)
  return _internal_total_share();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_total_share(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_share_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.total_share)
}
inline std::string* InsuranceFund::mutable_total_share() {
  std::string* _s = _internal_mutable_total_share();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.total_share)
  return _s;
}
inline const std::string& InsuranceFund::_internal_total_share() const {
  return _impl_.total_share_.Get();
}
inline void InsuranceFund::_internal_set_total_share(const std::string& value) {
  ;


  _impl_.total_share_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_total_share() {
  ;
  return _impl_.total_share_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_total_share() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.total_share)
  return _impl_.total_share_.Release();
}
inline void InsuranceFund::set_allocated_total_share(std::string* value) {
  _impl_.total_share_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_share_.IsDefault()) {
          _impl_.total_share_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.total_share)
}

// string market_id = 6 [json_name = "marketId"];
inline void InsuranceFund::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& InsuranceFund::market_id() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.market_id)
}
inline std::string* InsuranceFund::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.market_id)
  return _s;
}
inline const std::string& InsuranceFund::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void InsuranceFund::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.market_id)
  return _impl_.market_id_.Release();
}
inline void InsuranceFund::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.market_id)
}

// string market_ticker = 7 [json_name = "marketTicker"];
inline void InsuranceFund::clear_market_ticker() {
  _impl_.market_ticker_.ClearToEmpty();
}
inline const std::string& InsuranceFund::market_ticker() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.market_ticker)
  return _internal_market_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_market_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.market_ticker)
}
inline std::string* InsuranceFund::mutable_market_ticker() {
  std::string* _s = _internal_mutable_market_ticker();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.market_ticker)
  return _s;
}
inline const std::string& InsuranceFund::_internal_market_ticker() const {
  return _impl_.market_ticker_.Get();
}
inline void InsuranceFund::_internal_set_market_ticker(const std::string& value) {
  ;


  _impl_.market_ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_market_ticker() {
  ;
  return _impl_.market_ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_market_ticker() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.market_ticker)
  return _impl_.market_ticker_.Release();
}
inline void InsuranceFund::set_allocated_market_ticker(std::string* value) {
  _impl_.market_ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_ticker_.IsDefault()) {
          _impl_.market_ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.market_ticker)
}

// string oracle_base = 8 [json_name = "oracleBase"];
inline void InsuranceFund::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& InsuranceFund::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.oracle_base)
}
inline std::string* InsuranceFund::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.oracle_base)
  return _s;
}
inline const std::string& InsuranceFund::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void InsuranceFund::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void InsuranceFund::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.oracle_base)
}

// string oracle_quote = 9 [json_name = "oracleQuote"];
inline void InsuranceFund::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& InsuranceFund::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.oracle_quote)
}
inline std::string* InsuranceFund::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.InsuranceFund.oracle_quote)
  return _s;
}
inline const std::string& InsuranceFund::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void InsuranceFund::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.InsuranceFund.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void InsuranceFund::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.InsuranceFund.oracle_quote)
}

// .injective.oracle.v1beta1.OracleType oracle_type = 10 [json_name = "oracleType"];
inline void InsuranceFund::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType InsuranceFund::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.oracle_type)
  return _internal_oracle_type();
}
inline void InsuranceFund::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType InsuranceFund::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void InsuranceFund::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// int64 expiry = 11 [json_name = "expiry"];
inline void InsuranceFund::clear_expiry() {
  _impl_.expiry_ = ::int64_t{0};
}
inline ::int64_t InsuranceFund::expiry() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.InsuranceFund.expiry)
  return _internal_expiry();
}
inline void InsuranceFund::set_expiry(::int64_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.InsuranceFund.expiry)
}
inline ::int64_t InsuranceFund::_internal_expiry() const {
  return _impl_.expiry_;
}
inline void InsuranceFund::_internal_set_expiry(::int64_t value) {
  ;
  _impl_.expiry_ = value;
}

// -------------------------------------------------------------------

// RedemptionSchedule

// uint64 id = 1 [json_name = "id"];
inline void RedemptionSchedule::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t RedemptionSchedule::id() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.RedemptionSchedule.id)
  return _internal_id();
}
inline void RedemptionSchedule::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.RedemptionSchedule.id)
}
inline ::uint64_t RedemptionSchedule::_internal_id() const {
  return _impl_.id_;
}
inline void RedemptionSchedule::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// string marketId = 2 [json_name = "marketId"];
inline void RedemptionSchedule::clear_marketid() {
  _impl_.marketid_.ClearToEmpty();
}
inline const std::string& RedemptionSchedule::marketid() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.RedemptionSchedule.marketId)
  return _internal_marketid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionSchedule::set_marketid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.marketid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.RedemptionSchedule.marketId)
}
inline std::string* RedemptionSchedule::mutable_marketid() {
  std::string* _s = _internal_mutable_marketid();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.RedemptionSchedule.marketId)
  return _s;
}
inline const std::string& RedemptionSchedule::_internal_marketid() const {
  return _impl_.marketid_.Get();
}
inline void RedemptionSchedule::_internal_set_marketid(const std::string& value) {
  ;


  _impl_.marketid_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::_internal_mutable_marketid() {
  ;
  return _impl_.marketid_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::release_marketid() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.RedemptionSchedule.marketId)
  return _impl_.marketid_.Release();
}
inline void RedemptionSchedule::set_allocated_marketid(std::string* value) {
  _impl_.marketid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.marketid_.IsDefault()) {
          _impl_.marketid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.RedemptionSchedule.marketId)
}

// string redeemer = 3 [json_name = "redeemer"];
inline void RedemptionSchedule::clear_redeemer() {
  _impl_.redeemer_.ClearToEmpty();
}
inline const std::string& RedemptionSchedule::redeemer() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.RedemptionSchedule.redeemer)
  return _internal_redeemer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionSchedule::set_redeemer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.redeemer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.RedemptionSchedule.redeemer)
}
inline std::string* RedemptionSchedule::mutable_redeemer() {
  std::string* _s = _internal_mutable_redeemer();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.RedemptionSchedule.redeemer)
  return _s;
}
inline const std::string& RedemptionSchedule::_internal_redeemer() const {
  return _impl_.redeemer_.Get();
}
inline void RedemptionSchedule::_internal_set_redeemer(const std::string& value) {
  ;


  _impl_.redeemer_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::_internal_mutable_redeemer() {
  ;
  return _impl_.redeemer_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::release_redeemer() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.RedemptionSchedule.redeemer)
  return _impl_.redeemer_.Release();
}
inline void RedemptionSchedule::set_allocated_redeemer(std::string* value) {
  _impl_.redeemer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.redeemer_.IsDefault()) {
          _impl_.redeemer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.RedemptionSchedule.redeemer)
}

// .google.protobuf.Timestamp claimable_redemption_time = 4 [json_name = "claimableRedemptionTime", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"claimable_redemption_time\"", (.gogoproto.stdtime) = true];
inline bool RedemptionSchedule::has_claimable_redemption_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.claimable_redemption_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RedemptionSchedule::_internal_claimable_redemption_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.claimable_redemption_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RedemptionSchedule::claimable_redemption_time() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.RedemptionSchedule.claimable_redemption_time)
  return _internal_claimable_redemption_time();
}
inline void RedemptionSchedule::unsafe_arena_set_allocated_claimable_redemption_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* claimable_redemption_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claimable_redemption_time_);
  }
  _impl_.claimable_redemption_time_ = claimable_redemption_time;
  if (claimable_redemption_time) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.RedemptionSchedule.claimable_redemption_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RedemptionSchedule::release_claimable_redemption_time() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.claimable_redemption_time_;
  _impl_.claimable_redemption_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RedemptionSchedule::unsafe_arena_release_claimable_redemption_time() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.RedemptionSchedule.claimable_redemption_time)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.claimable_redemption_time_;
  _impl_.claimable_redemption_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RedemptionSchedule::_internal_mutable_claimable_redemption_time() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.claimable_redemption_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.claimable_redemption_time_ = p;
  }
  return _impl_.claimable_redemption_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RedemptionSchedule::mutable_claimable_redemption_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_claimable_redemption_time();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.RedemptionSchedule.claimable_redemption_time)
  return _msg;
}
inline void RedemptionSchedule::set_allocated_claimable_redemption_time(::PROTOBUF_NAMESPACE_ID::Timestamp* claimable_redemption_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claimable_redemption_time_);
  }
  if (claimable_redemption_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claimable_redemption_time));
    if (message_arena != submessage_arena) {
      claimable_redemption_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claimable_redemption_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.claimable_redemption_time_ = claimable_redemption_time;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.RedemptionSchedule.claimable_redemption_time)
}

// .cosmos.base.v1beta1.Coin redemption_amount = 5 [json_name = "redemptionAmount", (.gogoproto.nullable) = false];
inline bool RedemptionSchedule::has_redemption_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redemption_amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& RedemptionSchedule::_internal_redemption_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.redemption_amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& RedemptionSchedule::redemption_amount() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.RedemptionSchedule.redemption_amount)
  return _internal_redemption_amount();
}
inline void RedemptionSchedule::unsafe_arena_set_allocated_redemption_amount(
    ::cosmos::base::v1beta1::Coin* redemption_amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redemption_amount_);
  }
  _impl_.redemption_amount_ = redemption_amount;
  if (redemption_amount) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.RedemptionSchedule.redemption_amount)
}
inline ::cosmos::base::v1beta1::Coin* RedemptionSchedule::release_redemption_amount() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.redemption_amount_;
  _impl_.redemption_amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* RedemptionSchedule::unsafe_arena_release_redemption_amount() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.RedemptionSchedule.redemption_amount)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.redemption_amount_;
  _impl_.redemption_amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* RedemptionSchedule::_internal_mutable_redemption_amount() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.redemption_amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.redemption_amount_ = p;
  }
  return _impl_.redemption_amount_;
}
inline ::cosmos::base::v1beta1::Coin* RedemptionSchedule::mutable_redemption_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_redemption_amount();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.RedemptionSchedule.redemption_amount)
  return _msg;
}
inline void RedemptionSchedule::set_allocated_redemption_amount(::cosmos::base::v1beta1::Coin* redemption_amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redemption_amount_);
  }
  if (redemption_amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(redemption_amount));
    if (message_arena != submessage_arena) {
      redemption_amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redemption_amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.redemption_amount_ = redemption_amount;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.RedemptionSchedule.redemption_amount)
}

// -------------------------------------------------------------------

// EventInsuranceFundUpdate

// .injective.insurance.v1beta1.InsuranceFund fund = 1 [json_name = "fund"];
inline bool EventInsuranceFundUpdate::has_fund() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fund_ != nullptr);
  return value;
}
inline void EventInsuranceFundUpdate::clear_fund() {
  if (_impl_.fund_ != nullptr) _impl_.fund_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::insurance::v1beta1::InsuranceFund& EventInsuranceFundUpdate::_internal_fund() const {
  const ::injective::insurance::v1beta1::InsuranceFund* p = _impl_.fund_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::insurance::v1beta1::InsuranceFund&>(
      ::injective::insurance::v1beta1::_InsuranceFund_default_instance_);
}
inline const ::injective::insurance::v1beta1::InsuranceFund& EventInsuranceFundUpdate::fund() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.EventInsuranceFundUpdate.fund)
  return _internal_fund();
}
inline void EventInsuranceFundUpdate::unsafe_arena_set_allocated_fund(
    ::injective::insurance::v1beta1::InsuranceFund* fund) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fund_);
  }
  _impl_.fund_ = fund;
  if (fund) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.EventInsuranceFundUpdate.fund)
}
inline ::injective::insurance::v1beta1::InsuranceFund* EventInsuranceFundUpdate::release_fund() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::insurance::v1beta1::InsuranceFund* temp = _impl_.fund_;
  _impl_.fund_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::insurance::v1beta1::InsuranceFund* EventInsuranceFundUpdate::unsafe_arena_release_fund() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.EventInsuranceFundUpdate.fund)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::insurance::v1beta1::InsuranceFund* temp = _impl_.fund_;
  _impl_.fund_ = nullptr;
  return temp;
}
inline ::injective::insurance::v1beta1::InsuranceFund* EventInsuranceFundUpdate::_internal_mutable_fund() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fund_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::insurance::v1beta1::InsuranceFund>(GetArenaForAllocation());
    _impl_.fund_ = p;
  }
  return _impl_.fund_;
}
inline ::injective::insurance::v1beta1::InsuranceFund* EventInsuranceFundUpdate::mutable_fund() {
  ::injective::insurance::v1beta1::InsuranceFund* _msg = _internal_mutable_fund();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.EventInsuranceFundUpdate.fund)
  return _msg;
}
inline void EventInsuranceFundUpdate::set_allocated_fund(::injective::insurance::v1beta1::InsuranceFund* fund) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fund_;
  }
  if (fund) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fund);
    if (message_arena != submessage_arena) {
      fund = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fund, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fund_ = fund;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.EventInsuranceFundUpdate.fund)
}

// -------------------------------------------------------------------

// EventRequestRedemption

// .injective.insurance.v1beta1.RedemptionSchedule schedule = 1 [json_name = "schedule"];
inline bool EventRequestRedemption::has_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedule_ != nullptr);
  return value;
}
inline void EventRequestRedemption::clear_schedule() {
  if (_impl_.schedule_ != nullptr) _impl_.schedule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::insurance::v1beta1::RedemptionSchedule& EventRequestRedemption::_internal_schedule() const {
  const ::injective::insurance::v1beta1::RedemptionSchedule* p = _impl_.schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::insurance::v1beta1::RedemptionSchedule&>(
      ::injective::insurance::v1beta1::_RedemptionSchedule_default_instance_);
}
inline const ::injective::insurance::v1beta1::RedemptionSchedule& EventRequestRedemption::schedule() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.EventRequestRedemption.schedule)
  return _internal_schedule();
}
inline void EventRequestRedemption::unsafe_arena_set_allocated_schedule(
    ::injective::insurance::v1beta1::RedemptionSchedule* schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  _impl_.schedule_ = schedule;
  if (schedule) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.EventRequestRedemption.schedule)
}
inline ::injective::insurance::v1beta1::RedemptionSchedule* EventRequestRedemption::release_schedule() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::insurance::v1beta1::RedemptionSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::insurance::v1beta1::RedemptionSchedule* EventRequestRedemption::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.EventRequestRedemption.schedule)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::insurance::v1beta1::RedemptionSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  return temp;
}
inline ::injective::insurance::v1beta1::RedemptionSchedule* EventRequestRedemption::_internal_mutable_schedule() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::insurance::v1beta1::RedemptionSchedule>(GetArenaForAllocation());
    _impl_.schedule_ = p;
  }
  return _impl_.schedule_;
}
inline ::injective::insurance::v1beta1::RedemptionSchedule* EventRequestRedemption::mutable_schedule() {
  ::injective::insurance::v1beta1::RedemptionSchedule* _msg = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.EventRequestRedemption.schedule)
  return _msg;
}
inline void EventRequestRedemption::set_allocated_schedule(::injective::insurance::v1beta1::RedemptionSchedule* schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schedule_;
  }
  if (schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schedule);
    if (message_arena != submessage_arena) {
      schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.EventRequestRedemption.schedule)
}

// -------------------------------------------------------------------

// EventWithdrawRedemption

// .injective.insurance.v1beta1.RedemptionSchedule schedule = 1 [json_name = "schedule"];
inline bool EventWithdrawRedemption::has_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedule_ != nullptr);
  return value;
}
inline void EventWithdrawRedemption::clear_schedule() {
  if (_impl_.schedule_ != nullptr) _impl_.schedule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::insurance::v1beta1::RedemptionSchedule& EventWithdrawRedemption::_internal_schedule() const {
  const ::injective::insurance::v1beta1::RedemptionSchedule* p = _impl_.schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::insurance::v1beta1::RedemptionSchedule&>(
      ::injective::insurance::v1beta1::_RedemptionSchedule_default_instance_);
}
inline const ::injective::insurance::v1beta1::RedemptionSchedule& EventWithdrawRedemption::schedule() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.EventWithdrawRedemption.schedule)
  return _internal_schedule();
}
inline void EventWithdrawRedemption::unsafe_arena_set_allocated_schedule(
    ::injective::insurance::v1beta1::RedemptionSchedule* schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  _impl_.schedule_ = schedule;
  if (schedule) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.EventWithdrawRedemption.schedule)
}
inline ::injective::insurance::v1beta1::RedemptionSchedule* EventWithdrawRedemption::release_schedule() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::insurance::v1beta1::RedemptionSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::insurance::v1beta1::RedemptionSchedule* EventWithdrawRedemption::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.EventWithdrawRedemption.schedule)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::insurance::v1beta1::RedemptionSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  return temp;
}
inline ::injective::insurance::v1beta1::RedemptionSchedule* EventWithdrawRedemption::_internal_mutable_schedule() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::insurance::v1beta1::RedemptionSchedule>(GetArenaForAllocation());
    _impl_.schedule_ = p;
  }
  return _impl_.schedule_;
}
inline ::injective::insurance::v1beta1::RedemptionSchedule* EventWithdrawRedemption::mutable_schedule() {
  ::injective::insurance::v1beta1::RedemptionSchedule* _msg = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.EventWithdrawRedemption.schedule)
  return _msg;
}
inline void EventWithdrawRedemption::set_allocated_schedule(::injective::insurance::v1beta1::RedemptionSchedule* schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schedule_;
  }
  if (schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schedule);
    if (message_arena != submessage_arena) {
      schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.EventWithdrawRedemption.schedule)
}

// .cosmos.base.v1beta1.Coin redeem_coin = 2 [json_name = "redeemCoin", (.gogoproto.nullable) = false];
inline bool EventWithdrawRedemption::has_redeem_coin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redeem_coin_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& EventWithdrawRedemption::_internal_redeem_coin() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.redeem_coin_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& EventWithdrawRedemption::redeem_coin() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.EventWithdrawRedemption.redeem_coin)
  return _internal_redeem_coin();
}
inline void EventWithdrawRedemption::unsafe_arena_set_allocated_redeem_coin(
    ::cosmos::base::v1beta1::Coin* redeem_coin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redeem_coin_);
  }
  _impl_.redeem_coin_ = redeem_coin;
  if (redeem_coin) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.EventWithdrawRedemption.redeem_coin)
}
inline ::cosmos::base::v1beta1::Coin* EventWithdrawRedemption::release_redeem_coin() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.redeem_coin_;
  _impl_.redeem_coin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventWithdrawRedemption::unsafe_arena_release_redeem_coin() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.EventWithdrawRedemption.redeem_coin)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.redeem_coin_;
  _impl_.redeem_coin_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventWithdrawRedemption::_internal_mutable_redeem_coin() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.redeem_coin_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.redeem_coin_ = p;
  }
  return _impl_.redeem_coin_;
}
inline ::cosmos::base::v1beta1::Coin* EventWithdrawRedemption::mutable_redeem_coin() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_redeem_coin();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.EventWithdrawRedemption.redeem_coin)
  return _msg;
}
inline void EventWithdrawRedemption::set_allocated_redeem_coin(::cosmos::base::v1beta1::Coin* redeem_coin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redeem_coin_);
  }
  if (redeem_coin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(redeem_coin));
    if (message_arena != submessage_arena) {
      redeem_coin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redeem_coin, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.redeem_coin_ = redeem_coin;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.EventWithdrawRedemption.redeem_coin)
}

// -------------------------------------------------------------------

// EventUnderwrite

// string underwriter = 1 [json_name = "underwriter"];
inline void EventUnderwrite::clear_underwriter() {
  _impl_.underwriter_.ClearToEmpty();
}
inline const std::string& EventUnderwrite::underwriter() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.EventUnderwrite.underwriter)
  return _internal_underwriter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventUnderwrite::set_underwriter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.underwriter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.EventUnderwrite.underwriter)
}
inline std::string* EventUnderwrite::mutable_underwriter() {
  std::string* _s = _internal_mutable_underwriter();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.EventUnderwrite.underwriter)
  return _s;
}
inline const std::string& EventUnderwrite::_internal_underwriter() const {
  return _impl_.underwriter_.Get();
}
inline void EventUnderwrite::_internal_set_underwriter(const std::string& value) {
  ;


  _impl_.underwriter_.Set(value, GetArenaForAllocation());
}
inline std::string* EventUnderwrite::_internal_mutable_underwriter() {
  ;
  return _impl_.underwriter_.Mutable( GetArenaForAllocation());
}
inline std::string* EventUnderwrite::release_underwriter() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.EventUnderwrite.underwriter)
  return _impl_.underwriter_.Release();
}
inline void EventUnderwrite::set_allocated_underwriter(std::string* value) {
  _impl_.underwriter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.underwriter_.IsDefault()) {
          _impl_.underwriter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.EventUnderwrite.underwriter)
}

// string marketId = 2 [json_name = "marketId"];
inline void EventUnderwrite::clear_marketid() {
  _impl_.marketid_.ClearToEmpty();
}
inline const std::string& EventUnderwrite::marketid() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.EventUnderwrite.marketId)
  return _internal_marketid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventUnderwrite::set_marketid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.marketid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.insurance.v1beta1.EventUnderwrite.marketId)
}
inline std::string* EventUnderwrite::mutable_marketid() {
  std::string* _s = _internal_mutable_marketid();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.EventUnderwrite.marketId)
  return _s;
}
inline const std::string& EventUnderwrite::_internal_marketid() const {
  return _impl_.marketid_.Get();
}
inline void EventUnderwrite::_internal_set_marketid(const std::string& value) {
  ;


  _impl_.marketid_.Set(value, GetArenaForAllocation());
}
inline std::string* EventUnderwrite::_internal_mutable_marketid() {
  ;
  return _impl_.marketid_.Mutable( GetArenaForAllocation());
}
inline std::string* EventUnderwrite::release_marketid() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.EventUnderwrite.marketId)
  return _impl_.marketid_.Release();
}
inline void EventUnderwrite::set_allocated_marketid(std::string* value) {
  _impl_.marketid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.marketid_.IsDefault()) {
          _impl_.marketid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.EventUnderwrite.marketId)
}

// .cosmos.base.v1beta1.Coin deposit = 3 [json_name = "deposit", (.gogoproto.nullable) = false];
inline bool EventUnderwrite::has_deposit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deposit_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& EventUnderwrite::_internal_deposit() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.deposit_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& EventUnderwrite::deposit() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.EventUnderwrite.deposit)
  return _internal_deposit();
}
inline void EventUnderwrite::unsafe_arena_set_allocated_deposit(
    ::cosmos::base::v1beta1::Coin* deposit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deposit_);
  }
  _impl_.deposit_ = deposit;
  if (deposit) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.EventUnderwrite.deposit)
}
inline ::cosmos::base::v1beta1::Coin* EventUnderwrite::release_deposit() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.deposit_;
  _impl_.deposit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventUnderwrite::unsafe_arena_release_deposit() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.EventUnderwrite.deposit)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.deposit_;
  _impl_.deposit_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventUnderwrite::_internal_mutable_deposit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deposit_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.deposit_ = p;
  }
  return _impl_.deposit_;
}
inline ::cosmos::base::v1beta1::Coin* EventUnderwrite::mutable_deposit() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_deposit();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.EventUnderwrite.deposit)
  return _msg;
}
inline void EventUnderwrite::set_allocated_deposit(::cosmos::base::v1beta1::Coin* deposit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deposit_);
  }
  if (deposit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deposit));
    if (message_arena != submessage_arena) {
      deposit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deposit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deposit_ = deposit;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.EventUnderwrite.deposit)
}

// .cosmos.base.v1beta1.Coin shares = 4 [json_name = "shares", (.gogoproto.nullable) = false];
inline bool EventUnderwrite::has_shares() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shares_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& EventUnderwrite::_internal_shares() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.shares_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& EventUnderwrite::shares() const {
  // @@protoc_insertion_point(field_get:injective.insurance.v1beta1.EventUnderwrite.shares)
  return _internal_shares();
}
inline void EventUnderwrite::unsafe_arena_set_allocated_shares(
    ::cosmos::base::v1beta1::Coin* shares) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shares_);
  }
  _impl_.shares_ = shares;
  if (shares) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.insurance.v1beta1.EventUnderwrite.shares)
}
inline ::cosmos::base::v1beta1::Coin* EventUnderwrite::release_shares() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.shares_;
  _impl_.shares_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventUnderwrite::unsafe_arena_release_shares() {
  // @@protoc_insertion_point(field_release:injective.insurance.v1beta1.EventUnderwrite.shares)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.shares_;
  _impl_.shares_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventUnderwrite::_internal_mutable_shares() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shares_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.shares_ = p;
  }
  return _impl_.shares_;
}
inline ::cosmos::base::v1beta1::Coin* EventUnderwrite::mutable_shares() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_shares();
  // @@protoc_insertion_point(field_mutable:injective.insurance.v1beta1.EventUnderwrite.shares)
  return _msg;
}
inline void EventUnderwrite::set_allocated_shares(::cosmos::base::v1beta1::Coin* shares) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shares_);
  }
  if (shares) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shares));
    if (message_arena != submessage_arena) {
      shares = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shares, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.shares_ = shares;
  // @@protoc_insertion_point(field_set_allocated:injective.insurance.v1beta1.EventUnderwrite.shares)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace insurance
}  // namespace injective


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2finsurance_2fv1beta1_2finsurance_2eproto_2epb_2eh
