// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tendermint/privval/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tendermint_2fprivval_2ftypes_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tendermint_2fprivval_2ftypes_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "tendermint/crypto/keys.pb.h"
#include "tendermint/types/types.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tendermint_2fprivval_2ftypes_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tendermint_2fprivval_2ftypes_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_tendermint_2fprivval_2ftypes_2eproto;
namespace tendermint {
namespace privval {
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class PubKeyRequest;
struct PubKeyRequestDefaultTypeInternal;
extern PubKeyRequestDefaultTypeInternal _PubKeyRequest_default_instance_;
class PubKeyResponse;
struct PubKeyResponseDefaultTypeInternal;
extern PubKeyResponseDefaultTypeInternal _PubKeyResponse_default_instance_;
class RemoteSignerError;
struct RemoteSignerErrorDefaultTypeInternal;
extern RemoteSignerErrorDefaultTypeInternal _RemoteSignerError_default_instance_;
class SignProposalRequest;
struct SignProposalRequestDefaultTypeInternal;
extern SignProposalRequestDefaultTypeInternal _SignProposalRequest_default_instance_;
class SignVoteRequest;
struct SignVoteRequestDefaultTypeInternal;
extern SignVoteRequestDefaultTypeInternal _SignVoteRequest_default_instance_;
class SignedProposalResponse;
struct SignedProposalResponseDefaultTypeInternal;
extern SignedProposalResponseDefaultTypeInternal _SignedProposalResponse_default_instance_;
class SignedVoteResponse;
struct SignedVoteResponseDefaultTypeInternal;
extern SignedVoteResponseDefaultTypeInternal _SignedVoteResponse_default_instance_;
}  // namespace privval
}  // namespace tendermint
PROTOBUF_NAMESPACE_OPEN
template <>
::tendermint::privval::Message* Arena::CreateMaybeMessage<::tendermint::privval::Message>(Arena*);
template <>
::tendermint::privval::PingRequest* Arena::CreateMaybeMessage<::tendermint::privval::PingRequest>(Arena*);
template <>
::tendermint::privval::PingResponse* Arena::CreateMaybeMessage<::tendermint::privval::PingResponse>(Arena*);
template <>
::tendermint::privval::PubKeyRequest* Arena::CreateMaybeMessage<::tendermint::privval::PubKeyRequest>(Arena*);
template <>
::tendermint::privval::PubKeyResponse* Arena::CreateMaybeMessage<::tendermint::privval::PubKeyResponse>(Arena*);
template <>
::tendermint::privval::RemoteSignerError* Arena::CreateMaybeMessage<::tendermint::privval::RemoteSignerError>(Arena*);
template <>
::tendermint::privval::SignProposalRequest* Arena::CreateMaybeMessage<::tendermint::privval::SignProposalRequest>(Arena*);
template <>
::tendermint::privval::SignVoteRequest* Arena::CreateMaybeMessage<::tendermint::privval::SignVoteRequest>(Arena*);
template <>
::tendermint::privval::SignedProposalResponse* Arena::CreateMaybeMessage<::tendermint::privval::SignedProposalResponse>(Arena*);
template <>
::tendermint::privval::SignedVoteResponse* Arena::CreateMaybeMessage<::tendermint::privval::SignedVoteResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace tendermint {
namespace privval {
enum Errors : int {
  ERRORS_UNKNOWN = 0,
  ERRORS_UNEXPECTED_RESPONSE = 1,
  ERRORS_NO_CONNECTION = 2,
  ERRORS_CONNECTION_TIMEOUT = 3,
  ERRORS_READ_TIMEOUT = 4,
  ERRORS_WRITE_TIMEOUT = 5,
  Errors_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Errors_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Errors_IsValid(int value);
constexpr Errors Errors_MIN = static_cast<Errors>(0);
constexpr Errors Errors_MAX = static_cast<Errors>(5);
constexpr int Errors_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Errors_descriptor();
template <typename T>
const std::string& Errors_Name(T value) {
  static_assert(std::is_same<T, Errors>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Errors_Name().");
  return Errors_Name(static_cast<Errors>(value));
}
template <>
inline const std::string& Errors_Name(Errors value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Errors_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Errors_Parse(absl::string_view name, Errors* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Errors>(
      Errors_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RemoteSignerError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.RemoteSignerError) */ {
 public:
  inline RemoteSignerError() : RemoteSignerError(nullptr) {}
  ~RemoteSignerError() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteSignerError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteSignerError(const RemoteSignerError& from);
  RemoteSignerError(RemoteSignerError&& from) noexcept
    : RemoteSignerError() {
    *this = ::std::move(from);
  }

  inline RemoteSignerError& operator=(const RemoteSignerError& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteSignerError& operator=(RemoteSignerError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteSignerError& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteSignerError* internal_default_instance() {
    return reinterpret_cast<const RemoteSignerError*>(
               &_RemoteSignerError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RemoteSignerError& a, RemoteSignerError& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteSignerError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteSignerError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteSignerError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteSignerError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteSignerError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoteSignerError& from) {
    RemoteSignerError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteSignerError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.RemoteSignerError";
  }
  protected:
  explicit RemoteSignerError(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // int32 code = 1 [json_name = "code"];
  void clear_code() ;
  ::int32_t code() const;
  void set_code(::int32_t value);

  private:
  ::int32_t _internal_code() const;
  void _internal_set_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.privval.RemoteSignerError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class PubKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.PubKeyRequest) */ {
 public:
  inline PubKeyRequest() : PubKeyRequest(nullptr) {}
  ~PubKeyRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PubKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PubKeyRequest(const PubKeyRequest& from);
  PubKeyRequest(PubKeyRequest&& from) noexcept
    : PubKeyRequest() {
    *this = ::std::move(from);
  }

  inline PubKeyRequest& operator=(const PubKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubKeyRequest& operator=(PubKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PubKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PubKeyRequest* internal_default_instance() {
    return reinterpret_cast<const PubKeyRequest*>(
               &_PubKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PubKeyRequest& a, PubKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PubKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PubKeyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PubKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PubKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PubKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PubKeyRequest& from) {
    PubKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PubKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.PubKeyRequest";
  }
  protected:
  explicit PubKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 1,
  };
  // string chain_id = 1 [json_name = "chainId"];
  void clear_chain_id() ;
  const std::string& chain_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chain_id(Arg_&& arg, Args_... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* ptr);

  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(
      const std::string& value);
  std::string* _internal_mutable_chain_id();

  public:
  // @@protoc_insertion_point(class_scope:tendermint.privval.PubKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class PubKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.PubKeyResponse) */ {
 public:
  inline PubKeyResponse() : PubKeyResponse(nullptr) {}
  ~PubKeyResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PubKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PubKeyResponse(const PubKeyResponse& from);
  PubKeyResponse(PubKeyResponse&& from) noexcept
    : PubKeyResponse() {
    *this = ::std::move(from);
  }

  inline PubKeyResponse& operator=(const PubKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubKeyResponse& operator=(PubKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PubKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PubKeyResponse* internal_default_instance() {
    return reinterpret_cast<const PubKeyResponse*>(
               &_PubKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PubKeyResponse& a, PubKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PubKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PubKeyResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PubKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PubKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PubKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PubKeyResponse& from) {
    PubKeyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PubKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.PubKeyResponse";
  }
  protected:
  explicit PubKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .tendermint.crypto.PublicKey pub_key = 1 [json_name = "pubKey", (.gogoproto.nullable) = false];
  bool has_pub_key() const;
  void clear_pub_key() ;
  const ::tendermint::crypto::PublicKey& pub_key() const;
  PROTOBUF_NODISCARD ::tendermint::crypto::PublicKey* release_pub_key();
  ::tendermint::crypto::PublicKey* mutable_pub_key();
  void set_allocated_pub_key(::tendermint::crypto::PublicKey* pub_key);
  private:
  const ::tendermint::crypto::PublicKey& _internal_pub_key() const;
  ::tendermint::crypto::PublicKey* _internal_mutable_pub_key();
  public:
  void unsafe_arena_set_allocated_pub_key(
      ::tendermint::crypto::PublicKey* pub_key);
  ::tendermint::crypto::PublicKey* unsafe_arena_release_pub_key();
  // .tendermint.privval.RemoteSignerError error = 2 [json_name = "error"];
  bool has_error() const;
  void clear_error() ;
  const ::tendermint::privval::RemoteSignerError& error() const;
  PROTOBUF_NODISCARD ::tendermint::privval::RemoteSignerError* release_error();
  ::tendermint::privval::RemoteSignerError* mutable_error();
  void set_allocated_error(::tendermint::privval::RemoteSignerError* error);
  private:
  const ::tendermint::privval::RemoteSignerError& _internal_error() const;
  ::tendermint::privval::RemoteSignerError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tendermint::privval::RemoteSignerError* error);
  ::tendermint::privval::RemoteSignerError* unsafe_arena_release_error();
  // @@protoc_insertion_point(class_scope:tendermint.privval.PubKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::tendermint::crypto::PublicKey* pub_key_;
    ::tendermint::privval::RemoteSignerError* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class SignVoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.SignVoteRequest) */ {
 public:
  inline SignVoteRequest() : SignVoteRequest(nullptr) {}
  ~SignVoteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignVoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignVoteRequest(const SignVoteRequest& from);
  SignVoteRequest(SignVoteRequest&& from) noexcept
    : SignVoteRequest() {
    *this = ::std::move(from);
  }

  inline SignVoteRequest& operator=(const SignVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignVoteRequest& operator=(SignVoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignVoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignVoteRequest* internal_default_instance() {
    return reinterpret_cast<const SignVoteRequest*>(
               &_SignVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SignVoteRequest& a, SignVoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignVoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignVoteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignVoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignVoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignVoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignVoteRequest& from) {
    SignVoteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignVoteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.SignVoteRequest";
  }
  protected:
  explicit SignVoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 2,
    kVoteFieldNumber = 1,
  };
  // string chain_id = 2 [json_name = "chainId"];
  void clear_chain_id() ;
  const std::string& chain_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chain_id(Arg_&& arg, Args_... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* ptr);

  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(
      const std::string& value);
  std::string* _internal_mutable_chain_id();

  public:
  // .tendermint.types.Vote vote = 1 [json_name = "vote"];
  bool has_vote() const;
  void clear_vote() ;
  const ::tendermint::types::Vote& vote() const;
  PROTOBUF_NODISCARD ::tendermint::types::Vote* release_vote();
  ::tendermint::types::Vote* mutable_vote();
  void set_allocated_vote(::tendermint::types::Vote* vote);
  private:
  const ::tendermint::types::Vote& _internal_vote() const;
  ::tendermint::types::Vote* _internal_mutable_vote();
  public:
  void unsafe_arena_set_allocated_vote(
      ::tendermint::types::Vote* vote);
  ::tendermint::types::Vote* unsafe_arena_release_vote();
  // @@protoc_insertion_point(class_scope:tendermint.privval.SignVoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
    ::tendermint::types::Vote* vote_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class SignedVoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.SignedVoteResponse) */ {
 public:
  inline SignedVoteResponse() : SignedVoteResponse(nullptr) {}
  ~SignedVoteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignedVoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedVoteResponse(const SignedVoteResponse& from);
  SignedVoteResponse(SignedVoteResponse&& from) noexcept
    : SignedVoteResponse() {
    *this = ::std::move(from);
  }

  inline SignedVoteResponse& operator=(const SignedVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedVoteResponse& operator=(SignedVoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedVoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedVoteResponse* internal_default_instance() {
    return reinterpret_cast<const SignedVoteResponse*>(
               &_SignedVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SignedVoteResponse& a, SignedVoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedVoteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedVoteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedVoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedVoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignedVoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignedVoteResponse& from) {
    SignedVoteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedVoteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.SignedVoteResponse";
  }
  protected:
  explicit SignedVoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .tendermint.types.Vote vote = 1 [json_name = "vote", (.gogoproto.nullable) = false];
  bool has_vote() const;
  void clear_vote() ;
  const ::tendermint::types::Vote& vote() const;
  PROTOBUF_NODISCARD ::tendermint::types::Vote* release_vote();
  ::tendermint::types::Vote* mutable_vote();
  void set_allocated_vote(::tendermint::types::Vote* vote);
  private:
  const ::tendermint::types::Vote& _internal_vote() const;
  ::tendermint::types::Vote* _internal_mutable_vote();
  public:
  void unsafe_arena_set_allocated_vote(
      ::tendermint::types::Vote* vote);
  ::tendermint::types::Vote* unsafe_arena_release_vote();
  // .tendermint.privval.RemoteSignerError error = 2 [json_name = "error"];
  bool has_error() const;
  void clear_error() ;
  const ::tendermint::privval::RemoteSignerError& error() const;
  PROTOBUF_NODISCARD ::tendermint::privval::RemoteSignerError* release_error();
  ::tendermint::privval::RemoteSignerError* mutable_error();
  void set_allocated_error(::tendermint::privval::RemoteSignerError* error);
  private:
  const ::tendermint::privval::RemoteSignerError& _internal_error() const;
  ::tendermint::privval::RemoteSignerError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tendermint::privval::RemoteSignerError* error);
  ::tendermint::privval::RemoteSignerError* unsafe_arena_release_error();
  // @@protoc_insertion_point(class_scope:tendermint.privval.SignedVoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::tendermint::types::Vote* vote_;
    ::tendermint::privval::RemoteSignerError* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class SignProposalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.SignProposalRequest) */ {
 public:
  inline SignProposalRequest() : SignProposalRequest(nullptr) {}
  ~SignProposalRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignProposalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignProposalRequest(const SignProposalRequest& from);
  SignProposalRequest(SignProposalRequest&& from) noexcept
    : SignProposalRequest() {
    *this = ::std::move(from);
  }

  inline SignProposalRequest& operator=(const SignProposalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignProposalRequest& operator=(SignProposalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignProposalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignProposalRequest* internal_default_instance() {
    return reinterpret_cast<const SignProposalRequest*>(
               &_SignProposalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SignProposalRequest& a, SignProposalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignProposalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignProposalRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignProposalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignProposalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignProposalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignProposalRequest& from) {
    SignProposalRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignProposalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.SignProposalRequest";
  }
  protected:
  explicit SignProposalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 2,
    kProposalFieldNumber = 1,
  };
  // string chain_id = 2 [json_name = "chainId"];
  void clear_chain_id() ;
  const std::string& chain_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chain_id(Arg_&& arg, Args_... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* ptr);

  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(
      const std::string& value);
  std::string* _internal_mutable_chain_id();

  public:
  // .tendermint.types.Proposal proposal = 1 [json_name = "proposal"];
  bool has_proposal() const;
  void clear_proposal() ;
  const ::tendermint::types::Proposal& proposal() const;
  PROTOBUF_NODISCARD ::tendermint::types::Proposal* release_proposal();
  ::tendermint::types::Proposal* mutable_proposal();
  void set_allocated_proposal(::tendermint::types::Proposal* proposal);
  private:
  const ::tendermint::types::Proposal& _internal_proposal() const;
  ::tendermint::types::Proposal* _internal_mutable_proposal();
  public:
  void unsafe_arena_set_allocated_proposal(
      ::tendermint::types::Proposal* proposal);
  ::tendermint::types::Proposal* unsafe_arena_release_proposal();
  // @@protoc_insertion_point(class_scope:tendermint.privval.SignProposalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
    ::tendermint::types::Proposal* proposal_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class SignedProposalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.SignedProposalResponse) */ {
 public:
  inline SignedProposalResponse() : SignedProposalResponse(nullptr) {}
  ~SignedProposalResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignedProposalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedProposalResponse(const SignedProposalResponse& from);
  SignedProposalResponse(SignedProposalResponse&& from) noexcept
    : SignedProposalResponse() {
    *this = ::std::move(from);
  }

  inline SignedProposalResponse& operator=(const SignedProposalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedProposalResponse& operator=(SignedProposalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedProposalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedProposalResponse* internal_default_instance() {
    return reinterpret_cast<const SignedProposalResponse*>(
               &_SignedProposalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SignedProposalResponse& a, SignedProposalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedProposalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedProposalResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedProposalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedProposalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignedProposalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignedProposalResponse& from) {
    SignedProposalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedProposalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.SignedProposalResponse";
  }
  protected:
  explicit SignedProposalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .tendermint.types.Proposal proposal = 1 [json_name = "proposal", (.gogoproto.nullable) = false];
  bool has_proposal() const;
  void clear_proposal() ;
  const ::tendermint::types::Proposal& proposal() const;
  PROTOBUF_NODISCARD ::tendermint::types::Proposal* release_proposal();
  ::tendermint::types::Proposal* mutable_proposal();
  void set_allocated_proposal(::tendermint::types::Proposal* proposal);
  private:
  const ::tendermint::types::Proposal& _internal_proposal() const;
  ::tendermint::types::Proposal* _internal_mutable_proposal();
  public:
  void unsafe_arena_set_allocated_proposal(
      ::tendermint::types::Proposal* proposal);
  ::tendermint::types::Proposal* unsafe_arena_release_proposal();
  // .tendermint.privval.RemoteSignerError error = 2 [json_name = "error"];
  bool has_error() const;
  void clear_error() ;
  const ::tendermint::privval::RemoteSignerError& error() const;
  PROTOBUF_NODISCARD ::tendermint::privval::RemoteSignerError* release_error();
  ::tendermint::privval::RemoteSignerError* mutable_error();
  void set_allocated_error(::tendermint::privval::RemoteSignerError* error);
  private:
  const ::tendermint::privval::RemoteSignerError& _internal_error() const;
  ::tendermint::privval::RemoteSignerError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tendermint::privval::RemoteSignerError* error);
  ::tendermint::privval::RemoteSignerError* unsafe_arena_release_error();
  // @@protoc_insertion_point(class_scope:tendermint.privval.SignedProposalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::tendermint::types::Proposal* proposal_;
    ::tendermint::privval::RemoteSignerError* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.privval.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.privval.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class PingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.privval.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.privval.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum SumCase {
    kPubKeyRequest = 1,
    kPubKeyResponse = 2,
    kSignVoteRequest = 3,
    kSignedVoteResponse = 4,
    kSignProposalRequest = 5,
    kSignedProposalResponse = 6,
    kPingRequest = 7,
    kPingResponse = 8,
    SUM_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.privval.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyRequestFieldNumber = 1,
    kPubKeyResponseFieldNumber = 2,
    kSignVoteRequestFieldNumber = 3,
    kSignedVoteResponseFieldNumber = 4,
    kSignProposalRequestFieldNumber = 5,
    kSignedProposalResponseFieldNumber = 6,
    kPingRequestFieldNumber = 7,
    kPingResponseFieldNumber = 8,
  };
  // .tendermint.privval.PubKeyRequest pub_key_request = 1 [json_name = "pubKeyRequest"];
  bool has_pub_key_request() const;
  private:
  bool _internal_has_pub_key_request() const;

  public:
  void clear_pub_key_request() ;
  const ::tendermint::privval::PubKeyRequest& pub_key_request() const;
  PROTOBUF_NODISCARD ::tendermint::privval::PubKeyRequest* release_pub_key_request();
  ::tendermint::privval::PubKeyRequest* mutable_pub_key_request();
  void set_allocated_pub_key_request(::tendermint::privval::PubKeyRequest* pub_key_request);
  private:
  const ::tendermint::privval::PubKeyRequest& _internal_pub_key_request() const;
  ::tendermint::privval::PubKeyRequest* _internal_mutable_pub_key_request();
  public:
  void unsafe_arena_set_allocated_pub_key_request(
      ::tendermint::privval::PubKeyRequest* pub_key_request);
  ::tendermint::privval::PubKeyRequest* unsafe_arena_release_pub_key_request();
  // .tendermint.privval.PubKeyResponse pub_key_response = 2 [json_name = "pubKeyResponse"];
  bool has_pub_key_response() const;
  private:
  bool _internal_has_pub_key_response() const;

  public:
  void clear_pub_key_response() ;
  const ::tendermint::privval::PubKeyResponse& pub_key_response() const;
  PROTOBUF_NODISCARD ::tendermint::privval::PubKeyResponse* release_pub_key_response();
  ::tendermint::privval::PubKeyResponse* mutable_pub_key_response();
  void set_allocated_pub_key_response(::tendermint::privval::PubKeyResponse* pub_key_response);
  private:
  const ::tendermint::privval::PubKeyResponse& _internal_pub_key_response() const;
  ::tendermint::privval::PubKeyResponse* _internal_mutable_pub_key_response();
  public:
  void unsafe_arena_set_allocated_pub_key_response(
      ::tendermint::privval::PubKeyResponse* pub_key_response);
  ::tendermint::privval::PubKeyResponse* unsafe_arena_release_pub_key_response();
  // .tendermint.privval.SignVoteRequest sign_vote_request = 3 [json_name = "signVoteRequest"];
  bool has_sign_vote_request() const;
  private:
  bool _internal_has_sign_vote_request() const;

  public:
  void clear_sign_vote_request() ;
  const ::tendermint::privval::SignVoteRequest& sign_vote_request() const;
  PROTOBUF_NODISCARD ::tendermint::privval::SignVoteRequest* release_sign_vote_request();
  ::tendermint::privval::SignVoteRequest* mutable_sign_vote_request();
  void set_allocated_sign_vote_request(::tendermint::privval::SignVoteRequest* sign_vote_request);
  private:
  const ::tendermint::privval::SignVoteRequest& _internal_sign_vote_request() const;
  ::tendermint::privval::SignVoteRequest* _internal_mutable_sign_vote_request();
  public:
  void unsafe_arena_set_allocated_sign_vote_request(
      ::tendermint::privval::SignVoteRequest* sign_vote_request);
  ::tendermint::privval::SignVoteRequest* unsafe_arena_release_sign_vote_request();
  // .tendermint.privval.SignedVoteResponse signed_vote_response = 4 [json_name = "signedVoteResponse"];
  bool has_signed_vote_response() const;
  private:
  bool _internal_has_signed_vote_response() const;

  public:
  void clear_signed_vote_response() ;
  const ::tendermint::privval::SignedVoteResponse& signed_vote_response() const;
  PROTOBUF_NODISCARD ::tendermint::privval::SignedVoteResponse* release_signed_vote_response();
  ::tendermint::privval::SignedVoteResponse* mutable_signed_vote_response();
  void set_allocated_signed_vote_response(::tendermint::privval::SignedVoteResponse* signed_vote_response);
  private:
  const ::tendermint::privval::SignedVoteResponse& _internal_signed_vote_response() const;
  ::tendermint::privval::SignedVoteResponse* _internal_mutable_signed_vote_response();
  public:
  void unsafe_arena_set_allocated_signed_vote_response(
      ::tendermint::privval::SignedVoteResponse* signed_vote_response);
  ::tendermint::privval::SignedVoteResponse* unsafe_arena_release_signed_vote_response();
  // .tendermint.privval.SignProposalRequest sign_proposal_request = 5 [json_name = "signProposalRequest"];
  bool has_sign_proposal_request() const;
  private:
  bool _internal_has_sign_proposal_request() const;

  public:
  void clear_sign_proposal_request() ;
  const ::tendermint::privval::SignProposalRequest& sign_proposal_request() const;
  PROTOBUF_NODISCARD ::tendermint::privval::SignProposalRequest* release_sign_proposal_request();
  ::tendermint::privval::SignProposalRequest* mutable_sign_proposal_request();
  void set_allocated_sign_proposal_request(::tendermint::privval::SignProposalRequest* sign_proposal_request);
  private:
  const ::tendermint::privval::SignProposalRequest& _internal_sign_proposal_request() const;
  ::tendermint::privval::SignProposalRequest* _internal_mutable_sign_proposal_request();
  public:
  void unsafe_arena_set_allocated_sign_proposal_request(
      ::tendermint::privval::SignProposalRequest* sign_proposal_request);
  ::tendermint::privval::SignProposalRequest* unsafe_arena_release_sign_proposal_request();
  // .tendermint.privval.SignedProposalResponse signed_proposal_response = 6 [json_name = "signedProposalResponse"];
  bool has_signed_proposal_response() const;
  private:
  bool _internal_has_signed_proposal_response() const;

  public:
  void clear_signed_proposal_response() ;
  const ::tendermint::privval::SignedProposalResponse& signed_proposal_response() const;
  PROTOBUF_NODISCARD ::tendermint::privval::SignedProposalResponse* release_signed_proposal_response();
  ::tendermint::privval::SignedProposalResponse* mutable_signed_proposal_response();
  void set_allocated_signed_proposal_response(::tendermint::privval::SignedProposalResponse* signed_proposal_response);
  private:
  const ::tendermint::privval::SignedProposalResponse& _internal_signed_proposal_response() const;
  ::tendermint::privval::SignedProposalResponse* _internal_mutable_signed_proposal_response();
  public:
  void unsafe_arena_set_allocated_signed_proposal_response(
      ::tendermint::privval::SignedProposalResponse* signed_proposal_response);
  ::tendermint::privval::SignedProposalResponse* unsafe_arena_release_signed_proposal_response();
  // .tendermint.privval.PingRequest ping_request = 7 [json_name = "pingRequest"];
  bool has_ping_request() const;
  private:
  bool _internal_has_ping_request() const;

  public:
  void clear_ping_request() ;
  const ::tendermint::privval::PingRequest& ping_request() const;
  PROTOBUF_NODISCARD ::tendermint::privval::PingRequest* release_ping_request();
  ::tendermint::privval::PingRequest* mutable_ping_request();
  void set_allocated_ping_request(::tendermint::privval::PingRequest* ping_request);
  private:
  const ::tendermint::privval::PingRequest& _internal_ping_request() const;
  ::tendermint::privval::PingRequest* _internal_mutable_ping_request();
  public:
  void unsafe_arena_set_allocated_ping_request(
      ::tendermint::privval::PingRequest* ping_request);
  ::tendermint::privval::PingRequest* unsafe_arena_release_ping_request();
  // .tendermint.privval.PingResponse ping_response = 8 [json_name = "pingResponse"];
  bool has_ping_response() const;
  private:
  bool _internal_has_ping_response() const;

  public:
  void clear_ping_response() ;
  const ::tendermint::privval::PingResponse& ping_response() const;
  PROTOBUF_NODISCARD ::tendermint::privval::PingResponse* release_ping_response();
  ::tendermint::privval::PingResponse* mutable_ping_response();
  void set_allocated_ping_response(::tendermint::privval::PingResponse* ping_response);
  private:
  const ::tendermint::privval::PingResponse& _internal_ping_response() const;
  ::tendermint::privval::PingResponse* _internal_mutable_ping_response();
  public:
  void unsafe_arena_set_allocated_ping_response(
      ::tendermint::privval::PingResponse* ping_response);
  ::tendermint::privval::PingResponse* unsafe_arena_release_ping_response();
  void clear_sum();
  SumCase sum_case() const;
  // @@protoc_insertion_point(class_scope:tendermint.privval.Message)
 private:
  class _Internal;
  void set_has_pub_key_request();
  void set_has_pub_key_response();
  void set_has_sign_vote_request();
  void set_has_signed_vote_response();
  void set_has_sign_proposal_request();
  void set_has_signed_proposal_response();
  void set_has_ping_request();
  void set_has_ping_response();

  inline bool has_sum() const;
  inline void clear_has_sum();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SumUnion {
      constexpr SumUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tendermint::privval::PubKeyRequest* pub_key_request_;
      ::tendermint::privval::PubKeyResponse* pub_key_response_;
      ::tendermint::privval::SignVoteRequest* sign_vote_request_;
      ::tendermint::privval::SignedVoteResponse* signed_vote_response_;
      ::tendermint::privval::SignProposalRequest* sign_proposal_request_;
      ::tendermint::privval::SignedProposalResponse* signed_proposal_response_;
      ::tendermint::privval::PingRequest* ping_request_;
      ::tendermint::privval::PingResponse* ping_response_;
    } sum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RemoteSignerError

// int32 code = 1 [json_name = "code"];
inline void RemoteSignerError::clear_code() {
  _impl_.code_ = 0;
}
inline ::int32_t RemoteSignerError::code() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.RemoteSignerError.code)
  return _internal_code();
}
inline void RemoteSignerError::set_code(::int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.privval.RemoteSignerError.code)
}
inline ::int32_t RemoteSignerError::_internal_code() const {
  return _impl_.code_;
}
inline void RemoteSignerError::_internal_set_code(::int32_t value) {
  ;
  _impl_.code_ = value;
}

// string description = 2 [json_name = "description"];
inline void RemoteSignerError::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RemoteSignerError::description() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.RemoteSignerError.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteSignerError::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.privval.RemoteSignerError.description)
}
inline std::string* RemoteSignerError::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.RemoteSignerError.description)
  return _s;
}
inline const std::string& RemoteSignerError::_internal_description() const {
  return _impl_.description_.Get();
}
inline void RemoteSignerError::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteSignerError::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* RemoteSignerError::release_description() {
  // @@protoc_insertion_point(field_release:tendermint.privval.RemoteSignerError.description)
  return _impl_.description_.Release();
}
inline void RemoteSignerError::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.RemoteSignerError.description)
}

// -------------------------------------------------------------------

// PubKeyRequest

// string chain_id = 1 [json_name = "chainId"];
inline void PubKeyRequest::clear_chain_id() {
  _impl_.chain_id_.ClearToEmpty();
}
inline const std::string& PubKeyRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.PubKeyRequest.chain_id)
  return _internal_chain_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PubKeyRequest::set_chain_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.chain_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.privval.PubKeyRequest.chain_id)
}
inline std::string* PubKeyRequest::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.PubKeyRequest.chain_id)
  return _s;
}
inline const std::string& PubKeyRequest::_internal_chain_id() const {
  return _impl_.chain_id_.Get();
}
inline void PubKeyRequest::_internal_set_chain_id(const std::string& value) {
  ;


  _impl_.chain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PubKeyRequest::_internal_mutable_chain_id() {
  ;
  return _impl_.chain_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PubKeyRequest::release_chain_id() {
  // @@protoc_insertion_point(field_release:tendermint.privval.PubKeyRequest.chain_id)
  return _impl_.chain_id_.Release();
}
inline void PubKeyRequest::set_allocated_chain_id(std::string* value) {
  _impl_.chain_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chain_id_.IsDefault()) {
          _impl_.chain_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.PubKeyRequest.chain_id)
}

// -------------------------------------------------------------------

// PubKeyResponse

// .tendermint.crypto.PublicKey pub_key = 1 [json_name = "pubKey", (.gogoproto.nullable) = false];
inline bool PubKeyResponse::has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pub_key_ != nullptr);
  return value;
}
inline const ::tendermint::crypto::PublicKey& PubKeyResponse::_internal_pub_key() const {
  const ::tendermint::crypto::PublicKey* p = _impl_.pub_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::crypto::PublicKey&>(
      ::tendermint::crypto::_PublicKey_default_instance_);
}
inline const ::tendermint::crypto::PublicKey& PubKeyResponse::pub_key() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.PubKeyResponse.pub_key)
  return _internal_pub_key();
}
inline void PubKeyResponse::unsafe_arena_set_allocated_pub_key(
    ::tendermint::crypto::PublicKey* pub_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pub_key_);
  }
  _impl_.pub_key_ = pub_key;
  if (pub_key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.PubKeyResponse.pub_key)
}
inline ::tendermint::crypto::PublicKey* PubKeyResponse::release_pub_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::crypto::PublicKey* temp = _impl_.pub_key_;
  _impl_.pub_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::crypto::PublicKey* PubKeyResponse::unsafe_arena_release_pub_key() {
  // @@protoc_insertion_point(field_release:tendermint.privval.PubKeyResponse.pub_key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::crypto::PublicKey* temp = _impl_.pub_key_;
  _impl_.pub_key_ = nullptr;
  return temp;
}
inline ::tendermint::crypto::PublicKey* PubKeyResponse::_internal_mutable_pub_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::crypto::PublicKey>(GetArenaForAllocation());
    _impl_.pub_key_ = p;
  }
  return _impl_.pub_key_;
}
inline ::tendermint::crypto::PublicKey* PubKeyResponse::mutable_pub_key() {
  ::tendermint::crypto::PublicKey* _msg = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.PubKeyResponse.pub_key)
  return _msg;
}
inline void PubKeyResponse::set_allocated_pub_key(::tendermint::crypto::PublicKey* pub_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pub_key_);
  }
  if (pub_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pub_key));
    if (message_arena != submessage_arena) {
      pub_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pub_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pub_key_ = pub_key;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.PubKeyResponse.pub_key)
}

// .tendermint.privval.RemoteSignerError error = 2 [json_name = "error"];
inline bool PubKeyResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void PubKeyResponse::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tendermint::privval::RemoteSignerError& PubKeyResponse::_internal_error() const {
  const ::tendermint::privval::RemoteSignerError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::privval::RemoteSignerError&>(
      ::tendermint::privval::_RemoteSignerError_default_instance_);
}
inline const ::tendermint::privval::RemoteSignerError& PubKeyResponse::error() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.PubKeyResponse.error)
  return _internal_error();
}
inline void PubKeyResponse::unsafe_arena_set_allocated_error(
    ::tendermint::privval::RemoteSignerError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.PubKeyResponse.error)
}
inline ::tendermint::privval::RemoteSignerError* PubKeyResponse::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::privval::RemoteSignerError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* PubKeyResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tendermint.privval.PubKeyResponse.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::privval::RemoteSignerError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* PubKeyResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::privval::RemoteSignerError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::tendermint::privval::RemoteSignerError* PubKeyResponse::mutable_error() {
  ::tendermint::privval::RemoteSignerError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.PubKeyResponse.error)
  return _msg;
}
inline void PubKeyResponse::set_allocated_error(::tendermint::privval::RemoteSignerError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.PubKeyResponse.error)
}

// -------------------------------------------------------------------

// SignVoteRequest

// .tendermint.types.Vote vote = 1 [json_name = "vote"];
inline bool SignVoteRequest::has_vote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vote_ != nullptr);
  return value;
}
inline const ::tendermint::types::Vote& SignVoteRequest::_internal_vote() const {
  const ::tendermint::types::Vote* p = _impl_.vote_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Vote&>(
      ::tendermint::types::_Vote_default_instance_);
}
inline const ::tendermint::types::Vote& SignVoteRequest::vote() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignVoteRequest.vote)
  return _internal_vote();
}
inline void SignVoteRequest::unsafe_arena_set_allocated_vote(
    ::tendermint::types::Vote* vote) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vote_);
  }
  _impl_.vote_ = vote;
  if (vote) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignVoteRequest.vote)
}
inline ::tendermint::types::Vote* SignVoteRequest::release_vote() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Vote* temp = _impl_.vote_;
  _impl_.vote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Vote* SignVoteRequest::unsafe_arena_release_vote() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignVoteRequest.vote)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Vote* temp = _impl_.vote_;
  _impl_.vote_ = nullptr;
  return temp;
}
inline ::tendermint::types::Vote* SignVoteRequest::_internal_mutable_vote() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.vote_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Vote>(GetArenaForAllocation());
    _impl_.vote_ = p;
  }
  return _impl_.vote_;
}
inline ::tendermint::types::Vote* SignVoteRequest::mutable_vote() {
  ::tendermint::types::Vote* _msg = _internal_mutable_vote();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignVoteRequest.vote)
  return _msg;
}
inline void SignVoteRequest::set_allocated_vote(::tendermint::types::Vote* vote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vote_);
  }
  if (vote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vote));
    if (message_arena != submessage_arena) {
      vote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vote, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vote_ = vote;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignVoteRequest.vote)
}

// string chain_id = 2 [json_name = "chainId"];
inline void SignVoteRequest::clear_chain_id() {
  _impl_.chain_id_.ClearToEmpty();
}
inline const std::string& SignVoteRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignVoteRequest.chain_id)
  return _internal_chain_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignVoteRequest::set_chain_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.chain_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.privval.SignVoteRequest.chain_id)
}
inline std::string* SignVoteRequest::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignVoteRequest.chain_id)
  return _s;
}
inline const std::string& SignVoteRequest::_internal_chain_id() const {
  return _impl_.chain_id_.Get();
}
inline void SignVoteRequest::_internal_set_chain_id(const std::string& value) {
  ;


  _impl_.chain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SignVoteRequest::_internal_mutable_chain_id() {
  ;
  return _impl_.chain_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SignVoteRequest::release_chain_id() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignVoteRequest.chain_id)
  return _impl_.chain_id_.Release();
}
inline void SignVoteRequest::set_allocated_chain_id(std::string* value) {
  _impl_.chain_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chain_id_.IsDefault()) {
          _impl_.chain_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignVoteRequest.chain_id)
}

// -------------------------------------------------------------------

// SignedVoteResponse

// .tendermint.types.Vote vote = 1 [json_name = "vote", (.gogoproto.nullable) = false];
inline bool SignedVoteResponse::has_vote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vote_ != nullptr);
  return value;
}
inline const ::tendermint::types::Vote& SignedVoteResponse::_internal_vote() const {
  const ::tendermint::types::Vote* p = _impl_.vote_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Vote&>(
      ::tendermint::types::_Vote_default_instance_);
}
inline const ::tendermint::types::Vote& SignedVoteResponse::vote() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignedVoteResponse.vote)
  return _internal_vote();
}
inline void SignedVoteResponse::unsafe_arena_set_allocated_vote(
    ::tendermint::types::Vote* vote) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vote_);
  }
  _impl_.vote_ = vote;
  if (vote) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignedVoteResponse.vote)
}
inline ::tendermint::types::Vote* SignedVoteResponse::release_vote() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Vote* temp = _impl_.vote_;
  _impl_.vote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Vote* SignedVoteResponse::unsafe_arena_release_vote() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignedVoteResponse.vote)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Vote* temp = _impl_.vote_;
  _impl_.vote_ = nullptr;
  return temp;
}
inline ::tendermint::types::Vote* SignedVoteResponse::_internal_mutable_vote() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.vote_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Vote>(GetArenaForAllocation());
    _impl_.vote_ = p;
  }
  return _impl_.vote_;
}
inline ::tendermint::types::Vote* SignedVoteResponse::mutable_vote() {
  ::tendermint::types::Vote* _msg = _internal_mutable_vote();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignedVoteResponse.vote)
  return _msg;
}
inline void SignedVoteResponse::set_allocated_vote(::tendermint::types::Vote* vote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vote_);
  }
  if (vote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vote));
    if (message_arena != submessage_arena) {
      vote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vote, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vote_ = vote;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignedVoteResponse.vote)
}

// .tendermint.privval.RemoteSignerError error = 2 [json_name = "error"];
inline bool SignedVoteResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void SignedVoteResponse::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tendermint::privval::RemoteSignerError& SignedVoteResponse::_internal_error() const {
  const ::tendermint::privval::RemoteSignerError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::privval::RemoteSignerError&>(
      ::tendermint::privval::_RemoteSignerError_default_instance_);
}
inline const ::tendermint::privval::RemoteSignerError& SignedVoteResponse::error() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignedVoteResponse.error)
  return _internal_error();
}
inline void SignedVoteResponse::unsafe_arena_set_allocated_error(
    ::tendermint::privval::RemoteSignerError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignedVoteResponse.error)
}
inline ::tendermint::privval::RemoteSignerError* SignedVoteResponse::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::privval::RemoteSignerError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* SignedVoteResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignedVoteResponse.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::privval::RemoteSignerError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* SignedVoteResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::privval::RemoteSignerError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::tendermint::privval::RemoteSignerError* SignedVoteResponse::mutable_error() {
  ::tendermint::privval::RemoteSignerError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignedVoteResponse.error)
  return _msg;
}
inline void SignedVoteResponse::set_allocated_error(::tendermint::privval::RemoteSignerError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignedVoteResponse.error)
}

// -------------------------------------------------------------------

// SignProposalRequest

// .tendermint.types.Proposal proposal = 1 [json_name = "proposal"];
inline bool SignProposalRequest::has_proposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proposal_ != nullptr);
  return value;
}
inline const ::tendermint::types::Proposal& SignProposalRequest::_internal_proposal() const {
  const ::tendermint::types::Proposal* p = _impl_.proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Proposal&>(
      ::tendermint::types::_Proposal_default_instance_);
}
inline const ::tendermint::types::Proposal& SignProposalRequest::proposal() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignProposalRequest.proposal)
  return _internal_proposal();
}
inline void SignProposalRequest::unsafe_arena_set_allocated_proposal(
    ::tendermint::types::Proposal* proposal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proposal_);
  }
  _impl_.proposal_ = proposal;
  if (proposal) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignProposalRequest.proposal)
}
inline ::tendermint::types::Proposal* SignProposalRequest::release_proposal() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Proposal* temp = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Proposal* SignProposalRequest::unsafe_arena_release_proposal() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignProposalRequest.proposal)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Proposal* temp = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
  return temp;
}
inline ::tendermint::types::Proposal* SignProposalRequest::_internal_mutable_proposal() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Proposal>(GetArenaForAllocation());
    _impl_.proposal_ = p;
  }
  return _impl_.proposal_;
}
inline ::tendermint::types::Proposal* SignProposalRequest::mutable_proposal() {
  ::tendermint::types::Proposal* _msg = _internal_mutable_proposal();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignProposalRequest.proposal)
  return _msg;
}
inline void SignProposalRequest::set_allocated_proposal(::tendermint::types::Proposal* proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proposal_);
  }
  if (proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal));
    if (message_arena != submessage_arena) {
      proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignProposalRequest.proposal)
}

// string chain_id = 2 [json_name = "chainId"];
inline void SignProposalRequest::clear_chain_id() {
  _impl_.chain_id_.ClearToEmpty();
}
inline const std::string& SignProposalRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignProposalRequest.chain_id)
  return _internal_chain_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignProposalRequest::set_chain_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.chain_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.privval.SignProposalRequest.chain_id)
}
inline std::string* SignProposalRequest::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignProposalRequest.chain_id)
  return _s;
}
inline const std::string& SignProposalRequest::_internal_chain_id() const {
  return _impl_.chain_id_.Get();
}
inline void SignProposalRequest::_internal_set_chain_id(const std::string& value) {
  ;


  _impl_.chain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SignProposalRequest::_internal_mutable_chain_id() {
  ;
  return _impl_.chain_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SignProposalRequest::release_chain_id() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignProposalRequest.chain_id)
  return _impl_.chain_id_.Release();
}
inline void SignProposalRequest::set_allocated_chain_id(std::string* value) {
  _impl_.chain_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chain_id_.IsDefault()) {
          _impl_.chain_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignProposalRequest.chain_id)
}

// -------------------------------------------------------------------

// SignedProposalResponse

// .tendermint.types.Proposal proposal = 1 [json_name = "proposal", (.gogoproto.nullable) = false];
inline bool SignedProposalResponse::has_proposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proposal_ != nullptr);
  return value;
}
inline const ::tendermint::types::Proposal& SignedProposalResponse::_internal_proposal() const {
  const ::tendermint::types::Proposal* p = _impl_.proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Proposal&>(
      ::tendermint::types::_Proposal_default_instance_);
}
inline const ::tendermint::types::Proposal& SignedProposalResponse::proposal() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignedProposalResponse.proposal)
  return _internal_proposal();
}
inline void SignedProposalResponse::unsafe_arena_set_allocated_proposal(
    ::tendermint::types::Proposal* proposal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proposal_);
  }
  _impl_.proposal_ = proposal;
  if (proposal) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignedProposalResponse.proposal)
}
inline ::tendermint::types::Proposal* SignedProposalResponse::release_proposal() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Proposal* temp = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Proposal* SignedProposalResponse::unsafe_arena_release_proposal() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignedProposalResponse.proposal)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Proposal* temp = _impl_.proposal_;
  _impl_.proposal_ = nullptr;
  return temp;
}
inline ::tendermint::types::Proposal* SignedProposalResponse::_internal_mutable_proposal() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Proposal>(GetArenaForAllocation());
    _impl_.proposal_ = p;
  }
  return _impl_.proposal_;
}
inline ::tendermint::types::Proposal* SignedProposalResponse::mutable_proposal() {
  ::tendermint::types::Proposal* _msg = _internal_mutable_proposal();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignedProposalResponse.proposal)
  return _msg;
}
inline void SignedProposalResponse::set_allocated_proposal(::tendermint::types::Proposal* proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proposal_);
  }
  if (proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal));
    if (message_arena != submessage_arena) {
      proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignedProposalResponse.proposal)
}

// .tendermint.privval.RemoteSignerError error = 2 [json_name = "error"];
inline bool SignedProposalResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void SignedProposalResponse::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tendermint::privval::RemoteSignerError& SignedProposalResponse::_internal_error() const {
  const ::tendermint::privval::RemoteSignerError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::privval::RemoteSignerError&>(
      ::tendermint::privval::_RemoteSignerError_default_instance_);
}
inline const ::tendermint::privval::RemoteSignerError& SignedProposalResponse::error() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignedProposalResponse.error)
  return _internal_error();
}
inline void SignedProposalResponse::unsafe_arena_set_allocated_error(
    ::tendermint::privval::RemoteSignerError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignedProposalResponse.error)
}
inline ::tendermint::privval::RemoteSignerError* SignedProposalResponse::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::privval::RemoteSignerError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* SignedProposalResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignedProposalResponse.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::privval::RemoteSignerError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* SignedProposalResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::privval::RemoteSignerError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::tendermint::privval::RemoteSignerError* SignedProposalResponse::mutable_error() {
  ::tendermint::privval::RemoteSignerError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignedProposalResponse.error)
  return _msg;
}
inline void SignedProposalResponse::set_allocated_error(::tendermint::privval::RemoteSignerError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignedProposalResponse.error)
}

// -------------------------------------------------------------------

// PingRequest

// -------------------------------------------------------------------

// PingResponse

// -------------------------------------------------------------------

// Message

// .tendermint.privval.PubKeyRequest pub_key_request = 1 [json_name = "pubKeyRequest"];
inline bool Message::has_pub_key_request() const {
  return sum_case() == kPubKeyRequest;
}
inline bool Message::_internal_has_pub_key_request() const {
  return sum_case() == kPubKeyRequest;
}
inline void Message::set_has_pub_key_request() {
  _impl_._oneof_case_[0] = kPubKeyRequest;
}
inline void Message::clear_pub_key_request() {
  if (sum_case() == kPubKeyRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sum_.pub_key_request_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::PubKeyRequest* Message::release_pub_key_request() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.pub_key_request)
  if (sum_case() == kPubKeyRequest) {
    clear_has_sum();
    ::tendermint::privval::PubKeyRequest* temp = _impl_.sum_.pub_key_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sum_.pub_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::PubKeyRequest& Message::_internal_pub_key_request() const {
  return sum_case() == kPubKeyRequest
      ? *_impl_.sum_.pub_key_request_
      : reinterpret_cast<::tendermint::privval::PubKeyRequest&>(::tendermint::privval::_PubKeyRequest_default_instance_);
}
inline const ::tendermint::privval::PubKeyRequest& Message::pub_key_request() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.pub_key_request)
  return _internal_pub_key_request();
}
inline ::tendermint::privval::PubKeyRequest* Message::unsafe_arena_release_pub_key_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.pub_key_request)
  if (sum_case() == kPubKeyRequest) {
    clear_has_sum();
    ::tendermint::privval::PubKeyRequest* temp = _impl_.sum_.pub_key_request_;
    _impl_.sum_.pub_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_pub_key_request(::tendermint::privval::PubKeyRequest* pub_key_request) {
  clear_sum();
  if (pub_key_request) {
    set_has_pub_key_request();
    _impl_.sum_.pub_key_request_ = pub_key_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.pub_key_request)
}
inline ::tendermint::privval::PubKeyRequest* Message::_internal_mutable_pub_key_request() {
  if (sum_case() != kPubKeyRequest) {
    clear_sum();
    set_has_pub_key_request();
    _impl_.sum_.pub_key_request_ = CreateMaybeMessage< ::tendermint::privval::PubKeyRequest >(GetArenaForAllocation());
  }
  return _impl_.sum_.pub_key_request_;
}
inline ::tendermint::privval::PubKeyRequest* Message::mutable_pub_key_request() {
  ::tendermint::privval::PubKeyRequest* _msg = _internal_mutable_pub_key_request();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.pub_key_request)
  return _msg;
}

// .tendermint.privval.PubKeyResponse pub_key_response = 2 [json_name = "pubKeyResponse"];
inline bool Message::has_pub_key_response() const {
  return sum_case() == kPubKeyResponse;
}
inline bool Message::_internal_has_pub_key_response() const {
  return sum_case() == kPubKeyResponse;
}
inline void Message::set_has_pub_key_response() {
  _impl_._oneof_case_[0] = kPubKeyResponse;
}
inline void Message::clear_pub_key_response() {
  if (sum_case() == kPubKeyResponse) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sum_.pub_key_response_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::PubKeyResponse* Message::release_pub_key_response() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.pub_key_response)
  if (sum_case() == kPubKeyResponse) {
    clear_has_sum();
    ::tendermint::privval::PubKeyResponse* temp = _impl_.sum_.pub_key_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sum_.pub_key_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::PubKeyResponse& Message::_internal_pub_key_response() const {
  return sum_case() == kPubKeyResponse
      ? *_impl_.sum_.pub_key_response_
      : reinterpret_cast<::tendermint::privval::PubKeyResponse&>(::tendermint::privval::_PubKeyResponse_default_instance_);
}
inline const ::tendermint::privval::PubKeyResponse& Message::pub_key_response() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.pub_key_response)
  return _internal_pub_key_response();
}
inline ::tendermint::privval::PubKeyResponse* Message::unsafe_arena_release_pub_key_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.pub_key_response)
  if (sum_case() == kPubKeyResponse) {
    clear_has_sum();
    ::tendermint::privval::PubKeyResponse* temp = _impl_.sum_.pub_key_response_;
    _impl_.sum_.pub_key_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_pub_key_response(::tendermint::privval::PubKeyResponse* pub_key_response) {
  clear_sum();
  if (pub_key_response) {
    set_has_pub_key_response();
    _impl_.sum_.pub_key_response_ = pub_key_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.pub_key_response)
}
inline ::tendermint::privval::PubKeyResponse* Message::_internal_mutable_pub_key_response() {
  if (sum_case() != kPubKeyResponse) {
    clear_sum();
    set_has_pub_key_response();
    _impl_.sum_.pub_key_response_ = CreateMaybeMessage< ::tendermint::privval::PubKeyResponse >(GetArenaForAllocation());
  }
  return _impl_.sum_.pub_key_response_;
}
inline ::tendermint::privval::PubKeyResponse* Message::mutable_pub_key_response() {
  ::tendermint::privval::PubKeyResponse* _msg = _internal_mutable_pub_key_response();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.pub_key_response)
  return _msg;
}

// .tendermint.privval.SignVoteRequest sign_vote_request = 3 [json_name = "signVoteRequest"];
inline bool Message::has_sign_vote_request() const {
  return sum_case() == kSignVoteRequest;
}
inline bool Message::_internal_has_sign_vote_request() const {
  return sum_case() == kSignVoteRequest;
}
inline void Message::set_has_sign_vote_request() {
  _impl_._oneof_case_[0] = kSignVoteRequest;
}
inline void Message::clear_sign_vote_request() {
  if (sum_case() == kSignVoteRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sum_.sign_vote_request_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::SignVoteRequest* Message::release_sign_vote_request() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.sign_vote_request)
  if (sum_case() == kSignVoteRequest) {
    clear_has_sum();
    ::tendermint::privval::SignVoteRequest* temp = _impl_.sum_.sign_vote_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sum_.sign_vote_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::SignVoteRequest& Message::_internal_sign_vote_request() const {
  return sum_case() == kSignVoteRequest
      ? *_impl_.sum_.sign_vote_request_
      : reinterpret_cast<::tendermint::privval::SignVoteRequest&>(::tendermint::privval::_SignVoteRequest_default_instance_);
}
inline const ::tendermint::privval::SignVoteRequest& Message::sign_vote_request() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.sign_vote_request)
  return _internal_sign_vote_request();
}
inline ::tendermint::privval::SignVoteRequest* Message::unsafe_arena_release_sign_vote_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.sign_vote_request)
  if (sum_case() == kSignVoteRequest) {
    clear_has_sum();
    ::tendermint::privval::SignVoteRequest* temp = _impl_.sum_.sign_vote_request_;
    _impl_.sum_.sign_vote_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_sign_vote_request(::tendermint::privval::SignVoteRequest* sign_vote_request) {
  clear_sum();
  if (sign_vote_request) {
    set_has_sign_vote_request();
    _impl_.sum_.sign_vote_request_ = sign_vote_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.sign_vote_request)
}
inline ::tendermint::privval::SignVoteRequest* Message::_internal_mutable_sign_vote_request() {
  if (sum_case() != kSignVoteRequest) {
    clear_sum();
    set_has_sign_vote_request();
    _impl_.sum_.sign_vote_request_ = CreateMaybeMessage< ::tendermint::privval::SignVoteRequest >(GetArenaForAllocation());
  }
  return _impl_.sum_.sign_vote_request_;
}
inline ::tendermint::privval::SignVoteRequest* Message::mutable_sign_vote_request() {
  ::tendermint::privval::SignVoteRequest* _msg = _internal_mutable_sign_vote_request();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.sign_vote_request)
  return _msg;
}

// .tendermint.privval.SignedVoteResponse signed_vote_response = 4 [json_name = "signedVoteResponse"];
inline bool Message::has_signed_vote_response() const {
  return sum_case() == kSignedVoteResponse;
}
inline bool Message::_internal_has_signed_vote_response() const {
  return sum_case() == kSignedVoteResponse;
}
inline void Message::set_has_signed_vote_response() {
  _impl_._oneof_case_[0] = kSignedVoteResponse;
}
inline void Message::clear_signed_vote_response() {
  if (sum_case() == kSignedVoteResponse) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sum_.signed_vote_response_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::SignedVoteResponse* Message::release_signed_vote_response() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.signed_vote_response)
  if (sum_case() == kSignedVoteResponse) {
    clear_has_sum();
    ::tendermint::privval::SignedVoteResponse* temp = _impl_.sum_.signed_vote_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sum_.signed_vote_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::SignedVoteResponse& Message::_internal_signed_vote_response() const {
  return sum_case() == kSignedVoteResponse
      ? *_impl_.sum_.signed_vote_response_
      : reinterpret_cast<::tendermint::privval::SignedVoteResponse&>(::tendermint::privval::_SignedVoteResponse_default_instance_);
}
inline const ::tendermint::privval::SignedVoteResponse& Message::signed_vote_response() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.signed_vote_response)
  return _internal_signed_vote_response();
}
inline ::tendermint::privval::SignedVoteResponse* Message::unsafe_arena_release_signed_vote_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.signed_vote_response)
  if (sum_case() == kSignedVoteResponse) {
    clear_has_sum();
    ::tendermint::privval::SignedVoteResponse* temp = _impl_.sum_.signed_vote_response_;
    _impl_.sum_.signed_vote_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_signed_vote_response(::tendermint::privval::SignedVoteResponse* signed_vote_response) {
  clear_sum();
  if (signed_vote_response) {
    set_has_signed_vote_response();
    _impl_.sum_.signed_vote_response_ = signed_vote_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.signed_vote_response)
}
inline ::tendermint::privval::SignedVoteResponse* Message::_internal_mutable_signed_vote_response() {
  if (sum_case() != kSignedVoteResponse) {
    clear_sum();
    set_has_signed_vote_response();
    _impl_.sum_.signed_vote_response_ = CreateMaybeMessage< ::tendermint::privval::SignedVoteResponse >(GetArenaForAllocation());
  }
  return _impl_.sum_.signed_vote_response_;
}
inline ::tendermint::privval::SignedVoteResponse* Message::mutable_signed_vote_response() {
  ::tendermint::privval::SignedVoteResponse* _msg = _internal_mutable_signed_vote_response();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.signed_vote_response)
  return _msg;
}

// .tendermint.privval.SignProposalRequest sign_proposal_request = 5 [json_name = "signProposalRequest"];
inline bool Message::has_sign_proposal_request() const {
  return sum_case() == kSignProposalRequest;
}
inline bool Message::_internal_has_sign_proposal_request() const {
  return sum_case() == kSignProposalRequest;
}
inline void Message::set_has_sign_proposal_request() {
  _impl_._oneof_case_[0] = kSignProposalRequest;
}
inline void Message::clear_sign_proposal_request() {
  if (sum_case() == kSignProposalRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sum_.sign_proposal_request_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::SignProposalRequest* Message::release_sign_proposal_request() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.sign_proposal_request)
  if (sum_case() == kSignProposalRequest) {
    clear_has_sum();
    ::tendermint::privval::SignProposalRequest* temp = _impl_.sum_.sign_proposal_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sum_.sign_proposal_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::SignProposalRequest& Message::_internal_sign_proposal_request() const {
  return sum_case() == kSignProposalRequest
      ? *_impl_.sum_.sign_proposal_request_
      : reinterpret_cast<::tendermint::privval::SignProposalRequest&>(::tendermint::privval::_SignProposalRequest_default_instance_);
}
inline const ::tendermint::privval::SignProposalRequest& Message::sign_proposal_request() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.sign_proposal_request)
  return _internal_sign_proposal_request();
}
inline ::tendermint::privval::SignProposalRequest* Message::unsafe_arena_release_sign_proposal_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.sign_proposal_request)
  if (sum_case() == kSignProposalRequest) {
    clear_has_sum();
    ::tendermint::privval::SignProposalRequest* temp = _impl_.sum_.sign_proposal_request_;
    _impl_.sum_.sign_proposal_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_sign_proposal_request(::tendermint::privval::SignProposalRequest* sign_proposal_request) {
  clear_sum();
  if (sign_proposal_request) {
    set_has_sign_proposal_request();
    _impl_.sum_.sign_proposal_request_ = sign_proposal_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.sign_proposal_request)
}
inline ::tendermint::privval::SignProposalRequest* Message::_internal_mutable_sign_proposal_request() {
  if (sum_case() != kSignProposalRequest) {
    clear_sum();
    set_has_sign_proposal_request();
    _impl_.sum_.sign_proposal_request_ = CreateMaybeMessage< ::tendermint::privval::SignProposalRequest >(GetArenaForAllocation());
  }
  return _impl_.sum_.sign_proposal_request_;
}
inline ::tendermint::privval::SignProposalRequest* Message::mutable_sign_proposal_request() {
  ::tendermint::privval::SignProposalRequest* _msg = _internal_mutable_sign_proposal_request();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.sign_proposal_request)
  return _msg;
}

// .tendermint.privval.SignedProposalResponse signed_proposal_response = 6 [json_name = "signedProposalResponse"];
inline bool Message::has_signed_proposal_response() const {
  return sum_case() == kSignedProposalResponse;
}
inline bool Message::_internal_has_signed_proposal_response() const {
  return sum_case() == kSignedProposalResponse;
}
inline void Message::set_has_signed_proposal_response() {
  _impl_._oneof_case_[0] = kSignedProposalResponse;
}
inline void Message::clear_signed_proposal_response() {
  if (sum_case() == kSignedProposalResponse) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sum_.signed_proposal_response_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::SignedProposalResponse* Message::release_signed_proposal_response() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.signed_proposal_response)
  if (sum_case() == kSignedProposalResponse) {
    clear_has_sum();
    ::tendermint::privval::SignedProposalResponse* temp = _impl_.sum_.signed_proposal_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sum_.signed_proposal_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::SignedProposalResponse& Message::_internal_signed_proposal_response() const {
  return sum_case() == kSignedProposalResponse
      ? *_impl_.sum_.signed_proposal_response_
      : reinterpret_cast<::tendermint::privval::SignedProposalResponse&>(::tendermint::privval::_SignedProposalResponse_default_instance_);
}
inline const ::tendermint::privval::SignedProposalResponse& Message::signed_proposal_response() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.signed_proposal_response)
  return _internal_signed_proposal_response();
}
inline ::tendermint::privval::SignedProposalResponse* Message::unsafe_arena_release_signed_proposal_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.signed_proposal_response)
  if (sum_case() == kSignedProposalResponse) {
    clear_has_sum();
    ::tendermint::privval::SignedProposalResponse* temp = _impl_.sum_.signed_proposal_response_;
    _impl_.sum_.signed_proposal_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_signed_proposal_response(::tendermint::privval::SignedProposalResponse* signed_proposal_response) {
  clear_sum();
  if (signed_proposal_response) {
    set_has_signed_proposal_response();
    _impl_.sum_.signed_proposal_response_ = signed_proposal_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.signed_proposal_response)
}
inline ::tendermint::privval::SignedProposalResponse* Message::_internal_mutable_signed_proposal_response() {
  if (sum_case() != kSignedProposalResponse) {
    clear_sum();
    set_has_signed_proposal_response();
    _impl_.sum_.signed_proposal_response_ = CreateMaybeMessage< ::tendermint::privval::SignedProposalResponse >(GetArenaForAllocation());
  }
  return _impl_.sum_.signed_proposal_response_;
}
inline ::tendermint::privval::SignedProposalResponse* Message::mutable_signed_proposal_response() {
  ::tendermint::privval::SignedProposalResponse* _msg = _internal_mutable_signed_proposal_response();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.signed_proposal_response)
  return _msg;
}

// .tendermint.privval.PingRequest ping_request = 7 [json_name = "pingRequest"];
inline bool Message::has_ping_request() const {
  return sum_case() == kPingRequest;
}
inline bool Message::_internal_has_ping_request() const {
  return sum_case() == kPingRequest;
}
inline void Message::set_has_ping_request() {
  _impl_._oneof_case_[0] = kPingRequest;
}
inline void Message::clear_ping_request() {
  if (sum_case() == kPingRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sum_.ping_request_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::PingRequest* Message::release_ping_request() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.ping_request)
  if (sum_case() == kPingRequest) {
    clear_has_sum();
    ::tendermint::privval::PingRequest* temp = _impl_.sum_.ping_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sum_.ping_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::PingRequest& Message::_internal_ping_request() const {
  return sum_case() == kPingRequest
      ? *_impl_.sum_.ping_request_
      : reinterpret_cast<::tendermint::privval::PingRequest&>(::tendermint::privval::_PingRequest_default_instance_);
}
inline const ::tendermint::privval::PingRequest& Message::ping_request() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.ping_request)
  return _internal_ping_request();
}
inline ::tendermint::privval::PingRequest* Message::unsafe_arena_release_ping_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.ping_request)
  if (sum_case() == kPingRequest) {
    clear_has_sum();
    ::tendermint::privval::PingRequest* temp = _impl_.sum_.ping_request_;
    _impl_.sum_.ping_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_ping_request(::tendermint::privval::PingRequest* ping_request) {
  clear_sum();
  if (ping_request) {
    set_has_ping_request();
    _impl_.sum_.ping_request_ = ping_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.ping_request)
}
inline ::tendermint::privval::PingRequest* Message::_internal_mutable_ping_request() {
  if (sum_case() != kPingRequest) {
    clear_sum();
    set_has_ping_request();
    _impl_.sum_.ping_request_ = CreateMaybeMessage< ::tendermint::privval::PingRequest >(GetArenaForAllocation());
  }
  return _impl_.sum_.ping_request_;
}
inline ::tendermint::privval::PingRequest* Message::mutable_ping_request() {
  ::tendermint::privval::PingRequest* _msg = _internal_mutable_ping_request();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.ping_request)
  return _msg;
}

// .tendermint.privval.PingResponse ping_response = 8 [json_name = "pingResponse"];
inline bool Message::has_ping_response() const {
  return sum_case() == kPingResponse;
}
inline bool Message::_internal_has_ping_response() const {
  return sum_case() == kPingResponse;
}
inline void Message::set_has_ping_response() {
  _impl_._oneof_case_[0] = kPingResponse;
}
inline void Message::clear_ping_response() {
  if (sum_case() == kPingResponse) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sum_.ping_response_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::PingResponse* Message::release_ping_response() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.ping_response)
  if (sum_case() == kPingResponse) {
    clear_has_sum();
    ::tendermint::privval::PingResponse* temp = _impl_.sum_.ping_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sum_.ping_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::PingResponse& Message::_internal_ping_response() const {
  return sum_case() == kPingResponse
      ? *_impl_.sum_.ping_response_
      : reinterpret_cast<::tendermint::privval::PingResponse&>(::tendermint::privval::_PingResponse_default_instance_);
}
inline const ::tendermint::privval::PingResponse& Message::ping_response() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.ping_response)
  return _internal_ping_response();
}
inline ::tendermint::privval::PingResponse* Message::unsafe_arena_release_ping_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.ping_response)
  if (sum_case() == kPingResponse) {
    clear_has_sum();
    ::tendermint::privval::PingResponse* temp = _impl_.sum_.ping_response_;
    _impl_.sum_.ping_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_ping_response(::tendermint::privval::PingResponse* ping_response) {
  clear_sum();
  if (ping_response) {
    set_has_ping_response();
    _impl_.sum_.ping_response_ = ping_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.ping_response)
}
inline ::tendermint::privval::PingResponse* Message::_internal_mutable_ping_response() {
  if (sum_case() != kPingResponse) {
    clear_sum();
    set_has_ping_response();
    _impl_.sum_.ping_response_ = CreateMaybeMessage< ::tendermint::privval::PingResponse >(GetArenaForAllocation());
  }
  return _impl_.sum_.ping_response_;
}
inline ::tendermint::privval::PingResponse* Message::mutable_ping_response() {
  ::tendermint::privval::PingResponse* _msg = _internal_mutable_ping_response();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.ping_response)
  return _msg;
}

inline bool Message::has_sum() const {
  return sum_case() != SUM_NOT_SET;
}
inline void Message::clear_has_sum() {
  _impl_._oneof_case_[0] = SUM_NOT_SET;
}
inline Message::SumCase Message::sum_case() const {
  return Message::SumCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace privval
}  // namespace tendermint


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::tendermint::privval::Errors> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tendermint::privval::Errors>() {
  return ::tendermint::privval::Errors_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tendermint_2fprivval_2ftypes_2eproto_2epb_2eh
