// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tendermint/state/types.proto

#include "tendermint/state/types.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace tendermint {
namespace state {
template <typename>
PROTOBUF_CONSTEXPR ABCIResponses::ABCIResponses(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.deliver_txs_)*/{}
  , /*decltype(_impl_.end_block_)*/nullptr
  , /*decltype(_impl_.begin_block_)*/nullptr} {}
struct ABCIResponsesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ABCIResponsesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ABCIResponsesDefaultTypeInternal() {}
  union {
    ABCIResponses _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ABCIResponsesDefaultTypeInternal _ABCIResponses_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ValidatorsInfo::ValidatorsInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.validator_set_)*/nullptr
  , /*decltype(_impl_.last_height_changed_)*/ ::int64_t{0}
} {}
struct ValidatorsInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValidatorsInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValidatorsInfoDefaultTypeInternal() {}
  union {
    ValidatorsInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValidatorsInfoDefaultTypeInternal _ValidatorsInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ConsensusParamsInfo::ConsensusParamsInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.consensus_params_)*/nullptr
  , /*decltype(_impl_.last_height_changed_)*/ ::int64_t{0}
} {}
struct ConsensusParamsInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConsensusParamsInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConsensusParamsInfoDefaultTypeInternal() {}
  union {
    ConsensusParamsInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConsensusParamsInfoDefaultTypeInternal _ConsensusParamsInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ABCIResponsesInfo::ABCIResponsesInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.abci_responses_)*/nullptr
  , /*decltype(_impl_.height_)*/ ::int64_t{0}
} {}
struct ABCIResponsesInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ABCIResponsesInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ABCIResponsesInfoDefaultTypeInternal() {}
  union {
    ABCIResponsesInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ABCIResponsesInfoDefaultTypeInternal _ABCIResponsesInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Version::Version(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.software_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.consensus_)*/nullptr} {}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR State::State(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chain_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.last_results_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.app_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.version_)*/nullptr
  , /*decltype(_impl_.last_block_id_)*/nullptr
  , /*decltype(_impl_.last_block_time_)*/nullptr
  , /*decltype(_impl_.next_validators_)*/nullptr
  , /*decltype(_impl_.validators_)*/nullptr
  , /*decltype(_impl_.last_validators_)*/nullptr
  , /*decltype(_impl_.consensus_params_)*/nullptr
  , /*decltype(_impl_.last_block_height_)*/ ::int64_t{0}

  , /*decltype(_impl_.last_height_validators_changed_)*/ ::int64_t{0}

  , /*decltype(_impl_.last_height_consensus_params_changed_)*/ ::int64_t{0}

  , /*decltype(_impl_.initial_height_)*/ ::int64_t{0}
} {}
struct StateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateDefaultTypeInternal() {}
  union {
    State _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateDefaultTypeInternal _State_default_instance_;
}  // namespace state
}  // namespace tendermint
static ::_pb::Metadata file_level_metadata_tendermint_2fstate_2ftypes_2eproto[6];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_tendermint_2fstate_2ftypes_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_tendermint_2fstate_2ftypes_2eproto = nullptr;
const ::uint32_t TableStruct_tendermint_2fstate_2ftypes_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponses, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponses, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponses, _impl_.deliver_txs_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponses, _impl_.end_block_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponses, _impl_.begin_block_),
    ~0u,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ValidatorsInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ValidatorsInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ValidatorsInfo, _impl_.validator_set_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ValidatorsInfo, _impl_.last_height_changed_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ConsensusParamsInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ConsensusParamsInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ConsensusParamsInfo, _impl_.consensus_params_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ConsensusParamsInfo, _impl_.last_height_changed_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponsesInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponsesInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponsesInfo, _impl_.abci_responses_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::ABCIResponsesInfo, _impl_.height_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::tendermint::state::Version, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::Version, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::tendermint::state::Version, _impl_.consensus_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::Version, _impl_.software_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.version_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.chain_id_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.initial_height_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.last_block_height_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.last_block_id_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.last_block_time_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.next_validators_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.validators_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.last_validators_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.last_height_validators_changed_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.consensus_params_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.last_height_consensus_params_changed_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.last_results_hash_),
    PROTOBUF_FIELD_OFFSET(::tendermint::state::State, _impl_.app_hash_),
    0,
    ~0u,
    ~0u,
    ~0u,
    1,
    2,
    3,
    4,
    5,
    ~0u,
    6,
    ~0u,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 11, -1, sizeof(::tendermint::state::ABCIResponses)},
        { 14, 24, -1, sizeof(::tendermint::state::ValidatorsInfo)},
        { 26, 36, -1, sizeof(::tendermint::state::ConsensusParamsInfo)},
        { 38, 48, -1, sizeof(::tendermint::state::ABCIResponsesInfo)},
        { 50, 60, -1, sizeof(::tendermint::state::Version)},
        { 62, 84, -1, sizeof(::tendermint::state::State)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::tendermint::state::_ABCIResponses_default_instance_._instance,
    &::tendermint::state::_ValidatorsInfo_default_instance_._instance,
    &::tendermint::state::_ConsensusParamsInfo_default_instance_._instance,
    &::tendermint::state::_ABCIResponsesInfo_default_instance_._instance,
    &::tendermint::state::_Version_default_instance_._instance,
    &::tendermint::state::_State_default_instance_._instance,
};
const char descriptor_table_protodef_tendermint_2fstate_2ftypes_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\034tendermint/state/types.proto\022\020tendermi"
    "nt.state\032\024gogoproto/gogo.proto\032\033tendermi"
    "nt/abci/types.proto\032\034tendermint/types/ty"
    "pes.proto\032 tendermint/types/validator.pr"
    "oto\032\035tendermint/types/params.proto\032\036tend"
    "ermint/version/types.proto\032\037google/proto"
    "buf/timestamp.proto\"\332\001\n\rABCIResponses\022C\n"
    "\013deliver_txs\030\001 \003(\0132\".tendermint.abci.Res"
    "ponseDeliverTxR\ndeliverTxs\022>\n\tend_block\030"
    "\002 \001(\0132!.tendermint.abci.ResponseEndBlock"
    "R\010endBlock\022D\n\013begin_block\030\003 \001(\0132#.tender"
    "mint.abci.ResponseBeginBlockR\nbeginBlock"
    "\"\205\001\n\016ValidatorsInfo\022C\n\rvalidator_set\030\001 \001"
    "(\0132\036.tendermint.types.ValidatorSetR\014vali"
    "datorSet\022.\n\023last_height_changed\030\002 \001(\003R\021l"
    "astHeightChanged\"\231\001\n\023ConsensusParamsInfo"
    "\022R\n\020consensus_params\030\001 \001(\0132!.tendermint."
    "types.ConsensusParamsB\004\310\336\037\000R\017consensusPa"
    "rams\022.\n\023last_height_changed\030\002 \001(\003R\021lastH"
    "eightChanged\"s\n\021ABCIResponsesInfo\022F\n\016abc"
    "i_responses\030\001 \001(\0132\037.tendermint.state.ABC"
    "IResponsesR\rabciResponses\022\026\n\006height\030\002 \001("
    "\003R\006height\"h\n\007Version\022A\n\tconsensus\030\001 \001(\0132"
    "\035.tendermint.version.ConsensusB\004\310\336\037\000R\tco"
    "nsensus\022\032\n\010software\030\002 \001(\tR\010software\"\341\006\n\005"
    "State\0229\n\007version\030\001 \001(\0132\031.tendermint.stat"
    "e.VersionB\004\310\336\037\000R\007version\022&\n\010chain_id\030\002 \001"
    "(\tB\013\342\336\037\007ChainIDR\007chainId\022%\n\016initial_heig"
    "ht\030\016 \001(\003R\rinitialHeight\022*\n\021last_block_he"
    "ight\030\003 \001(\003R\017lastBlockHeight\022R\n\rlast_bloc"
    "k_id\030\004 \001(\0132\031.tendermint.types.BlockIDB\023\310"
    "\336\037\000\342\336\037\013LastBlockIDR\013lastBlockId\022L\n\017last_"
    "block_time\030\005 \001(\0132\032.google.protobuf.Times"
    "tampB\010\310\336\037\000\220\337\037\001R\rlastBlockTime\022G\n\017next_va"
    "lidators\030\006 \001(\0132\036.tendermint.types.Valida"
    "torSetR\016nextValidators\022>\n\nvalidators\030\007 \001"
    "(\0132\036.tendermint.types.ValidatorSetR\nvali"
    "dators\022G\n\017last_validators\030\010 \001(\0132\036.tender"
    "mint.types.ValidatorSetR\016lastValidators\022"
    "C\n\036last_height_validators_changed\030\t \001(\003R"
    "\033lastHeightValidatorsChanged\022R\n\020consensu"
    "s_params\030\n \001(\0132!.tendermint.types.Consen"
    "susParamsB\004\310\336\037\000R\017consensusParams\022N\n$last"
    "_height_consensus_params_changed\030\013 \001(\003R "
    "lastHeightConsensusParamsChanged\022*\n\021last"
    "_results_hash\030\014 \001(\014R\017lastResultsHash\022\031\n\010"
    "app_hash\030\r \001(\014R\007appHashB\270\001\n\024com.tendermi"
    "nt.stateB\nTypesProtoP\001Z3github.com/comet"
    "bft/cometbft/proto/tendermint/state\242\002\003TS"
    "X\252\002\020Tendermint.State\312\002\020Tendermint\\State\342"
    "\002\034Tendermint\\State\\GPBMetadata\352\002\021Tenderm"
    "int::Stateb\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_tendermint_2fstate_2ftypes_2eproto_deps[7] =
    {
        &::descriptor_table_gogoproto_2fgogo_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
        &::descriptor_table_tendermint_2fabci_2ftypes_2eproto,
        &::descriptor_table_tendermint_2ftypes_2fparams_2eproto,
        &::descriptor_table_tendermint_2ftypes_2ftypes_2eproto,
        &::descriptor_table_tendermint_2ftypes_2fvalidator_2eproto,
        &::descriptor_table_tendermint_2fversion_2ftypes_2eproto,
};
static ::absl::once_flag descriptor_table_tendermint_2fstate_2ftypes_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_tendermint_2fstate_2ftypes_2eproto = {
    false,
    false,
    2058,
    descriptor_table_protodef_tendermint_2fstate_2ftypes_2eproto,
    "tendermint/state/types.proto",
    &descriptor_table_tendermint_2fstate_2ftypes_2eproto_once,
    descriptor_table_tendermint_2fstate_2ftypes_2eproto_deps,
    7,
    6,
    schemas,
    file_default_instances,
    TableStruct_tendermint_2fstate_2ftypes_2eproto::offsets,
    file_level_metadata_tendermint_2fstate_2ftypes_2eproto,
    file_level_enum_descriptors_tendermint_2fstate_2ftypes_2eproto,
    file_level_service_descriptors_tendermint_2fstate_2ftypes_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_tendermint_2fstate_2ftypes_2eproto_getter() {
  return &descriptor_table_tendermint_2fstate_2ftypes_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_tendermint_2fstate_2ftypes_2eproto(&descriptor_table_tendermint_2fstate_2ftypes_2eproto);
namespace tendermint {
namespace state {
// ===================================================================

class ABCIResponses::_Internal {
 public:
  using HasBits = decltype(std::declval<ABCIResponses>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ABCIResponses, _impl_._has_bits_);
  static const ::tendermint::abci::ResponseEndBlock& end_block(const ABCIResponses* msg);
  static void set_has_end_block(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::tendermint::abci::ResponseBeginBlock& begin_block(const ABCIResponses* msg);
  static void set_has_begin_block(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::tendermint::abci::ResponseEndBlock&
ABCIResponses::_Internal::end_block(const ABCIResponses* msg) {
  return *msg->_impl_.end_block_;
}
const ::tendermint::abci::ResponseBeginBlock&
ABCIResponses::_Internal::begin_block(const ABCIResponses* msg) {
  return *msg->_impl_.begin_block_;
}
void ABCIResponses::clear_deliver_txs() {
  _internal_mutable_deliver_txs()->Clear();
}
void ABCIResponses::clear_end_block() {
  if (_impl_.end_block_ != nullptr) _impl_.end_block_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ABCIResponses::clear_begin_block() {
  if (_impl_.begin_block_ != nullptr) _impl_.begin_block_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ABCIResponses::ABCIResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:tendermint.state.ABCIResponses)
}
ABCIResponses::ABCIResponses(const ABCIResponses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ABCIResponses* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.deliver_txs_){from._impl_.deliver_txs_}
    , decltype(_impl_.end_block_){nullptr}
    , decltype(_impl_.begin_block_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.end_block_ = new ::tendermint::abci::ResponseEndBlock(*from._impl_.end_block_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.begin_block_ = new ::tendermint::abci::ResponseBeginBlock(*from._impl_.begin_block_);
  }
  // @@protoc_insertion_point(copy_constructor:tendermint.state.ABCIResponses)
}

inline void ABCIResponses::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.deliver_txs_){arena}
    , decltype(_impl_.end_block_){nullptr}
    , decltype(_impl_.begin_block_){nullptr}
  };
}

ABCIResponses::~ABCIResponses() {
  // @@protoc_insertion_point(destructor:tendermint.state.ABCIResponses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ABCIResponses::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_deliver_txs()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.end_block_;
  if (this != internal_default_instance()) delete _impl_.begin_block_;
}

void ABCIResponses::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ABCIResponses::Clear() {
// @@protoc_insertion_point(message_clear_start:tendermint.state.ABCIResponses)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_deliver_txs()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.end_block_ != nullptr);
      _impl_.end_block_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.begin_block_ != nullptr);
      _impl_.begin_block_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ABCIResponses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tendermint.abci.ResponseDeliverTx deliver_txs = 1 [json_name = "deliverTxs"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_deliver_txs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .tendermint.abci.ResponseEndBlock end_block = 2 [json_name = "endBlock"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_block(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .tendermint.abci.ResponseBeginBlock begin_block = 3 [json_name = "beginBlock"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_begin_block(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ABCIResponses::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tendermint.state.ABCIResponses)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tendermint.abci.ResponseDeliverTx deliver_txs = 1 [json_name = "deliverTxs"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_deliver_txs_size()); i < n; i++) {
    const auto& repfield = this->_internal_deliver_txs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .tendermint.abci.ResponseEndBlock end_block = 2 [json_name = "endBlock"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::end_block(this),
        _Internal::end_block(this).GetCachedSize(), target, stream);
  }

  // .tendermint.abci.ResponseBeginBlock begin_block = 3 [json_name = "beginBlock"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::begin_block(this),
        _Internal::begin_block(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tendermint.state.ABCIResponses)
  return target;
}

::size_t ABCIResponses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tendermint.state.ABCIResponses)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tendermint.abci.ResponseDeliverTx deliver_txs = 1 [json_name = "deliverTxs"];
  total_size += 1UL * this->_internal_deliver_txs_size();
  for (const auto& msg : this->_internal_deliver_txs()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .tendermint.abci.ResponseEndBlock end_block = 2 [json_name = "endBlock"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_block_);
    }

    // .tendermint.abci.ResponseBeginBlock begin_block = 3 [json_name = "beginBlock"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.begin_block_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ABCIResponses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ABCIResponses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ABCIResponses::GetClassData() const { return &_class_data_; }


void ABCIResponses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ABCIResponses*>(&to_msg);
  auto& from = static_cast<const ABCIResponses&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tendermint.state.ABCIResponses)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_deliver_txs()->MergeFrom(from._internal_deliver_txs());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_end_block()->::tendermint::abci::ResponseEndBlock::MergeFrom(
          from._internal_end_block());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_begin_block()->::tendermint::abci::ResponseBeginBlock::MergeFrom(
          from._internal_begin_block());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ABCIResponses::CopyFrom(const ABCIResponses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tendermint.state.ABCIResponses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ABCIResponses::IsInitialized() const {
  return true;
}

void ABCIResponses::InternalSwap(ABCIResponses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_deliver_txs()->InternalSwap(other->_internal_mutable_deliver_txs());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ABCIResponses, _impl_.begin_block_)
      + sizeof(ABCIResponses::_impl_.begin_block_)
      - PROTOBUF_FIELD_OFFSET(ABCIResponses, _impl_.end_block_)>(
          reinterpret_cast<char*>(&_impl_.end_block_),
          reinterpret_cast<char*>(&other->_impl_.end_block_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ABCIResponses::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tendermint_2fstate_2ftypes_2eproto_getter, &descriptor_table_tendermint_2fstate_2ftypes_2eproto_once,
      file_level_metadata_tendermint_2fstate_2ftypes_2eproto[0]);
}
// ===================================================================

class ValidatorsInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ValidatorsInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ValidatorsInfo, _impl_._has_bits_);
  static const ::tendermint::types::ValidatorSet& validator_set(const ValidatorsInfo* msg);
  static void set_has_validator_set(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::tendermint::types::ValidatorSet&
ValidatorsInfo::_Internal::validator_set(const ValidatorsInfo* msg) {
  return *msg->_impl_.validator_set_;
}
void ValidatorsInfo::clear_validator_set() {
  if (_impl_.validator_set_ != nullptr) _impl_.validator_set_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ValidatorsInfo::ValidatorsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:tendermint.state.ValidatorsInfo)
}
ValidatorsInfo::ValidatorsInfo(const ValidatorsInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ValidatorsInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.validator_set_){nullptr}
    , decltype(_impl_.last_height_changed_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.validator_set_ = new ::tendermint::types::ValidatorSet(*from._impl_.validator_set_);
  }
  _this->_impl_.last_height_changed_ = from._impl_.last_height_changed_;
  // @@protoc_insertion_point(copy_constructor:tendermint.state.ValidatorsInfo)
}

inline void ValidatorsInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.validator_set_){nullptr}
    , decltype(_impl_.last_height_changed_) { ::int64_t{0} }

  };
}

ValidatorsInfo::~ValidatorsInfo() {
  // @@protoc_insertion_point(destructor:tendermint.state.ValidatorsInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValidatorsInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.validator_set_;
}

void ValidatorsInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ValidatorsInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tendermint.state.ValidatorsInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.validator_set_ != nullptr);
    _impl_.validator_set_->Clear();
  }
  _impl_.last_height_changed_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ValidatorsInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tendermint.types.ValidatorSet validator_set = 1 [json_name = "validatorSet"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_validator_set(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_height_changed = 2 [json_name = "lastHeightChanged"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.last_height_changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ValidatorsInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tendermint.state.ValidatorsInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .tendermint.types.ValidatorSet validator_set = 1 [json_name = "validatorSet"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::validator_set(this),
        _Internal::validator_set(this).GetCachedSize(), target, stream);
  }

  // int64 last_height_changed = 2 [json_name = "lastHeightChanged"];
  if (this->_internal_last_height_changed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_last_height_changed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tendermint.state.ValidatorsInfo)
  return target;
}

::size_t ValidatorsInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tendermint.state.ValidatorsInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tendermint.types.ValidatorSet validator_set = 1 [json_name = "validatorSet"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.validator_set_);
  }

  // int64 last_height_changed = 2 [json_name = "lastHeightChanged"];
  if (this->_internal_last_height_changed() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_height_changed());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ValidatorsInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ValidatorsInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ValidatorsInfo::GetClassData() const { return &_class_data_; }


void ValidatorsInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ValidatorsInfo*>(&to_msg);
  auto& from = static_cast<const ValidatorsInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tendermint.state.ValidatorsInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_validator_set()->::tendermint::types::ValidatorSet::MergeFrom(
        from._internal_validator_set());
  }
  if (from._internal_last_height_changed() != 0) {
    _this->_internal_set_last_height_changed(from._internal_last_height_changed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ValidatorsInfo::CopyFrom(const ValidatorsInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tendermint.state.ValidatorsInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValidatorsInfo::IsInitialized() const {
  return true;
}

void ValidatorsInfo::InternalSwap(ValidatorsInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ValidatorsInfo, _impl_.last_height_changed_)
      + sizeof(ValidatorsInfo::_impl_.last_height_changed_)
      - PROTOBUF_FIELD_OFFSET(ValidatorsInfo, _impl_.validator_set_)>(
          reinterpret_cast<char*>(&_impl_.validator_set_),
          reinterpret_cast<char*>(&other->_impl_.validator_set_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ValidatorsInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tendermint_2fstate_2ftypes_2eproto_getter, &descriptor_table_tendermint_2fstate_2ftypes_2eproto_once,
      file_level_metadata_tendermint_2fstate_2ftypes_2eproto[1]);
}
// ===================================================================

class ConsensusParamsInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ConsensusParamsInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConsensusParamsInfo, _impl_._has_bits_);
  static const ::tendermint::types::ConsensusParams& consensus_params(const ConsensusParamsInfo* msg);
  static void set_has_consensus_params(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::tendermint::types::ConsensusParams&
ConsensusParamsInfo::_Internal::consensus_params(const ConsensusParamsInfo* msg) {
  return *msg->_impl_.consensus_params_;
}
void ConsensusParamsInfo::clear_consensus_params() {
  if (_impl_.consensus_params_ != nullptr) _impl_.consensus_params_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ConsensusParamsInfo::ConsensusParamsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:tendermint.state.ConsensusParamsInfo)
}
ConsensusParamsInfo::ConsensusParamsInfo(const ConsensusParamsInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConsensusParamsInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.consensus_params_){nullptr}
    , decltype(_impl_.last_height_changed_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.consensus_params_ = new ::tendermint::types::ConsensusParams(*from._impl_.consensus_params_);
  }
  _this->_impl_.last_height_changed_ = from._impl_.last_height_changed_;
  // @@protoc_insertion_point(copy_constructor:tendermint.state.ConsensusParamsInfo)
}

inline void ConsensusParamsInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.consensus_params_){nullptr}
    , decltype(_impl_.last_height_changed_) { ::int64_t{0} }

  };
}

ConsensusParamsInfo::~ConsensusParamsInfo() {
  // @@protoc_insertion_point(destructor:tendermint.state.ConsensusParamsInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConsensusParamsInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.consensus_params_;
}

void ConsensusParamsInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConsensusParamsInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tendermint.state.ConsensusParamsInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.consensus_params_ != nullptr);
    _impl_.consensus_params_->Clear();
  }
  _impl_.last_height_changed_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConsensusParamsInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tendermint.types.ConsensusParams consensus_params = 1 [json_name = "consensusParams", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_consensus_params(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_height_changed = 2 [json_name = "lastHeightChanged"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.last_height_changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConsensusParamsInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tendermint.state.ConsensusParamsInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .tendermint.types.ConsensusParams consensus_params = 1 [json_name = "consensusParams", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::consensus_params(this),
        _Internal::consensus_params(this).GetCachedSize(), target, stream);
  }

  // int64 last_height_changed = 2 [json_name = "lastHeightChanged"];
  if (this->_internal_last_height_changed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_last_height_changed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tendermint.state.ConsensusParamsInfo)
  return target;
}

::size_t ConsensusParamsInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tendermint.state.ConsensusParamsInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tendermint.types.ConsensusParams consensus_params = 1 [json_name = "consensusParams", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.consensus_params_);
  }

  // int64 last_height_changed = 2 [json_name = "lastHeightChanged"];
  if (this->_internal_last_height_changed() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_height_changed());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConsensusParamsInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConsensusParamsInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConsensusParamsInfo::GetClassData() const { return &_class_data_; }


void ConsensusParamsInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConsensusParamsInfo*>(&to_msg);
  auto& from = static_cast<const ConsensusParamsInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tendermint.state.ConsensusParamsInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_consensus_params()->::tendermint::types::ConsensusParams::MergeFrom(
        from._internal_consensus_params());
  }
  if (from._internal_last_height_changed() != 0) {
    _this->_internal_set_last_height_changed(from._internal_last_height_changed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConsensusParamsInfo::CopyFrom(const ConsensusParamsInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tendermint.state.ConsensusParamsInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConsensusParamsInfo::IsInitialized() const {
  return true;
}

void ConsensusParamsInfo::InternalSwap(ConsensusParamsInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConsensusParamsInfo, _impl_.last_height_changed_)
      + sizeof(ConsensusParamsInfo::_impl_.last_height_changed_)
      - PROTOBUF_FIELD_OFFSET(ConsensusParamsInfo, _impl_.consensus_params_)>(
          reinterpret_cast<char*>(&_impl_.consensus_params_),
          reinterpret_cast<char*>(&other->_impl_.consensus_params_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConsensusParamsInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tendermint_2fstate_2ftypes_2eproto_getter, &descriptor_table_tendermint_2fstate_2ftypes_2eproto_once,
      file_level_metadata_tendermint_2fstate_2ftypes_2eproto[2]);
}
// ===================================================================

class ABCIResponsesInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ABCIResponsesInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ABCIResponsesInfo, _impl_._has_bits_);
  static const ::tendermint::state::ABCIResponses& abci_responses(const ABCIResponsesInfo* msg);
  static void set_has_abci_responses(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::tendermint::state::ABCIResponses&
ABCIResponsesInfo::_Internal::abci_responses(const ABCIResponsesInfo* msg) {
  return *msg->_impl_.abci_responses_;
}
ABCIResponsesInfo::ABCIResponsesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:tendermint.state.ABCIResponsesInfo)
}
ABCIResponsesInfo::ABCIResponsesInfo(const ABCIResponsesInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ABCIResponsesInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.abci_responses_){nullptr}
    , decltype(_impl_.height_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.abci_responses_ = new ::tendermint::state::ABCIResponses(*from._impl_.abci_responses_);
  }
  _this->_impl_.height_ = from._impl_.height_;
  // @@protoc_insertion_point(copy_constructor:tendermint.state.ABCIResponsesInfo)
}

inline void ABCIResponsesInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.abci_responses_){nullptr}
    , decltype(_impl_.height_) { ::int64_t{0} }

  };
}

ABCIResponsesInfo::~ABCIResponsesInfo() {
  // @@protoc_insertion_point(destructor:tendermint.state.ABCIResponsesInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ABCIResponsesInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.abci_responses_;
}

void ABCIResponsesInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ABCIResponsesInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tendermint.state.ABCIResponsesInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.abci_responses_ != nullptr);
    _impl_.abci_responses_->Clear();
  }
  _impl_.height_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ABCIResponsesInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tendermint.state.ABCIResponses abci_responses = 1 [json_name = "abciResponses"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_abci_responses(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 height = 2 [json_name = "height"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ABCIResponsesInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tendermint.state.ABCIResponsesInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .tendermint.state.ABCIResponses abci_responses = 1 [json_name = "abciResponses"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::abci_responses(this),
        _Internal::abci_responses(this).GetCachedSize(), target, stream);
  }

  // int64 height = 2 [json_name = "height"];
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tendermint.state.ABCIResponsesInfo)
  return target;
}

::size_t ABCIResponsesInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tendermint.state.ABCIResponsesInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tendermint.state.ABCIResponses abci_responses = 1 [json_name = "abciResponses"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.abci_responses_);
  }

  // int64 height = 2 [json_name = "height"];
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ABCIResponsesInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ABCIResponsesInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ABCIResponsesInfo::GetClassData() const { return &_class_data_; }


void ABCIResponsesInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ABCIResponsesInfo*>(&to_msg);
  auto& from = static_cast<const ABCIResponsesInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tendermint.state.ABCIResponsesInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_abci_responses()->::tendermint::state::ABCIResponses::MergeFrom(
        from._internal_abci_responses());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ABCIResponsesInfo::CopyFrom(const ABCIResponsesInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tendermint.state.ABCIResponsesInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ABCIResponsesInfo::IsInitialized() const {
  return true;
}

void ABCIResponsesInfo::InternalSwap(ABCIResponsesInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ABCIResponsesInfo, _impl_.height_)
      + sizeof(ABCIResponsesInfo::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(ABCIResponsesInfo, _impl_.abci_responses_)>(
          reinterpret_cast<char*>(&_impl_.abci_responses_),
          reinterpret_cast<char*>(&other->_impl_.abci_responses_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ABCIResponsesInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tendermint_2fstate_2ftypes_2eproto_getter, &descriptor_table_tendermint_2fstate_2ftypes_2eproto_once,
      file_level_metadata_tendermint_2fstate_2ftypes_2eproto[3]);
}
// ===================================================================

class Version::_Internal {
 public:
  using HasBits = decltype(std::declval<Version>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Version, _impl_._has_bits_);
  static const ::tendermint::version::Consensus& consensus(const Version* msg);
  static void set_has_consensus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::tendermint::version::Consensus&
Version::_Internal::consensus(const Version* msg) {
  return *msg->_impl_.consensus_;
}
void Version::clear_consensus() {
  if (_impl_.consensus_ != nullptr) _impl_.consensus_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Version::Version(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:tendermint.state.Version)
}
Version::Version(const Version& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Version* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.software_) {}

    , decltype(_impl_.consensus_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.software_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.software_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_software().empty()) {
    _this->_impl_.software_.Set(from._internal_software(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.consensus_ = new ::tendermint::version::Consensus(*from._impl_.consensus_);
  }
  // @@protoc_insertion_point(copy_constructor:tendermint.state.Version)
}

inline void Version::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.software_) {}

    , decltype(_impl_.consensus_){nullptr}
  };
  _impl_.software_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.software_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:tendermint.state.Version)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Version::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.software_.Destroy();
  if (this != internal_default_instance()) delete _impl_.consensus_;
}

void Version::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:tendermint.state.Version)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.software_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.consensus_ != nullptr);
    _impl_.consensus_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Version::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tendermint.version.Consensus consensus = 1 [json_name = "consensus", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_consensus(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string software = 2 [json_name = "software"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_software();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tendermint.state.Version.software"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Version::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tendermint.state.Version)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .tendermint.version.Consensus consensus = 1 [json_name = "consensus", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::consensus(this),
        _Internal::consensus(this).GetCachedSize(), target, stream);
  }

  // string software = 2 [json_name = "software"];
  if (!this->_internal_software().empty()) {
    const std::string& _s = this->_internal_software();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "tendermint.state.Version.software");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tendermint.state.Version)
  return target;
}

::size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tendermint.state.Version)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string software = 2 [json_name = "software"];
  if (!this->_internal_software().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_software());
  }

  // .tendermint.version.Consensus consensus = 1 [json_name = "consensus", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.consensus_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Version::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Version::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Version::GetClassData() const { return &_class_data_; }


void Version::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Version*>(&to_msg);
  auto& from = static_cast<const Version&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tendermint.state.Version)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_software().empty()) {
    _this->_internal_set_software(from._internal_software());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_consensus()->::tendermint::version::Consensus::MergeFrom(
        from._internal_consensus());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tendermint.state.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  return true;
}

void Version::InternalSwap(Version* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.software_, lhs_arena,
                                       &other->_impl_.software_, rhs_arena);
  swap(_impl_.consensus_, other->_impl_.consensus_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Version::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tendermint_2fstate_2ftypes_2eproto_getter, &descriptor_table_tendermint_2fstate_2ftypes_2eproto_once,
      file_level_metadata_tendermint_2fstate_2ftypes_2eproto[4]);
}
// ===================================================================

class State::_Internal {
 public:
  using HasBits = decltype(std::declval<State>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(State, _impl_._has_bits_);
  static const ::tendermint::state::Version& version(const State* msg);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::tendermint::types::BlockID& last_block_id(const State* msg);
  static void set_has_last_block_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_block_time(const State* msg);
  static void set_has_last_block_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::tendermint::types::ValidatorSet& next_validators(const State* msg);
  static void set_has_next_validators(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::tendermint::types::ValidatorSet& validators(const State* msg);
  static void set_has_validators(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::tendermint::types::ValidatorSet& last_validators(const State* msg);
  static void set_has_last_validators(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::tendermint::types::ConsensusParams& consensus_params(const State* msg);
  static void set_has_consensus_params(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::tendermint::state::Version&
State::_Internal::version(const State* msg) {
  return *msg->_impl_.version_;
}
const ::tendermint::types::BlockID&
State::_Internal::last_block_id(const State* msg) {
  return *msg->_impl_.last_block_id_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
State::_Internal::last_block_time(const State* msg) {
  return *msg->_impl_.last_block_time_;
}
const ::tendermint::types::ValidatorSet&
State::_Internal::next_validators(const State* msg) {
  return *msg->_impl_.next_validators_;
}
const ::tendermint::types::ValidatorSet&
State::_Internal::validators(const State* msg) {
  return *msg->_impl_.validators_;
}
const ::tendermint::types::ValidatorSet&
State::_Internal::last_validators(const State* msg) {
  return *msg->_impl_.last_validators_;
}
const ::tendermint::types::ConsensusParams&
State::_Internal::consensus_params(const State* msg) {
  return *msg->_impl_.consensus_params_;
}
void State::clear_last_block_id() {
  if (_impl_.last_block_id_ != nullptr) _impl_.last_block_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void State::clear_last_block_time() {
  if (_impl_.last_block_time_ != nullptr) _impl_.last_block_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void State::clear_next_validators() {
  if (_impl_.next_validators_ != nullptr) _impl_.next_validators_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void State::clear_validators() {
  if (_impl_.validators_ != nullptr) _impl_.validators_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void State::clear_last_validators() {
  if (_impl_.last_validators_ != nullptr) _impl_.last_validators_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void State::clear_consensus_params() {
  if (_impl_.consensus_params_ != nullptr) _impl_.consensus_params_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
State::State(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:tendermint.state.State)
}
State::State(const State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  State* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chain_id_) {}

    , decltype(_impl_.last_results_hash_) {}

    , decltype(_impl_.app_hash_) {}

    , decltype(_impl_.version_){nullptr}
    , decltype(_impl_.last_block_id_){nullptr}
    , decltype(_impl_.last_block_time_){nullptr}
    , decltype(_impl_.next_validators_){nullptr}
    , decltype(_impl_.validators_){nullptr}
    , decltype(_impl_.last_validators_){nullptr}
    , decltype(_impl_.consensus_params_){nullptr}
    , decltype(_impl_.last_block_height_) {}

    , decltype(_impl_.last_height_validators_changed_) {}

    , decltype(_impl_.last_height_consensus_params_changed_) {}

    , decltype(_impl_.initial_height_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.chain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.chain_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_chain_id().empty()) {
    _this->_impl_.chain_id_.Set(from._internal_chain_id(), _this->GetArenaForAllocation());
  }
  _impl_.last_results_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.last_results_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_last_results_hash().empty()) {
    _this->_impl_.last_results_hash_.Set(from._internal_last_results_hash(), _this->GetArenaForAllocation());
  }
  _impl_.app_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.app_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_app_hash().empty()) {
    _this->_impl_.app_hash_.Set(from._internal_app_hash(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.version_ = new ::tendermint::state::Version(*from._impl_.version_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.last_block_id_ = new ::tendermint::types::BlockID(*from._impl_.last_block_id_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.last_block_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.last_block_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.next_validators_ = new ::tendermint::types::ValidatorSet(*from._impl_.next_validators_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.validators_ = new ::tendermint::types::ValidatorSet(*from._impl_.validators_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.last_validators_ = new ::tendermint::types::ValidatorSet(*from._impl_.last_validators_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.consensus_params_ = new ::tendermint::types::ConsensusParams(*from._impl_.consensus_params_);
  }
  ::memcpy(&_impl_.last_block_height_, &from._impl_.last_block_height_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.initial_height_) -
    reinterpret_cast<char*>(&_impl_.last_block_height_)) + sizeof(_impl_.initial_height_));
  // @@protoc_insertion_point(copy_constructor:tendermint.state.State)
}

inline void State::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chain_id_) {}

    , decltype(_impl_.last_results_hash_) {}

    , decltype(_impl_.app_hash_) {}

    , decltype(_impl_.version_){nullptr}
    , decltype(_impl_.last_block_id_){nullptr}
    , decltype(_impl_.last_block_time_){nullptr}
    , decltype(_impl_.next_validators_){nullptr}
    , decltype(_impl_.validators_){nullptr}
    , decltype(_impl_.last_validators_){nullptr}
    , decltype(_impl_.consensus_params_){nullptr}
    , decltype(_impl_.last_block_height_) { ::int64_t{0} }

    , decltype(_impl_.last_height_validators_changed_) { ::int64_t{0} }

    , decltype(_impl_.last_height_consensus_params_changed_) { ::int64_t{0} }

    , decltype(_impl_.initial_height_) { ::int64_t{0} }

  };
  _impl_.chain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.chain_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.last_results_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.last_results_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.app_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

State::~State() {
  // @@protoc_insertion_point(destructor:tendermint.state.State)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void State::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chain_id_.Destroy();
  _impl_.last_results_hash_.Destroy();
  _impl_.app_hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.version_;
  if (this != internal_default_instance()) delete _impl_.last_block_id_;
  if (this != internal_default_instance()) delete _impl_.last_block_time_;
  if (this != internal_default_instance()) delete _impl_.next_validators_;
  if (this != internal_default_instance()) delete _impl_.validators_;
  if (this != internal_default_instance()) delete _impl_.last_validators_;
  if (this != internal_default_instance()) delete _impl_.consensus_params_;
}

void State::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void State::Clear() {
// @@protoc_insertion_point(message_clear_start:tendermint.state.State)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.chain_id_.ClearToEmpty();
  _impl_.last_results_hash_.ClearToEmpty();
  _impl_.app_hash_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.version_ != nullptr);
      _impl_.version_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.last_block_id_ != nullptr);
      _impl_.last_block_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.last_block_time_ != nullptr);
      _impl_.last_block_time_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.next_validators_ != nullptr);
      _impl_.next_validators_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.validators_ != nullptr);
      _impl_.validators_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.last_validators_ != nullptr);
      _impl_.last_validators_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.consensus_params_ != nullptr);
      _impl_.consensus_params_->Clear();
    }
  }
  ::memset(&_impl_.last_block_height_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.initial_height_) -
      reinterpret_cast<char*>(&_impl_.last_block_height_)) + sizeof(_impl_.initial_height_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tendermint.state.Version version = 1 [json_name = "version", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_version(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string chain_id = 2 [json_name = "chainId", (.gogoproto.customname) = "ChainID"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chain_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tendermint.state.State.chain_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_block_height = 3 [json_name = "lastBlockHeight"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.last_block_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .tendermint.types.BlockID last_block_id = 4 [json_name = "lastBlockId", (.gogoproto.nullable) = false, (.gogoproto.customname) = "LastBlockID"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_block_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp last_block_time = 5 [json_name = "lastBlockTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_block_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .tendermint.types.ValidatorSet next_validators = 6 [json_name = "nextValidators"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_next_validators(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .tendermint.types.ValidatorSet validators = 7 [json_name = "validators"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_validators(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .tendermint.types.ValidatorSet last_validators = 8 [json_name = "lastValidators"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_validators(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_height_validators_changed = 9 [json_name = "lastHeightValidatorsChanged"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.last_height_validators_changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .tendermint.types.ConsensusParams consensus_params = 10 [json_name = "consensusParams", (.gogoproto.nullable) = false];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_consensus_params(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_height_consensus_params_changed = 11 [json_name = "lastHeightConsensusParamsChanged"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.last_height_consensus_params_changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes last_results_hash = 12 [json_name = "lastResultsHash"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_last_results_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes app_hash = 13 [json_name = "appHash"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_app_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 initial_height = 14 [json_name = "initialHeight"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.initial_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* State::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tendermint.state.State)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .tendermint.state.Version version = 1 [json_name = "version", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::version(this),
        _Internal::version(this).GetCachedSize(), target, stream);
  }

  // string chain_id = 2 [json_name = "chainId", (.gogoproto.customname) = "ChainID"];
  if (!this->_internal_chain_id().empty()) {
    const std::string& _s = this->_internal_chain_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "tendermint.state.State.chain_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // int64 last_block_height = 3 [json_name = "lastBlockHeight"];
  if (this->_internal_last_block_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_last_block_height(), target);
  }

  // .tendermint.types.BlockID last_block_id = 4 [json_name = "lastBlockId", (.gogoproto.nullable) = false, (.gogoproto.customname) = "LastBlockID"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::last_block_id(this),
        _Internal::last_block_id(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp last_block_time = 5 [json_name = "lastBlockTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::last_block_time(this),
        _Internal::last_block_time(this).GetCachedSize(), target, stream);
  }

  // .tendermint.types.ValidatorSet next_validators = 6 [json_name = "nextValidators"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::next_validators(this),
        _Internal::next_validators(this).GetCachedSize(), target, stream);
  }

  // .tendermint.types.ValidatorSet validators = 7 [json_name = "validators"];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::validators(this),
        _Internal::validators(this).GetCachedSize(), target, stream);
  }

  // .tendermint.types.ValidatorSet last_validators = 8 [json_name = "lastValidators"];
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::last_validators(this),
        _Internal::last_validators(this).GetCachedSize(), target, stream);
  }

  // int64 last_height_validators_changed = 9 [json_name = "lastHeightValidatorsChanged"];
  if (this->_internal_last_height_validators_changed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        9, this->_internal_last_height_validators_changed(), target);
  }

  // .tendermint.types.ConsensusParams consensus_params = 10 [json_name = "consensusParams", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::consensus_params(this),
        _Internal::consensus_params(this).GetCachedSize(), target, stream);
  }

  // int64 last_height_consensus_params_changed = 11 [json_name = "lastHeightConsensusParamsChanged"];
  if (this->_internal_last_height_consensus_params_changed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        11, this->_internal_last_height_consensus_params_changed(), target);
  }

  // bytes last_results_hash = 12 [json_name = "lastResultsHash"];
  if (!this->_internal_last_results_hash().empty()) {
    const std::string& _s = this->_internal_last_results_hash();
    target = stream->WriteBytesMaybeAliased(12, _s, target);
  }

  // bytes app_hash = 13 [json_name = "appHash"];
  if (!this->_internal_app_hash().empty()) {
    const std::string& _s = this->_internal_app_hash();
    target = stream->WriteBytesMaybeAliased(13, _s, target);
  }

  // int64 initial_height = 14 [json_name = "initialHeight"];
  if (this->_internal_initial_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        14, this->_internal_initial_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tendermint.state.State)
  return target;
}

::size_t State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tendermint.state.State)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string chain_id = 2 [json_name = "chainId", (.gogoproto.customname) = "ChainID"];
  if (!this->_internal_chain_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_chain_id());
  }

  // bytes last_results_hash = 12 [json_name = "lastResultsHash"];
  if (!this->_internal_last_results_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_last_results_hash());
  }

  // bytes app_hash = 13 [json_name = "appHash"];
  if (!this->_internal_app_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_app_hash());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // .tendermint.state.Version version = 1 [json_name = "version", (.gogoproto.nullable) = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.version_);
    }

    // .tendermint.types.BlockID last_block_id = 4 [json_name = "lastBlockId", (.gogoproto.nullable) = false, (.gogoproto.customname) = "LastBlockID"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.last_block_id_);
    }

    // .google.protobuf.Timestamp last_block_time = 5 [json_name = "lastBlockTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.last_block_time_);
    }

    // .tendermint.types.ValidatorSet next_validators = 6 [json_name = "nextValidators"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.next_validators_);
    }

    // .tendermint.types.ValidatorSet validators = 7 [json_name = "validators"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.validators_);
    }

    // .tendermint.types.ValidatorSet last_validators = 8 [json_name = "lastValidators"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.last_validators_);
    }

    // .tendermint.types.ConsensusParams consensus_params = 10 [json_name = "consensusParams", (.gogoproto.nullable) = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.consensus_params_);
    }

  }
  // int64 last_block_height = 3 [json_name = "lastBlockHeight"];
  if (this->_internal_last_block_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_block_height());
  }

  // int64 last_height_validators_changed = 9 [json_name = "lastHeightValidatorsChanged"];
  if (this->_internal_last_height_validators_changed() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_height_validators_changed());
  }

  // int64 last_height_consensus_params_changed = 11 [json_name = "lastHeightConsensusParamsChanged"];
  if (this->_internal_last_height_consensus_params_changed() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_height_consensus_params_changed());
  }

  // int64 initial_height = 14 [json_name = "initialHeight"];
  if (this->_internal_initial_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_initial_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData State::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    State::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*State::GetClassData() const { return &_class_data_; }


void State::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<State*>(&to_msg);
  auto& from = static_cast<const State&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tendermint.state.State)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_chain_id().empty()) {
    _this->_internal_set_chain_id(from._internal_chain_id());
  }
  if (!from._internal_last_results_hash().empty()) {
    _this->_internal_set_last_results_hash(from._internal_last_results_hash());
  }
  if (!from._internal_app_hash().empty()) {
    _this->_internal_set_app_hash(from._internal_app_hash());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_version()->::tendermint::state::Version::MergeFrom(
          from._internal_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_last_block_id()->::tendermint::types::BlockID::MergeFrom(
          from._internal_last_block_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_last_block_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_last_block_time());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_next_validators()->::tendermint::types::ValidatorSet::MergeFrom(
          from._internal_next_validators());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_validators()->::tendermint::types::ValidatorSet::MergeFrom(
          from._internal_validators());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_last_validators()->::tendermint::types::ValidatorSet::MergeFrom(
          from._internal_last_validators());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_consensus_params()->::tendermint::types::ConsensusParams::MergeFrom(
          from._internal_consensus_params());
    }
  }
  if (from._internal_last_block_height() != 0) {
    _this->_internal_set_last_block_height(from._internal_last_block_height());
  }
  if (from._internal_last_height_validators_changed() != 0) {
    _this->_internal_set_last_height_validators_changed(from._internal_last_height_validators_changed());
  }
  if (from._internal_last_height_consensus_params_changed() != 0) {
    _this->_internal_set_last_height_consensus_params_changed(from._internal_last_height_consensus_params_changed());
  }
  if (from._internal_initial_height() != 0) {
    _this->_internal_set_initial_height(from._internal_initial_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void State::CopyFrom(const State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tendermint.state.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  return true;
}

void State::InternalSwap(State* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.chain_id_, lhs_arena,
                                       &other->_impl_.chain_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_results_hash_, lhs_arena,
                                       &other->_impl_.last_results_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.app_hash_, lhs_arena,
                                       &other->_impl_.app_hash_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(State, _impl_.initial_height_)
      + sizeof(State::_impl_.initial_height_)
      - PROTOBUF_FIELD_OFFSET(State, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata State::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tendermint_2fstate_2ftypes_2eproto_getter, &descriptor_table_tendermint_2fstate_2ftypes_2eproto_once,
      file_level_metadata_tendermint_2fstate_2ftypes_2eproto[5]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace state
}  // namespace tendermint
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::tendermint::state::ABCIResponses*
Arena::CreateMaybeMessage< ::tendermint::state::ABCIResponses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tendermint::state::ABCIResponses >(arena);
}
template<> PROTOBUF_NOINLINE ::tendermint::state::ValidatorsInfo*
Arena::CreateMaybeMessage< ::tendermint::state::ValidatorsInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tendermint::state::ValidatorsInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::tendermint::state::ConsensusParamsInfo*
Arena::CreateMaybeMessage< ::tendermint::state::ConsensusParamsInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tendermint::state::ConsensusParamsInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::tendermint::state::ABCIResponsesInfo*
Arena::CreateMaybeMessage< ::tendermint::state::ABCIResponsesInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tendermint::state::ABCIResponsesInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::tendermint::state::Version*
Arena::CreateMaybeMessage< ::tendermint::state::Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tendermint::state::Version >(arena);
}
template<> PROTOBUF_NOINLINE ::tendermint::state::State*
Arena::CreateMaybeMessage< ::tendermint::state::State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tendermint::state::State >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
