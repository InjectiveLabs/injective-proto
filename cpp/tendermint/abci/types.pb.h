// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tendermint/abci/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tendermint_2fabci_2ftypes_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tendermint_2fabci_2ftypes_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "tendermint/crypto/proof.pb.h"
#include "tendermint/types/types.pb.h"
#include "tendermint/crypto/keys.pb.h"
#include "tendermint/types/params.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tendermint_2fabci_2ftypes_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tendermint_2fabci_2ftypes_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_tendermint_2fabci_2ftypes_2eproto;
namespace tendermint {
namespace abci {
class CommitInfo;
struct CommitInfoDefaultTypeInternal;
extern CommitInfoDefaultTypeInternal _CommitInfo_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventAttribute;
struct EventAttributeDefaultTypeInternal;
extern EventAttributeDefaultTypeInternal _EventAttribute_default_instance_;
class ExtendedCommitInfo;
struct ExtendedCommitInfoDefaultTypeInternal;
extern ExtendedCommitInfoDefaultTypeInternal _ExtendedCommitInfo_default_instance_;
class ExtendedVoteInfo;
struct ExtendedVoteInfoDefaultTypeInternal;
extern ExtendedVoteInfoDefaultTypeInternal _ExtendedVoteInfo_default_instance_;
class Misbehavior;
struct MisbehaviorDefaultTypeInternal;
extern MisbehaviorDefaultTypeInternal _Misbehavior_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestApplySnapshotChunk;
struct RequestApplySnapshotChunkDefaultTypeInternal;
extern RequestApplySnapshotChunkDefaultTypeInternal _RequestApplySnapshotChunk_default_instance_;
class RequestBeginBlock;
struct RequestBeginBlockDefaultTypeInternal;
extern RequestBeginBlockDefaultTypeInternal _RequestBeginBlock_default_instance_;
class RequestCheckTx;
struct RequestCheckTxDefaultTypeInternal;
extern RequestCheckTxDefaultTypeInternal _RequestCheckTx_default_instance_;
class RequestCommit;
struct RequestCommitDefaultTypeInternal;
extern RequestCommitDefaultTypeInternal _RequestCommit_default_instance_;
class RequestDeliverTx;
struct RequestDeliverTxDefaultTypeInternal;
extern RequestDeliverTxDefaultTypeInternal _RequestDeliverTx_default_instance_;
class RequestEcho;
struct RequestEchoDefaultTypeInternal;
extern RequestEchoDefaultTypeInternal _RequestEcho_default_instance_;
class RequestEndBlock;
struct RequestEndBlockDefaultTypeInternal;
extern RequestEndBlockDefaultTypeInternal _RequestEndBlock_default_instance_;
class RequestFlush;
struct RequestFlushDefaultTypeInternal;
extern RequestFlushDefaultTypeInternal _RequestFlush_default_instance_;
class RequestInfo;
struct RequestInfoDefaultTypeInternal;
extern RequestInfoDefaultTypeInternal _RequestInfo_default_instance_;
class RequestInitChain;
struct RequestInitChainDefaultTypeInternal;
extern RequestInitChainDefaultTypeInternal _RequestInitChain_default_instance_;
class RequestListSnapshots;
struct RequestListSnapshotsDefaultTypeInternal;
extern RequestListSnapshotsDefaultTypeInternal _RequestListSnapshots_default_instance_;
class RequestLoadSnapshotChunk;
struct RequestLoadSnapshotChunkDefaultTypeInternal;
extern RequestLoadSnapshotChunkDefaultTypeInternal _RequestLoadSnapshotChunk_default_instance_;
class RequestOfferSnapshot;
struct RequestOfferSnapshotDefaultTypeInternal;
extern RequestOfferSnapshotDefaultTypeInternal _RequestOfferSnapshot_default_instance_;
class RequestPrepareProposal;
struct RequestPrepareProposalDefaultTypeInternal;
extern RequestPrepareProposalDefaultTypeInternal _RequestPrepareProposal_default_instance_;
class RequestProcessProposal;
struct RequestProcessProposalDefaultTypeInternal;
extern RequestProcessProposalDefaultTypeInternal _RequestProcessProposal_default_instance_;
class RequestQuery;
struct RequestQueryDefaultTypeInternal;
extern RequestQueryDefaultTypeInternal _RequestQuery_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseApplySnapshotChunk;
struct ResponseApplySnapshotChunkDefaultTypeInternal;
extern ResponseApplySnapshotChunkDefaultTypeInternal _ResponseApplySnapshotChunk_default_instance_;
class ResponseBeginBlock;
struct ResponseBeginBlockDefaultTypeInternal;
extern ResponseBeginBlockDefaultTypeInternal _ResponseBeginBlock_default_instance_;
class ResponseCheckTx;
struct ResponseCheckTxDefaultTypeInternal;
extern ResponseCheckTxDefaultTypeInternal _ResponseCheckTx_default_instance_;
class ResponseCommit;
struct ResponseCommitDefaultTypeInternal;
extern ResponseCommitDefaultTypeInternal _ResponseCommit_default_instance_;
class ResponseDeliverTx;
struct ResponseDeliverTxDefaultTypeInternal;
extern ResponseDeliverTxDefaultTypeInternal _ResponseDeliverTx_default_instance_;
class ResponseEcho;
struct ResponseEchoDefaultTypeInternal;
extern ResponseEchoDefaultTypeInternal _ResponseEcho_default_instance_;
class ResponseEndBlock;
struct ResponseEndBlockDefaultTypeInternal;
extern ResponseEndBlockDefaultTypeInternal _ResponseEndBlock_default_instance_;
class ResponseException;
struct ResponseExceptionDefaultTypeInternal;
extern ResponseExceptionDefaultTypeInternal _ResponseException_default_instance_;
class ResponseFlush;
struct ResponseFlushDefaultTypeInternal;
extern ResponseFlushDefaultTypeInternal _ResponseFlush_default_instance_;
class ResponseInfo;
struct ResponseInfoDefaultTypeInternal;
extern ResponseInfoDefaultTypeInternal _ResponseInfo_default_instance_;
class ResponseInitChain;
struct ResponseInitChainDefaultTypeInternal;
extern ResponseInitChainDefaultTypeInternal _ResponseInitChain_default_instance_;
class ResponseListSnapshots;
struct ResponseListSnapshotsDefaultTypeInternal;
extern ResponseListSnapshotsDefaultTypeInternal _ResponseListSnapshots_default_instance_;
class ResponseLoadSnapshotChunk;
struct ResponseLoadSnapshotChunkDefaultTypeInternal;
extern ResponseLoadSnapshotChunkDefaultTypeInternal _ResponseLoadSnapshotChunk_default_instance_;
class ResponseOfferSnapshot;
struct ResponseOfferSnapshotDefaultTypeInternal;
extern ResponseOfferSnapshotDefaultTypeInternal _ResponseOfferSnapshot_default_instance_;
class ResponsePrepareProposal;
struct ResponsePrepareProposalDefaultTypeInternal;
extern ResponsePrepareProposalDefaultTypeInternal _ResponsePrepareProposal_default_instance_;
class ResponseProcessProposal;
struct ResponseProcessProposalDefaultTypeInternal;
extern ResponseProcessProposalDefaultTypeInternal _ResponseProcessProposal_default_instance_;
class ResponseQuery;
struct ResponseQueryDefaultTypeInternal;
extern ResponseQueryDefaultTypeInternal _ResponseQuery_default_instance_;
class Snapshot;
struct SnapshotDefaultTypeInternal;
extern SnapshotDefaultTypeInternal _Snapshot_default_instance_;
class TxResult;
struct TxResultDefaultTypeInternal;
extern TxResultDefaultTypeInternal _TxResult_default_instance_;
class Validator;
struct ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
class ValidatorUpdate;
struct ValidatorUpdateDefaultTypeInternal;
extern ValidatorUpdateDefaultTypeInternal _ValidatorUpdate_default_instance_;
class VoteInfo;
struct VoteInfoDefaultTypeInternal;
extern VoteInfoDefaultTypeInternal _VoteInfo_default_instance_;
}  // namespace abci
}  // namespace tendermint
PROTOBUF_NAMESPACE_OPEN
template <>
::tendermint::abci::CommitInfo* Arena::CreateMaybeMessage<::tendermint::abci::CommitInfo>(Arena*);
template <>
::tendermint::abci::Event* Arena::CreateMaybeMessage<::tendermint::abci::Event>(Arena*);
template <>
::tendermint::abci::EventAttribute* Arena::CreateMaybeMessage<::tendermint::abci::EventAttribute>(Arena*);
template <>
::tendermint::abci::ExtendedCommitInfo* Arena::CreateMaybeMessage<::tendermint::abci::ExtendedCommitInfo>(Arena*);
template <>
::tendermint::abci::ExtendedVoteInfo* Arena::CreateMaybeMessage<::tendermint::abci::ExtendedVoteInfo>(Arena*);
template <>
::tendermint::abci::Misbehavior* Arena::CreateMaybeMessage<::tendermint::abci::Misbehavior>(Arena*);
template <>
::tendermint::abci::Request* Arena::CreateMaybeMessage<::tendermint::abci::Request>(Arena*);
template <>
::tendermint::abci::RequestApplySnapshotChunk* Arena::CreateMaybeMessage<::tendermint::abci::RequestApplySnapshotChunk>(Arena*);
template <>
::tendermint::abci::RequestBeginBlock* Arena::CreateMaybeMessage<::tendermint::abci::RequestBeginBlock>(Arena*);
template <>
::tendermint::abci::RequestCheckTx* Arena::CreateMaybeMessage<::tendermint::abci::RequestCheckTx>(Arena*);
template <>
::tendermint::abci::RequestCommit* Arena::CreateMaybeMessage<::tendermint::abci::RequestCommit>(Arena*);
template <>
::tendermint::abci::RequestDeliverTx* Arena::CreateMaybeMessage<::tendermint::abci::RequestDeliverTx>(Arena*);
template <>
::tendermint::abci::RequestEcho* Arena::CreateMaybeMessage<::tendermint::abci::RequestEcho>(Arena*);
template <>
::tendermint::abci::RequestEndBlock* Arena::CreateMaybeMessage<::tendermint::abci::RequestEndBlock>(Arena*);
template <>
::tendermint::abci::RequestFlush* Arena::CreateMaybeMessage<::tendermint::abci::RequestFlush>(Arena*);
template <>
::tendermint::abci::RequestInfo* Arena::CreateMaybeMessage<::tendermint::abci::RequestInfo>(Arena*);
template <>
::tendermint::abci::RequestInitChain* Arena::CreateMaybeMessage<::tendermint::abci::RequestInitChain>(Arena*);
template <>
::tendermint::abci::RequestListSnapshots* Arena::CreateMaybeMessage<::tendermint::abci::RequestListSnapshots>(Arena*);
template <>
::tendermint::abci::RequestLoadSnapshotChunk* Arena::CreateMaybeMessage<::tendermint::abci::RequestLoadSnapshotChunk>(Arena*);
template <>
::tendermint::abci::RequestOfferSnapshot* Arena::CreateMaybeMessage<::tendermint::abci::RequestOfferSnapshot>(Arena*);
template <>
::tendermint::abci::RequestPrepareProposal* Arena::CreateMaybeMessage<::tendermint::abci::RequestPrepareProposal>(Arena*);
template <>
::tendermint::abci::RequestProcessProposal* Arena::CreateMaybeMessage<::tendermint::abci::RequestProcessProposal>(Arena*);
template <>
::tendermint::abci::RequestQuery* Arena::CreateMaybeMessage<::tendermint::abci::RequestQuery>(Arena*);
template <>
::tendermint::abci::Response* Arena::CreateMaybeMessage<::tendermint::abci::Response>(Arena*);
template <>
::tendermint::abci::ResponseApplySnapshotChunk* Arena::CreateMaybeMessage<::tendermint::abci::ResponseApplySnapshotChunk>(Arena*);
template <>
::tendermint::abci::ResponseBeginBlock* Arena::CreateMaybeMessage<::tendermint::abci::ResponseBeginBlock>(Arena*);
template <>
::tendermint::abci::ResponseCheckTx* Arena::CreateMaybeMessage<::tendermint::abci::ResponseCheckTx>(Arena*);
template <>
::tendermint::abci::ResponseCommit* Arena::CreateMaybeMessage<::tendermint::abci::ResponseCommit>(Arena*);
template <>
::tendermint::abci::ResponseDeliverTx* Arena::CreateMaybeMessage<::tendermint::abci::ResponseDeliverTx>(Arena*);
template <>
::tendermint::abci::ResponseEcho* Arena::CreateMaybeMessage<::tendermint::abci::ResponseEcho>(Arena*);
template <>
::tendermint::abci::ResponseEndBlock* Arena::CreateMaybeMessage<::tendermint::abci::ResponseEndBlock>(Arena*);
template <>
::tendermint::abci::ResponseException* Arena::CreateMaybeMessage<::tendermint::abci::ResponseException>(Arena*);
template <>
::tendermint::abci::ResponseFlush* Arena::CreateMaybeMessage<::tendermint::abci::ResponseFlush>(Arena*);
template <>
::tendermint::abci::ResponseInfo* Arena::CreateMaybeMessage<::tendermint::abci::ResponseInfo>(Arena*);
template <>
::tendermint::abci::ResponseInitChain* Arena::CreateMaybeMessage<::tendermint::abci::ResponseInitChain>(Arena*);
template <>
::tendermint::abci::ResponseListSnapshots* Arena::CreateMaybeMessage<::tendermint::abci::ResponseListSnapshots>(Arena*);
template <>
::tendermint::abci::ResponseLoadSnapshotChunk* Arena::CreateMaybeMessage<::tendermint::abci::ResponseLoadSnapshotChunk>(Arena*);
template <>
::tendermint::abci::ResponseOfferSnapshot* Arena::CreateMaybeMessage<::tendermint::abci::ResponseOfferSnapshot>(Arena*);
template <>
::tendermint::abci::ResponsePrepareProposal* Arena::CreateMaybeMessage<::tendermint::abci::ResponsePrepareProposal>(Arena*);
template <>
::tendermint::abci::ResponseProcessProposal* Arena::CreateMaybeMessage<::tendermint::abci::ResponseProcessProposal>(Arena*);
template <>
::tendermint::abci::ResponseQuery* Arena::CreateMaybeMessage<::tendermint::abci::ResponseQuery>(Arena*);
template <>
::tendermint::abci::Snapshot* Arena::CreateMaybeMessage<::tendermint::abci::Snapshot>(Arena*);
template <>
::tendermint::abci::TxResult* Arena::CreateMaybeMessage<::tendermint::abci::TxResult>(Arena*);
template <>
::tendermint::abci::Validator* Arena::CreateMaybeMessage<::tendermint::abci::Validator>(Arena*);
template <>
::tendermint::abci::ValidatorUpdate* Arena::CreateMaybeMessage<::tendermint::abci::ValidatorUpdate>(Arena*);
template <>
::tendermint::abci::VoteInfo* Arena::CreateMaybeMessage<::tendermint::abci::VoteInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace tendermint {
namespace abci {
enum ResponseOfferSnapshot_Result : int {
  ResponseOfferSnapshot_Result_UNKNOWN = 0,
  ResponseOfferSnapshot_Result_ACCEPT = 1,
  ResponseOfferSnapshot_Result_ABORT = 2,
  ResponseOfferSnapshot_Result_REJECT = 3,
  ResponseOfferSnapshot_Result_REJECT_FORMAT = 4,
  ResponseOfferSnapshot_Result_REJECT_SENDER = 5,
  ResponseOfferSnapshot_Result_ResponseOfferSnapshot_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResponseOfferSnapshot_Result_ResponseOfferSnapshot_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ResponseOfferSnapshot_Result_IsValid(int value);
constexpr ResponseOfferSnapshot_Result ResponseOfferSnapshot_Result_Result_MIN = static_cast<ResponseOfferSnapshot_Result>(0);
constexpr ResponseOfferSnapshot_Result ResponseOfferSnapshot_Result_Result_MAX = static_cast<ResponseOfferSnapshot_Result>(5);
constexpr int ResponseOfferSnapshot_Result_Result_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ResponseOfferSnapshot_Result_descriptor();
template <typename T>
const std::string& ResponseOfferSnapshot_Result_Name(T value) {
  static_assert(std::is_same<T, ResponseOfferSnapshot_Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return ResponseOfferSnapshot_Result_Name(static_cast<ResponseOfferSnapshot_Result>(value));
}
template <>
inline const std::string& ResponseOfferSnapshot_Result_Name(ResponseOfferSnapshot_Result value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ResponseOfferSnapshot_Result_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ResponseOfferSnapshot_Result_Parse(absl::string_view name, ResponseOfferSnapshot_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseOfferSnapshot_Result>(
      ResponseOfferSnapshot_Result_descriptor(), name, value);
}
enum ResponseApplySnapshotChunk_Result : int {
  ResponseApplySnapshotChunk_Result_UNKNOWN = 0,
  ResponseApplySnapshotChunk_Result_ACCEPT = 1,
  ResponseApplySnapshotChunk_Result_ABORT = 2,
  ResponseApplySnapshotChunk_Result_RETRY = 3,
  ResponseApplySnapshotChunk_Result_RETRY_SNAPSHOT = 4,
  ResponseApplySnapshotChunk_Result_REJECT_SNAPSHOT = 5,
  ResponseApplySnapshotChunk_Result_ResponseApplySnapshotChunk_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResponseApplySnapshotChunk_Result_ResponseApplySnapshotChunk_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ResponseApplySnapshotChunk_Result_IsValid(int value);
constexpr ResponseApplySnapshotChunk_Result ResponseApplySnapshotChunk_Result_Result_MIN = static_cast<ResponseApplySnapshotChunk_Result>(0);
constexpr ResponseApplySnapshotChunk_Result ResponseApplySnapshotChunk_Result_Result_MAX = static_cast<ResponseApplySnapshotChunk_Result>(5);
constexpr int ResponseApplySnapshotChunk_Result_Result_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ResponseApplySnapshotChunk_Result_descriptor();
template <typename T>
const std::string& ResponseApplySnapshotChunk_Result_Name(T value) {
  static_assert(std::is_same<T, ResponseApplySnapshotChunk_Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return ResponseApplySnapshotChunk_Result_Name(static_cast<ResponseApplySnapshotChunk_Result>(value));
}
template <>
inline const std::string& ResponseApplySnapshotChunk_Result_Name(ResponseApplySnapshotChunk_Result value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ResponseApplySnapshotChunk_Result_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ResponseApplySnapshotChunk_Result_Parse(absl::string_view name, ResponseApplySnapshotChunk_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseApplySnapshotChunk_Result>(
      ResponseApplySnapshotChunk_Result_descriptor(), name, value);
}
enum ResponseProcessProposal_ProposalStatus : int {
  ResponseProcessProposal_ProposalStatus_UNKNOWN = 0,
  ResponseProcessProposal_ProposalStatus_ACCEPT = 1,
  ResponseProcessProposal_ProposalStatus_REJECT = 2,
  ResponseProcessProposal_ProposalStatus_ResponseProcessProposal_ProposalStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResponseProcessProposal_ProposalStatus_ResponseProcessProposal_ProposalStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ResponseProcessProposal_ProposalStatus_IsValid(int value);
constexpr ResponseProcessProposal_ProposalStatus ResponseProcessProposal_ProposalStatus_ProposalStatus_MIN = static_cast<ResponseProcessProposal_ProposalStatus>(0);
constexpr ResponseProcessProposal_ProposalStatus ResponseProcessProposal_ProposalStatus_ProposalStatus_MAX = static_cast<ResponseProcessProposal_ProposalStatus>(2);
constexpr int ResponseProcessProposal_ProposalStatus_ProposalStatus_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ResponseProcessProposal_ProposalStatus_descriptor();
template <typename T>
const std::string& ResponseProcessProposal_ProposalStatus_Name(T value) {
  static_assert(std::is_same<T, ResponseProcessProposal_ProposalStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProposalStatus_Name().");
  return ResponseProcessProposal_ProposalStatus_Name(static_cast<ResponseProcessProposal_ProposalStatus>(value));
}
template <>
inline const std::string& ResponseProcessProposal_ProposalStatus_Name(ResponseProcessProposal_ProposalStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ResponseProcessProposal_ProposalStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ResponseProcessProposal_ProposalStatus_Parse(absl::string_view name, ResponseProcessProposal_ProposalStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseProcessProposal_ProposalStatus>(
      ResponseProcessProposal_ProposalStatus_descriptor(), name, value);
}
enum CheckTxType : int {
  NEW = 0,
  RECHECK = 1,
  CheckTxType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CheckTxType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CheckTxType_IsValid(int value);
constexpr CheckTxType CheckTxType_MIN = static_cast<CheckTxType>(0);
constexpr CheckTxType CheckTxType_MAX = static_cast<CheckTxType>(1);
constexpr int CheckTxType_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CheckTxType_descriptor();
template <typename T>
const std::string& CheckTxType_Name(T value) {
  static_assert(std::is_same<T, CheckTxType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CheckTxType_Name().");
  return CheckTxType_Name(static_cast<CheckTxType>(value));
}
template <>
inline const std::string& CheckTxType_Name(CheckTxType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CheckTxType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool CheckTxType_Parse(absl::string_view name, CheckTxType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CheckTxType>(
      CheckTxType_descriptor(), name, value);
}
enum MisbehaviorType : int {
  UNKNOWN = 0,
  DUPLICATE_VOTE = 1,
  LIGHT_CLIENT_ATTACK = 2,
  MisbehaviorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MisbehaviorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MisbehaviorType_IsValid(int value);
constexpr MisbehaviorType MisbehaviorType_MIN = static_cast<MisbehaviorType>(0);
constexpr MisbehaviorType MisbehaviorType_MAX = static_cast<MisbehaviorType>(2);
constexpr int MisbehaviorType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
MisbehaviorType_descriptor();
template <typename T>
const std::string& MisbehaviorType_Name(T value) {
  static_assert(std::is_same<T, MisbehaviorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MisbehaviorType_Name().");
  return MisbehaviorType_Name(static_cast<MisbehaviorType>(value));
}
template <>
inline const std::string& MisbehaviorType_Name(MisbehaviorType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<MisbehaviorType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool MisbehaviorType_Parse(absl::string_view name, MisbehaviorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MisbehaviorType>(
      MisbehaviorType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kEcho = 1,
    kFlush = 2,
    kInfo = 3,
    kInitChain = 5,
    kQuery = 6,
    kBeginBlock = 7,
    kCheckTx = 8,
    kDeliverTx = 9,
    kEndBlock = 10,
    kCommit = 11,
    kListSnapshots = 12,
    kOfferSnapshot = 13,
    kLoadSnapshotChunk = 14,
    kApplySnapshotChunk = 15,
    kPrepareProposal = 16,
    kProcessProposal = 17,
    VALUE_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEchoFieldNumber = 1,
    kFlushFieldNumber = 2,
    kInfoFieldNumber = 3,
    kInitChainFieldNumber = 5,
    kQueryFieldNumber = 6,
    kBeginBlockFieldNumber = 7,
    kCheckTxFieldNumber = 8,
    kDeliverTxFieldNumber = 9,
    kEndBlockFieldNumber = 10,
    kCommitFieldNumber = 11,
    kListSnapshotsFieldNumber = 12,
    kOfferSnapshotFieldNumber = 13,
    kLoadSnapshotChunkFieldNumber = 14,
    kApplySnapshotChunkFieldNumber = 15,
    kPrepareProposalFieldNumber = 16,
    kProcessProposalFieldNumber = 17,
  };
  // .tendermint.abci.RequestEcho echo = 1 [json_name = "echo"];
  bool has_echo() const;
  private:
  bool _internal_has_echo() const;

  public:
  void clear_echo() ;
  const ::tendermint::abci::RequestEcho& echo() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestEcho* release_echo();
  ::tendermint::abci::RequestEcho* mutable_echo();
  void set_allocated_echo(::tendermint::abci::RequestEcho* echo);
  private:
  const ::tendermint::abci::RequestEcho& _internal_echo() const;
  ::tendermint::abci::RequestEcho* _internal_mutable_echo();
  public:
  void unsafe_arena_set_allocated_echo(
      ::tendermint::abci::RequestEcho* echo);
  ::tendermint::abci::RequestEcho* unsafe_arena_release_echo();
  // .tendermint.abci.RequestFlush flush = 2 [json_name = "flush"];
  bool has_flush() const;
  private:
  bool _internal_has_flush() const;

  public:
  void clear_flush() ;
  const ::tendermint::abci::RequestFlush& flush() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestFlush* release_flush();
  ::tendermint::abci::RequestFlush* mutable_flush();
  void set_allocated_flush(::tendermint::abci::RequestFlush* flush);
  private:
  const ::tendermint::abci::RequestFlush& _internal_flush() const;
  ::tendermint::abci::RequestFlush* _internal_mutable_flush();
  public:
  void unsafe_arena_set_allocated_flush(
      ::tendermint::abci::RequestFlush* flush);
  ::tendermint::abci::RequestFlush* unsafe_arena_release_flush();
  // .tendermint.abci.RequestInfo info = 3 [json_name = "info"];
  bool has_info() const;
  private:
  bool _internal_has_info() const;

  public:
  void clear_info() ;
  const ::tendermint::abci::RequestInfo& info() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestInfo* release_info();
  ::tendermint::abci::RequestInfo* mutable_info();
  void set_allocated_info(::tendermint::abci::RequestInfo* info);
  private:
  const ::tendermint::abci::RequestInfo& _internal_info() const;
  ::tendermint::abci::RequestInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::tendermint::abci::RequestInfo* info);
  ::tendermint::abci::RequestInfo* unsafe_arena_release_info();
  // .tendermint.abci.RequestInitChain init_chain = 5 [json_name = "initChain"];
  bool has_init_chain() const;
  private:
  bool _internal_has_init_chain() const;

  public:
  void clear_init_chain() ;
  const ::tendermint::abci::RequestInitChain& init_chain() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestInitChain* release_init_chain();
  ::tendermint::abci::RequestInitChain* mutable_init_chain();
  void set_allocated_init_chain(::tendermint::abci::RequestInitChain* init_chain);
  private:
  const ::tendermint::abci::RequestInitChain& _internal_init_chain() const;
  ::tendermint::abci::RequestInitChain* _internal_mutable_init_chain();
  public:
  void unsafe_arena_set_allocated_init_chain(
      ::tendermint::abci::RequestInitChain* init_chain);
  ::tendermint::abci::RequestInitChain* unsafe_arena_release_init_chain();
  // .tendermint.abci.RequestQuery query = 6 [json_name = "query"];
  bool has_query() const;
  private:
  bool _internal_has_query() const;

  public:
  void clear_query() ;
  const ::tendermint::abci::RequestQuery& query() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestQuery* release_query();
  ::tendermint::abci::RequestQuery* mutable_query();
  void set_allocated_query(::tendermint::abci::RequestQuery* query);
  private:
  const ::tendermint::abci::RequestQuery& _internal_query() const;
  ::tendermint::abci::RequestQuery* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::tendermint::abci::RequestQuery* query);
  ::tendermint::abci::RequestQuery* unsafe_arena_release_query();
  // .tendermint.abci.RequestBeginBlock begin_block = 7 [json_name = "beginBlock"];
  bool has_begin_block() const;
  private:
  bool _internal_has_begin_block() const;

  public:
  void clear_begin_block() ;
  const ::tendermint::abci::RequestBeginBlock& begin_block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestBeginBlock* release_begin_block();
  ::tendermint::abci::RequestBeginBlock* mutable_begin_block();
  void set_allocated_begin_block(::tendermint::abci::RequestBeginBlock* begin_block);
  private:
  const ::tendermint::abci::RequestBeginBlock& _internal_begin_block() const;
  ::tendermint::abci::RequestBeginBlock* _internal_mutable_begin_block();
  public:
  void unsafe_arena_set_allocated_begin_block(
      ::tendermint::abci::RequestBeginBlock* begin_block);
  ::tendermint::abci::RequestBeginBlock* unsafe_arena_release_begin_block();
  // .tendermint.abci.RequestCheckTx check_tx = 8 [json_name = "checkTx"];
  bool has_check_tx() const;
  private:
  bool _internal_has_check_tx() const;

  public:
  void clear_check_tx() ;
  const ::tendermint::abci::RequestCheckTx& check_tx() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestCheckTx* release_check_tx();
  ::tendermint::abci::RequestCheckTx* mutable_check_tx();
  void set_allocated_check_tx(::tendermint::abci::RequestCheckTx* check_tx);
  private:
  const ::tendermint::abci::RequestCheckTx& _internal_check_tx() const;
  ::tendermint::abci::RequestCheckTx* _internal_mutable_check_tx();
  public:
  void unsafe_arena_set_allocated_check_tx(
      ::tendermint::abci::RequestCheckTx* check_tx);
  ::tendermint::abci::RequestCheckTx* unsafe_arena_release_check_tx();
  // .tendermint.abci.RequestDeliverTx deliver_tx = 9 [json_name = "deliverTx"];
  bool has_deliver_tx() const;
  private:
  bool _internal_has_deliver_tx() const;

  public:
  void clear_deliver_tx() ;
  const ::tendermint::abci::RequestDeliverTx& deliver_tx() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestDeliverTx* release_deliver_tx();
  ::tendermint::abci::RequestDeliverTx* mutable_deliver_tx();
  void set_allocated_deliver_tx(::tendermint::abci::RequestDeliverTx* deliver_tx);
  private:
  const ::tendermint::abci::RequestDeliverTx& _internal_deliver_tx() const;
  ::tendermint::abci::RequestDeliverTx* _internal_mutable_deliver_tx();
  public:
  void unsafe_arena_set_allocated_deliver_tx(
      ::tendermint::abci::RequestDeliverTx* deliver_tx);
  ::tendermint::abci::RequestDeliverTx* unsafe_arena_release_deliver_tx();
  // .tendermint.abci.RequestEndBlock end_block = 10 [json_name = "endBlock"];
  bool has_end_block() const;
  private:
  bool _internal_has_end_block() const;

  public:
  void clear_end_block() ;
  const ::tendermint::abci::RequestEndBlock& end_block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestEndBlock* release_end_block();
  ::tendermint::abci::RequestEndBlock* mutable_end_block();
  void set_allocated_end_block(::tendermint::abci::RequestEndBlock* end_block);
  private:
  const ::tendermint::abci::RequestEndBlock& _internal_end_block() const;
  ::tendermint::abci::RequestEndBlock* _internal_mutable_end_block();
  public:
  void unsafe_arena_set_allocated_end_block(
      ::tendermint::abci::RequestEndBlock* end_block);
  ::tendermint::abci::RequestEndBlock* unsafe_arena_release_end_block();
  // .tendermint.abci.RequestCommit commit = 11 [json_name = "commit"];
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;

  public:
  void clear_commit() ;
  const ::tendermint::abci::RequestCommit& commit() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestCommit* release_commit();
  ::tendermint::abci::RequestCommit* mutable_commit();
  void set_allocated_commit(::tendermint::abci::RequestCommit* commit);
  private:
  const ::tendermint::abci::RequestCommit& _internal_commit() const;
  ::tendermint::abci::RequestCommit* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::tendermint::abci::RequestCommit* commit);
  ::tendermint::abci::RequestCommit* unsafe_arena_release_commit();
  // .tendermint.abci.RequestListSnapshots list_snapshots = 12 [json_name = "listSnapshots"];
  bool has_list_snapshots() const;
  private:
  bool _internal_has_list_snapshots() const;

  public:
  void clear_list_snapshots() ;
  const ::tendermint::abci::RequestListSnapshots& list_snapshots() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestListSnapshots* release_list_snapshots();
  ::tendermint::abci::RequestListSnapshots* mutable_list_snapshots();
  void set_allocated_list_snapshots(::tendermint::abci::RequestListSnapshots* list_snapshots);
  private:
  const ::tendermint::abci::RequestListSnapshots& _internal_list_snapshots() const;
  ::tendermint::abci::RequestListSnapshots* _internal_mutable_list_snapshots();
  public:
  void unsafe_arena_set_allocated_list_snapshots(
      ::tendermint::abci::RequestListSnapshots* list_snapshots);
  ::tendermint::abci::RequestListSnapshots* unsafe_arena_release_list_snapshots();
  // .tendermint.abci.RequestOfferSnapshot offer_snapshot = 13 [json_name = "offerSnapshot"];
  bool has_offer_snapshot() const;
  private:
  bool _internal_has_offer_snapshot() const;

  public:
  void clear_offer_snapshot() ;
  const ::tendermint::abci::RequestOfferSnapshot& offer_snapshot() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestOfferSnapshot* release_offer_snapshot();
  ::tendermint::abci::RequestOfferSnapshot* mutable_offer_snapshot();
  void set_allocated_offer_snapshot(::tendermint::abci::RequestOfferSnapshot* offer_snapshot);
  private:
  const ::tendermint::abci::RequestOfferSnapshot& _internal_offer_snapshot() const;
  ::tendermint::abci::RequestOfferSnapshot* _internal_mutable_offer_snapshot();
  public:
  void unsafe_arena_set_allocated_offer_snapshot(
      ::tendermint::abci::RequestOfferSnapshot* offer_snapshot);
  ::tendermint::abci::RequestOfferSnapshot* unsafe_arena_release_offer_snapshot();
  // .tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14 [json_name = "loadSnapshotChunk"];
  bool has_load_snapshot_chunk() const;
  private:
  bool _internal_has_load_snapshot_chunk() const;

  public:
  void clear_load_snapshot_chunk() ;
  const ::tendermint::abci::RequestLoadSnapshotChunk& load_snapshot_chunk() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestLoadSnapshotChunk* release_load_snapshot_chunk();
  ::tendermint::abci::RequestLoadSnapshotChunk* mutable_load_snapshot_chunk();
  void set_allocated_load_snapshot_chunk(::tendermint::abci::RequestLoadSnapshotChunk* load_snapshot_chunk);
  private:
  const ::tendermint::abci::RequestLoadSnapshotChunk& _internal_load_snapshot_chunk() const;
  ::tendermint::abci::RequestLoadSnapshotChunk* _internal_mutable_load_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_load_snapshot_chunk(
      ::tendermint::abci::RequestLoadSnapshotChunk* load_snapshot_chunk);
  ::tendermint::abci::RequestLoadSnapshotChunk* unsafe_arena_release_load_snapshot_chunk();
  // .tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15 [json_name = "applySnapshotChunk"];
  bool has_apply_snapshot_chunk() const;
  private:
  bool _internal_has_apply_snapshot_chunk() const;

  public:
  void clear_apply_snapshot_chunk() ;
  const ::tendermint::abci::RequestApplySnapshotChunk& apply_snapshot_chunk() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestApplySnapshotChunk* release_apply_snapshot_chunk();
  ::tendermint::abci::RequestApplySnapshotChunk* mutable_apply_snapshot_chunk();
  void set_allocated_apply_snapshot_chunk(::tendermint::abci::RequestApplySnapshotChunk* apply_snapshot_chunk);
  private:
  const ::tendermint::abci::RequestApplySnapshotChunk& _internal_apply_snapshot_chunk() const;
  ::tendermint::abci::RequestApplySnapshotChunk* _internal_mutable_apply_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_apply_snapshot_chunk(
      ::tendermint::abci::RequestApplySnapshotChunk* apply_snapshot_chunk);
  ::tendermint::abci::RequestApplySnapshotChunk* unsafe_arena_release_apply_snapshot_chunk();
  // .tendermint.abci.RequestPrepareProposal prepare_proposal = 16 [json_name = "prepareProposal"];
  bool has_prepare_proposal() const;
  private:
  bool _internal_has_prepare_proposal() const;

  public:
  void clear_prepare_proposal() ;
  const ::tendermint::abci::RequestPrepareProposal& prepare_proposal() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestPrepareProposal* release_prepare_proposal();
  ::tendermint::abci::RequestPrepareProposal* mutable_prepare_proposal();
  void set_allocated_prepare_proposal(::tendermint::abci::RequestPrepareProposal* prepare_proposal);
  private:
  const ::tendermint::abci::RequestPrepareProposal& _internal_prepare_proposal() const;
  ::tendermint::abci::RequestPrepareProposal* _internal_mutable_prepare_proposal();
  public:
  void unsafe_arena_set_allocated_prepare_proposal(
      ::tendermint::abci::RequestPrepareProposal* prepare_proposal);
  ::tendermint::abci::RequestPrepareProposal* unsafe_arena_release_prepare_proposal();
  // .tendermint.abci.RequestProcessProposal process_proposal = 17 [json_name = "processProposal"];
  bool has_process_proposal() const;
  private:
  bool _internal_has_process_proposal() const;

  public:
  void clear_process_proposal() ;
  const ::tendermint::abci::RequestProcessProposal& process_proposal() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestProcessProposal* release_process_proposal();
  ::tendermint::abci::RequestProcessProposal* mutable_process_proposal();
  void set_allocated_process_proposal(::tendermint::abci::RequestProcessProposal* process_proposal);
  private:
  const ::tendermint::abci::RequestProcessProposal& _internal_process_proposal() const;
  ::tendermint::abci::RequestProcessProposal* _internal_mutable_process_proposal();
  public:
  void unsafe_arena_set_allocated_process_proposal(
      ::tendermint::abci::RequestProcessProposal* process_proposal);
  ::tendermint::abci::RequestProcessProposal* unsafe_arena_release_process_proposal();
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:tendermint.abci.Request)
 private:
  class _Internal;
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();
  void set_has_list_snapshots();
  void set_has_offer_snapshot();
  void set_has_load_snapshot_chunk();
  void set_has_apply_snapshot_chunk();
  void set_has_prepare_proposal();
  void set_has_process_proposal();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tendermint::abci::RequestEcho* echo_;
      ::tendermint::abci::RequestFlush* flush_;
      ::tendermint::abci::RequestInfo* info_;
      ::tendermint::abci::RequestInitChain* init_chain_;
      ::tendermint::abci::RequestQuery* query_;
      ::tendermint::abci::RequestBeginBlock* begin_block_;
      ::tendermint::abci::RequestCheckTx* check_tx_;
      ::tendermint::abci::RequestDeliverTx* deliver_tx_;
      ::tendermint::abci::RequestEndBlock* end_block_;
      ::tendermint::abci::RequestCommit* commit_;
      ::tendermint::abci::RequestListSnapshots* list_snapshots_;
      ::tendermint::abci::RequestOfferSnapshot* offer_snapshot_;
      ::tendermint::abci::RequestLoadSnapshotChunk* load_snapshot_chunk_;
      ::tendermint::abci::RequestApplySnapshotChunk* apply_snapshot_chunk_;
      ::tendermint::abci::RequestPrepareProposal* prepare_proposal_;
      ::tendermint::abci::RequestProcessProposal* process_proposal_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestEcho final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestEcho) */ {
 public:
  inline RequestEcho() : RequestEcho(nullptr) {}
  ~RequestEcho() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestEcho(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestEcho(const RequestEcho& from);
  RequestEcho(RequestEcho&& from) noexcept
    : RequestEcho() {
    *this = ::std::move(from);
  }

  inline RequestEcho& operator=(const RequestEcho& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestEcho& operator=(RequestEcho&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestEcho& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestEcho* internal_default_instance() {
    return reinterpret_cast<const RequestEcho*>(
               &_RequestEcho_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RequestEcho& a, RequestEcho& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestEcho* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestEcho* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestEcho* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestEcho>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestEcho& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestEcho& from) {
    RequestEcho::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestEcho* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestEcho";
  }
  protected:
  explicit RequestEcho(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestEcho)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestFlush final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestFlush) */ {
 public:
  inline RequestFlush() : RequestFlush(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestFlush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestFlush(const RequestFlush& from);
  RequestFlush(RequestFlush&& from) noexcept
    : RequestFlush() {
    *this = ::std::move(from);
  }

  inline RequestFlush& operator=(const RequestFlush& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestFlush& operator=(RequestFlush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestFlush& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestFlush* internal_default_instance() {
    return reinterpret_cast<const RequestFlush*>(
               &_RequestFlush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestFlush& a, RequestFlush& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestFlush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestFlush* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestFlush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestFlush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestFlush& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestFlush& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestFlush";
  }
  protected:
  explicit RequestFlush(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestFlush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestInfo) */ {
 public:
  inline RequestInfo() : RequestInfo(nullptr) {}
  ~RequestInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestInfo(const RequestInfo& from);
  RequestInfo(RequestInfo&& from) noexcept
    : RequestInfo() {
    *this = ::std::move(from);
  }

  inline RequestInfo& operator=(const RequestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestInfo& operator=(RequestInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestInfo* internal_default_instance() {
    return reinterpret_cast<const RequestInfo*>(
               &_RequestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestInfo& a, RequestInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestInfo& from) {
    RequestInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestInfo";
  }
  protected:
  explicit RequestInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kAbciVersionFieldNumber = 4,
    kBlockVersionFieldNumber = 2,
    kP2PVersionFieldNumber = 3,
  };
  // string version = 1 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string abci_version = 4 [json_name = "abciVersion"];
  void clear_abci_version() ;
  const std::string& abci_version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_abci_version(Arg_&& arg, Args_... args);
  std::string* mutable_abci_version();
  PROTOBUF_NODISCARD std::string* release_abci_version();
  void set_allocated_abci_version(std::string* ptr);

  private:
  const std::string& _internal_abci_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abci_version(
      const std::string& value);
  std::string* _internal_mutable_abci_version();

  public:
  // uint64 block_version = 2 [json_name = "blockVersion"];
  void clear_block_version() ;
  ::uint64_t block_version() const;
  void set_block_version(::uint64_t value);

  private:
  ::uint64_t _internal_block_version() const;
  void _internal_set_block_version(::uint64_t value);

  public:
  // uint64 p2p_version = 3 [json_name = "p2pVersion"];
  void clear_p2p_version() ;
  ::uint64_t p2p_version() const;
  void set_p2p_version(::uint64_t value);

  private:
  ::uint64_t _internal_p2p_version() const;
  void _internal_set_p2p_version(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abci_version_;
    ::uint64_t block_version_;
    ::uint64_t p2p_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestInitChain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestInitChain) */ {
 public:
  inline RequestInitChain() : RequestInitChain(nullptr) {}
  ~RequestInitChain() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestInitChain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestInitChain(const RequestInitChain& from);
  RequestInitChain(RequestInitChain&& from) noexcept
    : RequestInitChain() {
    *this = ::std::move(from);
  }

  inline RequestInitChain& operator=(const RequestInitChain& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestInitChain& operator=(RequestInitChain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestInitChain& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestInitChain* internal_default_instance() {
    return reinterpret_cast<const RequestInitChain*>(
               &_RequestInitChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestInitChain& a, RequestInitChain& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestInitChain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestInitChain* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestInitChain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestInitChain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestInitChain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestInitChain& from) {
    RequestInitChain::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestInitChain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestInitChain";
  }
  protected:
  explicit RequestInitChain(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorsFieldNumber = 4,
    kChainIdFieldNumber = 2,
    kAppStateBytesFieldNumber = 5,
    kTimeFieldNumber = 1,
    kConsensusParamsFieldNumber = 3,
    kInitialHeightFieldNumber = 6,
  };
  // repeated .tendermint.abci.ValidatorUpdate validators = 4 [json_name = "validators", (.gogoproto.nullable) = false];
  int validators_size() const;
  private:
  int _internal_validators_size() const;

  public:
  void clear_validators() ;
  ::tendermint::abci::ValidatorUpdate* mutable_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
      mutable_validators();
  private:
  const ::tendermint::abci::ValidatorUpdate& _internal_validators(int index) const;
  ::tendermint::abci::ValidatorUpdate* _internal_add_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>& _internal_validators() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>* _internal_mutable_validators();
  public:
  const ::tendermint::abci::ValidatorUpdate& validators(int index) const;
  ::tendermint::abci::ValidatorUpdate* add_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
      validators() const;
  // string chain_id = 2 [json_name = "chainId"];
  void clear_chain_id() ;
  const std::string& chain_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chain_id(Arg_&& arg, Args_... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* ptr);

  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(
      const std::string& value);
  std::string* _internal_mutable_chain_id();

  public:
  // bytes app_state_bytes = 5 [json_name = "appStateBytes"];
  void clear_app_state_bytes() ;
  const std::string& app_state_bytes() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_state_bytes(Arg_&& arg, Args_... args);
  std::string* mutable_app_state_bytes();
  PROTOBUF_NODISCARD std::string* release_app_state_bytes();
  void set_allocated_app_state_bytes(std::string* ptr);

  private:
  const std::string& _internal_app_state_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_state_bytes(
      const std::string& value);
  std::string* _internal_mutable_app_state_bytes();

  public:
  // .google.protobuf.Timestamp time = 1 [json_name = "time", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  void clear_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();
  // .tendermint.types.ConsensusParams consensus_params = 3 [json_name = "consensusParams"];
  bool has_consensus_params() const;
  void clear_consensus_params() ;
  const ::tendermint::types::ConsensusParams& consensus_params() const;
  PROTOBUF_NODISCARD ::tendermint::types::ConsensusParams* release_consensus_params();
  ::tendermint::types::ConsensusParams* mutable_consensus_params();
  void set_allocated_consensus_params(::tendermint::types::ConsensusParams* consensus_params);
  private:
  const ::tendermint::types::ConsensusParams& _internal_consensus_params() const;
  ::tendermint::types::ConsensusParams* _internal_mutable_consensus_params();
  public:
  void unsafe_arena_set_allocated_consensus_params(
      ::tendermint::types::ConsensusParams* consensus_params);
  ::tendermint::types::ConsensusParams* unsafe_arena_release_consensus_params();
  // int64 initial_height = 6 [json_name = "initialHeight"];
  void clear_initial_height() ;
  ::int64_t initial_height() const;
  void set_initial_height(::int64_t value);

  private:
  ::int64_t _internal_initial_height() const;
  void _internal_set_initial_height(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestInitChain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate > validators_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_state_bytes_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    ::tendermint::types::ConsensusParams* consensus_params_;
    ::int64_t initial_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestQuery) */ {
 public:
  inline RequestQuery() : RequestQuery(nullptr) {}
  ~RequestQuery() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestQuery(const RequestQuery& from);
  RequestQuery(RequestQuery&& from) noexcept
    : RequestQuery() {
    *this = ::std::move(from);
  }

  inline RequestQuery& operator=(const RequestQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestQuery& operator=(RequestQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestQuery* internal_default_instance() {
    return reinterpret_cast<const RequestQuery*>(
               &_RequestQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RequestQuery& a, RequestQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestQuery& from) {
    RequestQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestQuery";
  }
  protected:
  explicit RequestQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kPathFieldNumber = 2,
    kHeightFieldNumber = 3,
    kProveFieldNumber = 4,
  };
  // bytes data = 1 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string path = 2 [json_name = "path"];
  void clear_path() ;
  const std::string& path() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* ptr);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // int64 height = 3 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // bool prove = 4 [json_name = "prove"];
  void clear_prove() ;
  bool prove() const;
  void set_prove(bool value);

  private:
  bool _internal_prove() const;
  void _internal_set_prove(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::int64_t height_;
    bool prove_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestBeginBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestBeginBlock) */ {
 public:
  inline RequestBeginBlock() : RequestBeginBlock(nullptr) {}
  ~RequestBeginBlock() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestBeginBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBeginBlock(const RequestBeginBlock& from);
  RequestBeginBlock(RequestBeginBlock&& from) noexcept
    : RequestBeginBlock() {
    *this = ::std::move(from);
  }

  inline RequestBeginBlock& operator=(const RequestBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBeginBlock& operator=(RequestBeginBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBeginBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestBeginBlock* internal_default_instance() {
    return reinterpret_cast<const RequestBeginBlock*>(
               &_RequestBeginBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RequestBeginBlock& a, RequestBeginBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBeginBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBeginBlock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBeginBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBeginBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBeginBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestBeginBlock& from) {
    RequestBeginBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBeginBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestBeginBlock";
  }
  protected:
  explicit RequestBeginBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByzantineValidatorsFieldNumber = 4,
    kHashFieldNumber = 1,
    kHeaderFieldNumber = 2,
    kLastCommitInfoFieldNumber = 3,
  };
  // repeated .tendermint.abci.Misbehavior byzantine_validators = 4 [json_name = "byzantineValidators", (.gogoproto.nullable) = false];
  int byzantine_validators_size() const;
  private:
  int _internal_byzantine_validators_size() const;

  public:
  void clear_byzantine_validators() ;
  ::tendermint::abci::Misbehavior* mutable_byzantine_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >*
      mutable_byzantine_validators();
  private:
  const ::tendermint::abci::Misbehavior& _internal_byzantine_validators(int index) const;
  ::tendermint::abci::Misbehavior* _internal_add_byzantine_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>& _internal_byzantine_validators() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>* _internal_mutable_byzantine_validators();
  public:
  const ::tendermint::abci::Misbehavior& byzantine_validators(int index) const;
  ::tendermint::abci::Misbehavior* add_byzantine_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >&
      byzantine_validators() const;
  // bytes hash = 1 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // .tendermint.types.Header header = 2 [json_name = "header", (.gogoproto.nullable) = false];
  bool has_header() const;
  void clear_header() ;
  const ::tendermint::types::Header& header() const;
  PROTOBUF_NODISCARD ::tendermint::types::Header* release_header();
  ::tendermint::types::Header* mutable_header();
  void set_allocated_header(::tendermint::types::Header* header);
  private:
  const ::tendermint::types::Header& _internal_header() const;
  ::tendermint::types::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tendermint::types::Header* header);
  ::tendermint::types::Header* unsafe_arena_release_header();
  // .tendermint.abci.CommitInfo last_commit_info = 3 [json_name = "lastCommitInfo", (.gogoproto.nullable) = false];
  bool has_last_commit_info() const;
  void clear_last_commit_info() ;
  const ::tendermint::abci::CommitInfo& last_commit_info() const;
  PROTOBUF_NODISCARD ::tendermint::abci::CommitInfo* release_last_commit_info();
  ::tendermint::abci::CommitInfo* mutable_last_commit_info();
  void set_allocated_last_commit_info(::tendermint::abci::CommitInfo* last_commit_info);
  private:
  const ::tendermint::abci::CommitInfo& _internal_last_commit_info() const;
  ::tendermint::abci::CommitInfo* _internal_mutable_last_commit_info();
  public:
  void unsafe_arena_set_allocated_last_commit_info(
      ::tendermint::abci::CommitInfo* last_commit_info);
  ::tendermint::abci::CommitInfo* unsafe_arena_release_last_commit_info();
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestBeginBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior > byzantine_validators_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::tendermint::types::Header* header_;
    ::tendermint::abci::CommitInfo* last_commit_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestCheckTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestCheckTx) */ {
 public:
  inline RequestCheckTx() : RequestCheckTx(nullptr) {}
  ~RequestCheckTx() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestCheckTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestCheckTx(const RequestCheckTx& from);
  RequestCheckTx(RequestCheckTx&& from) noexcept
    : RequestCheckTx() {
    *this = ::std::move(from);
  }

  inline RequestCheckTx& operator=(const RequestCheckTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCheckTx& operator=(RequestCheckTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestCheckTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestCheckTx* internal_default_instance() {
    return reinterpret_cast<const RequestCheckTx*>(
               &_RequestCheckTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RequestCheckTx& a, RequestCheckTx& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCheckTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCheckTx* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestCheckTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestCheckTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestCheckTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestCheckTx& from) {
    RequestCheckTx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCheckTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestCheckTx";
  }
  protected:
  explicit RequestCheckTx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes tx = 1 [json_name = "tx"];
  void clear_tx() ;
  const std::string& tx() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx(Arg_&& arg, Args_... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* ptr);

  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(
      const std::string& value);
  std::string* _internal_mutable_tx();

  public:
  // .tendermint.abci.CheckTxType type = 2 [json_name = "type"];
  void clear_type() ;
  ::tendermint::abci::CheckTxType type() const;
  void set_type(::tendermint::abci::CheckTxType value);

  private:
  ::tendermint::abci::CheckTxType _internal_type() const;
  void _internal_set_type(::tendermint::abci::CheckTxType value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestCheckTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestDeliverTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestDeliverTx) */ {
 public:
  inline RequestDeliverTx() : RequestDeliverTx(nullptr) {}
  ~RequestDeliverTx() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestDeliverTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestDeliverTx(const RequestDeliverTx& from);
  RequestDeliverTx(RequestDeliverTx&& from) noexcept
    : RequestDeliverTx() {
    *this = ::std::move(from);
  }

  inline RequestDeliverTx& operator=(const RequestDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestDeliverTx& operator=(RequestDeliverTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestDeliverTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestDeliverTx* internal_default_instance() {
    return reinterpret_cast<const RequestDeliverTx*>(
               &_RequestDeliverTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RequestDeliverTx& a, RequestDeliverTx& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestDeliverTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestDeliverTx* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestDeliverTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestDeliverTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestDeliverTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestDeliverTx& from) {
    RequestDeliverTx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestDeliverTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestDeliverTx";
  }
  protected:
  explicit RequestDeliverTx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 1,
  };
  // bytes tx = 1 [json_name = "tx"];
  void clear_tx() ;
  const std::string& tx() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx(Arg_&& arg, Args_... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* ptr);

  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(
      const std::string& value);
  std::string* _internal_mutable_tx();

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestDeliverTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestEndBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestEndBlock) */ {
 public:
  inline RequestEndBlock() : RequestEndBlock(nullptr) {}
  ~RequestEndBlock() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestEndBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestEndBlock(const RequestEndBlock& from);
  RequestEndBlock(RequestEndBlock&& from) noexcept
    : RequestEndBlock() {
    *this = ::std::move(from);
  }

  inline RequestEndBlock& operator=(const RequestEndBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestEndBlock& operator=(RequestEndBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestEndBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestEndBlock* internal_default_instance() {
    return reinterpret_cast<const RequestEndBlock*>(
               &_RequestEndBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RequestEndBlock& a, RequestEndBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestEndBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestEndBlock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestEndBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestEndBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestEndBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestEndBlock& from) {
    RequestEndBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestEndBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestEndBlock";
  }
  protected:
  explicit RequestEndBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // int64 height = 1 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestEndBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestCommit final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestCommit) */ {
 public:
  inline RequestCommit() : RequestCommit(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestCommit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestCommit(const RequestCommit& from);
  RequestCommit(RequestCommit&& from) noexcept
    : RequestCommit() {
    *this = ::std::move(from);
  }

  inline RequestCommit& operator=(const RequestCommit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCommit& operator=(RequestCommit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestCommit& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestCommit* internal_default_instance() {
    return reinterpret_cast<const RequestCommit*>(
               &_RequestCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RequestCommit& a, RequestCommit& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCommit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCommit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestCommit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestCommit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestCommit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestCommit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestCommit";
  }
  protected:
  explicit RequestCommit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestCommit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestListSnapshots final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestListSnapshots) */ {
 public:
  inline RequestListSnapshots() : RequestListSnapshots(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestListSnapshots(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestListSnapshots(const RequestListSnapshots& from);
  RequestListSnapshots(RequestListSnapshots&& from) noexcept
    : RequestListSnapshots() {
    *this = ::std::move(from);
  }

  inline RequestListSnapshots& operator=(const RequestListSnapshots& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestListSnapshots& operator=(RequestListSnapshots&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestListSnapshots& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestListSnapshots* internal_default_instance() {
    return reinterpret_cast<const RequestListSnapshots*>(
               &_RequestListSnapshots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RequestListSnapshots& a, RequestListSnapshots& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestListSnapshots* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestListSnapshots* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestListSnapshots* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestListSnapshots>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestListSnapshots& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestListSnapshots& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestListSnapshots";
  }
  protected:
  explicit RequestListSnapshots(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestListSnapshots)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestOfferSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestOfferSnapshot) */ {
 public:
  inline RequestOfferSnapshot() : RequestOfferSnapshot(nullptr) {}
  ~RequestOfferSnapshot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestOfferSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestOfferSnapshot(const RequestOfferSnapshot& from);
  RequestOfferSnapshot(RequestOfferSnapshot&& from) noexcept
    : RequestOfferSnapshot() {
    *this = ::std::move(from);
  }

  inline RequestOfferSnapshot& operator=(const RequestOfferSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestOfferSnapshot& operator=(RequestOfferSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestOfferSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestOfferSnapshot* internal_default_instance() {
    return reinterpret_cast<const RequestOfferSnapshot*>(
               &_RequestOfferSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RequestOfferSnapshot& a, RequestOfferSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestOfferSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestOfferSnapshot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestOfferSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestOfferSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestOfferSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestOfferSnapshot& from) {
    RequestOfferSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestOfferSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestOfferSnapshot";
  }
  protected:
  explicit RequestOfferSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppHashFieldNumber = 2,
    kSnapshotFieldNumber = 1,
  };
  // bytes app_hash = 2 [json_name = "appHash"];
  void clear_app_hash() ;
  const std::string& app_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_hash(Arg_&& arg, Args_... args);
  std::string* mutable_app_hash();
  PROTOBUF_NODISCARD std::string* release_app_hash();
  void set_allocated_app_hash(std::string* ptr);

  private:
  const std::string& _internal_app_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_hash(
      const std::string& value);
  std::string* _internal_mutable_app_hash();

  public:
  // .tendermint.abci.Snapshot snapshot = 1 [json_name = "snapshot"];
  bool has_snapshot() const;
  void clear_snapshot() ;
  const ::tendermint::abci::Snapshot& snapshot() const;
  PROTOBUF_NODISCARD ::tendermint::abci::Snapshot* release_snapshot();
  ::tendermint::abci::Snapshot* mutable_snapshot();
  void set_allocated_snapshot(::tendermint::abci::Snapshot* snapshot);
  private:
  const ::tendermint::abci::Snapshot& _internal_snapshot() const;
  ::tendermint::abci::Snapshot* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::tendermint::abci::Snapshot* snapshot);
  ::tendermint::abci::Snapshot* unsafe_arena_release_snapshot();
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestOfferSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_hash_;
    ::tendermint::abci::Snapshot* snapshot_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestLoadSnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestLoadSnapshotChunk) */ {
 public:
  inline RequestLoadSnapshotChunk() : RequestLoadSnapshotChunk(nullptr) {}
  ~RequestLoadSnapshotChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestLoadSnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestLoadSnapshotChunk(const RequestLoadSnapshotChunk& from);
  RequestLoadSnapshotChunk(RequestLoadSnapshotChunk&& from) noexcept
    : RequestLoadSnapshotChunk() {
    *this = ::std::move(from);
  }

  inline RequestLoadSnapshotChunk& operator=(const RequestLoadSnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLoadSnapshotChunk& operator=(RequestLoadSnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestLoadSnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestLoadSnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const RequestLoadSnapshotChunk*>(
               &_RequestLoadSnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RequestLoadSnapshotChunk& a, RequestLoadSnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLoadSnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLoadSnapshotChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestLoadSnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestLoadSnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestLoadSnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestLoadSnapshotChunk& from) {
    RequestLoadSnapshotChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLoadSnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestLoadSnapshotChunk";
  }
  protected:
  explicit RequestLoadSnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
    kFormatFieldNumber = 2,
    kChunkFieldNumber = 3,
  };
  // uint64 height = 1 [json_name = "height"];
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // uint32 format = 2 [json_name = "format"];
  void clear_format() ;
  ::uint32_t format() const;
  void set_format(::uint32_t value);

  private:
  ::uint32_t _internal_format() const;
  void _internal_set_format(::uint32_t value);

  public:
  // uint32 chunk = 3 [json_name = "chunk"];
  void clear_chunk() ;
  ::uint32_t chunk() const;
  void set_chunk(::uint32_t value);

  private:
  ::uint32_t _internal_chunk() const;
  void _internal_set_chunk(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestLoadSnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t height_;
    ::uint32_t format_;
    ::uint32_t chunk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestApplySnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestApplySnapshotChunk) */ {
 public:
  inline RequestApplySnapshotChunk() : RequestApplySnapshotChunk(nullptr) {}
  ~RequestApplySnapshotChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestApplySnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestApplySnapshotChunk(const RequestApplySnapshotChunk& from);
  RequestApplySnapshotChunk(RequestApplySnapshotChunk&& from) noexcept
    : RequestApplySnapshotChunk() {
    *this = ::std::move(from);
  }

  inline RequestApplySnapshotChunk& operator=(const RequestApplySnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestApplySnapshotChunk& operator=(RequestApplySnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestApplySnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestApplySnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const RequestApplySnapshotChunk*>(
               &_RequestApplySnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RequestApplySnapshotChunk& a, RequestApplySnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestApplySnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestApplySnapshotChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestApplySnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestApplySnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestApplySnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestApplySnapshotChunk& from) {
    RequestApplySnapshotChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestApplySnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestApplySnapshotChunk";
  }
  protected:
  explicit RequestApplySnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 2,
    kSenderFieldNumber = 3,
    kIndexFieldNumber = 1,
  };
  // bytes chunk = 2 [json_name = "chunk"];
  void clear_chunk() ;
  const std::string& chunk() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chunk(Arg_&& arg, Args_... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* ptr);

  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(
      const std::string& value);
  std::string* _internal_mutable_chunk();

  public:
  // string sender = 3 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // uint32 index = 1 [json_name = "index"];
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestApplySnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestPrepareProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestPrepareProposal) */ {
 public:
  inline RequestPrepareProposal() : RequestPrepareProposal(nullptr) {}
  ~RequestPrepareProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestPrepareProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestPrepareProposal(const RequestPrepareProposal& from);
  RequestPrepareProposal(RequestPrepareProposal&& from) noexcept
    : RequestPrepareProposal() {
    *this = ::std::move(from);
  }

  inline RequestPrepareProposal& operator=(const RequestPrepareProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestPrepareProposal& operator=(RequestPrepareProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestPrepareProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestPrepareProposal* internal_default_instance() {
    return reinterpret_cast<const RequestPrepareProposal*>(
               &_RequestPrepareProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RequestPrepareProposal& a, RequestPrepareProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestPrepareProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestPrepareProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestPrepareProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestPrepareProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestPrepareProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestPrepareProposal& from) {
    RequestPrepareProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPrepareProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestPrepareProposal";
  }
  protected:
  explicit RequestPrepareProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxsFieldNumber = 2,
    kMisbehaviorFieldNumber = 4,
    kNextValidatorsHashFieldNumber = 7,
    kProposerAddressFieldNumber = 8,
    kLocalLastCommitFieldNumber = 3,
    kTimeFieldNumber = 6,
    kMaxTxBytesFieldNumber = 1,
    kHeightFieldNumber = 5,
  };
  // repeated bytes txs = 2 [json_name = "txs"];
  int txs_size() const;
  private:
  int _internal_txs_size() const;

  public:
  void clear_txs() ;
  const std::string& txs(int index) const;
  std::string* mutable_txs(int index);
  void set_txs(int index, const std::string& value);
  void set_txs(int index, std::string&& value);
  void set_txs(int index, const char* value);
  void set_txs(int index, const void* value, std::size_t size);
  void set_txs(int index, absl::string_view value);
  std::string* add_txs();
  void add_txs(const std::string& value);
  void add_txs(std::string&& value);
  void add_txs(const char* value);
  void add_txs(const void* value, std::size_t size);
  void add_txs(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txs();

  private:
  const std::string& _internal_txs(int index) const;
  std::string* _internal_add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_txs();

  public:
  // repeated .tendermint.abci.Misbehavior misbehavior = 4 [json_name = "misbehavior", (.gogoproto.nullable) = false];
  int misbehavior_size() const;
  private:
  int _internal_misbehavior_size() const;

  public:
  void clear_misbehavior() ;
  ::tendermint::abci::Misbehavior* mutable_misbehavior(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >*
      mutable_misbehavior();
  private:
  const ::tendermint::abci::Misbehavior& _internal_misbehavior(int index) const;
  ::tendermint::abci::Misbehavior* _internal_add_misbehavior();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>& _internal_misbehavior() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>* _internal_mutable_misbehavior();
  public:
  const ::tendermint::abci::Misbehavior& misbehavior(int index) const;
  ::tendermint::abci::Misbehavior* add_misbehavior();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >&
      misbehavior() const;
  // bytes next_validators_hash = 7 [json_name = "nextValidatorsHash"];
  void clear_next_validators_hash() ;
  const std::string& next_validators_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_validators_hash(Arg_&& arg, Args_... args);
  std::string* mutable_next_validators_hash();
  PROTOBUF_NODISCARD std::string* release_next_validators_hash();
  void set_allocated_next_validators_hash(std::string* ptr);

  private:
  const std::string& _internal_next_validators_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_validators_hash(
      const std::string& value);
  std::string* _internal_mutable_next_validators_hash();

  public:
  // bytes proposer_address = 8 [json_name = "proposerAddress"];
  void clear_proposer_address() ;
  const std::string& proposer_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proposer_address(Arg_&& arg, Args_... args);
  std::string* mutable_proposer_address();
  PROTOBUF_NODISCARD std::string* release_proposer_address();
  void set_allocated_proposer_address(std::string* ptr);

  private:
  const std::string& _internal_proposer_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposer_address(
      const std::string& value);
  std::string* _internal_mutable_proposer_address();

  public:
  // .tendermint.abci.ExtendedCommitInfo local_last_commit = 3 [json_name = "localLastCommit", (.gogoproto.nullable) = false];
  bool has_local_last_commit() const;
  void clear_local_last_commit() ;
  const ::tendermint::abci::ExtendedCommitInfo& local_last_commit() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ExtendedCommitInfo* release_local_last_commit();
  ::tendermint::abci::ExtendedCommitInfo* mutable_local_last_commit();
  void set_allocated_local_last_commit(::tendermint::abci::ExtendedCommitInfo* local_last_commit);
  private:
  const ::tendermint::abci::ExtendedCommitInfo& _internal_local_last_commit() const;
  ::tendermint::abci::ExtendedCommitInfo* _internal_mutable_local_last_commit();
  public:
  void unsafe_arena_set_allocated_local_last_commit(
      ::tendermint::abci::ExtendedCommitInfo* local_last_commit);
  ::tendermint::abci::ExtendedCommitInfo* unsafe_arena_release_local_last_commit();
  // .google.protobuf.Timestamp time = 6 [json_name = "time", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  void clear_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();
  // int64 max_tx_bytes = 1 [json_name = "maxTxBytes"];
  void clear_max_tx_bytes() ;
  ::int64_t max_tx_bytes() const;
  void set_max_tx_bytes(::int64_t value);

  private:
  ::int64_t _internal_max_tx_bytes() const;
  void _internal_set_max_tx_bytes(::int64_t value);

  public:
  // int64 height = 5 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestPrepareProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior > misbehavior_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_validators_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposer_address_;
    ::tendermint::abci::ExtendedCommitInfo* local_last_commit_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    ::int64_t max_tx_bytes_;
    ::int64_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class RequestProcessProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestProcessProposal) */ {
 public:
  inline RequestProcessProposal() : RequestProcessProposal(nullptr) {}
  ~RequestProcessProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestProcessProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestProcessProposal(const RequestProcessProposal& from);
  RequestProcessProposal(RequestProcessProposal&& from) noexcept
    : RequestProcessProposal() {
    *this = ::std::move(from);
  }

  inline RequestProcessProposal& operator=(const RequestProcessProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestProcessProposal& operator=(RequestProcessProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestProcessProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestProcessProposal* internal_default_instance() {
    return reinterpret_cast<const RequestProcessProposal*>(
               &_RequestProcessProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RequestProcessProposal& a, RequestProcessProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestProcessProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestProcessProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestProcessProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestProcessProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestProcessProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestProcessProposal& from) {
    RequestProcessProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestProcessProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.RequestProcessProposal";
  }
  protected:
  explicit RequestProcessProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxsFieldNumber = 1,
    kMisbehaviorFieldNumber = 3,
    kHashFieldNumber = 4,
    kNextValidatorsHashFieldNumber = 7,
    kProposerAddressFieldNumber = 8,
    kProposedLastCommitFieldNumber = 2,
    kTimeFieldNumber = 6,
    kHeightFieldNumber = 5,
  };
  // repeated bytes txs = 1 [json_name = "txs"];
  int txs_size() const;
  private:
  int _internal_txs_size() const;

  public:
  void clear_txs() ;
  const std::string& txs(int index) const;
  std::string* mutable_txs(int index);
  void set_txs(int index, const std::string& value);
  void set_txs(int index, std::string&& value);
  void set_txs(int index, const char* value);
  void set_txs(int index, const void* value, std::size_t size);
  void set_txs(int index, absl::string_view value);
  std::string* add_txs();
  void add_txs(const std::string& value);
  void add_txs(std::string&& value);
  void add_txs(const char* value);
  void add_txs(const void* value, std::size_t size);
  void add_txs(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txs();

  private:
  const std::string& _internal_txs(int index) const;
  std::string* _internal_add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_txs();

  public:
  // repeated .tendermint.abci.Misbehavior misbehavior = 3 [json_name = "misbehavior", (.gogoproto.nullable) = false];
  int misbehavior_size() const;
  private:
  int _internal_misbehavior_size() const;

  public:
  void clear_misbehavior() ;
  ::tendermint::abci::Misbehavior* mutable_misbehavior(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >*
      mutable_misbehavior();
  private:
  const ::tendermint::abci::Misbehavior& _internal_misbehavior(int index) const;
  ::tendermint::abci::Misbehavior* _internal_add_misbehavior();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>& _internal_misbehavior() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>* _internal_mutable_misbehavior();
  public:
  const ::tendermint::abci::Misbehavior& misbehavior(int index) const;
  ::tendermint::abci::Misbehavior* add_misbehavior();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >&
      misbehavior() const;
  // bytes hash = 4 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // bytes next_validators_hash = 7 [json_name = "nextValidatorsHash"];
  void clear_next_validators_hash() ;
  const std::string& next_validators_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_validators_hash(Arg_&& arg, Args_... args);
  std::string* mutable_next_validators_hash();
  PROTOBUF_NODISCARD std::string* release_next_validators_hash();
  void set_allocated_next_validators_hash(std::string* ptr);

  private:
  const std::string& _internal_next_validators_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_validators_hash(
      const std::string& value);
  std::string* _internal_mutable_next_validators_hash();

  public:
  // bytes proposer_address = 8 [json_name = "proposerAddress"];
  void clear_proposer_address() ;
  const std::string& proposer_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proposer_address(Arg_&& arg, Args_... args);
  std::string* mutable_proposer_address();
  PROTOBUF_NODISCARD std::string* release_proposer_address();
  void set_allocated_proposer_address(std::string* ptr);

  private:
  const std::string& _internal_proposer_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposer_address(
      const std::string& value);
  std::string* _internal_mutable_proposer_address();

  public:
  // .tendermint.abci.CommitInfo proposed_last_commit = 2 [json_name = "proposedLastCommit", (.gogoproto.nullable) = false];
  bool has_proposed_last_commit() const;
  void clear_proposed_last_commit() ;
  const ::tendermint::abci::CommitInfo& proposed_last_commit() const;
  PROTOBUF_NODISCARD ::tendermint::abci::CommitInfo* release_proposed_last_commit();
  ::tendermint::abci::CommitInfo* mutable_proposed_last_commit();
  void set_allocated_proposed_last_commit(::tendermint::abci::CommitInfo* proposed_last_commit);
  private:
  const ::tendermint::abci::CommitInfo& _internal_proposed_last_commit() const;
  ::tendermint::abci::CommitInfo* _internal_mutable_proposed_last_commit();
  public:
  void unsafe_arena_set_allocated_proposed_last_commit(
      ::tendermint::abci::CommitInfo* proposed_last_commit);
  ::tendermint::abci::CommitInfo* unsafe_arena_release_proposed_last_commit();
  // .google.protobuf.Timestamp time = 6 [json_name = "time", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  void clear_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();
  // int64 height = 5 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestProcessProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior > misbehavior_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_validators_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposer_address_;
    ::tendermint::abci::CommitInfo* proposed_last_commit_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    ::int64_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kException = 1,
    kEcho = 2,
    kFlush = 3,
    kInfo = 4,
    kInitChain = 6,
    kQuery = 7,
    kBeginBlock = 8,
    kCheckTx = 9,
    kDeliverTx = 10,
    kEndBlock = 11,
    kCommit = 12,
    kListSnapshots = 13,
    kOfferSnapshot = 14,
    kLoadSnapshotChunk = 15,
    kApplySnapshotChunk = 16,
    kPrepareProposal = 17,
    kProcessProposal = 18,
    VALUE_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExceptionFieldNumber = 1,
    kEchoFieldNumber = 2,
    kFlushFieldNumber = 3,
    kInfoFieldNumber = 4,
    kInitChainFieldNumber = 6,
    kQueryFieldNumber = 7,
    kBeginBlockFieldNumber = 8,
    kCheckTxFieldNumber = 9,
    kDeliverTxFieldNumber = 10,
    kEndBlockFieldNumber = 11,
    kCommitFieldNumber = 12,
    kListSnapshotsFieldNumber = 13,
    kOfferSnapshotFieldNumber = 14,
    kLoadSnapshotChunkFieldNumber = 15,
    kApplySnapshotChunkFieldNumber = 16,
    kPrepareProposalFieldNumber = 17,
    kProcessProposalFieldNumber = 18,
  };
  // .tendermint.abci.ResponseException exception = 1 [json_name = "exception"];
  bool has_exception() const;
  private:
  bool _internal_has_exception() const;

  public:
  void clear_exception() ;
  const ::tendermint::abci::ResponseException& exception() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseException* release_exception();
  ::tendermint::abci::ResponseException* mutable_exception();
  void set_allocated_exception(::tendermint::abci::ResponseException* exception);
  private:
  const ::tendermint::abci::ResponseException& _internal_exception() const;
  ::tendermint::abci::ResponseException* _internal_mutable_exception();
  public:
  void unsafe_arena_set_allocated_exception(
      ::tendermint::abci::ResponseException* exception);
  ::tendermint::abci::ResponseException* unsafe_arena_release_exception();
  // .tendermint.abci.ResponseEcho echo = 2 [json_name = "echo"];
  bool has_echo() const;
  private:
  bool _internal_has_echo() const;

  public:
  void clear_echo() ;
  const ::tendermint::abci::ResponseEcho& echo() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseEcho* release_echo();
  ::tendermint::abci::ResponseEcho* mutable_echo();
  void set_allocated_echo(::tendermint::abci::ResponseEcho* echo);
  private:
  const ::tendermint::abci::ResponseEcho& _internal_echo() const;
  ::tendermint::abci::ResponseEcho* _internal_mutable_echo();
  public:
  void unsafe_arena_set_allocated_echo(
      ::tendermint::abci::ResponseEcho* echo);
  ::tendermint::abci::ResponseEcho* unsafe_arena_release_echo();
  // .tendermint.abci.ResponseFlush flush = 3 [json_name = "flush"];
  bool has_flush() const;
  private:
  bool _internal_has_flush() const;

  public:
  void clear_flush() ;
  const ::tendermint::abci::ResponseFlush& flush() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseFlush* release_flush();
  ::tendermint::abci::ResponseFlush* mutable_flush();
  void set_allocated_flush(::tendermint::abci::ResponseFlush* flush);
  private:
  const ::tendermint::abci::ResponseFlush& _internal_flush() const;
  ::tendermint::abci::ResponseFlush* _internal_mutable_flush();
  public:
  void unsafe_arena_set_allocated_flush(
      ::tendermint::abci::ResponseFlush* flush);
  ::tendermint::abci::ResponseFlush* unsafe_arena_release_flush();
  // .tendermint.abci.ResponseInfo info = 4 [json_name = "info"];
  bool has_info() const;
  private:
  bool _internal_has_info() const;

  public:
  void clear_info() ;
  const ::tendermint::abci::ResponseInfo& info() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseInfo* release_info();
  ::tendermint::abci::ResponseInfo* mutable_info();
  void set_allocated_info(::tendermint::abci::ResponseInfo* info);
  private:
  const ::tendermint::abci::ResponseInfo& _internal_info() const;
  ::tendermint::abci::ResponseInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::tendermint::abci::ResponseInfo* info);
  ::tendermint::abci::ResponseInfo* unsafe_arena_release_info();
  // .tendermint.abci.ResponseInitChain init_chain = 6 [json_name = "initChain"];
  bool has_init_chain() const;
  private:
  bool _internal_has_init_chain() const;

  public:
  void clear_init_chain() ;
  const ::tendermint::abci::ResponseInitChain& init_chain() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseInitChain* release_init_chain();
  ::tendermint::abci::ResponseInitChain* mutable_init_chain();
  void set_allocated_init_chain(::tendermint::abci::ResponseInitChain* init_chain);
  private:
  const ::tendermint::abci::ResponseInitChain& _internal_init_chain() const;
  ::tendermint::abci::ResponseInitChain* _internal_mutable_init_chain();
  public:
  void unsafe_arena_set_allocated_init_chain(
      ::tendermint::abci::ResponseInitChain* init_chain);
  ::tendermint::abci::ResponseInitChain* unsafe_arena_release_init_chain();
  // .tendermint.abci.ResponseQuery query = 7 [json_name = "query"];
  bool has_query() const;
  private:
  bool _internal_has_query() const;

  public:
  void clear_query() ;
  const ::tendermint::abci::ResponseQuery& query() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseQuery* release_query();
  ::tendermint::abci::ResponseQuery* mutable_query();
  void set_allocated_query(::tendermint::abci::ResponseQuery* query);
  private:
  const ::tendermint::abci::ResponseQuery& _internal_query() const;
  ::tendermint::abci::ResponseQuery* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::tendermint::abci::ResponseQuery* query);
  ::tendermint::abci::ResponseQuery* unsafe_arena_release_query();
  // .tendermint.abci.ResponseBeginBlock begin_block = 8 [json_name = "beginBlock"];
  bool has_begin_block() const;
  private:
  bool _internal_has_begin_block() const;

  public:
  void clear_begin_block() ;
  const ::tendermint::abci::ResponseBeginBlock& begin_block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseBeginBlock* release_begin_block();
  ::tendermint::abci::ResponseBeginBlock* mutable_begin_block();
  void set_allocated_begin_block(::tendermint::abci::ResponseBeginBlock* begin_block);
  private:
  const ::tendermint::abci::ResponseBeginBlock& _internal_begin_block() const;
  ::tendermint::abci::ResponseBeginBlock* _internal_mutable_begin_block();
  public:
  void unsafe_arena_set_allocated_begin_block(
      ::tendermint::abci::ResponseBeginBlock* begin_block);
  ::tendermint::abci::ResponseBeginBlock* unsafe_arena_release_begin_block();
  // .tendermint.abci.ResponseCheckTx check_tx = 9 [json_name = "checkTx"];
  bool has_check_tx() const;
  private:
  bool _internal_has_check_tx() const;

  public:
  void clear_check_tx() ;
  const ::tendermint::abci::ResponseCheckTx& check_tx() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseCheckTx* release_check_tx();
  ::tendermint::abci::ResponseCheckTx* mutable_check_tx();
  void set_allocated_check_tx(::tendermint::abci::ResponseCheckTx* check_tx);
  private:
  const ::tendermint::abci::ResponseCheckTx& _internal_check_tx() const;
  ::tendermint::abci::ResponseCheckTx* _internal_mutable_check_tx();
  public:
  void unsafe_arena_set_allocated_check_tx(
      ::tendermint::abci::ResponseCheckTx* check_tx);
  ::tendermint::abci::ResponseCheckTx* unsafe_arena_release_check_tx();
  // .tendermint.abci.ResponseDeliverTx deliver_tx = 10 [json_name = "deliverTx"];
  bool has_deliver_tx() const;
  private:
  bool _internal_has_deliver_tx() const;

  public:
  void clear_deliver_tx() ;
  const ::tendermint::abci::ResponseDeliverTx& deliver_tx() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseDeliverTx* release_deliver_tx();
  ::tendermint::abci::ResponseDeliverTx* mutable_deliver_tx();
  void set_allocated_deliver_tx(::tendermint::abci::ResponseDeliverTx* deliver_tx);
  private:
  const ::tendermint::abci::ResponseDeliverTx& _internal_deliver_tx() const;
  ::tendermint::abci::ResponseDeliverTx* _internal_mutable_deliver_tx();
  public:
  void unsafe_arena_set_allocated_deliver_tx(
      ::tendermint::abci::ResponseDeliverTx* deliver_tx);
  ::tendermint::abci::ResponseDeliverTx* unsafe_arena_release_deliver_tx();
  // .tendermint.abci.ResponseEndBlock end_block = 11 [json_name = "endBlock"];
  bool has_end_block() const;
  private:
  bool _internal_has_end_block() const;

  public:
  void clear_end_block() ;
  const ::tendermint::abci::ResponseEndBlock& end_block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseEndBlock* release_end_block();
  ::tendermint::abci::ResponseEndBlock* mutable_end_block();
  void set_allocated_end_block(::tendermint::abci::ResponseEndBlock* end_block);
  private:
  const ::tendermint::abci::ResponseEndBlock& _internal_end_block() const;
  ::tendermint::abci::ResponseEndBlock* _internal_mutable_end_block();
  public:
  void unsafe_arena_set_allocated_end_block(
      ::tendermint::abci::ResponseEndBlock* end_block);
  ::tendermint::abci::ResponseEndBlock* unsafe_arena_release_end_block();
  // .tendermint.abci.ResponseCommit commit = 12 [json_name = "commit"];
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;

  public:
  void clear_commit() ;
  const ::tendermint::abci::ResponseCommit& commit() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseCommit* release_commit();
  ::tendermint::abci::ResponseCommit* mutable_commit();
  void set_allocated_commit(::tendermint::abci::ResponseCommit* commit);
  private:
  const ::tendermint::abci::ResponseCommit& _internal_commit() const;
  ::tendermint::abci::ResponseCommit* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::tendermint::abci::ResponseCommit* commit);
  ::tendermint::abci::ResponseCommit* unsafe_arena_release_commit();
  // .tendermint.abci.ResponseListSnapshots list_snapshots = 13 [json_name = "listSnapshots"];
  bool has_list_snapshots() const;
  private:
  bool _internal_has_list_snapshots() const;

  public:
  void clear_list_snapshots() ;
  const ::tendermint::abci::ResponseListSnapshots& list_snapshots() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseListSnapshots* release_list_snapshots();
  ::tendermint::abci::ResponseListSnapshots* mutable_list_snapshots();
  void set_allocated_list_snapshots(::tendermint::abci::ResponseListSnapshots* list_snapshots);
  private:
  const ::tendermint::abci::ResponseListSnapshots& _internal_list_snapshots() const;
  ::tendermint::abci::ResponseListSnapshots* _internal_mutable_list_snapshots();
  public:
  void unsafe_arena_set_allocated_list_snapshots(
      ::tendermint::abci::ResponseListSnapshots* list_snapshots);
  ::tendermint::abci::ResponseListSnapshots* unsafe_arena_release_list_snapshots();
  // .tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14 [json_name = "offerSnapshot"];
  bool has_offer_snapshot() const;
  private:
  bool _internal_has_offer_snapshot() const;

  public:
  void clear_offer_snapshot() ;
  const ::tendermint::abci::ResponseOfferSnapshot& offer_snapshot() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseOfferSnapshot* release_offer_snapshot();
  ::tendermint::abci::ResponseOfferSnapshot* mutable_offer_snapshot();
  void set_allocated_offer_snapshot(::tendermint::abci::ResponseOfferSnapshot* offer_snapshot);
  private:
  const ::tendermint::abci::ResponseOfferSnapshot& _internal_offer_snapshot() const;
  ::tendermint::abci::ResponseOfferSnapshot* _internal_mutable_offer_snapshot();
  public:
  void unsafe_arena_set_allocated_offer_snapshot(
      ::tendermint::abci::ResponseOfferSnapshot* offer_snapshot);
  ::tendermint::abci::ResponseOfferSnapshot* unsafe_arena_release_offer_snapshot();
  // .tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15 [json_name = "loadSnapshotChunk"];
  bool has_load_snapshot_chunk() const;
  private:
  bool _internal_has_load_snapshot_chunk() const;

  public:
  void clear_load_snapshot_chunk() ;
  const ::tendermint::abci::ResponseLoadSnapshotChunk& load_snapshot_chunk() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseLoadSnapshotChunk* release_load_snapshot_chunk();
  ::tendermint::abci::ResponseLoadSnapshotChunk* mutable_load_snapshot_chunk();
  void set_allocated_load_snapshot_chunk(::tendermint::abci::ResponseLoadSnapshotChunk* load_snapshot_chunk);
  private:
  const ::tendermint::abci::ResponseLoadSnapshotChunk& _internal_load_snapshot_chunk() const;
  ::tendermint::abci::ResponseLoadSnapshotChunk* _internal_mutable_load_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_load_snapshot_chunk(
      ::tendermint::abci::ResponseLoadSnapshotChunk* load_snapshot_chunk);
  ::tendermint::abci::ResponseLoadSnapshotChunk* unsafe_arena_release_load_snapshot_chunk();
  // .tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16 [json_name = "applySnapshotChunk"];
  bool has_apply_snapshot_chunk() const;
  private:
  bool _internal_has_apply_snapshot_chunk() const;

  public:
  void clear_apply_snapshot_chunk() ;
  const ::tendermint::abci::ResponseApplySnapshotChunk& apply_snapshot_chunk() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseApplySnapshotChunk* release_apply_snapshot_chunk();
  ::tendermint::abci::ResponseApplySnapshotChunk* mutable_apply_snapshot_chunk();
  void set_allocated_apply_snapshot_chunk(::tendermint::abci::ResponseApplySnapshotChunk* apply_snapshot_chunk);
  private:
  const ::tendermint::abci::ResponseApplySnapshotChunk& _internal_apply_snapshot_chunk() const;
  ::tendermint::abci::ResponseApplySnapshotChunk* _internal_mutable_apply_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_apply_snapshot_chunk(
      ::tendermint::abci::ResponseApplySnapshotChunk* apply_snapshot_chunk);
  ::tendermint::abci::ResponseApplySnapshotChunk* unsafe_arena_release_apply_snapshot_chunk();
  // .tendermint.abci.ResponsePrepareProposal prepare_proposal = 17 [json_name = "prepareProposal"];
  bool has_prepare_proposal() const;
  private:
  bool _internal_has_prepare_proposal() const;

  public:
  void clear_prepare_proposal() ;
  const ::tendermint::abci::ResponsePrepareProposal& prepare_proposal() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponsePrepareProposal* release_prepare_proposal();
  ::tendermint::abci::ResponsePrepareProposal* mutable_prepare_proposal();
  void set_allocated_prepare_proposal(::tendermint::abci::ResponsePrepareProposal* prepare_proposal);
  private:
  const ::tendermint::abci::ResponsePrepareProposal& _internal_prepare_proposal() const;
  ::tendermint::abci::ResponsePrepareProposal* _internal_mutable_prepare_proposal();
  public:
  void unsafe_arena_set_allocated_prepare_proposal(
      ::tendermint::abci::ResponsePrepareProposal* prepare_proposal);
  ::tendermint::abci::ResponsePrepareProposal* unsafe_arena_release_prepare_proposal();
  // .tendermint.abci.ResponseProcessProposal process_proposal = 18 [json_name = "processProposal"];
  bool has_process_proposal() const;
  private:
  bool _internal_has_process_proposal() const;

  public:
  void clear_process_proposal() ;
  const ::tendermint::abci::ResponseProcessProposal& process_proposal() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseProcessProposal* release_process_proposal();
  ::tendermint::abci::ResponseProcessProposal* mutable_process_proposal();
  void set_allocated_process_proposal(::tendermint::abci::ResponseProcessProposal* process_proposal);
  private:
  const ::tendermint::abci::ResponseProcessProposal& _internal_process_proposal() const;
  ::tendermint::abci::ResponseProcessProposal* _internal_mutable_process_proposal();
  public:
  void unsafe_arena_set_allocated_process_proposal(
      ::tendermint::abci::ResponseProcessProposal* process_proposal);
  ::tendermint::abci::ResponseProcessProposal* unsafe_arena_release_process_proposal();
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:tendermint.abci.Response)
 private:
  class _Internal;
  void set_has_exception();
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();
  void set_has_list_snapshots();
  void set_has_offer_snapshot();
  void set_has_load_snapshot_chunk();
  void set_has_apply_snapshot_chunk();
  void set_has_prepare_proposal();
  void set_has_process_proposal();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tendermint::abci::ResponseException* exception_;
      ::tendermint::abci::ResponseEcho* echo_;
      ::tendermint::abci::ResponseFlush* flush_;
      ::tendermint::abci::ResponseInfo* info_;
      ::tendermint::abci::ResponseInitChain* init_chain_;
      ::tendermint::abci::ResponseQuery* query_;
      ::tendermint::abci::ResponseBeginBlock* begin_block_;
      ::tendermint::abci::ResponseCheckTx* check_tx_;
      ::tendermint::abci::ResponseDeliverTx* deliver_tx_;
      ::tendermint::abci::ResponseEndBlock* end_block_;
      ::tendermint::abci::ResponseCommit* commit_;
      ::tendermint::abci::ResponseListSnapshots* list_snapshots_;
      ::tendermint::abci::ResponseOfferSnapshot* offer_snapshot_;
      ::tendermint::abci::ResponseLoadSnapshotChunk* load_snapshot_chunk_;
      ::tendermint::abci::ResponseApplySnapshotChunk* apply_snapshot_chunk_;
      ::tendermint::abci::ResponsePrepareProposal* prepare_proposal_;
      ::tendermint::abci::ResponseProcessProposal* process_proposal_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseException final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseException) */ {
 public:
  inline ResponseException() : ResponseException(nullptr) {}
  ~ResponseException() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseException(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseException(const ResponseException& from);
  ResponseException(ResponseException&& from) noexcept
    : ResponseException() {
    *this = ::std::move(from);
  }

  inline ResponseException& operator=(const ResponseException& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseException& operator=(ResponseException&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseException& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseException* internal_default_instance() {
    return reinterpret_cast<const ResponseException*>(
               &_ResponseException_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ResponseException& a, ResponseException& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseException* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseException* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseException* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseException>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseException& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseException& from) {
    ResponseException::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseException* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseException";
  }
  protected:
  explicit ResponseException(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1 [json_name = "error"];
  void clear_error() ;
  const std::string& error() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* ptr);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseException)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseEcho final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseEcho) */ {
 public:
  inline ResponseEcho() : ResponseEcho(nullptr) {}
  ~ResponseEcho() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseEcho(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseEcho(const ResponseEcho& from);
  ResponseEcho(ResponseEcho&& from) noexcept
    : ResponseEcho() {
    *this = ::std::move(from);
  }

  inline ResponseEcho& operator=(const ResponseEcho& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseEcho& operator=(ResponseEcho&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseEcho& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseEcho* internal_default_instance() {
    return reinterpret_cast<const ResponseEcho*>(
               &_ResponseEcho_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResponseEcho& a, ResponseEcho& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseEcho* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseEcho* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseEcho* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseEcho>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseEcho& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseEcho& from) {
    ResponseEcho::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseEcho* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseEcho";
  }
  protected:
  explicit ResponseEcho(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseEcho)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseFlush final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseFlush) */ {
 public:
  inline ResponseFlush() : ResponseFlush(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseFlush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseFlush(const ResponseFlush& from);
  ResponseFlush(ResponseFlush&& from) noexcept
    : ResponseFlush() {
    *this = ::std::move(from);
  }

  inline ResponseFlush& operator=(const ResponseFlush& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseFlush& operator=(ResponseFlush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseFlush& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseFlush* internal_default_instance() {
    return reinterpret_cast<const ResponseFlush*>(
               &_ResponseFlush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ResponseFlush& a, ResponseFlush& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseFlush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseFlush* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseFlush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseFlush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResponseFlush& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResponseFlush& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseFlush";
  }
  protected:
  explicit ResponseFlush(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseFlush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseInfo) */ {
 public:
  inline ResponseInfo() : ResponseInfo(nullptr) {}
  ~ResponseInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseInfo(const ResponseInfo& from);
  ResponseInfo(ResponseInfo&& from) noexcept
    : ResponseInfo() {
    *this = ::std::move(from);
  }

  inline ResponseInfo& operator=(const ResponseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseInfo& operator=(ResponseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseInfo*>(
               &_ResponseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ResponseInfo& a, ResponseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseInfo& from) {
    ResponseInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseInfo";
  }
  protected:
  explicit ResponseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kVersionFieldNumber = 2,
    kLastBlockAppHashFieldNumber = 5,
    kAppVersionFieldNumber = 3,
    kLastBlockHeightFieldNumber = 4,
  };
  // string data = 1 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string version = 2 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // bytes last_block_app_hash = 5 [json_name = "lastBlockAppHash"];
  void clear_last_block_app_hash() ;
  const std::string& last_block_app_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_block_app_hash(Arg_&& arg, Args_... args);
  std::string* mutable_last_block_app_hash();
  PROTOBUF_NODISCARD std::string* release_last_block_app_hash();
  void set_allocated_last_block_app_hash(std::string* ptr);

  private:
  const std::string& _internal_last_block_app_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_block_app_hash(
      const std::string& value);
  std::string* _internal_mutable_last_block_app_hash();

  public:
  // uint64 app_version = 3 [json_name = "appVersion"];
  void clear_app_version() ;
  ::uint64_t app_version() const;
  void set_app_version(::uint64_t value);

  private:
  ::uint64_t _internal_app_version() const;
  void _internal_set_app_version(::uint64_t value);

  public:
  // int64 last_block_height = 4 [json_name = "lastBlockHeight"];
  void clear_last_block_height() ;
  ::int64_t last_block_height() const;
  void set_last_block_height(::int64_t value);

  private:
  ::int64_t _internal_last_block_height() const;
  void _internal_set_last_block_height(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_block_app_hash_;
    ::uint64_t app_version_;
    ::int64_t last_block_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseInitChain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseInitChain) */ {
 public:
  inline ResponseInitChain() : ResponseInitChain(nullptr) {}
  ~ResponseInitChain() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseInitChain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseInitChain(const ResponseInitChain& from);
  ResponseInitChain(ResponseInitChain&& from) noexcept
    : ResponseInitChain() {
    *this = ::std::move(from);
  }

  inline ResponseInitChain& operator=(const ResponseInitChain& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseInitChain& operator=(ResponseInitChain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseInitChain& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseInitChain* internal_default_instance() {
    return reinterpret_cast<const ResponseInitChain*>(
               &_ResponseInitChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ResponseInitChain& a, ResponseInitChain& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseInitChain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseInitChain* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseInitChain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseInitChain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseInitChain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseInitChain& from) {
    ResponseInitChain::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseInitChain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseInitChain";
  }
  protected:
  explicit ResponseInitChain(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorsFieldNumber = 2,
    kAppHashFieldNumber = 3,
    kConsensusParamsFieldNumber = 1,
  };
  // repeated .tendermint.abci.ValidatorUpdate validators = 2 [json_name = "validators", (.gogoproto.nullable) = false];
  int validators_size() const;
  private:
  int _internal_validators_size() const;

  public:
  void clear_validators() ;
  ::tendermint::abci::ValidatorUpdate* mutable_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
      mutable_validators();
  private:
  const ::tendermint::abci::ValidatorUpdate& _internal_validators(int index) const;
  ::tendermint::abci::ValidatorUpdate* _internal_add_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>& _internal_validators() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>* _internal_mutable_validators();
  public:
  const ::tendermint::abci::ValidatorUpdate& validators(int index) const;
  ::tendermint::abci::ValidatorUpdate* add_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
      validators() const;
  // bytes app_hash = 3 [json_name = "appHash"];
  void clear_app_hash() ;
  const std::string& app_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_hash(Arg_&& arg, Args_... args);
  std::string* mutable_app_hash();
  PROTOBUF_NODISCARD std::string* release_app_hash();
  void set_allocated_app_hash(std::string* ptr);

  private:
  const std::string& _internal_app_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_hash(
      const std::string& value);
  std::string* _internal_mutable_app_hash();

  public:
  // .tendermint.types.ConsensusParams consensus_params = 1 [json_name = "consensusParams"];
  bool has_consensus_params() const;
  void clear_consensus_params() ;
  const ::tendermint::types::ConsensusParams& consensus_params() const;
  PROTOBUF_NODISCARD ::tendermint::types::ConsensusParams* release_consensus_params();
  ::tendermint::types::ConsensusParams* mutable_consensus_params();
  void set_allocated_consensus_params(::tendermint::types::ConsensusParams* consensus_params);
  private:
  const ::tendermint::types::ConsensusParams& _internal_consensus_params() const;
  ::tendermint::types::ConsensusParams* _internal_mutable_consensus_params();
  public:
  void unsafe_arena_set_allocated_consensus_params(
      ::tendermint::types::ConsensusParams* consensus_params);
  ::tendermint::types::ConsensusParams* unsafe_arena_release_consensus_params();
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseInitChain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate > validators_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_hash_;
    ::tendermint::types::ConsensusParams* consensus_params_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseQuery) */ {
 public:
  inline ResponseQuery() : ResponseQuery(nullptr) {}
  ~ResponseQuery() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseQuery(const ResponseQuery& from);
  ResponseQuery(ResponseQuery&& from) noexcept
    : ResponseQuery() {
    *this = ::std::move(from);
  }

  inline ResponseQuery& operator=(const ResponseQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseQuery& operator=(ResponseQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseQuery* internal_default_instance() {
    return reinterpret_cast<const ResponseQuery*>(
               &_ResponseQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ResponseQuery& a, ResponseQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseQuery& from) {
    ResponseQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseQuery";
  }
  protected:
  explicit ResponseQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogFieldNumber = 3,
    kInfoFieldNumber = 4,
    kKeyFieldNumber = 6,
    kValueFieldNumber = 7,
    kCodespaceFieldNumber = 10,
    kProofOpsFieldNumber = 8,
    kIndexFieldNumber = 5,
    kHeightFieldNumber = 9,
    kCodeFieldNumber = 1,
  };
  // string log = 3 [json_name = "log"];
  void clear_log() ;
  const std::string& log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log(Arg_&& arg, Args_... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* ptr);

  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(
      const std::string& value);
  std::string* _internal_mutable_log();

  public:
  // string info = 4 [json_name = "info"];
  void clear_info() ;
  const std::string& info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_info(Arg_&& arg, Args_... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* ptr);

  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(
      const std::string& value);
  std::string* _internal_mutable_info();

  public:
  // bytes key = 6 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 7 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // string codespace = 10 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // .tendermint.crypto.ProofOps proof_ops = 8 [json_name = "proofOps"];
  bool has_proof_ops() const;
  void clear_proof_ops() ;
  const ::tendermint::crypto::ProofOps& proof_ops() const;
  PROTOBUF_NODISCARD ::tendermint::crypto::ProofOps* release_proof_ops();
  ::tendermint::crypto::ProofOps* mutable_proof_ops();
  void set_allocated_proof_ops(::tendermint::crypto::ProofOps* proof_ops);
  private:
  const ::tendermint::crypto::ProofOps& _internal_proof_ops() const;
  ::tendermint::crypto::ProofOps* _internal_mutable_proof_ops();
  public:
  void unsafe_arena_set_allocated_proof_ops(
      ::tendermint::crypto::ProofOps* proof_ops);
  ::tendermint::crypto::ProofOps* unsafe_arena_release_proof_ops();
  // int64 index = 5 [json_name = "index"];
  void clear_index() ;
  ::int64_t index() const;
  void set_index(::int64_t value);

  private:
  ::int64_t _internal_index() const;
  void _internal_set_index(::int64_t value);

  public:
  // int64 height = 9 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // uint32 code = 1 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::tendermint::crypto::ProofOps* proof_ops_;
    ::int64_t index_;
    ::int64_t height_;
    ::uint32_t code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseBeginBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseBeginBlock) */ {
 public:
  inline ResponseBeginBlock() : ResponseBeginBlock(nullptr) {}
  ~ResponseBeginBlock() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseBeginBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseBeginBlock(const ResponseBeginBlock& from);
  ResponseBeginBlock(ResponseBeginBlock&& from) noexcept
    : ResponseBeginBlock() {
    *this = ::std::move(from);
  }

  inline ResponseBeginBlock& operator=(const ResponseBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseBeginBlock& operator=(ResponseBeginBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseBeginBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseBeginBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseBeginBlock*>(
               &_ResponseBeginBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ResponseBeginBlock& a, ResponseBeginBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseBeginBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseBeginBlock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseBeginBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseBeginBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseBeginBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseBeginBlock& from) {
    ResponseBeginBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseBeginBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseBeginBlock";
  }
  protected:
  explicit ResponseBeginBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
  };
  // repeated .tendermint.abci.Event events = 1 [json_name = "events", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::tendermint::abci::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
      mutable_events();
  private:
  const ::tendermint::abci::Event& _internal_events(int index) const;
  ::tendermint::abci::Event* _internal_add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>& _internal_events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>* _internal_mutable_events();
  public:
  const ::tendermint::abci::Event& events(int index) const;
  ::tendermint::abci::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
      events() const;
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseBeginBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event > events_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseCheckTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseCheckTx) */ {
 public:
  inline ResponseCheckTx() : ResponseCheckTx(nullptr) {}
  ~ResponseCheckTx() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseCheckTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseCheckTx(const ResponseCheckTx& from);
  ResponseCheckTx(ResponseCheckTx&& from) noexcept
    : ResponseCheckTx() {
    *this = ::std::move(from);
  }

  inline ResponseCheckTx& operator=(const ResponseCheckTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseCheckTx& operator=(ResponseCheckTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseCheckTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseCheckTx* internal_default_instance() {
    return reinterpret_cast<const ResponseCheckTx*>(
               &_ResponseCheckTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ResponseCheckTx& a, ResponseCheckTx& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseCheckTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseCheckTx* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseCheckTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseCheckTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseCheckTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseCheckTx& from) {
    ResponseCheckTx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCheckTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseCheckTx";
  }
  protected:
  explicit ResponseCheckTx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 7,
    kDataFieldNumber = 2,
    kLogFieldNumber = 3,
    kInfoFieldNumber = 4,
    kCodespaceFieldNumber = 8,
    kSenderFieldNumber = 9,
    kMempoolErrorFieldNumber = 11,
    kGasWantedFieldNumber = 5,
    kGasUsedFieldNumber = 6,
    kPriorityFieldNumber = 10,
    kCodeFieldNumber = 1,
  };
  // repeated .tendermint.abci.Event events = 7 [json_name = "events", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::tendermint::abci::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
      mutable_events();
  private:
  const ::tendermint::abci::Event& _internal_events(int index) const;
  ::tendermint::abci::Event* _internal_add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>& _internal_events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>* _internal_mutable_events();
  public:
  const ::tendermint::abci::Event& events(int index) const;
  ::tendermint::abci::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
      events() const;
  // bytes data = 2 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string log = 3 [json_name = "log"];
  void clear_log() ;
  const std::string& log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log(Arg_&& arg, Args_... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* ptr);

  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(
      const std::string& value);
  std::string* _internal_mutable_log();

  public:
  // string info = 4 [json_name = "info"];
  void clear_info() ;
  const std::string& info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_info(Arg_&& arg, Args_... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* ptr);

  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(
      const std::string& value);
  std::string* _internal_mutable_info();

  public:
  // string codespace = 8 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // string sender = 9 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string mempool_error = 11 [json_name = "mempoolError"];
  void clear_mempool_error() ;
  const std::string& mempool_error() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mempool_error(Arg_&& arg, Args_... args);
  std::string* mutable_mempool_error();
  PROTOBUF_NODISCARD std::string* release_mempool_error();
  void set_allocated_mempool_error(std::string* ptr);

  private:
  const std::string& _internal_mempool_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mempool_error(
      const std::string& value);
  std::string* _internal_mutable_mempool_error();

  public:
  // int64 gas_wanted = 5 [json_name = "gas_wanted"];
  void clear_gas_wanted() ;
  ::int64_t gas_wanted() const;
  void set_gas_wanted(::int64_t value);

  private:
  ::int64_t _internal_gas_wanted() const;
  void _internal_set_gas_wanted(::int64_t value);

  public:
  // int64 gas_used = 6 [json_name = "gas_used"];
  void clear_gas_used() ;
  ::int64_t gas_used() const;
  void set_gas_used(::int64_t value);

  private:
  ::int64_t _internal_gas_used() const;
  void _internal_set_gas_used(::int64_t value);

  public:
  // int64 priority = 10 [json_name = "priority"];
  void clear_priority() ;
  ::int64_t priority() const;
  void set_priority(::int64_t value);

  private:
  ::int64_t _internal_priority() const;
  void _internal_set_priority(::int64_t value);

  public:
  // uint32 code = 1 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseCheckTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mempool_error_;
    ::int64_t gas_wanted_;
    ::int64_t gas_used_;
    ::int64_t priority_;
    ::uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseDeliverTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseDeliverTx) */ {
 public:
  inline ResponseDeliverTx() : ResponseDeliverTx(nullptr) {}
  ~ResponseDeliverTx() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseDeliverTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseDeliverTx(const ResponseDeliverTx& from);
  ResponseDeliverTx(ResponseDeliverTx&& from) noexcept
    : ResponseDeliverTx() {
    *this = ::std::move(from);
  }

  inline ResponseDeliverTx& operator=(const ResponseDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseDeliverTx& operator=(ResponseDeliverTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseDeliverTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseDeliverTx* internal_default_instance() {
    return reinterpret_cast<const ResponseDeliverTx*>(
               &_ResponseDeliverTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResponseDeliverTx& a, ResponseDeliverTx& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseDeliverTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseDeliverTx* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseDeliverTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseDeliverTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseDeliverTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseDeliverTx& from) {
    ResponseDeliverTx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDeliverTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseDeliverTx";
  }
  protected:
  explicit ResponseDeliverTx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 7,
    kDataFieldNumber = 2,
    kLogFieldNumber = 3,
    kInfoFieldNumber = 4,
    kCodespaceFieldNumber = 8,
    kGasWantedFieldNumber = 5,
    kGasUsedFieldNumber = 6,
    kCodeFieldNumber = 1,
  };
  // repeated .tendermint.abci.Event events = 7 [json_name = "events", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::tendermint::abci::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
      mutable_events();
  private:
  const ::tendermint::abci::Event& _internal_events(int index) const;
  ::tendermint::abci::Event* _internal_add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>& _internal_events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>* _internal_mutable_events();
  public:
  const ::tendermint::abci::Event& events(int index) const;
  ::tendermint::abci::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
      events() const;
  // bytes data = 2 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string log = 3 [json_name = "log"];
  void clear_log() ;
  const std::string& log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log(Arg_&& arg, Args_... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* ptr);

  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(
      const std::string& value);
  std::string* _internal_mutable_log();

  public:
  // string info = 4 [json_name = "info"];
  void clear_info() ;
  const std::string& info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_info(Arg_&& arg, Args_... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* ptr);

  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(
      const std::string& value);
  std::string* _internal_mutable_info();

  public:
  // string codespace = 8 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // int64 gas_wanted = 5 [json_name = "gas_wanted"];
  void clear_gas_wanted() ;
  ::int64_t gas_wanted() const;
  void set_gas_wanted(::int64_t value);

  private:
  ::int64_t _internal_gas_wanted() const;
  void _internal_set_gas_wanted(::int64_t value);

  public:
  // int64 gas_used = 6 [json_name = "gas_used"];
  void clear_gas_used() ;
  ::int64_t gas_used() const;
  void set_gas_used(::int64_t value);

  private:
  ::int64_t _internal_gas_used() const;
  void _internal_set_gas_used(::int64_t value);

  public:
  // uint32 code = 1 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseDeliverTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::int64_t gas_wanted_;
    ::int64_t gas_used_;
    ::uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseEndBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseEndBlock) */ {
 public:
  inline ResponseEndBlock() : ResponseEndBlock(nullptr) {}
  ~ResponseEndBlock() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseEndBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseEndBlock(const ResponseEndBlock& from);
  ResponseEndBlock(ResponseEndBlock&& from) noexcept
    : ResponseEndBlock() {
    *this = ::std::move(from);
  }

  inline ResponseEndBlock& operator=(const ResponseEndBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseEndBlock& operator=(ResponseEndBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseEndBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseEndBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseEndBlock*>(
               &_ResponseEndBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ResponseEndBlock& a, ResponseEndBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseEndBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseEndBlock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseEndBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseEndBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseEndBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseEndBlock& from) {
    ResponseEndBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseEndBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseEndBlock";
  }
  protected:
  explicit ResponseEndBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorUpdatesFieldNumber = 1,
    kEventsFieldNumber = 3,
    kConsensusParamUpdatesFieldNumber = 2,
  };
  // repeated .tendermint.abci.ValidatorUpdate validator_updates = 1 [json_name = "validatorUpdates", (.gogoproto.nullable) = false];
  int validator_updates_size() const;
  private:
  int _internal_validator_updates_size() const;

  public:
  void clear_validator_updates() ;
  ::tendermint::abci::ValidatorUpdate* mutable_validator_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
      mutable_validator_updates();
  private:
  const ::tendermint::abci::ValidatorUpdate& _internal_validator_updates(int index) const;
  ::tendermint::abci::ValidatorUpdate* _internal_add_validator_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>& _internal_validator_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>* _internal_mutable_validator_updates();
  public:
  const ::tendermint::abci::ValidatorUpdate& validator_updates(int index) const;
  ::tendermint::abci::ValidatorUpdate* add_validator_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
      validator_updates() const;
  // repeated .tendermint.abci.Event events = 3 [json_name = "events", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::tendermint::abci::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
      mutable_events();
  private:
  const ::tendermint::abci::Event& _internal_events(int index) const;
  ::tendermint::abci::Event* _internal_add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>& _internal_events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>* _internal_mutable_events();
  public:
  const ::tendermint::abci::Event& events(int index) const;
  ::tendermint::abci::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
      events() const;
  // .tendermint.types.ConsensusParams consensus_param_updates = 2 [json_name = "consensusParamUpdates"];
  bool has_consensus_param_updates() const;
  void clear_consensus_param_updates() ;
  const ::tendermint::types::ConsensusParams& consensus_param_updates() const;
  PROTOBUF_NODISCARD ::tendermint::types::ConsensusParams* release_consensus_param_updates();
  ::tendermint::types::ConsensusParams* mutable_consensus_param_updates();
  void set_allocated_consensus_param_updates(::tendermint::types::ConsensusParams* consensus_param_updates);
  private:
  const ::tendermint::types::ConsensusParams& _internal_consensus_param_updates() const;
  ::tendermint::types::ConsensusParams* _internal_mutable_consensus_param_updates();
  public:
  void unsafe_arena_set_allocated_consensus_param_updates(
      ::tendermint::types::ConsensusParams* consensus_param_updates);
  ::tendermint::types::ConsensusParams* unsafe_arena_release_consensus_param_updates();
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseEndBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate > validator_updates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event > events_;
    ::tendermint::types::ConsensusParams* consensus_param_updates_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseCommit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseCommit) */ {
 public:
  inline ResponseCommit() : ResponseCommit(nullptr) {}
  ~ResponseCommit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseCommit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseCommit(const ResponseCommit& from);
  ResponseCommit(ResponseCommit&& from) noexcept
    : ResponseCommit() {
    *this = ::std::move(from);
  }

  inline ResponseCommit& operator=(const ResponseCommit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseCommit& operator=(ResponseCommit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseCommit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseCommit* internal_default_instance() {
    return reinterpret_cast<const ResponseCommit*>(
               &_ResponseCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ResponseCommit& a, ResponseCommit& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseCommit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseCommit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseCommit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseCommit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseCommit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseCommit& from) {
    ResponseCommit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCommit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseCommit";
  }
  protected:
  explicit ResponseCommit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kRetainHeightFieldNumber = 3,
  };
  // bytes data = 2 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int64 retain_height = 3 [json_name = "retainHeight"];
  void clear_retain_height() ;
  ::int64_t retain_height() const;
  void set_retain_height(::int64_t value);

  private:
  ::int64_t _internal_retain_height() const;
  void _internal_set_retain_height(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseCommit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::int64_t retain_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseListSnapshots final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseListSnapshots) */ {
 public:
  inline ResponseListSnapshots() : ResponseListSnapshots(nullptr) {}
  ~ResponseListSnapshots() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseListSnapshots(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseListSnapshots(const ResponseListSnapshots& from);
  ResponseListSnapshots(ResponseListSnapshots&& from) noexcept
    : ResponseListSnapshots() {
    *this = ::std::move(from);
  }

  inline ResponseListSnapshots& operator=(const ResponseListSnapshots& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseListSnapshots& operator=(ResponseListSnapshots&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseListSnapshots& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseListSnapshots* internal_default_instance() {
    return reinterpret_cast<const ResponseListSnapshots*>(
               &_ResponseListSnapshots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ResponseListSnapshots& a, ResponseListSnapshots& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseListSnapshots* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseListSnapshots* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseListSnapshots* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseListSnapshots>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseListSnapshots& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseListSnapshots& from) {
    ResponseListSnapshots::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseListSnapshots* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseListSnapshots";
  }
  protected:
  explicit ResponseListSnapshots(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotsFieldNumber = 1,
  };
  // repeated .tendermint.abci.Snapshot snapshots = 1 [json_name = "snapshots"];
  int snapshots_size() const;
  private:
  int _internal_snapshots_size() const;

  public:
  void clear_snapshots() ;
  ::tendermint::abci::Snapshot* mutable_snapshots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot >*
      mutable_snapshots();
  private:
  const ::tendermint::abci::Snapshot& _internal_snapshots(int index) const;
  ::tendermint::abci::Snapshot* _internal_add_snapshots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Snapshot>& _internal_snapshots() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Snapshot>* _internal_mutable_snapshots();
  public:
  const ::tendermint::abci::Snapshot& snapshots(int index) const;
  ::tendermint::abci::Snapshot* add_snapshots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot >&
      snapshots() const;
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseListSnapshots)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot > snapshots_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseOfferSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseOfferSnapshot) */ {
 public:
  inline ResponseOfferSnapshot() : ResponseOfferSnapshot(nullptr) {}
  ~ResponseOfferSnapshot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseOfferSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseOfferSnapshot(const ResponseOfferSnapshot& from);
  ResponseOfferSnapshot(ResponseOfferSnapshot&& from) noexcept
    : ResponseOfferSnapshot() {
    *this = ::std::move(from);
  }

  inline ResponseOfferSnapshot& operator=(const ResponseOfferSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseOfferSnapshot& operator=(ResponseOfferSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseOfferSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseOfferSnapshot* internal_default_instance() {
    return reinterpret_cast<const ResponseOfferSnapshot*>(
               &_ResponseOfferSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ResponseOfferSnapshot& a, ResponseOfferSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseOfferSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseOfferSnapshot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseOfferSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseOfferSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseOfferSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseOfferSnapshot& from) {
    ResponseOfferSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseOfferSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseOfferSnapshot";
  }
  protected:
  explicit ResponseOfferSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Result = ResponseOfferSnapshot_Result;
  static constexpr Result UNKNOWN = ResponseOfferSnapshot_Result_UNKNOWN;
  static constexpr Result ACCEPT = ResponseOfferSnapshot_Result_ACCEPT;
  static constexpr Result ABORT = ResponseOfferSnapshot_Result_ABORT;
  static constexpr Result REJECT = ResponseOfferSnapshot_Result_REJECT;
  static constexpr Result REJECT_FORMAT = ResponseOfferSnapshot_Result_REJECT_FORMAT;
  static constexpr Result REJECT_SENDER = ResponseOfferSnapshot_Result_REJECT_SENDER;
  static inline bool Result_IsValid(int value) {
    return ResponseOfferSnapshot_Result_IsValid(value);
  }
  static constexpr Result Result_MIN = ResponseOfferSnapshot_Result_Result_MIN;
  static constexpr Result Result_MAX = ResponseOfferSnapshot_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE = ResponseOfferSnapshot_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor() {
    return ResponseOfferSnapshot_Result_descriptor();
  }
  template <typename T>
  static inline const std::string& Result_Name(T value) {
    return ResponseOfferSnapshot_Result_Name(value);
  }
  static inline bool Result_Parse(absl::string_view name, Result* value) {
    return ResponseOfferSnapshot_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .tendermint.abci.ResponseOfferSnapshot.Result result = 1 [json_name = "result"];
  void clear_result() ;
  ::tendermint::abci::ResponseOfferSnapshot_Result result() const;
  void set_result(::tendermint::abci::ResponseOfferSnapshot_Result value);

  private:
  ::tendermint::abci::ResponseOfferSnapshot_Result _internal_result() const;
  void _internal_set_result(::tendermint::abci::ResponseOfferSnapshot_Result value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseOfferSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseLoadSnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseLoadSnapshotChunk) */ {
 public:
  inline ResponseLoadSnapshotChunk() : ResponseLoadSnapshotChunk(nullptr) {}
  ~ResponseLoadSnapshotChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseLoadSnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseLoadSnapshotChunk(const ResponseLoadSnapshotChunk& from);
  ResponseLoadSnapshotChunk(ResponseLoadSnapshotChunk&& from) noexcept
    : ResponseLoadSnapshotChunk() {
    *this = ::std::move(from);
  }

  inline ResponseLoadSnapshotChunk& operator=(const ResponseLoadSnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseLoadSnapshotChunk& operator=(ResponseLoadSnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseLoadSnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseLoadSnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const ResponseLoadSnapshotChunk*>(
               &_ResponseLoadSnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ResponseLoadSnapshotChunk& a, ResponseLoadSnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseLoadSnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseLoadSnapshotChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseLoadSnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseLoadSnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseLoadSnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseLoadSnapshotChunk& from) {
    ResponseLoadSnapshotChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLoadSnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseLoadSnapshotChunk";
  }
  protected:
  explicit ResponseLoadSnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 1,
  };
  // bytes chunk = 1 [json_name = "chunk"];
  void clear_chunk() ;
  const std::string& chunk() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chunk(Arg_&& arg, Args_... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* ptr);

  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(
      const std::string& value);
  std::string* _internal_mutable_chunk();

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseLoadSnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseApplySnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseApplySnapshotChunk) */ {
 public:
  inline ResponseApplySnapshotChunk() : ResponseApplySnapshotChunk(nullptr) {}
  ~ResponseApplySnapshotChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseApplySnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseApplySnapshotChunk(const ResponseApplySnapshotChunk& from);
  ResponseApplySnapshotChunk(ResponseApplySnapshotChunk&& from) noexcept
    : ResponseApplySnapshotChunk() {
    *this = ::std::move(from);
  }

  inline ResponseApplySnapshotChunk& operator=(const ResponseApplySnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseApplySnapshotChunk& operator=(ResponseApplySnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseApplySnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseApplySnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const ResponseApplySnapshotChunk*>(
               &_ResponseApplySnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ResponseApplySnapshotChunk& a, ResponseApplySnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseApplySnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseApplySnapshotChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseApplySnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseApplySnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseApplySnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseApplySnapshotChunk& from) {
    ResponseApplySnapshotChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseApplySnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseApplySnapshotChunk";
  }
  protected:
  explicit ResponseApplySnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Result = ResponseApplySnapshotChunk_Result;
  static constexpr Result UNKNOWN = ResponseApplySnapshotChunk_Result_UNKNOWN;
  static constexpr Result ACCEPT = ResponseApplySnapshotChunk_Result_ACCEPT;
  static constexpr Result ABORT = ResponseApplySnapshotChunk_Result_ABORT;
  static constexpr Result RETRY = ResponseApplySnapshotChunk_Result_RETRY;
  static constexpr Result RETRY_SNAPSHOT = ResponseApplySnapshotChunk_Result_RETRY_SNAPSHOT;
  static constexpr Result REJECT_SNAPSHOT = ResponseApplySnapshotChunk_Result_REJECT_SNAPSHOT;
  static inline bool Result_IsValid(int value) {
    return ResponseApplySnapshotChunk_Result_IsValid(value);
  }
  static constexpr Result Result_MIN = ResponseApplySnapshotChunk_Result_Result_MIN;
  static constexpr Result Result_MAX = ResponseApplySnapshotChunk_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE = ResponseApplySnapshotChunk_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor() {
    return ResponseApplySnapshotChunk_Result_descriptor();
  }
  template <typename T>
  static inline const std::string& Result_Name(T value) {
    return ResponseApplySnapshotChunk_Result_Name(value);
  }
  static inline bool Result_Parse(absl::string_view name, Result* value) {
    return ResponseApplySnapshotChunk_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRefetchChunksFieldNumber = 2,
    kRejectSendersFieldNumber = 3,
    kResultFieldNumber = 1,
  };
  // repeated uint32 refetch_chunks = 2 [json_name = "refetchChunks"];
  int refetch_chunks_size() const;
  private:
  int _internal_refetch_chunks_size() const;

  public:
  void clear_refetch_chunks() ;
  ::uint32_t refetch_chunks(int index) const;
  void set_refetch_chunks(int index, ::uint32_t value);
  void add_refetch_chunks(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& refetch_chunks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* mutable_refetch_chunks();

  private:
  ::uint32_t _internal_refetch_chunks(int index) const;
  void _internal_add_refetch_chunks(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& _internal_refetch_chunks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* _internal_mutable_refetch_chunks();

  public:
  // repeated string reject_senders = 3 [json_name = "rejectSenders"];
  int reject_senders_size() const;
  private:
  int _internal_reject_senders_size() const;

  public:
  void clear_reject_senders() ;
  const std::string& reject_senders(int index) const;
  std::string* mutable_reject_senders(int index);
  void set_reject_senders(int index, const std::string& value);
  void set_reject_senders(int index, std::string&& value);
  void set_reject_senders(int index, const char* value);
  void set_reject_senders(int index, const char* value, std::size_t size);
  void set_reject_senders(int index, absl::string_view value);
  std::string* add_reject_senders();
  void add_reject_senders(const std::string& value);
  void add_reject_senders(std::string&& value);
  void add_reject_senders(const char* value);
  void add_reject_senders(const char* value, std::size_t size);
  void add_reject_senders(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& reject_senders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_reject_senders();

  private:
  const std::string& _internal_reject_senders(int index) const;
  std::string* _internal_add_reject_senders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_reject_senders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_reject_senders();

  public:
  // .tendermint.abci.ResponseApplySnapshotChunk.Result result = 1 [json_name = "result"];
  void clear_result() ;
  ::tendermint::abci::ResponseApplySnapshotChunk_Result result() const;
  void set_result(::tendermint::abci::ResponseApplySnapshotChunk_Result value);

  private:
  ::tendermint::abci::ResponseApplySnapshotChunk_Result _internal_result() const;
  void _internal_set_result(::tendermint::abci::ResponseApplySnapshotChunk_Result value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseApplySnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t> refetch_chunks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _refetch_chunks_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> reject_senders_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponsePrepareProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponsePrepareProposal) */ {
 public:
  inline ResponsePrepareProposal() : ResponsePrepareProposal(nullptr) {}
  ~ResponsePrepareProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponsePrepareProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponsePrepareProposal(const ResponsePrepareProposal& from);
  ResponsePrepareProposal(ResponsePrepareProposal&& from) noexcept
    : ResponsePrepareProposal() {
    *this = ::std::move(from);
  }

  inline ResponsePrepareProposal& operator=(const ResponsePrepareProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponsePrepareProposal& operator=(ResponsePrepareProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponsePrepareProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponsePrepareProposal* internal_default_instance() {
    return reinterpret_cast<const ResponsePrepareProposal*>(
               &_ResponsePrepareProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ResponsePrepareProposal& a, ResponsePrepareProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponsePrepareProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponsePrepareProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponsePrepareProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponsePrepareProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponsePrepareProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponsePrepareProposal& from) {
    ResponsePrepareProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsePrepareProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponsePrepareProposal";
  }
  protected:
  explicit ResponsePrepareProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxsFieldNumber = 1,
  };
  // repeated bytes txs = 1 [json_name = "txs"];
  int txs_size() const;
  private:
  int _internal_txs_size() const;

  public:
  void clear_txs() ;
  const std::string& txs(int index) const;
  std::string* mutable_txs(int index);
  void set_txs(int index, const std::string& value);
  void set_txs(int index, std::string&& value);
  void set_txs(int index, const char* value);
  void set_txs(int index, const void* value, std::size_t size);
  void set_txs(int index, absl::string_view value);
  std::string* add_txs();
  void add_txs(const std::string& value);
  void add_txs(std::string&& value);
  void add_txs(const char* value);
  void add_txs(const void* value, std::size_t size);
  void add_txs(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txs();

  private:
  const std::string& _internal_txs(int index) const;
  std::string* _internal_add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_txs();

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponsePrepareProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ResponseProcessProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseProcessProposal) */ {
 public:
  inline ResponseProcessProposal() : ResponseProcessProposal(nullptr) {}
  ~ResponseProcessProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseProcessProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseProcessProposal(const ResponseProcessProposal& from);
  ResponseProcessProposal(ResponseProcessProposal&& from) noexcept
    : ResponseProcessProposal() {
    *this = ::std::move(from);
  }

  inline ResponseProcessProposal& operator=(const ResponseProcessProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseProcessProposal& operator=(ResponseProcessProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseProcessProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseProcessProposal* internal_default_instance() {
    return reinterpret_cast<const ResponseProcessProposal*>(
               &_ResponseProcessProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ResponseProcessProposal& a, ResponseProcessProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseProcessProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseProcessProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseProcessProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseProcessProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseProcessProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseProcessProposal& from) {
    ResponseProcessProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseProcessProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ResponseProcessProposal";
  }
  protected:
  explicit ResponseProcessProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ProposalStatus = ResponseProcessProposal_ProposalStatus;
  static constexpr ProposalStatus UNKNOWN = ResponseProcessProposal_ProposalStatus_UNKNOWN;
  static constexpr ProposalStatus ACCEPT = ResponseProcessProposal_ProposalStatus_ACCEPT;
  static constexpr ProposalStatus REJECT = ResponseProcessProposal_ProposalStatus_REJECT;
  static inline bool ProposalStatus_IsValid(int value) {
    return ResponseProcessProposal_ProposalStatus_IsValid(value);
  }
  static constexpr ProposalStatus ProposalStatus_MIN = ResponseProcessProposal_ProposalStatus_ProposalStatus_MIN;
  static constexpr ProposalStatus ProposalStatus_MAX = ResponseProcessProposal_ProposalStatus_ProposalStatus_MAX;
  static constexpr int ProposalStatus_ARRAYSIZE = ResponseProcessProposal_ProposalStatus_ProposalStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProposalStatus_descriptor() {
    return ResponseProcessProposal_ProposalStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& ProposalStatus_Name(T value) {
    return ResponseProcessProposal_ProposalStatus_Name(value);
  }
  static inline bool ProposalStatus_Parse(absl::string_view name, ProposalStatus* value) {
    return ResponseProcessProposal_ProposalStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .tendermint.abci.ResponseProcessProposal.ProposalStatus status = 1 [json_name = "status"];
  void clear_status() ;
  ::tendermint::abci::ResponseProcessProposal_ProposalStatus status() const;
  void set_status(::tendermint::abci::ResponseProcessProposal_ProposalStatus value);

  private:
  ::tendermint::abci::ResponseProcessProposal_ProposalStatus _internal_status() const;
  void _internal_set_status(::tendermint::abci::ResponseProcessProposal_ProposalStatus value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseProcessProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class CommitInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.CommitInfo) */ {
 public:
  inline CommitInfo() : CommitInfo(nullptr) {}
  ~CommitInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommitInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitInfo(const CommitInfo& from);
  CommitInfo(CommitInfo&& from) noexcept
    : CommitInfo() {
    *this = ::std::move(from);
  }

  inline CommitInfo& operator=(const CommitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitInfo& operator=(CommitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitInfo* internal_default_instance() {
    return reinterpret_cast<const CommitInfo*>(
               &_CommitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CommitInfo& a, CommitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommitInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommitInfo& from) {
    CommitInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommitInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.CommitInfo";
  }
  protected:
  explicit CommitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVotesFieldNumber = 2,
    kRoundFieldNumber = 1,
  };
  // repeated .tendermint.abci.VoteInfo votes = 2 [json_name = "votes", (.gogoproto.nullable) = false];
  int votes_size() const;
  private:
  int _internal_votes_size() const;

  public:
  void clear_votes() ;
  ::tendermint::abci::VoteInfo* mutable_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo >*
      mutable_votes();
  private:
  const ::tendermint::abci::VoteInfo& _internal_votes(int index) const;
  ::tendermint::abci::VoteInfo* _internal_add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::VoteInfo>& _internal_votes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::VoteInfo>* _internal_mutable_votes();
  public:
  const ::tendermint::abci::VoteInfo& votes(int index) const;
  ::tendermint::abci::VoteInfo* add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo >&
      votes() const;
  // int32 round = 1 [json_name = "round"];
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.CommitInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo > votes_;
    ::int32_t round_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ExtendedCommitInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ExtendedCommitInfo) */ {
 public:
  inline ExtendedCommitInfo() : ExtendedCommitInfo(nullptr) {}
  ~ExtendedCommitInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExtendedCommitInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtendedCommitInfo(const ExtendedCommitInfo& from);
  ExtendedCommitInfo(ExtendedCommitInfo&& from) noexcept
    : ExtendedCommitInfo() {
    *this = ::std::move(from);
  }

  inline ExtendedCommitInfo& operator=(const ExtendedCommitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendedCommitInfo& operator=(ExtendedCommitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtendedCommitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtendedCommitInfo* internal_default_instance() {
    return reinterpret_cast<const ExtendedCommitInfo*>(
               &_ExtendedCommitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ExtendedCommitInfo& a, ExtendedCommitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtendedCommitInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendedCommitInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtendedCommitInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtendedCommitInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExtendedCommitInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExtendedCommitInfo& from) {
    ExtendedCommitInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtendedCommitInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ExtendedCommitInfo";
  }
  protected:
  explicit ExtendedCommitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVotesFieldNumber = 2,
    kRoundFieldNumber = 1,
  };
  // repeated .tendermint.abci.ExtendedVoteInfo votes = 2 [json_name = "votes", (.gogoproto.nullable) = false];
  int votes_size() const;
  private:
  int _internal_votes_size() const;

  public:
  void clear_votes() ;
  ::tendermint::abci::ExtendedVoteInfo* mutable_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ExtendedVoteInfo >*
      mutable_votes();
  private:
  const ::tendermint::abci::ExtendedVoteInfo& _internal_votes(int index) const;
  ::tendermint::abci::ExtendedVoteInfo* _internal_add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ExtendedVoteInfo>& _internal_votes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ExtendedVoteInfo>* _internal_mutable_votes();
  public:
  const ::tendermint::abci::ExtendedVoteInfo& votes(int index) const;
  ::tendermint::abci::ExtendedVoteInfo* add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ExtendedVoteInfo >&
      votes() const;
  // int32 round = 1 [json_name = "round"];
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ExtendedCommitInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ExtendedVoteInfo > votes_;
    ::int32_t round_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event& from) {
    Event::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .tendermint.abci.EventAttribute attributes = 2 [json_name = "attributes", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "attributes,omitempty"];
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::tendermint::abci::EventAttribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute >*
      mutable_attributes();
  private:
  const ::tendermint::abci::EventAttribute& _internal_attributes(int index) const;
  ::tendermint::abci::EventAttribute* _internal_add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::EventAttribute>& _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::EventAttribute>* _internal_mutable_attributes();
  public:
  const ::tendermint::abci::EventAttribute& attributes(int index) const;
  ::tendermint::abci::EventAttribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute >&
      attributes() const;
  // string type = 1 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute > attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class EventAttribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.EventAttribute) */ {
 public:
  inline EventAttribute() : EventAttribute(nullptr) {}
  ~EventAttribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventAttribute(const EventAttribute& from);
  EventAttribute(EventAttribute&& from) noexcept
    : EventAttribute() {
    *this = ::std::move(from);
  }

  inline EventAttribute& operator=(const EventAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAttribute& operator=(EventAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventAttribute* internal_default_instance() {
    return reinterpret_cast<const EventAttribute*>(
               &_EventAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(EventAttribute& a, EventAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(EventAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAttribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventAttribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventAttribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventAttribute& from) {
    EventAttribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventAttribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.EventAttribute";
  }
  protected:
  explicit EventAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  // string key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // string value = 2 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // bool index = 3 [json_name = "index"];
  void clear_index() ;
  bool index() const;
  void set_index(bool value);

  private:
  bool _internal_index() const;
  void _internal_set_index(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.EventAttribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    bool index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class TxResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.TxResult) */ {
 public:
  inline TxResult() : TxResult(nullptr) {}
  ~TxResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TxResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxResult(const TxResult& from);
  TxResult(TxResult&& from) noexcept
    : TxResult() {
    *this = ::std::move(from);
  }

  inline TxResult& operator=(const TxResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxResult& operator=(TxResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxResult* internal_default_instance() {
    return reinterpret_cast<const TxResult*>(
               &_TxResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(TxResult& a, TxResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TxResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxResult& from) {
    TxResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.TxResult";
  }
  protected:
  explicit TxResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 3,
    kResultFieldNumber = 4,
    kHeightFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // bytes tx = 3 [json_name = "tx"];
  void clear_tx() ;
  const std::string& tx() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx(Arg_&& arg, Args_... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* ptr);

  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(
      const std::string& value);
  std::string* _internal_mutable_tx();

  public:
  // .tendermint.abci.ResponseDeliverTx result = 4 [json_name = "result", (.gogoproto.nullable) = false];
  bool has_result() const;
  void clear_result() ;
  const ::tendermint::abci::ResponseDeliverTx& result() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseDeliverTx* release_result();
  ::tendermint::abci::ResponseDeliverTx* mutable_result();
  void set_allocated_result(::tendermint::abci::ResponseDeliverTx* result);
  private:
  const ::tendermint::abci::ResponseDeliverTx& _internal_result() const;
  ::tendermint::abci::ResponseDeliverTx* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::tendermint::abci::ResponseDeliverTx* result);
  ::tendermint::abci::ResponseDeliverTx* unsafe_arena_release_result();
  // int64 height = 1 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // uint32 index = 2 [json_name = "index"];
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.TxResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    ::tendermint::abci::ResponseDeliverTx* result_;
    ::int64_t height_;
    ::uint32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Validator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Validator) */ {
 public:
  inline Validator() : Validator(nullptr) {}
  ~Validator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Validator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Validator(const Validator& from);
  Validator(Validator&& from) noexcept
    : Validator() {
    *this = ::std::move(from);
  }

  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Validator& operator=(Validator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Validator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
               &_Validator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Validator& a, Validator& b) {
    a.Swap(&b);
  }
  inline void Swap(Validator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Validator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Validator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Validator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Validator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Validator& from) {
    Validator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Validator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.Validator";
  }
  protected:
  explicit Validator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPowerFieldNumber = 3,
  };
  // bytes address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // int64 power = 3 [json_name = "power"];
  void clear_power() ;
  ::int64_t power() const;
  void set_power(::int64_t value);

  private:
  ::int64_t _internal_power() const;
  void _internal_set_power(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.Validator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::int64_t power_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ValidatorUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ValidatorUpdate) */ {
 public:
  inline ValidatorUpdate() : ValidatorUpdate(nullptr) {}
  ~ValidatorUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorUpdate(const ValidatorUpdate& from);
  ValidatorUpdate(ValidatorUpdate&& from) noexcept
    : ValidatorUpdate() {
    *this = ::std::move(from);
  }

  inline ValidatorUpdate& operator=(const ValidatorUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorUpdate& operator=(ValidatorUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorUpdate* internal_default_instance() {
    return reinterpret_cast<const ValidatorUpdate*>(
               &_ValidatorUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ValidatorUpdate& a, ValidatorUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorUpdate& from) {
    ValidatorUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ValidatorUpdate";
  }
  protected:
  explicit ValidatorUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kPowerFieldNumber = 2,
  };
  // .tendermint.crypto.PublicKey pub_key = 1 [json_name = "pubKey", (.gogoproto.nullable) = false];
  bool has_pub_key() const;
  void clear_pub_key() ;
  const ::tendermint::crypto::PublicKey& pub_key() const;
  PROTOBUF_NODISCARD ::tendermint::crypto::PublicKey* release_pub_key();
  ::tendermint::crypto::PublicKey* mutable_pub_key();
  void set_allocated_pub_key(::tendermint::crypto::PublicKey* pub_key);
  private:
  const ::tendermint::crypto::PublicKey& _internal_pub_key() const;
  ::tendermint::crypto::PublicKey* _internal_mutable_pub_key();
  public:
  void unsafe_arena_set_allocated_pub_key(
      ::tendermint::crypto::PublicKey* pub_key);
  ::tendermint::crypto::PublicKey* unsafe_arena_release_pub_key();
  // int64 power = 2 [json_name = "power"];
  void clear_power() ;
  ::int64_t power() const;
  void set_power(::int64_t value);

  private:
  ::int64_t _internal_power() const;
  void _internal_set_power(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ValidatorUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::tendermint::crypto::PublicKey* pub_key_;
    ::int64_t power_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class VoteInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.VoteInfo) */ {
 public:
  inline VoteInfo() : VoteInfo(nullptr) {}
  ~VoteInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VoteInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteInfo(const VoteInfo& from);
  VoteInfo(VoteInfo&& from) noexcept
    : VoteInfo() {
    *this = ::std::move(from);
  }

  inline VoteInfo& operator=(const VoteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteInfo& operator=(VoteInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteInfo* internal_default_instance() {
    return reinterpret_cast<const VoteInfo*>(
               &_VoteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(VoteInfo& a, VoteInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoteInfo& from) {
    VoteInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.VoteInfo";
  }
  protected:
  explicit VoteInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorFieldNumber = 1,
    kSignedLastBlockFieldNumber = 2,
  };
  // .tendermint.abci.Validator validator = 1 [json_name = "validator", (.gogoproto.nullable) = false];
  bool has_validator() const;
  void clear_validator() ;
  const ::tendermint::abci::Validator& validator() const;
  PROTOBUF_NODISCARD ::tendermint::abci::Validator* release_validator();
  ::tendermint::abci::Validator* mutable_validator();
  void set_allocated_validator(::tendermint::abci::Validator* validator);
  private:
  const ::tendermint::abci::Validator& _internal_validator() const;
  ::tendermint::abci::Validator* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::tendermint::abci::Validator* validator);
  ::tendermint::abci::Validator* unsafe_arena_release_validator();
  // bool signed_last_block = 2 [json_name = "signedLastBlock"];
  void clear_signed_last_block() ;
  bool signed_last_block() const;
  void set_signed_last_block(bool value);

  private:
  bool _internal_signed_last_block() const;
  void _internal_set_signed_last_block(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.VoteInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::tendermint::abci::Validator* validator_;
    bool signed_last_block_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ExtendedVoteInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ExtendedVoteInfo) */ {
 public:
  inline ExtendedVoteInfo() : ExtendedVoteInfo(nullptr) {}
  ~ExtendedVoteInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExtendedVoteInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtendedVoteInfo(const ExtendedVoteInfo& from);
  ExtendedVoteInfo(ExtendedVoteInfo&& from) noexcept
    : ExtendedVoteInfo() {
    *this = ::std::move(from);
  }

  inline ExtendedVoteInfo& operator=(const ExtendedVoteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendedVoteInfo& operator=(ExtendedVoteInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtendedVoteInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtendedVoteInfo* internal_default_instance() {
    return reinterpret_cast<const ExtendedVoteInfo*>(
               &_ExtendedVoteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ExtendedVoteInfo& a, ExtendedVoteInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtendedVoteInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendedVoteInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtendedVoteInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtendedVoteInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExtendedVoteInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExtendedVoteInfo& from) {
    ExtendedVoteInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtendedVoteInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.ExtendedVoteInfo";
  }
  protected:
  explicit ExtendedVoteInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteExtensionFieldNumber = 3,
    kValidatorFieldNumber = 1,
    kSignedLastBlockFieldNumber = 2,
  };
  // bytes vote_extension = 3 [json_name = "voteExtension"];
  void clear_vote_extension() ;
  const std::string& vote_extension() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vote_extension(Arg_&& arg, Args_... args);
  std::string* mutable_vote_extension();
  PROTOBUF_NODISCARD std::string* release_vote_extension();
  void set_allocated_vote_extension(std::string* ptr);

  private:
  const std::string& _internal_vote_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vote_extension(
      const std::string& value);
  std::string* _internal_mutable_vote_extension();

  public:
  // .tendermint.abci.Validator validator = 1 [json_name = "validator", (.gogoproto.nullable) = false];
  bool has_validator() const;
  void clear_validator() ;
  const ::tendermint::abci::Validator& validator() const;
  PROTOBUF_NODISCARD ::tendermint::abci::Validator* release_validator();
  ::tendermint::abci::Validator* mutable_validator();
  void set_allocated_validator(::tendermint::abci::Validator* validator);
  private:
  const ::tendermint::abci::Validator& _internal_validator() const;
  ::tendermint::abci::Validator* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::tendermint::abci::Validator* validator);
  ::tendermint::abci::Validator* unsafe_arena_release_validator();
  // bool signed_last_block = 2 [json_name = "signedLastBlock"];
  void clear_signed_last_block() ;
  bool signed_last_block() const;
  void set_signed_last_block(bool value);

  private:
  bool _internal_signed_last_block() const;
  void _internal_set_signed_last_block(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.ExtendedVoteInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vote_extension_;
    ::tendermint::abci::Validator* validator_;
    bool signed_last_block_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Misbehavior final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Misbehavior) */ {
 public:
  inline Misbehavior() : Misbehavior(nullptr) {}
  ~Misbehavior() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Misbehavior(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Misbehavior(const Misbehavior& from);
  Misbehavior(Misbehavior&& from) noexcept
    : Misbehavior() {
    *this = ::std::move(from);
  }

  inline Misbehavior& operator=(const Misbehavior& from) {
    CopyFrom(from);
    return *this;
  }
  inline Misbehavior& operator=(Misbehavior&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Misbehavior& default_instance() {
    return *internal_default_instance();
  }
  static inline const Misbehavior* internal_default_instance() {
    return reinterpret_cast<const Misbehavior*>(
               &_Misbehavior_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Misbehavior& a, Misbehavior& b) {
    a.Swap(&b);
  }
  inline void Swap(Misbehavior* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Misbehavior* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Misbehavior* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Misbehavior>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Misbehavior& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Misbehavior& from) {
    Misbehavior::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Misbehavior* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.Misbehavior";
  }
  protected:
  explicit Misbehavior(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorFieldNumber = 2,
    kTimeFieldNumber = 4,
    kHeightFieldNumber = 3,
    kTotalVotingPowerFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // .tendermint.abci.Validator validator = 2 [json_name = "validator", (.gogoproto.nullable) = false];
  bool has_validator() const;
  void clear_validator() ;
  const ::tendermint::abci::Validator& validator() const;
  PROTOBUF_NODISCARD ::tendermint::abci::Validator* release_validator();
  ::tendermint::abci::Validator* mutable_validator();
  void set_allocated_validator(::tendermint::abci::Validator* validator);
  private:
  const ::tendermint::abci::Validator& _internal_validator() const;
  ::tendermint::abci::Validator* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::tendermint::abci::Validator* validator);
  ::tendermint::abci::Validator* unsafe_arena_release_validator();
  // .google.protobuf.Timestamp time = 4 [json_name = "time", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  void clear_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();
  // int64 height = 3 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // int64 total_voting_power = 5 [json_name = "totalVotingPower"];
  void clear_total_voting_power() ;
  ::int64_t total_voting_power() const;
  void set_total_voting_power(::int64_t value);

  private:
  ::int64_t _internal_total_voting_power() const;
  void _internal_set_total_voting_power(::int64_t value);

  public:
  // .tendermint.abci.MisbehaviorType type = 1 [json_name = "type"];
  void clear_type() ;
  ::tendermint::abci::MisbehaviorType type() const;
  void set_type(::tendermint::abci::MisbehaviorType value);

  private:
  ::tendermint::abci::MisbehaviorType _internal_type() const;
  void _internal_set_type(::tendermint::abci::MisbehaviorType value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.Misbehavior)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::tendermint::abci::Validator* validator_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    ::int64_t height_;
    ::int64_t total_voting_power_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Snapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Snapshot) */ {
 public:
  inline Snapshot() : Snapshot(nullptr) {}
  ~Snapshot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Snapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Snapshot(const Snapshot& from);
  Snapshot(Snapshot&& from) noexcept
    : Snapshot() {
    *this = ::std::move(from);
  }

  inline Snapshot& operator=(const Snapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snapshot& operator=(Snapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Snapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Snapshot* internal_default_instance() {
    return reinterpret_cast<const Snapshot*>(
               &_Snapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Snapshot& a, Snapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Snapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snapshot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Snapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Snapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Snapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Snapshot& from) {
    Snapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Snapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tendermint.abci.Snapshot";
  }
  protected:
  explicit Snapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 4,
    kMetadataFieldNumber = 5,
    kHeightFieldNumber = 1,
    kFormatFieldNumber = 2,
    kChunksFieldNumber = 3,
  };
  // bytes hash = 4 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // bytes metadata = 5 [json_name = "metadata"];
  void clear_metadata() ;
  const std::string& metadata() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* ptr);

  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(
      const std::string& value);
  std::string* _internal_mutable_metadata();

  public:
  // uint64 height = 1 [json_name = "height"];
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // uint32 format = 2 [json_name = "format"];
  void clear_format() ;
  ::uint32_t format() const;
  void set_format(::uint32_t value);

  private:
  ::uint32_t _internal_format() const;
  void _internal_set_format(::uint32_t value);

  public:
  // uint32 chunks = 3 [json_name = "chunks"];
  void clear_chunks() ;
  ::uint32_t chunks() const;
  void set_chunks(::uint32_t value);

  private:
  ::uint32_t _internal_chunks() const;
  void _internal_set_chunks(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tendermint.abci.Snapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    ::uint64_t height_;
    ::uint32_t format_;
    ::uint32_t chunks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Request

// .tendermint.abci.RequestEcho echo = 1 [json_name = "echo"];
inline bool Request::has_echo() const {
  return value_case() == kEcho;
}
inline bool Request::_internal_has_echo() const {
  return value_case() == kEcho;
}
inline void Request::set_has_echo() {
  _impl_._oneof_case_[0] = kEcho;
}
inline void Request::clear_echo() {
  if (value_case() == kEcho) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.echo_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestEcho* Request::release_echo() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.echo)
  if (value_case() == kEcho) {
    clear_has_value();
    ::tendermint::abci::RequestEcho* temp = _impl_.value_.echo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestEcho& Request::_internal_echo() const {
  return value_case() == kEcho
      ? *_impl_.value_.echo_
      : reinterpret_cast<::tendermint::abci::RequestEcho&>(::tendermint::abci::_RequestEcho_default_instance_);
}
inline const ::tendermint::abci::RequestEcho& Request::echo() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.echo)
  return _internal_echo();
}
inline ::tendermint::abci::RequestEcho* Request::unsafe_arena_release_echo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.echo)
  if (value_case() == kEcho) {
    clear_has_value();
    ::tendermint::abci::RequestEcho* temp = _impl_.value_.echo_;
    _impl_.value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_echo(::tendermint::abci::RequestEcho* echo) {
  clear_value();
  if (echo) {
    set_has_echo();
    _impl_.value_.echo_ = echo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.echo)
}
inline ::tendermint::abci::RequestEcho* Request::_internal_mutable_echo() {
  if (value_case() != kEcho) {
    clear_value();
    set_has_echo();
    _impl_.value_.echo_ = CreateMaybeMessage< ::tendermint::abci::RequestEcho >(GetArenaForAllocation());
  }
  return _impl_.value_.echo_;
}
inline ::tendermint::abci::RequestEcho* Request::mutable_echo() {
  ::tendermint::abci::RequestEcho* _msg = _internal_mutable_echo();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.echo)
  return _msg;
}

// .tendermint.abci.RequestFlush flush = 2 [json_name = "flush"];
inline bool Request::has_flush() const {
  return value_case() == kFlush;
}
inline bool Request::_internal_has_flush() const {
  return value_case() == kFlush;
}
inline void Request::set_has_flush() {
  _impl_._oneof_case_[0] = kFlush;
}
inline void Request::clear_flush() {
  if (value_case() == kFlush) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.flush_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestFlush* Request::release_flush() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.flush)
  if (value_case() == kFlush) {
    clear_has_value();
    ::tendermint::abci::RequestFlush* temp = _impl_.value_.flush_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestFlush& Request::_internal_flush() const {
  return value_case() == kFlush
      ? *_impl_.value_.flush_
      : reinterpret_cast<::tendermint::abci::RequestFlush&>(::tendermint::abci::_RequestFlush_default_instance_);
}
inline const ::tendermint::abci::RequestFlush& Request::flush() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.flush)
  return _internal_flush();
}
inline ::tendermint::abci::RequestFlush* Request::unsafe_arena_release_flush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.flush)
  if (value_case() == kFlush) {
    clear_has_value();
    ::tendermint::abci::RequestFlush* temp = _impl_.value_.flush_;
    _impl_.value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_flush(::tendermint::abci::RequestFlush* flush) {
  clear_value();
  if (flush) {
    set_has_flush();
    _impl_.value_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.flush)
}
inline ::tendermint::abci::RequestFlush* Request::_internal_mutable_flush() {
  if (value_case() != kFlush) {
    clear_value();
    set_has_flush();
    _impl_.value_.flush_ = CreateMaybeMessage< ::tendermint::abci::RequestFlush >(GetArenaForAllocation());
  }
  return _impl_.value_.flush_;
}
inline ::tendermint::abci::RequestFlush* Request::mutable_flush() {
  ::tendermint::abci::RequestFlush* _msg = _internal_mutable_flush();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.flush)
  return _msg;
}

// .tendermint.abci.RequestInfo info = 3 [json_name = "info"];
inline bool Request::has_info() const {
  return value_case() == kInfo;
}
inline bool Request::_internal_has_info() const {
  return value_case() == kInfo;
}
inline void Request::set_has_info() {
  _impl_._oneof_case_[0] = kInfo;
}
inline void Request::clear_info() {
  if (value_case() == kInfo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.info_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestInfo* Request::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.info)
  if (value_case() == kInfo) {
    clear_has_value();
    ::tendermint::abci::RequestInfo* temp = _impl_.value_.info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestInfo& Request::_internal_info() const {
  return value_case() == kInfo
      ? *_impl_.value_.info_
      : reinterpret_cast<::tendermint::abci::RequestInfo&>(::tendermint::abci::_RequestInfo_default_instance_);
}
inline const ::tendermint::abci::RequestInfo& Request::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.info)
  return _internal_info();
}
inline ::tendermint::abci::RequestInfo* Request::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.info)
  if (value_case() == kInfo) {
    clear_has_value();
    ::tendermint::abci::RequestInfo* temp = _impl_.value_.info_;
    _impl_.value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_info(::tendermint::abci::RequestInfo* info) {
  clear_value();
  if (info) {
    set_has_info();
    _impl_.value_.info_ = info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.info)
}
inline ::tendermint::abci::RequestInfo* Request::_internal_mutable_info() {
  if (value_case() != kInfo) {
    clear_value();
    set_has_info();
    _impl_.value_.info_ = CreateMaybeMessage< ::tendermint::abci::RequestInfo >(GetArenaForAllocation());
  }
  return _impl_.value_.info_;
}
inline ::tendermint::abci::RequestInfo* Request::mutable_info() {
  ::tendermint::abci::RequestInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.info)
  return _msg;
}

// .tendermint.abci.RequestInitChain init_chain = 5 [json_name = "initChain"];
inline bool Request::has_init_chain() const {
  return value_case() == kInitChain;
}
inline bool Request::_internal_has_init_chain() const {
  return value_case() == kInitChain;
}
inline void Request::set_has_init_chain() {
  _impl_._oneof_case_[0] = kInitChain;
}
inline void Request::clear_init_chain() {
  if (value_case() == kInitChain) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.init_chain_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestInitChain* Request::release_init_chain() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.init_chain)
  if (value_case() == kInitChain) {
    clear_has_value();
    ::tendermint::abci::RequestInitChain* temp = _impl_.value_.init_chain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestInitChain& Request::_internal_init_chain() const {
  return value_case() == kInitChain
      ? *_impl_.value_.init_chain_
      : reinterpret_cast<::tendermint::abci::RequestInitChain&>(::tendermint::abci::_RequestInitChain_default_instance_);
}
inline const ::tendermint::abci::RequestInitChain& Request::init_chain() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.init_chain)
  return _internal_init_chain();
}
inline ::tendermint::abci::RequestInitChain* Request::unsafe_arena_release_init_chain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.init_chain)
  if (value_case() == kInitChain) {
    clear_has_value();
    ::tendermint::abci::RequestInitChain* temp = _impl_.value_.init_chain_;
    _impl_.value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_init_chain(::tendermint::abci::RequestInitChain* init_chain) {
  clear_value();
  if (init_chain) {
    set_has_init_chain();
    _impl_.value_.init_chain_ = init_chain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.init_chain)
}
inline ::tendermint::abci::RequestInitChain* Request::_internal_mutable_init_chain() {
  if (value_case() != kInitChain) {
    clear_value();
    set_has_init_chain();
    _impl_.value_.init_chain_ = CreateMaybeMessage< ::tendermint::abci::RequestInitChain >(GetArenaForAllocation());
  }
  return _impl_.value_.init_chain_;
}
inline ::tendermint::abci::RequestInitChain* Request::mutable_init_chain() {
  ::tendermint::abci::RequestInitChain* _msg = _internal_mutable_init_chain();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.init_chain)
  return _msg;
}

// .tendermint.abci.RequestQuery query = 6 [json_name = "query"];
inline bool Request::has_query() const {
  return value_case() == kQuery;
}
inline bool Request::_internal_has_query() const {
  return value_case() == kQuery;
}
inline void Request::set_has_query() {
  _impl_._oneof_case_[0] = kQuery;
}
inline void Request::clear_query() {
  if (value_case() == kQuery) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.query_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.query)
  if (value_case() == kQuery) {
    clear_has_value();
    ::tendermint::abci::RequestQuery* temp = _impl_.value_.query_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestQuery& Request::_internal_query() const {
  return value_case() == kQuery
      ? *_impl_.value_.query_
      : reinterpret_cast<::tendermint::abci::RequestQuery&>(::tendermint::abci::_RequestQuery_default_instance_);
}
inline const ::tendermint::abci::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.query)
  return _internal_query();
}
inline ::tendermint::abci::RequestQuery* Request::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.query)
  if (value_case() == kQuery) {
    clear_has_value();
    ::tendermint::abci::RequestQuery* temp = _impl_.value_.query_;
    _impl_.value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_query(::tendermint::abci::RequestQuery* query) {
  clear_value();
  if (query) {
    set_has_query();
    _impl_.value_.query_ = query;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.query)
}
inline ::tendermint::abci::RequestQuery* Request::_internal_mutable_query() {
  if (value_case() != kQuery) {
    clear_value();
    set_has_query();
    _impl_.value_.query_ = CreateMaybeMessage< ::tendermint::abci::RequestQuery >(GetArenaForAllocation());
  }
  return _impl_.value_.query_;
}
inline ::tendermint::abci::RequestQuery* Request::mutable_query() {
  ::tendermint::abci::RequestQuery* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.query)
  return _msg;
}

// .tendermint.abci.RequestBeginBlock begin_block = 7 [json_name = "beginBlock"];
inline bool Request::has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline bool Request::_internal_has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline void Request::set_has_begin_block() {
  _impl_._oneof_case_[0] = kBeginBlock;
}
inline void Request::clear_begin_block() {
  if (value_case() == kBeginBlock) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.begin_block_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestBeginBlock* Request::release_begin_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.begin_block)
  if (value_case() == kBeginBlock) {
    clear_has_value();
    ::tendermint::abci::RequestBeginBlock* temp = _impl_.value_.begin_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestBeginBlock& Request::_internal_begin_block() const {
  return value_case() == kBeginBlock
      ? *_impl_.value_.begin_block_
      : reinterpret_cast<::tendermint::abci::RequestBeginBlock&>(::tendermint::abci::_RequestBeginBlock_default_instance_);
}
inline const ::tendermint::abci::RequestBeginBlock& Request::begin_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.begin_block)
  return _internal_begin_block();
}
inline ::tendermint::abci::RequestBeginBlock* Request::unsafe_arena_release_begin_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.begin_block)
  if (value_case() == kBeginBlock) {
    clear_has_value();
    ::tendermint::abci::RequestBeginBlock* temp = _impl_.value_.begin_block_;
    _impl_.value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_begin_block(::tendermint::abci::RequestBeginBlock* begin_block) {
  clear_value();
  if (begin_block) {
    set_has_begin_block();
    _impl_.value_.begin_block_ = begin_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.begin_block)
}
inline ::tendermint::abci::RequestBeginBlock* Request::_internal_mutable_begin_block() {
  if (value_case() != kBeginBlock) {
    clear_value();
    set_has_begin_block();
    _impl_.value_.begin_block_ = CreateMaybeMessage< ::tendermint::abci::RequestBeginBlock >(GetArenaForAllocation());
  }
  return _impl_.value_.begin_block_;
}
inline ::tendermint::abci::RequestBeginBlock* Request::mutable_begin_block() {
  ::tendermint::abci::RequestBeginBlock* _msg = _internal_mutable_begin_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.begin_block)
  return _msg;
}

// .tendermint.abci.RequestCheckTx check_tx = 8 [json_name = "checkTx"];
inline bool Request::has_check_tx() const {
  return value_case() == kCheckTx;
}
inline bool Request::_internal_has_check_tx() const {
  return value_case() == kCheckTx;
}
inline void Request::set_has_check_tx() {
  _impl_._oneof_case_[0] = kCheckTx;
}
inline void Request::clear_check_tx() {
  if (value_case() == kCheckTx) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.check_tx_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestCheckTx* Request::release_check_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.check_tx)
  if (value_case() == kCheckTx) {
    clear_has_value();
    ::tendermint::abci::RequestCheckTx* temp = _impl_.value_.check_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestCheckTx& Request::_internal_check_tx() const {
  return value_case() == kCheckTx
      ? *_impl_.value_.check_tx_
      : reinterpret_cast<::tendermint::abci::RequestCheckTx&>(::tendermint::abci::_RequestCheckTx_default_instance_);
}
inline const ::tendermint::abci::RequestCheckTx& Request::check_tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.check_tx)
  return _internal_check_tx();
}
inline ::tendermint::abci::RequestCheckTx* Request::unsafe_arena_release_check_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.check_tx)
  if (value_case() == kCheckTx) {
    clear_has_value();
    ::tendermint::abci::RequestCheckTx* temp = _impl_.value_.check_tx_;
    _impl_.value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_check_tx(::tendermint::abci::RequestCheckTx* check_tx) {
  clear_value();
  if (check_tx) {
    set_has_check_tx();
    _impl_.value_.check_tx_ = check_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.check_tx)
}
inline ::tendermint::abci::RequestCheckTx* Request::_internal_mutable_check_tx() {
  if (value_case() != kCheckTx) {
    clear_value();
    set_has_check_tx();
    _impl_.value_.check_tx_ = CreateMaybeMessage< ::tendermint::abci::RequestCheckTx >(GetArenaForAllocation());
  }
  return _impl_.value_.check_tx_;
}
inline ::tendermint::abci::RequestCheckTx* Request::mutable_check_tx() {
  ::tendermint::abci::RequestCheckTx* _msg = _internal_mutable_check_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.check_tx)
  return _msg;
}

// .tendermint.abci.RequestDeliverTx deliver_tx = 9 [json_name = "deliverTx"];
inline bool Request::has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline bool Request::_internal_has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline void Request::set_has_deliver_tx() {
  _impl_._oneof_case_[0] = kDeliverTx;
}
inline void Request::clear_deliver_tx() {
  if (value_case() == kDeliverTx) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.deliver_tx_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestDeliverTx* Request::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.deliver_tx)
  if (value_case() == kDeliverTx) {
    clear_has_value();
    ::tendermint::abci::RequestDeliverTx* temp = _impl_.value_.deliver_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestDeliverTx& Request::_internal_deliver_tx() const {
  return value_case() == kDeliverTx
      ? *_impl_.value_.deliver_tx_
      : reinterpret_cast<::tendermint::abci::RequestDeliverTx&>(::tendermint::abci::_RequestDeliverTx_default_instance_);
}
inline const ::tendermint::abci::RequestDeliverTx& Request::deliver_tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.deliver_tx)
  return _internal_deliver_tx();
}
inline ::tendermint::abci::RequestDeliverTx* Request::unsafe_arena_release_deliver_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.deliver_tx)
  if (value_case() == kDeliverTx) {
    clear_has_value();
    ::tendermint::abci::RequestDeliverTx* temp = _impl_.value_.deliver_tx_;
    _impl_.value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_deliver_tx(::tendermint::abci::RequestDeliverTx* deliver_tx) {
  clear_value();
  if (deliver_tx) {
    set_has_deliver_tx();
    _impl_.value_.deliver_tx_ = deliver_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.deliver_tx)
}
inline ::tendermint::abci::RequestDeliverTx* Request::_internal_mutable_deliver_tx() {
  if (value_case() != kDeliverTx) {
    clear_value();
    set_has_deliver_tx();
    _impl_.value_.deliver_tx_ = CreateMaybeMessage< ::tendermint::abci::RequestDeliverTx >(GetArenaForAllocation());
  }
  return _impl_.value_.deliver_tx_;
}
inline ::tendermint::abci::RequestDeliverTx* Request::mutable_deliver_tx() {
  ::tendermint::abci::RequestDeliverTx* _msg = _internal_mutable_deliver_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.deliver_tx)
  return _msg;
}

// .tendermint.abci.RequestEndBlock end_block = 10 [json_name = "endBlock"];
inline bool Request::has_end_block() const {
  return value_case() == kEndBlock;
}
inline bool Request::_internal_has_end_block() const {
  return value_case() == kEndBlock;
}
inline void Request::set_has_end_block() {
  _impl_._oneof_case_[0] = kEndBlock;
}
inline void Request::clear_end_block() {
  if (value_case() == kEndBlock) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.end_block_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestEndBlock* Request::release_end_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.end_block)
  if (value_case() == kEndBlock) {
    clear_has_value();
    ::tendermint::abci::RequestEndBlock* temp = _impl_.value_.end_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestEndBlock& Request::_internal_end_block() const {
  return value_case() == kEndBlock
      ? *_impl_.value_.end_block_
      : reinterpret_cast<::tendermint::abci::RequestEndBlock&>(::tendermint::abci::_RequestEndBlock_default_instance_);
}
inline const ::tendermint::abci::RequestEndBlock& Request::end_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.end_block)
  return _internal_end_block();
}
inline ::tendermint::abci::RequestEndBlock* Request::unsafe_arena_release_end_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.end_block)
  if (value_case() == kEndBlock) {
    clear_has_value();
    ::tendermint::abci::RequestEndBlock* temp = _impl_.value_.end_block_;
    _impl_.value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_end_block(::tendermint::abci::RequestEndBlock* end_block) {
  clear_value();
  if (end_block) {
    set_has_end_block();
    _impl_.value_.end_block_ = end_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.end_block)
}
inline ::tendermint::abci::RequestEndBlock* Request::_internal_mutable_end_block() {
  if (value_case() != kEndBlock) {
    clear_value();
    set_has_end_block();
    _impl_.value_.end_block_ = CreateMaybeMessage< ::tendermint::abci::RequestEndBlock >(GetArenaForAllocation());
  }
  return _impl_.value_.end_block_;
}
inline ::tendermint::abci::RequestEndBlock* Request::mutable_end_block() {
  ::tendermint::abci::RequestEndBlock* _msg = _internal_mutable_end_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.end_block)
  return _msg;
}

// .tendermint.abci.RequestCommit commit = 11 [json_name = "commit"];
inline bool Request::has_commit() const {
  return value_case() == kCommit;
}
inline bool Request::_internal_has_commit() const {
  return value_case() == kCommit;
}
inline void Request::set_has_commit() {
  _impl_._oneof_case_[0] = kCommit;
}
inline void Request::clear_commit() {
  if (value_case() == kCommit) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.commit_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestCommit* Request::release_commit() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.commit)
  if (value_case() == kCommit) {
    clear_has_value();
    ::tendermint::abci::RequestCommit* temp = _impl_.value_.commit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestCommit& Request::_internal_commit() const {
  return value_case() == kCommit
      ? *_impl_.value_.commit_
      : reinterpret_cast<::tendermint::abci::RequestCommit&>(::tendermint::abci::_RequestCommit_default_instance_);
}
inline const ::tendermint::abci::RequestCommit& Request::commit() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.commit)
  return _internal_commit();
}
inline ::tendermint::abci::RequestCommit* Request::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.commit)
  if (value_case() == kCommit) {
    clear_has_value();
    ::tendermint::abci::RequestCommit* temp = _impl_.value_.commit_;
    _impl_.value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_commit(::tendermint::abci::RequestCommit* commit) {
  clear_value();
  if (commit) {
    set_has_commit();
    _impl_.value_.commit_ = commit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.commit)
}
inline ::tendermint::abci::RequestCommit* Request::_internal_mutable_commit() {
  if (value_case() != kCommit) {
    clear_value();
    set_has_commit();
    _impl_.value_.commit_ = CreateMaybeMessage< ::tendermint::abci::RequestCommit >(GetArenaForAllocation());
  }
  return _impl_.value_.commit_;
}
inline ::tendermint::abci::RequestCommit* Request::mutable_commit() {
  ::tendermint::abci::RequestCommit* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.commit)
  return _msg;
}

// .tendermint.abci.RequestListSnapshots list_snapshots = 12 [json_name = "listSnapshots"];
inline bool Request::has_list_snapshots() const {
  return value_case() == kListSnapshots;
}
inline bool Request::_internal_has_list_snapshots() const {
  return value_case() == kListSnapshots;
}
inline void Request::set_has_list_snapshots() {
  _impl_._oneof_case_[0] = kListSnapshots;
}
inline void Request::clear_list_snapshots() {
  if (value_case() == kListSnapshots) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.list_snapshots_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestListSnapshots* Request::release_list_snapshots() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.list_snapshots)
  if (value_case() == kListSnapshots) {
    clear_has_value();
    ::tendermint::abci::RequestListSnapshots* temp = _impl_.value_.list_snapshots_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.list_snapshots_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestListSnapshots& Request::_internal_list_snapshots() const {
  return value_case() == kListSnapshots
      ? *_impl_.value_.list_snapshots_
      : reinterpret_cast<::tendermint::abci::RequestListSnapshots&>(::tendermint::abci::_RequestListSnapshots_default_instance_);
}
inline const ::tendermint::abci::RequestListSnapshots& Request::list_snapshots() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.list_snapshots)
  return _internal_list_snapshots();
}
inline ::tendermint::abci::RequestListSnapshots* Request::unsafe_arena_release_list_snapshots() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.list_snapshots)
  if (value_case() == kListSnapshots) {
    clear_has_value();
    ::tendermint::abci::RequestListSnapshots* temp = _impl_.value_.list_snapshots_;
    _impl_.value_.list_snapshots_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_list_snapshots(::tendermint::abci::RequestListSnapshots* list_snapshots) {
  clear_value();
  if (list_snapshots) {
    set_has_list_snapshots();
    _impl_.value_.list_snapshots_ = list_snapshots;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.list_snapshots)
}
inline ::tendermint::abci::RequestListSnapshots* Request::_internal_mutable_list_snapshots() {
  if (value_case() != kListSnapshots) {
    clear_value();
    set_has_list_snapshots();
    _impl_.value_.list_snapshots_ = CreateMaybeMessage< ::tendermint::abci::RequestListSnapshots >(GetArenaForAllocation());
  }
  return _impl_.value_.list_snapshots_;
}
inline ::tendermint::abci::RequestListSnapshots* Request::mutable_list_snapshots() {
  ::tendermint::abci::RequestListSnapshots* _msg = _internal_mutable_list_snapshots();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.list_snapshots)
  return _msg;
}

// .tendermint.abci.RequestOfferSnapshot offer_snapshot = 13 [json_name = "offerSnapshot"];
inline bool Request::has_offer_snapshot() const {
  return value_case() == kOfferSnapshot;
}
inline bool Request::_internal_has_offer_snapshot() const {
  return value_case() == kOfferSnapshot;
}
inline void Request::set_has_offer_snapshot() {
  _impl_._oneof_case_[0] = kOfferSnapshot;
}
inline void Request::clear_offer_snapshot() {
  if (value_case() == kOfferSnapshot) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.offer_snapshot_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestOfferSnapshot* Request::release_offer_snapshot() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.offer_snapshot)
  if (value_case() == kOfferSnapshot) {
    clear_has_value();
    ::tendermint::abci::RequestOfferSnapshot* temp = _impl_.value_.offer_snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.offer_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestOfferSnapshot& Request::_internal_offer_snapshot() const {
  return value_case() == kOfferSnapshot
      ? *_impl_.value_.offer_snapshot_
      : reinterpret_cast<::tendermint::abci::RequestOfferSnapshot&>(::tendermint::abci::_RequestOfferSnapshot_default_instance_);
}
inline const ::tendermint::abci::RequestOfferSnapshot& Request::offer_snapshot() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.offer_snapshot)
  return _internal_offer_snapshot();
}
inline ::tendermint::abci::RequestOfferSnapshot* Request::unsafe_arena_release_offer_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.offer_snapshot)
  if (value_case() == kOfferSnapshot) {
    clear_has_value();
    ::tendermint::abci::RequestOfferSnapshot* temp = _impl_.value_.offer_snapshot_;
    _impl_.value_.offer_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_offer_snapshot(::tendermint::abci::RequestOfferSnapshot* offer_snapshot) {
  clear_value();
  if (offer_snapshot) {
    set_has_offer_snapshot();
    _impl_.value_.offer_snapshot_ = offer_snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.offer_snapshot)
}
inline ::tendermint::abci::RequestOfferSnapshot* Request::_internal_mutable_offer_snapshot() {
  if (value_case() != kOfferSnapshot) {
    clear_value();
    set_has_offer_snapshot();
    _impl_.value_.offer_snapshot_ = CreateMaybeMessage< ::tendermint::abci::RequestOfferSnapshot >(GetArenaForAllocation());
  }
  return _impl_.value_.offer_snapshot_;
}
inline ::tendermint::abci::RequestOfferSnapshot* Request::mutable_offer_snapshot() {
  ::tendermint::abci::RequestOfferSnapshot* _msg = _internal_mutable_offer_snapshot();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.offer_snapshot)
  return _msg;
}

// .tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14 [json_name = "loadSnapshotChunk"];
inline bool Request::has_load_snapshot_chunk() const {
  return value_case() == kLoadSnapshotChunk;
}
inline bool Request::_internal_has_load_snapshot_chunk() const {
  return value_case() == kLoadSnapshotChunk;
}
inline void Request::set_has_load_snapshot_chunk() {
  _impl_._oneof_case_[0] = kLoadSnapshotChunk;
}
inline void Request::clear_load_snapshot_chunk() {
  if (value_case() == kLoadSnapshotChunk) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.load_snapshot_chunk_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestLoadSnapshotChunk* Request::release_load_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.load_snapshot_chunk)
  if (value_case() == kLoadSnapshotChunk) {
    clear_has_value();
    ::tendermint::abci::RequestLoadSnapshotChunk* temp = _impl_.value_.load_snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.load_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestLoadSnapshotChunk& Request::_internal_load_snapshot_chunk() const {
  return value_case() == kLoadSnapshotChunk
      ? *_impl_.value_.load_snapshot_chunk_
      : reinterpret_cast<::tendermint::abci::RequestLoadSnapshotChunk&>(::tendermint::abci::_RequestLoadSnapshotChunk_default_instance_);
}
inline const ::tendermint::abci::RequestLoadSnapshotChunk& Request::load_snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.load_snapshot_chunk)
  return _internal_load_snapshot_chunk();
}
inline ::tendermint::abci::RequestLoadSnapshotChunk* Request::unsafe_arena_release_load_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.load_snapshot_chunk)
  if (value_case() == kLoadSnapshotChunk) {
    clear_has_value();
    ::tendermint::abci::RequestLoadSnapshotChunk* temp = _impl_.value_.load_snapshot_chunk_;
    _impl_.value_.load_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_load_snapshot_chunk(::tendermint::abci::RequestLoadSnapshotChunk* load_snapshot_chunk) {
  clear_value();
  if (load_snapshot_chunk) {
    set_has_load_snapshot_chunk();
    _impl_.value_.load_snapshot_chunk_ = load_snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.load_snapshot_chunk)
}
inline ::tendermint::abci::RequestLoadSnapshotChunk* Request::_internal_mutable_load_snapshot_chunk() {
  if (value_case() != kLoadSnapshotChunk) {
    clear_value();
    set_has_load_snapshot_chunk();
    _impl_.value_.load_snapshot_chunk_ = CreateMaybeMessage< ::tendermint::abci::RequestLoadSnapshotChunk >(GetArenaForAllocation());
  }
  return _impl_.value_.load_snapshot_chunk_;
}
inline ::tendermint::abci::RequestLoadSnapshotChunk* Request::mutable_load_snapshot_chunk() {
  ::tendermint::abci::RequestLoadSnapshotChunk* _msg = _internal_mutable_load_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.load_snapshot_chunk)
  return _msg;
}

// .tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15 [json_name = "applySnapshotChunk"];
inline bool Request::has_apply_snapshot_chunk() const {
  return value_case() == kApplySnapshotChunk;
}
inline bool Request::_internal_has_apply_snapshot_chunk() const {
  return value_case() == kApplySnapshotChunk;
}
inline void Request::set_has_apply_snapshot_chunk() {
  _impl_._oneof_case_[0] = kApplySnapshotChunk;
}
inline void Request::clear_apply_snapshot_chunk() {
  if (value_case() == kApplySnapshotChunk) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.apply_snapshot_chunk_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestApplySnapshotChunk* Request::release_apply_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.apply_snapshot_chunk)
  if (value_case() == kApplySnapshotChunk) {
    clear_has_value();
    ::tendermint::abci::RequestApplySnapshotChunk* temp = _impl_.value_.apply_snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.apply_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestApplySnapshotChunk& Request::_internal_apply_snapshot_chunk() const {
  return value_case() == kApplySnapshotChunk
      ? *_impl_.value_.apply_snapshot_chunk_
      : reinterpret_cast<::tendermint::abci::RequestApplySnapshotChunk&>(::tendermint::abci::_RequestApplySnapshotChunk_default_instance_);
}
inline const ::tendermint::abci::RequestApplySnapshotChunk& Request::apply_snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.apply_snapshot_chunk)
  return _internal_apply_snapshot_chunk();
}
inline ::tendermint::abci::RequestApplySnapshotChunk* Request::unsafe_arena_release_apply_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.apply_snapshot_chunk)
  if (value_case() == kApplySnapshotChunk) {
    clear_has_value();
    ::tendermint::abci::RequestApplySnapshotChunk* temp = _impl_.value_.apply_snapshot_chunk_;
    _impl_.value_.apply_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_apply_snapshot_chunk(::tendermint::abci::RequestApplySnapshotChunk* apply_snapshot_chunk) {
  clear_value();
  if (apply_snapshot_chunk) {
    set_has_apply_snapshot_chunk();
    _impl_.value_.apply_snapshot_chunk_ = apply_snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.apply_snapshot_chunk)
}
inline ::tendermint::abci::RequestApplySnapshotChunk* Request::_internal_mutable_apply_snapshot_chunk() {
  if (value_case() != kApplySnapshotChunk) {
    clear_value();
    set_has_apply_snapshot_chunk();
    _impl_.value_.apply_snapshot_chunk_ = CreateMaybeMessage< ::tendermint::abci::RequestApplySnapshotChunk >(GetArenaForAllocation());
  }
  return _impl_.value_.apply_snapshot_chunk_;
}
inline ::tendermint::abci::RequestApplySnapshotChunk* Request::mutable_apply_snapshot_chunk() {
  ::tendermint::abci::RequestApplySnapshotChunk* _msg = _internal_mutable_apply_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.apply_snapshot_chunk)
  return _msg;
}

// .tendermint.abci.RequestPrepareProposal prepare_proposal = 16 [json_name = "prepareProposal"];
inline bool Request::has_prepare_proposal() const {
  return value_case() == kPrepareProposal;
}
inline bool Request::_internal_has_prepare_proposal() const {
  return value_case() == kPrepareProposal;
}
inline void Request::set_has_prepare_proposal() {
  _impl_._oneof_case_[0] = kPrepareProposal;
}
inline void Request::clear_prepare_proposal() {
  if (value_case() == kPrepareProposal) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.prepare_proposal_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestPrepareProposal* Request::release_prepare_proposal() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.prepare_proposal)
  if (value_case() == kPrepareProposal) {
    clear_has_value();
    ::tendermint::abci::RequestPrepareProposal* temp = _impl_.value_.prepare_proposal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.prepare_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestPrepareProposal& Request::_internal_prepare_proposal() const {
  return value_case() == kPrepareProposal
      ? *_impl_.value_.prepare_proposal_
      : reinterpret_cast<::tendermint::abci::RequestPrepareProposal&>(::tendermint::abci::_RequestPrepareProposal_default_instance_);
}
inline const ::tendermint::abci::RequestPrepareProposal& Request::prepare_proposal() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.prepare_proposal)
  return _internal_prepare_proposal();
}
inline ::tendermint::abci::RequestPrepareProposal* Request::unsafe_arena_release_prepare_proposal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.prepare_proposal)
  if (value_case() == kPrepareProposal) {
    clear_has_value();
    ::tendermint::abci::RequestPrepareProposal* temp = _impl_.value_.prepare_proposal_;
    _impl_.value_.prepare_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_prepare_proposal(::tendermint::abci::RequestPrepareProposal* prepare_proposal) {
  clear_value();
  if (prepare_proposal) {
    set_has_prepare_proposal();
    _impl_.value_.prepare_proposal_ = prepare_proposal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.prepare_proposal)
}
inline ::tendermint::abci::RequestPrepareProposal* Request::_internal_mutable_prepare_proposal() {
  if (value_case() != kPrepareProposal) {
    clear_value();
    set_has_prepare_proposal();
    _impl_.value_.prepare_proposal_ = CreateMaybeMessage< ::tendermint::abci::RequestPrepareProposal >(GetArenaForAllocation());
  }
  return _impl_.value_.prepare_proposal_;
}
inline ::tendermint::abci::RequestPrepareProposal* Request::mutable_prepare_proposal() {
  ::tendermint::abci::RequestPrepareProposal* _msg = _internal_mutable_prepare_proposal();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.prepare_proposal)
  return _msg;
}

// .tendermint.abci.RequestProcessProposal process_proposal = 17 [json_name = "processProposal"];
inline bool Request::has_process_proposal() const {
  return value_case() == kProcessProposal;
}
inline bool Request::_internal_has_process_proposal() const {
  return value_case() == kProcessProposal;
}
inline void Request::set_has_process_proposal() {
  _impl_._oneof_case_[0] = kProcessProposal;
}
inline void Request::clear_process_proposal() {
  if (value_case() == kProcessProposal) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.process_proposal_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestProcessProposal* Request::release_process_proposal() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.process_proposal)
  if (value_case() == kProcessProposal) {
    clear_has_value();
    ::tendermint::abci::RequestProcessProposal* temp = _impl_.value_.process_proposal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.process_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestProcessProposal& Request::_internal_process_proposal() const {
  return value_case() == kProcessProposal
      ? *_impl_.value_.process_proposal_
      : reinterpret_cast<::tendermint::abci::RequestProcessProposal&>(::tendermint::abci::_RequestProcessProposal_default_instance_);
}
inline const ::tendermint::abci::RequestProcessProposal& Request::process_proposal() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.process_proposal)
  return _internal_process_proposal();
}
inline ::tendermint::abci::RequestProcessProposal* Request::unsafe_arena_release_process_proposal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.process_proposal)
  if (value_case() == kProcessProposal) {
    clear_has_value();
    ::tendermint::abci::RequestProcessProposal* temp = _impl_.value_.process_proposal_;
    _impl_.value_.process_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_process_proposal(::tendermint::abci::RequestProcessProposal* process_proposal) {
  clear_value();
  if (process_proposal) {
    set_has_process_proposal();
    _impl_.value_.process_proposal_ = process_proposal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.process_proposal)
}
inline ::tendermint::abci::RequestProcessProposal* Request::_internal_mutable_process_proposal() {
  if (value_case() != kProcessProposal) {
    clear_value();
    set_has_process_proposal();
    _impl_.value_.process_proposal_ = CreateMaybeMessage< ::tendermint::abci::RequestProcessProposal >(GetArenaForAllocation());
  }
  return _impl_.value_.process_proposal_;
}
inline ::tendermint::abci::RequestProcessProposal* Request::mutable_process_proposal() {
  ::tendermint::abci::RequestProcessProposal* _msg = _internal_mutable_process_proposal();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.process_proposal)
  return _msg;
}

inline bool Request::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Request::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Request::ValueCase Request::value_case() const {
  return Request::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestEcho

// string message = 1 [json_name = "message"];
inline void RequestEcho::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RequestEcho::message() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestEcho.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestEcho::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestEcho.message)
}
inline std::string* RequestEcho::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestEcho.message)
  return _s;
}
inline const std::string& RequestEcho::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RequestEcho::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestEcho::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestEcho::release_message() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestEcho.message)
  return _impl_.message_.Release();
}
inline void RequestEcho::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestEcho.message)
}

// -------------------------------------------------------------------

// RequestFlush

// -------------------------------------------------------------------

// RequestInfo

// string version = 1 [json_name = "version"];
inline void RequestInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& RequestInfo::version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInfo.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestInfo::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInfo.version)
}
inline std::string* RequestInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInfo.version)
  return _s;
}
inline const std::string& RequestInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void RequestInfo::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestInfo::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestInfo::release_version() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInfo.version)
  return _impl_.version_.Release();
}
inline void RequestInfo::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInfo.version)
}

// uint64 block_version = 2 [json_name = "blockVersion"];
inline void RequestInfo::clear_block_version() {
  _impl_.block_version_ = ::uint64_t{0u};
}
inline ::uint64_t RequestInfo::block_version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInfo.block_version)
  return _internal_block_version();
}
inline void RequestInfo::set_block_version(::uint64_t value) {
  _internal_set_block_version(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInfo.block_version)
}
inline ::uint64_t RequestInfo::_internal_block_version() const {
  return _impl_.block_version_;
}
inline void RequestInfo::_internal_set_block_version(::uint64_t value) {
  ;
  _impl_.block_version_ = value;
}

// uint64 p2p_version = 3 [json_name = "p2pVersion"];
inline void RequestInfo::clear_p2p_version() {
  _impl_.p2p_version_ = ::uint64_t{0u};
}
inline ::uint64_t RequestInfo::p2p_version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInfo.p2p_version)
  return _internal_p2p_version();
}
inline void RequestInfo::set_p2p_version(::uint64_t value) {
  _internal_set_p2p_version(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInfo.p2p_version)
}
inline ::uint64_t RequestInfo::_internal_p2p_version() const {
  return _impl_.p2p_version_;
}
inline void RequestInfo::_internal_set_p2p_version(::uint64_t value) {
  ;
  _impl_.p2p_version_ = value;
}

// string abci_version = 4 [json_name = "abciVersion"];
inline void RequestInfo::clear_abci_version() {
  _impl_.abci_version_.ClearToEmpty();
}
inline const std::string& RequestInfo::abci_version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInfo.abci_version)
  return _internal_abci_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestInfo::set_abci_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.abci_version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInfo.abci_version)
}
inline std::string* RequestInfo::mutable_abci_version() {
  std::string* _s = _internal_mutable_abci_version();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInfo.abci_version)
  return _s;
}
inline const std::string& RequestInfo::_internal_abci_version() const {
  return _impl_.abci_version_.Get();
}
inline void RequestInfo::_internal_set_abci_version(const std::string& value) {
  ;


  _impl_.abci_version_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestInfo::_internal_mutable_abci_version() {
  ;
  return _impl_.abci_version_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestInfo::release_abci_version() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInfo.abci_version)
  return _impl_.abci_version_.Release();
}
inline void RequestInfo::set_allocated_abci_version(std::string* value) {
  _impl_.abci_version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.abci_version_.IsDefault()) {
          _impl_.abci_version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInfo.abci_version)
}

// -------------------------------------------------------------------

// RequestInitChain

// .google.protobuf.Timestamp time = 1 [json_name = "time", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool RequestInitChain::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RequestInitChain::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RequestInitChain::time() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.time)
  return _internal_time();
}
inline void RequestInitChain::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestInitChain.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestInitChain::release_time() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestInitChain::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInitChain.time)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestInitChain::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestInitChain::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.time)
  return _msg;
}
inline void RequestInitChain::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInitChain.time)
}

// string chain_id = 2 [json_name = "chainId"];
inline void RequestInitChain::clear_chain_id() {
  _impl_.chain_id_.ClearToEmpty();
}
inline const std::string& RequestInitChain::chain_id() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.chain_id)
  return _internal_chain_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestInitChain::set_chain_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.chain_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInitChain.chain_id)
}
inline std::string* RequestInitChain::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.chain_id)
  return _s;
}
inline const std::string& RequestInitChain::_internal_chain_id() const {
  return _impl_.chain_id_.Get();
}
inline void RequestInitChain::_internal_set_chain_id(const std::string& value) {
  ;


  _impl_.chain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestInitChain::_internal_mutable_chain_id() {
  ;
  return _impl_.chain_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestInitChain::release_chain_id() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInitChain.chain_id)
  return _impl_.chain_id_.Release();
}
inline void RequestInitChain::set_allocated_chain_id(std::string* value) {
  _impl_.chain_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chain_id_.IsDefault()) {
          _impl_.chain_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInitChain.chain_id)
}

// .tendermint.types.ConsensusParams consensus_params = 3 [json_name = "consensusParams"];
inline bool RequestInitChain::has_consensus_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consensus_params_ != nullptr);
  return value;
}
inline const ::tendermint::types::ConsensusParams& RequestInitChain::_internal_consensus_params() const {
  const ::tendermint::types::ConsensusParams* p = _impl_.consensus_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::ConsensusParams&>(
      ::tendermint::types::_ConsensusParams_default_instance_);
}
inline const ::tendermint::types::ConsensusParams& RequestInitChain::consensus_params() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.consensus_params)
  return _internal_consensus_params();
}
inline void RequestInitChain::unsafe_arena_set_allocated_consensus_params(
    ::tendermint::types::ConsensusParams* consensus_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_params_);
  }
  _impl_.consensus_params_ = consensus_params;
  if (consensus_params) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestInitChain.consensus_params)
}
inline ::tendermint::types::ConsensusParams* RequestInitChain::release_consensus_params() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::types::ConsensusParams* temp = _impl_.consensus_params_;
  _impl_.consensus_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::ConsensusParams* RequestInitChain::unsafe_arena_release_consensus_params() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInitChain.consensus_params)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::types::ConsensusParams* temp = _impl_.consensus_params_;
  _impl_.consensus_params_ = nullptr;
  return temp;
}
inline ::tendermint::types::ConsensusParams* RequestInitChain::_internal_mutable_consensus_params() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.consensus_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::ConsensusParams>(GetArenaForAllocation());
    _impl_.consensus_params_ = p;
  }
  return _impl_.consensus_params_;
}
inline ::tendermint::types::ConsensusParams* RequestInitChain::mutable_consensus_params() {
  ::tendermint::types::ConsensusParams* _msg = _internal_mutable_consensus_params();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.consensus_params)
  return _msg;
}
inline void RequestInitChain::set_allocated_consensus_params(::tendermint::types::ConsensusParams* consensus_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_params_);
  }
  if (consensus_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consensus_params));
    if (message_arena != submessage_arena) {
      consensus_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consensus_params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.consensus_params_ = consensus_params;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInitChain.consensus_params)
}

// repeated .tendermint.abci.ValidatorUpdate validators = 4 [json_name = "validators", (.gogoproto.nullable) = false];
inline int RequestInitChain::_internal_validators_size() const {
  return _impl_.validators_.size();
}
inline int RequestInitChain::validators_size() const {
  return _internal_validators_size();
}
inline void RequestInitChain::clear_validators() {
  _internal_mutable_validators()->Clear();
}
inline ::tendermint::abci::ValidatorUpdate* RequestInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.validators)
  return _internal_mutable_validators()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
RequestInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.RequestInitChain.validators)
  return _internal_mutable_validators();
}
inline const ::tendermint::abci::ValidatorUpdate& RequestInitChain::_internal_validators(int index) const {
  return _internal_validators().Get(index);
}
inline const ::tendermint::abci::ValidatorUpdate& RequestInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.validators)
  return _internal_validators(index);
}
inline ::tendermint::abci::ValidatorUpdate* RequestInitChain::_internal_add_validators() {
  return _internal_mutable_validators()->Add();
}
inline ::tendermint::abci::ValidatorUpdate* RequestInitChain::add_validators() {
  ::tendermint::abci::ValidatorUpdate* _add = _internal_add_validators();
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestInitChain.validators)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
RequestInitChain::validators() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.RequestInitChain.validators)
  return _internal_validators();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>&
RequestInitChain::_internal_validators() const {
  return _impl_.validators_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>*
RequestInitChain::_internal_mutable_validators() {
  return &_impl_.validators_;
}

// bytes app_state_bytes = 5 [json_name = "appStateBytes"];
inline void RequestInitChain::clear_app_state_bytes() {
  _impl_.app_state_bytes_.ClearToEmpty();
}
inline const std::string& RequestInitChain::app_state_bytes() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.app_state_bytes)
  return _internal_app_state_bytes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestInitChain::set_app_state_bytes(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.app_state_bytes_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInitChain.app_state_bytes)
}
inline std::string* RequestInitChain::mutable_app_state_bytes() {
  std::string* _s = _internal_mutable_app_state_bytes();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.app_state_bytes)
  return _s;
}
inline const std::string& RequestInitChain::_internal_app_state_bytes() const {
  return _impl_.app_state_bytes_.Get();
}
inline void RequestInitChain::_internal_set_app_state_bytes(const std::string& value) {
  ;


  _impl_.app_state_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestInitChain::_internal_mutable_app_state_bytes() {
  ;
  return _impl_.app_state_bytes_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestInitChain::release_app_state_bytes() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInitChain.app_state_bytes)
  return _impl_.app_state_bytes_.Release();
}
inline void RequestInitChain::set_allocated_app_state_bytes(std::string* value) {
  _impl_.app_state_bytes_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_state_bytes_.IsDefault()) {
          _impl_.app_state_bytes_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInitChain.app_state_bytes)
}

// int64 initial_height = 6 [json_name = "initialHeight"];
inline void RequestInitChain::clear_initial_height() {
  _impl_.initial_height_ = ::int64_t{0};
}
inline ::int64_t RequestInitChain::initial_height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.initial_height)
  return _internal_initial_height();
}
inline void RequestInitChain::set_initial_height(::int64_t value) {
  _internal_set_initial_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInitChain.initial_height)
}
inline ::int64_t RequestInitChain::_internal_initial_height() const {
  return _impl_.initial_height_;
}
inline void RequestInitChain::_internal_set_initial_height(::int64_t value) {
  ;
  _impl_.initial_height_ = value;
}

// -------------------------------------------------------------------

// RequestQuery

// bytes data = 1 [json_name = "data"];
inline void RequestQuery::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& RequestQuery::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestQuery.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestQuery::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestQuery.data)
}
inline std::string* RequestQuery::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestQuery.data)
  return _s;
}
inline const std::string& RequestQuery::_internal_data() const {
  return _impl_.data_.Get();
}
inline void RequestQuery::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestQuery::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestQuery::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestQuery.data)
  return _impl_.data_.Release();
}
inline void RequestQuery::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestQuery.data)
}

// string path = 2 [json_name = "path"];
inline void RequestQuery::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RequestQuery::path() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestQuery.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestQuery::set_path(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestQuery.path)
}
inline std::string* RequestQuery::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestQuery.path)
  return _s;
}
inline const std::string& RequestQuery::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RequestQuery::_internal_set_path(const std::string& value) {
  ;


  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestQuery::_internal_mutable_path() {
  ;
  return _impl_.path_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestQuery::release_path() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestQuery.path)
  return _impl_.path_.Release();
}
inline void RequestQuery::set_allocated_path(std::string* value) {
  _impl_.path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestQuery.path)
}

// int64 height = 3 [json_name = "height"];
inline void RequestQuery::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t RequestQuery::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestQuery.height)
  return _internal_height();
}
inline void RequestQuery::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestQuery.height)
}
inline ::int64_t RequestQuery::_internal_height() const {
  return _impl_.height_;
}
inline void RequestQuery::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// bool prove = 4 [json_name = "prove"];
inline void RequestQuery::clear_prove() {
  _impl_.prove_ = false;
}
inline bool RequestQuery::prove() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestQuery.prove)
  return _internal_prove();
}
inline void RequestQuery::set_prove(bool value) {
  _internal_set_prove(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestQuery.prove)
}
inline bool RequestQuery::_internal_prove() const {
  return _impl_.prove_;
}
inline void RequestQuery::_internal_set_prove(bool value) {
  ;
  _impl_.prove_ = value;
}

// -------------------------------------------------------------------

// RequestBeginBlock

// bytes hash = 1 [json_name = "hash"];
inline void RequestBeginBlock::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& RequestBeginBlock::hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestBeginBlock.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestBeginBlock::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestBeginBlock.hash)
}
inline std::string* RequestBeginBlock::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestBeginBlock.hash)
  return _s;
}
inline const std::string& RequestBeginBlock::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void RequestBeginBlock::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestBeginBlock::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestBeginBlock::release_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestBeginBlock.hash)
  return _impl_.hash_.Release();
}
inline void RequestBeginBlock::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestBeginBlock.hash)
}

// .tendermint.types.Header header = 2 [json_name = "header", (.gogoproto.nullable) = false];
inline bool RequestBeginBlock::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::tendermint::types::Header& RequestBeginBlock::_internal_header() const {
  const ::tendermint::types::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Header&>(
      ::tendermint::types::_Header_default_instance_);
}
inline const ::tendermint::types::Header& RequestBeginBlock::header() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestBeginBlock.header)
  return _internal_header();
}
inline void RequestBeginBlock::unsafe_arena_set_allocated_header(
    ::tendermint::types::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestBeginBlock.header)
}
inline ::tendermint::types::Header* RequestBeginBlock::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Header* RequestBeginBlock::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestBeginBlock.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::tendermint::types::Header* RequestBeginBlock::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::tendermint::types::Header* RequestBeginBlock::mutable_header() {
  ::tendermint::types::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestBeginBlock.header)
  return _msg;
}
inline void RequestBeginBlock::set_allocated_header(::tendermint::types::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestBeginBlock.header)
}

// .tendermint.abci.CommitInfo last_commit_info = 3 [json_name = "lastCommitInfo", (.gogoproto.nullable) = false];
inline bool RequestBeginBlock::has_last_commit_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_commit_info_ != nullptr);
  return value;
}
inline void RequestBeginBlock::clear_last_commit_info() {
  if (_impl_.last_commit_info_ != nullptr) _impl_.last_commit_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tendermint::abci::CommitInfo& RequestBeginBlock::_internal_last_commit_info() const {
  const ::tendermint::abci::CommitInfo* p = _impl_.last_commit_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::CommitInfo&>(
      ::tendermint::abci::_CommitInfo_default_instance_);
}
inline const ::tendermint::abci::CommitInfo& RequestBeginBlock::last_commit_info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestBeginBlock.last_commit_info)
  return _internal_last_commit_info();
}
inline void RequestBeginBlock::unsafe_arena_set_allocated_last_commit_info(
    ::tendermint::abci::CommitInfo* last_commit_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_commit_info_);
  }
  _impl_.last_commit_info_ = last_commit_info;
  if (last_commit_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestBeginBlock.last_commit_info)
}
inline ::tendermint::abci::CommitInfo* RequestBeginBlock::release_last_commit_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::abci::CommitInfo* temp = _impl_.last_commit_info_;
  _impl_.last_commit_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::CommitInfo* RequestBeginBlock::unsafe_arena_release_last_commit_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestBeginBlock.last_commit_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tendermint::abci::CommitInfo* temp = _impl_.last_commit_info_;
  _impl_.last_commit_info_ = nullptr;
  return temp;
}
inline ::tendermint::abci::CommitInfo* RequestBeginBlock::_internal_mutable_last_commit_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.last_commit_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::CommitInfo>(GetArenaForAllocation());
    _impl_.last_commit_info_ = p;
  }
  return _impl_.last_commit_info_;
}
inline ::tendermint::abci::CommitInfo* RequestBeginBlock::mutable_last_commit_info() {
  ::tendermint::abci::CommitInfo* _msg = _internal_mutable_last_commit_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestBeginBlock.last_commit_info)
  return _msg;
}
inline void RequestBeginBlock::set_allocated_last_commit_info(::tendermint::abci::CommitInfo* last_commit_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.last_commit_info_;
  }
  if (last_commit_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(last_commit_info);
    if (message_arena != submessage_arena) {
      last_commit_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_commit_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.last_commit_info_ = last_commit_info;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestBeginBlock.last_commit_info)
}

// repeated .tendermint.abci.Misbehavior byzantine_validators = 4 [json_name = "byzantineValidators", (.gogoproto.nullable) = false];
inline int RequestBeginBlock::_internal_byzantine_validators_size() const {
  return _impl_.byzantine_validators_.size();
}
inline int RequestBeginBlock::byzantine_validators_size() const {
  return _internal_byzantine_validators_size();
}
inline void RequestBeginBlock::clear_byzantine_validators() {
  _internal_mutable_byzantine_validators()->Clear();
}
inline ::tendermint::abci::Misbehavior* RequestBeginBlock::mutable_byzantine_validators(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return _internal_mutable_byzantine_validators()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >*
RequestBeginBlock::mutable_byzantine_validators() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return _internal_mutable_byzantine_validators();
}
inline const ::tendermint::abci::Misbehavior& RequestBeginBlock::_internal_byzantine_validators(int index) const {
  return _internal_byzantine_validators().Get(index);
}
inline const ::tendermint::abci::Misbehavior& RequestBeginBlock::byzantine_validators(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return _internal_byzantine_validators(index);
}
inline ::tendermint::abci::Misbehavior* RequestBeginBlock::_internal_add_byzantine_validators() {
  return _internal_mutable_byzantine_validators()->Add();
}
inline ::tendermint::abci::Misbehavior* RequestBeginBlock::add_byzantine_validators() {
  ::tendermint::abci::Misbehavior* _add = _internal_add_byzantine_validators();
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >&
RequestBeginBlock::byzantine_validators() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return _internal_byzantine_validators();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>&
RequestBeginBlock::_internal_byzantine_validators() const {
  return _impl_.byzantine_validators_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>*
RequestBeginBlock::_internal_mutable_byzantine_validators() {
  return &_impl_.byzantine_validators_;
}

// -------------------------------------------------------------------

// RequestCheckTx

// bytes tx = 1 [json_name = "tx"];
inline void RequestCheckTx::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& RequestCheckTx::tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestCheckTx.tx)
  return _internal_tx();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestCheckTx::set_tx(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestCheckTx.tx)
}
inline std::string* RequestCheckTx::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestCheckTx.tx)
  return _s;
}
inline const std::string& RequestCheckTx::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void RequestCheckTx::_internal_set_tx(const std::string& value) {
  ;


  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestCheckTx::_internal_mutable_tx() {
  ;
  return _impl_.tx_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestCheckTx::release_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestCheckTx.tx)
  return _impl_.tx_.Release();
}
inline void RequestCheckTx::set_allocated_tx(std::string* value) {
  _impl_.tx_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_.IsDefault()) {
          _impl_.tx_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestCheckTx.tx)
}

// .tendermint.abci.CheckTxType type = 2 [json_name = "type"];
inline void RequestCheckTx::clear_type() {
  _impl_.type_ = 0;
}
inline ::tendermint::abci::CheckTxType RequestCheckTx::type() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestCheckTx.type)
  return _internal_type();
}
inline void RequestCheckTx::set_type(::tendermint::abci::CheckTxType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestCheckTx.type)
}
inline ::tendermint::abci::CheckTxType RequestCheckTx::_internal_type() const {
  return static_cast<::tendermint::abci::CheckTxType>(_impl_.type_);
}
inline void RequestCheckTx::_internal_set_type(::tendermint::abci::CheckTxType value) {
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// RequestDeliverTx

// bytes tx = 1 [json_name = "tx"];
inline void RequestDeliverTx::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& RequestDeliverTx::tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestDeliverTx.tx)
  return _internal_tx();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestDeliverTx::set_tx(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestDeliverTx.tx)
}
inline std::string* RequestDeliverTx::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestDeliverTx.tx)
  return _s;
}
inline const std::string& RequestDeliverTx::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void RequestDeliverTx::_internal_set_tx(const std::string& value) {
  ;


  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestDeliverTx::_internal_mutable_tx() {
  ;
  return _impl_.tx_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestDeliverTx::release_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestDeliverTx.tx)
  return _impl_.tx_.Release();
}
inline void RequestDeliverTx::set_allocated_tx(std::string* value) {
  _impl_.tx_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_.IsDefault()) {
          _impl_.tx_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestDeliverTx.tx)
}

// -------------------------------------------------------------------

// RequestEndBlock

// int64 height = 1 [json_name = "height"];
inline void RequestEndBlock::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t RequestEndBlock::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestEndBlock.height)
  return _internal_height();
}
inline void RequestEndBlock::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestEndBlock.height)
}
inline ::int64_t RequestEndBlock::_internal_height() const {
  return _impl_.height_;
}
inline void RequestEndBlock::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// RequestCommit

// -------------------------------------------------------------------

// RequestListSnapshots

// -------------------------------------------------------------------

// RequestOfferSnapshot

// .tendermint.abci.Snapshot snapshot = 1 [json_name = "snapshot"];
inline bool RequestOfferSnapshot::has_snapshot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.snapshot_ != nullptr);
  return value;
}
inline void RequestOfferSnapshot::clear_snapshot() {
  if (_impl_.snapshot_ != nullptr) _impl_.snapshot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tendermint::abci::Snapshot& RequestOfferSnapshot::_internal_snapshot() const {
  const ::tendermint::abci::Snapshot* p = _impl_.snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::Snapshot&>(
      ::tendermint::abci::_Snapshot_default_instance_);
}
inline const ::tendermint::abci::Snapshot& RequestOfferSnapshot::snapshot() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestOfferSnapshot.snapshot)
  return _internal_snapshot();
}
inline void RequestOfferSnapshot::unsafe_arena_set_allocated_snapshot(
    ::tendermint::abci::Snapshot* snapshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.snapshot_);
  }
  _impl_.snapshot_ = snapshot;
  if (snapshot) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestOfferSnapshot.snapshot)
}
inline ::tendermint::abci::Snapshot* RequestOfferSnapshot::release_snapshot() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::Snapshot* temp = _impl_.snapshot_;
  _impl_.snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::Snapshot* RequestOfferSnapshot::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestOfferSnapshot.snapshot)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::Snapshot* temp = _impl_.snapshot_;
  _impl_.snapshot_ = nullptr;
  return temp;
}
inline ::tendermint::abci::Snapshot* RequestOfferSnapshot::_internal_mutable_snapshot() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::Snapshot>(GetArenaForAllocation());
    _impl_.snapshot_ = p;
  }
  return _impl_.snapshot_;
}
inline ::tendermint::abci::Snapshot* RequestOfferSnapshot::mutable_snapshot() {
  ::tendermint::abci::Snapshot* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestOfferSnapshot.snapshot)
  return _msg;
}
inline void RequestOfferSnapshot::set_allocated_snapshot(::tendermint::abci::Snapshot* snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.snapshot_;
  }
  if (snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshot);
    if (message_arena != submessage_arena) {
      snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.snapshot_ = snapshot;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestOfferSnapshot.snapshot)
}

// bytes app_hash = 2 [json_name = "appHash"];
inline void RequestOfferSnapshot::clear_app_hash() {
  _impl_.app_hash_.ClearToEmpty();
}
inline const std::string& RequestOfferSnapshot::app_hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestOfferSnapshot.app_hash)
  return _internal_app_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestOfferSnapshot::set_app_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.app_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestOfferSnapshot.app_hash)
}
inline std::string* RequestOfferSnapshot::mutable_app_hash() {
  std::string* _s = _internal_mutable_app_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestOfferSnapshot.app_hash)
  return _s;
}
inline const std::string& RequestOfferSnapshot::_internal_app_hash() const {
  return _impl_.app_hash_.Get();
}
inline void RequestOfferSnapshot::_internal_set_app_hash(const std::string& value) {
  ;


  _impl_.app_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestOfferSnapshot::_internal_mutable_app_hash() {
  ;
  return _impl_.app_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestOfferSnapshot::release_app_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestOfferSnapshot.app_hash)
  return _impl_.app_hash_.Release();
}
inline void RequestOfferSnapshot::set_allocated_app_hash(std::string* value) {
  _impl_.app_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_hash_.IsDefault()) {
          _impl_.app_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestOfferSnapshot.app_hash)
}

// -------------------------------------------------------------------

// RequestLoadSnapshotChunk

// uint64 height = 1 [json_name = "height"];
inline void RequestLoadSnapshotChunk::clear_height() {
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t RequestLoadSnapshotChunk::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestLoadSnapshotChunk.height)
  return _internal_height();
}
inline void RequestLoadSnapshotChunk::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestLoadSnapshotChunk.height)
}
inline ::uint64_t RequestLoadSnapshotChunk::_internal_height() const {
  return _impl_.height_;
}
inline void RequestLoadSnapshotChunk::_internal_set_height(::uint64_t value) {
  ;
  _impl_.height_ = value;
}

// uint32 format = 2 [json_name = "format"];
inline void RequestLoadSnapshotChunk::clear_format() {
  _impl_.format_ = 0u;
}
inline ::uint32_t RequestLoadSnapshotChunk::format() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestLoadSnapshotChunk.format)
  return _internal_format();
}
inline void RequestLoadSnapshotChunk::set_format(::uint32_t value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestLoadSnapshotChunk.format)
}
inline ::uint32_t RequestLoadSnapshotChunk::_internal_format() const {
  return _impl_.format_;
}
inline void RequestLoadSnapshotChunk::_internal_set_format(::uint32_t value) {
  ;
  _impl_.format_ = value;
}

// uint32 chunk = 3 [json_name = "chunk"];
inline void RequestLoadSnapshotChunk::clear_chunk() {
  _impl_.chunk_ = 0u;
}
inline ::uint32_t RequestLoadSnapshotChunk::chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestLoadSnapshotChunk.chunk)
  return _internal_chunk();
}
inline void RequestLoadSnapshotChunk::set_chunk(::uint32_t value) {
  _internal_set_chunk(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestLoadSnapshotChunk.chunk)
}
inline ::uint32_t RequestLoadSnapshotChunk::_internal_chunk() const {
  return _impl_.chunk_;
}
inline void RequestLoadSnapshotChunk::_internal_set_chunk(::uint32_t value) {
  ;
  _impl_.chunk_ = value;
}

// -------------------------------------------------------------------

// RequestApplySnapshotChunk

// uint32 index = 1 [json_name = "index"];
inline void RequestApplySnapshotChunk::clear_index() {
  _impl_.index_ = 0u;
}
inline ::uint32_t RequestApplySnapshotChunk::index() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestApplySnapshotChunk.index)
  return _internal_index();
}
inline void RequestApplySnapshotChunk::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestApplySnapshotChunk.index)
}
inline ::uint32_t RequestApplySnapshotChunk::_internal_index() const {
  return _impl_.index_;
}
inline void RequestApplySnapshotChunk::_internal_set_index(::uint32_t value) {
  ;
  _impl_.index_ = value;
}

// bytes chunk = 2 [json_name = "chunk"];
inline void RequestApplySnapshotChunk::clear_chunk() {
  _impl_.chunk_.ClearToEmpty();
}
inline const std::string& RequestApplySnapshotChunk::chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestApplySnapshotChunk.chunk)
  return _internal_chunk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestApplySnapshotChunk::set_chunk(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.chunk_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestApplySnapshotChunk.chunk)
}
inline std::string* RequestApplySnapshotChunk::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestApplySnapshotChunk.chunk)
  return _s;
}
inline const std::string& RequestApplySnapshotChunk::_internal_chunk() const {
  return _impl_.chunk_.Get();
}
inline void RequestApplySnapshotChunk::_internal_set_chunk(const std::string& value) {
  ;


  _impl_.chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestApplySnapshotChunk::_internal_mutable_chunk() {
  ;
  return _impl_.chunk_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestApplySnapshotChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestApplySnapshotChunk.chunk)
  return _impl_.chunk_.Release();
}
inline void RequestApplySnapshotChunk::set_allocated_chunk(std::string* value) {
  _impl_.chunk_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chunk_.IsDefault()) {
          _impl_.chunk_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestApplySnapshotChunk.chunk)
}

// string sender = 3 [json_name = "sender"];
inline void RequestApplySnapshotChunk::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& RequestApplySnapshotChunk::sender() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestApplySnapshotChunk.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestApplySnapshotChunk::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestApplySnapshotChunk.sender)
}
inline std::string* RequestApplySnapshotChunk::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestApplySnapshotChunk.sender)
  return _s;
}
inline const std::string& RequestApplySnapshotChunk::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void RequestApplySnapshotChunk::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestApplySnapshotChunk::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestApplySnapshotChunk::release_sender() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestApplySnapshotChunk.sender)
  return _impl_.sender_.Release();
}
inline void RequestApplySnapshotChunk::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestApplySnapshotChunk.sender)
}

// -------------------------------------------------------------------

// RequestPrepareProposal

// int64 max_tx_bytes = 1 [json_name = "maxTxBytes"];
inline void RequestPrepareProposal::clear_max_tx_bytes() {
  _impl_.max_tx_bytes_ = ::int64_t{0};
}
inline ::int64_t RequestPrepareProposal::max_tx_bytes() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestPrepareProposal.max_tx_bytes)
  return _internal_max_tx_bytes();
}
inline void RequestPrepareProposal::set_max_tx_bytes(::int64_t value) {
  _internal_set_max_tx_bytes(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestPrepareProposal.max_tx_bytes)
}
inline ::int64_t RequestPrepareProposal::_internal_max_tx_bytes() const {
  return _impl_.max_tx_bytes_;
}
inline void RequestPrepareProposal::_internal_set_max_tx_bytes(::int64_t value) {
  ;
  _impl_.max_tx_bytes_ = value;
}

// repeated bytes txs = 2 [json_name = "txs"];
inline int RequestPrepareProposal::_internal_txs_size() const {
  return _impl_.txs_.size();
}
inline int RequestPrepareProposal::txs_size() const {
  return _internal_txs_size();
}
inline void RequestPrepareProposal::clear_txs() {
  _internal_mutable_txs()->Clear();
}
inline std::string* RequestPrepareProposal::add_txs() {
  std::string* _s = _internal_add_txs();
  // @@protoc_insertion_point(field_add_mutable:tendermint.abci.RequestPrepareProposal.txs)
  return _s;
}
inline const std::string& RequestPrepareProposal::txs(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestPrepareProposal.txs)
  return _internal_txs(index);
}
inline std::string* RequestPrepareProposal::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestPrepareProposal.txs)
  return _internal_mutable_txs()->Mutable(index);
}
inline void RequestPrepareProposal::set_txs(int index, const std::string& value) {
  _internal_mutable_txs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::set_txs(int index, std::string&& value) {
  _internal_mutable_txs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::set_txs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_txs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::set_txs(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_txs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::set_txs(int index, absl::string_view value) {
  _internal_mutable_txs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::add_txs(const std::string& value) {
  _internal_mutable_txs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::add_txs(std::string&& value) {
  _internal_mutable_txs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::add_txs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_txs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::add_txs(const void* value, std::size_t size) {
  _internal_mutable_txs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tendermint.abci.RequestPrepareProposal.txs)
}
inline void RequestPrepareProposal::add_txs(absl::string_view value) {
  _internal_mutable_txs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:tendermint.abci.RequestPrepareProposal.txs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestPrepareProposal::txs() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.RequestPrepareProposal.txs)
  return _internal_txs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* RequestPrepareProposal::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.RequestPrepareProposal.txs)
  return _internal_mutable_txs();
}
inline const std::string& RequestPrepareProposal::_internal_txs(int index) const {
  return _internal_txs().Get(index);
}
inline std::string* RequestPrepareProposal::_internal_add_txs() {
  return _internal_mutable_txs()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestPrepareProposal::_internal_txs() const {
  return _impl_.txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestPrepareProposal::_internal_mutable_txs() {
  return &_impl_.txs_;
}

// .tendermint.abci.ExtendedCommitInfo local_last_commit = 3 [json_name = "localLastCommit", (.gogoproto.nullable) = false];
inline bool RequestPrepareProposal::has_local_last_commit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.local_last_commit_ != nullptr);
  return value;
}
inline void RequestPrepareProposal::clear_local_last_commit() {
  if (_impl_.local_last_commit_ != nullptr) _impl_.local_last_commit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tendermint::abci::ExtendedCommitInfo& RequestPrepareProposal::_internal_local_last_commit() const {
  const ::tendermint::abci::ExtendedCommitInfo* p = _impl_.local_last_commit_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::ExtendedCommitInfo&>(
      ::tendermint::abci::_ExtendedCommitInfo_default_instance_);
}
inline const ::tendermint::abci::ExtendedCommitInfo& RequestPrepareProposal::local_last_commit() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestPrepareProposal.local_last_commit)
  return _internal_local_last_commit();
}
inline void RequestPrepareProposal::unsafe_arena_set_allocated_local_last_commit(
    ::tendermint::abci::ExtendedCommitInfo* local_last_commit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_last_commit_);
  }
  _impl_.local_last_commit_ = local_last_commit;
  if (local_last_commit) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestPrepareProposal.local_last_commit)
}
inline ::tendermint::abci::ExtendedCommitInfo* RequestPrepareProposal::release_local_last_commit() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::ExtendedCommitInfo* temp = _impl_.local_last_commit_;
  _impl_.local_last_commit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::ExtendedCommitInfo* RequestPrepareProposal::unsafe_arena_release_local_last_commit() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestPrepareProposal.local_last_commit)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::ExtendedCommitInfo* temp = _impl_.local_last_commit_;
  _impl_.local_last_commit_ = nullptr;
  return temp;
}
inline ::tendermint::abci::ExtendedCommitInfo* RequestPrepareProposal::_internal_mutable_local_last_commit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.local_last_commit_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::ExtendedCommitInfo>(GetArenaForAllocation());
    _impl_.local_last_commit_ = p;
  }
  return _impl_.local_last_commit_;
}
inline ::tendermint::abci::ExtendedCommitInfo* RequestPrepareProposal::mutable_local_last_commit() {
  ::tendermint::abci::ExtendedCommitInfo* _msg = _internal_mutable_local_last_commit();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestPrepareProposal.local_last_commit)
  return _msg;
}
inline void RequestPrepareProposal::set_allocated_local_last_commit(::tendermint::abci::ExtendedCommitInfo* local_last_commit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_last_commit_;
  }
  if (local_last_commit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_last_commit);
    if (message_arena != submessage_arena) {
      local_last_commit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_last_commit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.local_last_commit_ = local_last_commit;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestPrepareProposal.local_last_commit)
}

// repeated .tendermint.abci.Misbehavior misbehavior = 4 [json_name = "misbehavior", (.gogoproto.nullable) = false];
inline int RequestPrepareProposal::_internal_misbehavior_size() const {
  return _impl_.misbehavior_.size();
}
inline int RequestPrepareProposal::misbehavior_size() const {
  return _internal_misbehavior_size();
}
inline void RequestPrepareProposal::clear_misbehavior() {
  _internal_mutable_misbehavior()->Clear();
}
inline ::tendermint::abci::Misbehavior* RequestPrepareProposal::mutable_misbehavior(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestPrepareProposal.misbehavior)
  return _internal_mutable_misbehavior()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >*
RequestPrepareProposal::mutable_misbehavior() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.RequestPrepareProposal.misbehavior)
  return _internal_mutable_misbehavior();
}
inline const ::tendermint::abci::Misbehavior& RequestPrepareProposal::_internal_misbehavior(int index) const {
  return _internal_misbehavior().Get(index);
}
inline const ::tendermint::abci::Misbehavior& RequestPrepareProposal::misbehavior(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestPrepareProposal.misbehavior)
  return _internal_misbehavior(index);
}
inline ::tendermint::abci::Misbehavior* RequestPrepareProposal::_internal_add_misbehavior() {
  return _internal_mutable_misbehavior()->Add();
}
inline ::tendermint::abci::Misbehavior* RequestPrepareProposal::add_misbehavior() {
  ::tendermint::abci::Misbehavior* _add = _internal_add_misbehavior();
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestPrepareProposal.misbehavior)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >&
RequestPrepareProposal::misbehavior() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.RequestPrepareProposal.misbehavior)
  return _internal_misbehavior();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>&
RequestPrepareProposal::_internal_misbehavior() const {
  return _impl_.misbehavior_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>*
RequestPrepareProposal::_internal_mutable_misbehavior() {
  return &_impl_.misbehavior_;
}

// int64 height = 5 [json_name = "height"];
inline void RequestPrepareProposal::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t RequestPrepareProposal::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestPrepareProposal.height)
  return _internal_height();
}
inline void RequestPrepareProposal::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestPrepareProposal.height)
}
inline ::int64_t RequestPrepareProposal::_internal_height() const {
  return _impl_.height_;
}
inline void RequestPrepareProposal::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// .google.protobuf.Timestamp time = 6 [json_name = "time", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool RequestPrepareProposal::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RequestPrepareProposal::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RequestPrepareProposal::time() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestPrepareProposal.time)
  return _internal_time();
}
inline void RequestPrepareProposal::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestPrepareProposal.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestPrepareProposal::release_time() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestPrepareProposal::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestPrepareProposal.time)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestPrepareProposal::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestPrepareProposal::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestPrepareProposal.time)
  return _msg;
}
inline void RequestPrepareProposal::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestPrepareProposal.time)
}

// bytes next_validators_hash = 7 [json_name = "nextValidatorsHash"];
inline void RequestPrepareProposal::clear_next_validators_hash() {
  _impl_.next_validators_hash_.ClearToEmpty();
}
inline const std::string& RequestPrepareProposal::next_validators_hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestPrepareProposal.next_validators_hash)
  return _internal_next_validators_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestPrepareProposal::set_next_validators_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.next_validators_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestPrepareProposal.next_validators_hash)
}
inline std::string* RequestPrepareProposal::mutable_next_validators_hash() {
  std::string* _s = _internal_mutable_next_validators_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestPrepareProposal.next_validators_hash)
  return _s;
}
inline const std::string& RequestPrepareProposal::_internal_next_validators_hash() const {
  return _impl_.next_validators_hash_.Get();
}
inline void RequestPrepareProposal::_internal_set_next_validators_hash(const std::string& value) {
  ;


  _impl_.next_validators_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestPrepareProposal::_internal_mutable_next_validators_hash() {
  ;
  return _impl_.next_validators_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestPrepareProposal::release_next_validators_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestPrepareProposal.next_validators_hash)
  return _impl_.next_validators_hash_.Release();
}
inline void RequestPrepareProposal::set_allocated_next_validators_hash(std::string* value) {
  _impl_.next_validators_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_validators_hash_.IsDefault()) {
          _impl_.next_validators_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestPrepareProposal.next_validators_hash)
}

// bytes proposer_address = 8 [json_name = "proposerAddress"];
inline void RequestPrepareProposal::clear_proposer_address() {
  _impl_.proposer_address_.ClearToEmpty();
}
inline const std::string& RequestPrepareProposal::proposer_address() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestPrepareProposal.proposer_address)
  return _internal_proposer_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestPrepareProposal::set_proposer_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proposer_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestPrepareProposal.proposer_address)
}
inline std::string* RequestPrepareProposal::mutable_proposer_address() {
  std::string* _s = _internal_mutable_proposer_address();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestPrepareProposal.proposer_address)
  return _s;
}
inline const std::string& RequestPrepareProposal::_internal_proposer_address() const {
  return _impl_.proposer_address_.Get();
}
inline void RequestPrepareProposal::_internal_set_proposer_address(const std::string& value) {
  ;


  _impl_.proposer_address_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestPrepareProposal::_internal_mutable_proposer_address() {
  ;
  return _impl_.proposer_address_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestPrepareProposal::release_proposer_address() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestPrepareProposal.proposer_address)
  return _impl_.proposer_address_.Release();
}
inline void RequestPrepareProposal::set_allocated_proposer_address(std::string* value) {
  _impl_.proposer_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proposer_address_.IsDefault()) {
          _impl_.proposer_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestPrepareProposal.proposer_address)
}

// -------------------------------------------------------------------

// RequestProcessProposal

// repeated bytes txs = 1 [json_name = "txs"];
inline int RequestProcessProposal::_internal_txs_size() const {
  return _impl_.txs_.size();
}
inline int RequestProcessProposal::txs_size() const {
  return _internal_txs_size();
}
inline void RequestProcessProposal::clear_txs() {
  _internal_mutable_txs()->Clear();
}
inline std::string* RequestProcessProposal::add_txs() {
  std::string* _s = _internal_add_txs();
  // @@protoc_insertion_point(field_add_mutable:tendermint.abci.RequestProcessProposal.txs)
  return _s;
}
inline const std::string& RequestProcessProposal::txs(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestProcessProposal.txs)
  return _internal_txs(index);
}
inline std::string* RequestProcessProposal::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestProcessProposal.txs)
  return _internal_mutable_txs()->Mutable(index);
}
inline void RequestProcessProposal::set_txs(int index, const std::string& value) {
  _internal_mutable_txs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::set_txs(int index, std::string&& value) {
  _internal_mutable_txs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::set_txs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_txs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::set_txs(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_txs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::set_txs(int index, absl::string_view value) {
  _internal_mutable_txs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::add_txs(const std::string& value) {
  _internal_mutable_txs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::add_txs(std::string&& value) {
  _internal_mutable_txs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::add_txs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_txs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::add_txs(const void* value, std::size_t size) {
  _internal_mutable_txs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tendermint.abci.RequestProcessProposal.txs)
}
inline void RequestProcessProposal::add_txs(absl::string_view value) {
  _internal_mutable_txs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:tendermint.abci.RequestProcessProposal.txs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestProcessProposal::txs() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.RequestProcessProposal.txs)
  return _internal_txs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* RequestProcessProposal::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.RequestProcessProposal.txs)
  return _internal_mutable_txs();
}
inline const std::string& RequestProcessProposal::_internal_txs(int index) const {
  return _internal_txs().Get(index);
}
inline std::string* RequestProcessProposal::_internal_add_txs() {
  return _internal_mutable_txs()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestProcessProposal::_internal_txs() const {
  return _impl_.txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestProcessProposal::_internal_mutable_txs() {
  return &_impl_.txs_;
}

// .tendermint.abci.CommitInfo proposed_last_commit = 2 [json_name = "proposedLastCommit", (.gogoproto.nullable) = false];
inline bool RequestProcessProposal::has_proposed_last_commit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proposed_last_commit_ != nullptr);
  return value;
}
inline void RequestProcessProposal::clear_proposed_last_commit() {
  if (_impl_.proposed_last_commit_ != nullptr) _impl_.proposed_last_commit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tendermint::abci::CommitInfo& RequestProcessProposal::_internal_proposed_last_commit() const {
  const ::tendermint::abci::CommitInfo* p = _impl_.proposed_last_commit_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::CommitInfo&>(
      ::tendermint::abci::_CommitInfo_default_instance_);
}
inline const ::tendermint::abci::CommitInfo& RequestProcessProposal::proposed_last_commit() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestProcessProposal.proposed_last_commit)
  return _internal_proposed_last_commit();
}
inline void RequestProcessProposal::unsafe_arena_set_allocated_proposed_last_commit(
    ::tendermint::abci::CommitInfo* proposed_last_commit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proposed_last_commit_);
  }
  _impl_.proposed_last_commit_ = proposed_last_commit;
  if (proposed_last_commit) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestProcessProposal.proposed_last_commit)
}
inline ::tendermint::abci::CommitInfo* RequestProcessProposal::release_proposed_last_commit() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::CommitInfo* temp = _impl_.proposed_last_commit_;
  _impl_.proposed_last_commit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::CommitInfo* RequestProcessProposal::unsafe_arena_release_proposed_last_commit() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestProcessProposal.proposed_last_commit)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::CommitInfo* temp = _impl_.proposed_last_commit_;
  _impl_.proposed_last_commit_ = nullptr;
  return temp;
}
inline ::tendermint::abci::CommitInfo* RequestProcessProposal::_internal_mutable_proposed_last_commit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proposed_last_commit_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::CommitInfo>(GetArenaForAllocation());
    _impl_.proposed_last_commit_ = p;
  }
  return _impl_.proposed_last_commit_;
}
inline ::tendermint::abci::CommitInfo* RequestProcessProposal::mutable_proposed_last_commit() {
  ::tendermint::abci::CommitInfo* _msg = _internal_mutable_proposed_last_commit();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestProcessProposal.proposed_last_commit)
  return _msg;
}
inline void RequestProcessProposal::set_allocated_proposed_last_commit(::tendermint::abci::CommitInfo* proposed_last_commit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.proposed_last_commit_;
  }
  if (proposed_last_commit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(proposed_last_commit);
    if (message_arena != submessage_arena) {
      proposed_last_commit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposed_last_commit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.proposed_last_commit_ = proposed_last_commit;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestProcessProposal.proposed_last_commit)
}

// repeated .tendermint.abci.Misbehavior misbehavior = 3 [json_name = "misbehavior", (.gogoproto.nullable) = false];
inline int RequestProcessProposal::_internal_misbehavior_size() const {
  return _impl_.misbehavior_.size();
}
inline int RequestProcessProposal::misbehavior_size() const {
  return _internal_misbehavior_size();
}
inline void RequestProcessProposal::clear_misbehavior() {
  _internal_mutable_misbehavior()->Clear();
}
inline ::tendermint::abci::Misbehavior* RequestProcessProposal::mutable_misbehavior(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestProcessProposal.misbehavior)
  return _internal_mutable_misbehavior()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >*
RequestProcessProposal::mutable_misbehavior() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.RequestProcessProposal.misbehavior)
  return _internal_mutable_misbehavior();
}
inline const ::tendermint::abci::Misbehavior& RequestProcessProposal::_internal_misbehavior(int index) const {
  return _internal_misbehavior().Get(index);
}
inline const ::tendermint::abci::Misbehavior& RequestProcessProposal::misbehavior(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestProcessProposal.misbehavior)
  return _internal_misbehavior(index);
}
inline ::tendermint::abci::Misbehavior* RequestProcessProposal::_internal_add_misbehavior() {
  return _internal_mutable_misbehavior()->Add();
}
inline ::tendermint::abci::Misbehavior* RequestProcessProposal::add_misbehavior() {
  ::tendermint::abci::Misbehavior* _add = _internal_add_misbehavior();
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestProcessProposal.misbehavior)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Misbehavior >&
RequestProcessProposal::misbehavior() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.RequestProcessProposal.misbehavior)
  return _internal_misbehavior();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>&
RequestProcessProposal::_internal_misbehavior() const {
  return _impl_.misbehavior_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Misbehavior>*
RequestProcessProposal::_internal_mutable_misbehavior() {
  return &_impl_.misbehavior_;
}

// bytes hash = 4 [json_name = "hash"];
inline void RequestProcessProposal::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& RequestProcessProposal::hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestProcessProposal.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestProcessProposal::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestProcessProposal.hash)
}
inline std::string* RequestProcessProposal::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestProcessProposal.hash)
  return _s;
}
inline const std::string& RequestProcessProposal::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void RequestProcessProposal::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestProcessProposal::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestProcessProposal::release_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestProcessProposal.hash)
  return _impl_.hash_.Release();
}
inline void RequestProcessProposal::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestProcessProposal.hash)
}

// int64 height = 5 [json_name = "height"];
inline void RequestProcessProposal::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t RequestProcessProposal::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestProcessProposal.height)
  return _internal_height();
}
inline void RequestProcessProposal::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestProcessProposal.height)
}
inline ::int64_t RequestProcessProposal::_internal_height() const {
  return _impl_.height_;
}
inline void RequestProcessProposal::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// .google.protobuf.Timestamp time = 6 [json_name = "time", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool RequestProcessProposal::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RequestProcessProposal::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RequestProcessProposal::time() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestProcessProposal.time)
  return _internal_time();
}
inline void RequestProcessProposal::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestProcessProposal.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestProcessProposal::release_time() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestProcessProposal::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestProcessProposal.time)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestProcessProposal::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestProcessProposal::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestProcessProposal.time)
  return _msg;
}
inline void RequestProcessProposal::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestProcessProposal.time)
}

// bytes next_validators_hash = 7 [json_name = "nextValidatorsHash"];
inline void RequestProcessProposal::clear_next_validators_hash() {
  _impl_.next_validators_hash_.ClearToEmpty();
}
inline const std::string& RequestProcessProposal::next_validators_hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestProcessProposal.next_validators_hash)
  return _internal_next_validators_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestProcessProposal::set_next_validators_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.next_validators_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestProcessProposal.next_validators_hash)
}
inline std::string* RequestProcessProposal::mutable_next_validators_hash() {
  std::string* _s = _internal_mutable_next_validators_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestProcessProposal.next_validators_hash)
  return _s;
}
inline const std::string& RequestProcessProposal::_internal_next_validators_hash() const {
  return _impl_.next_validators_hash_.Get();
}
inline void RequestProcessProposal::_internal_set_next_validators_hash(const std::string& value) {
  ;


  _impl_.next_validators_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestProcessProposal::_internal_mutable_next_validators_hash() {
  ;
  return _impl_.next_validators_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestProcessProposal::release_next_validators_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestProcessProposal.next_validators_hash)
  return _impl_.next_validators_hash_.Release();
}
inline void RequestProcessProposal::set_allocated_next_validators_hash(std::string* value) {
  _impl_.next_validators_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_validators_hash_.IsDefault()) {
          _impl_.next_validators_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestProcessProposal.next_validators_hash)
}

// bytes proposer_address = 8 [json_name = "proposerAddress"];
inline void RequestProcessProposal::clear_proposer_address() {
  _impl_.proposer_address_.ClearToEmpty();
}
inline const std::string& RequestProcessProposal::proposer_address() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestProcessProposal.proposer_address)
  return _internal_proposer_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestProcessProposal::set_proposer_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proposer_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestProcessProposal.proposer_address)
}
inline std::string* RequestProcessProposal::mutable_proposer_address() {
  std::string* _s = _internal_mutable_proposer_address();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestProcessProposal.proposer_address)
  return _s;
}
inline const std::string& RequestProcessProposal::_internal_proposer_address() const {
  return _impl_.proposer_address_.Get();
}
inline void RequestProcessProposal::_internal_set_proposer_address(const std::string& value) {
  ;


  _impl_.proposer_address_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestProcessProposal::_internal_mutable_proposer_address() {
  ;
  return _impl_.proposer_address_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestProcessProposal::release_proposer_address() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestProcessProposal.proposer_address)
  return _impl_.proposer_address_.Release();
}
inline void RequestProcessProposal::set_allocated_proposer_address(std::string* value) {
  _impl_.proposer_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proposer_address_.IsDefault()) {
          _impl_.proposer_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestProcessProposal.proposer_address)
}

// -------------------------------------------------------------------

// Response

// .tendermint.abci.ResponseException exception = 1 [json_name = "exception"];
inline bool Response::has_exception() const {
  return value_case() == kException;
}
inline bool Response::_internal_has_exception() const {
  return value_case() == kException;
}
inline void Response::set_has_exception() {
  _impl_._oneof_case_[0] = kException;
}
inline void Response::clear_exception() {
  if (value_case() == kException) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.exception_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseException* Response::release_exception() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.exception)
  if (value_case() == kException) {
    clear_has_value();
    ::tendermint::abci::ResponseException* temp = _impl_.value_.exception_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.exception_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseException& Response::_internal_exception() const {
  return value_case() == kException
      ? *_impl_.value_.exception_
      : reinterpret_cast<::tendermint::abci::ResponseException&>(::tendermint::abci::_ResponseException_default_instance_);
}
inline const ::tendermint::abci::ResponseException& Response::exception() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.exception)
  return _internal_exception();
}
inline ::tendermint::abci::ResponseException* Response::unsafe_arena_release_exception() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.exception)
  if (value_case() == kException) {
    clear_has_value();
    ::tendermint::abci::ResponseException* temp = _impl_.value_.exception_;
    _impl_.value_.exception_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_exception(::tendermint::abci::ResponseException* exception) {
  clear_value();
  if (exception) {
    set_has_exception();
    _impl_.value_.exception_ = exception;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.exception)
}
inline ::tendermint::abci::ResponseException* Response::_internal_mutable_exception() {
  if (value_case() != kException) {
    clear_value();
    set_has_exception();
    _impl_.value_.exception_ = CreateMaybeMessage< ::tendermint::abci::ResponseException >(GetArenaForAllocation());
  }
  return _impl_.value_.exception_;
}
inline ::tendermint::abci::ResponseException* Response::mutable_exception() {
  ::tendermint::abci::ResponseException* _msg = _internal_mutable_exception();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.exception)
  return _msg;
}

// .tendermint.abci.ResponseEcho echo = 2 [json_name = "echo"];
inline bool Response::has_echo() const {
  return value_case() == kEcho;
}
inline bool Response::_internal_has_echo() const {
  return value_case() == kEcho;
}
inline void Response::set_has_echo() {
  _impl_._oneof_case_[0] = kEcho;
}
inline void Response::clear_echo() {
  if (value_case() == kEcho) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.echo_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseEcho* Response::release_echo() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.echo)
  if (value_case() == kEcho) {
    clear_has_value();
    ::tendermint::abci::ResponseEcho* temp = _impl_.value_.echo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseEcho& Response::_internal_echo() const {
  return value_case() == kEcho
      ? *_impl_.value_.echo_
      : reinterpret_cast<::tendermint::abci::ResponseEcho&>(::tendermint::abci::_ResponseEcho_default_instance_);
}
inline const ::tendermint::abci::ResponseEcho& Response::echo() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.echo)
  return _internal_echo();
}
inline ::tendermint::abci::ResponseEcho* Response::unsafe_arena_release_echo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.echo)
  if (value_case() == kEcho) {
    clear_has_value();
    ::tendermint::abci::ResponseEcho* temp = _impl_.value_.echo_;
    _impl_.value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_echo(::tendermint::abci::ResponseEcho* echo) {
  clear_value();
  if (echo) {
    set_has_echo();
    _impl_.value_.echo_ = echo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.echo)
}
inline ::tendermint::abci::ResponseEcho* Response::_internal_mutable_echo() {
  if (value_case() != kEcho) {
    clear_value();
    set_has_echo();
    _impl_.value_.echo_ = CreateMaybeMessage< ::tendermint::abci::ResponseEcho >(GetArenaForAllocation());
  }
  return _impl_.value_.echo_;
}
inline ::tendermint::abci::ResponseEcho* Response::mutable_echo() {
  ::tendermint::abci::ResponseEcho* _msg = _internal_mutable_echo();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.echo)
  return _msg;
}

// .tendermint.abci.ResponseFlush flush = 3 [json_name = "flush"];
inline bool Response::has_flush() const {
  return value_case() == kFlush;
}
inline bool Response::_internal_has_flush() const {
  return value_case() == kFlush;
}
inline void Response::set_has_flush() {
  _impl_._oneof_case_[0] = kFlush;
}
inline void Response::clear_flush() {
  if (value_case() == kFlush) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.flush_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseFlush* Response::release_flush() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.flush)
  if (value_case() == kFlush) {
    clear_has_value();
    ::tendermint::abci::ResponseFlush* temp = _impl_.value_.flush_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseFlush& Response::_internal_flush() const {
  return value_case() == kFlush
      ? *_impl_.value_.flush_
      : reinterpret_cast<::tendermint::abci::ResponseFlush&>(::tendermint::abci::_ResponseFlush_default_instance_);
}
inline const ::tendermint::abci::ResponseFlush& Response::flush() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.flush)
  return _internal_flush();
}
inline ::tendermint::abci::ResponseFlush* Response::unsafe_arena_release_flush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.flush)
  if (value_case() == kFlush) {
    clear_has_value();
    ::tendermint::abci::ResponseFlush* temp = _impl_.value_.flush_;
    _impl_.value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_flush(::tendermint::abci::ResponseFlush* flush) {
  clear_value();
  if (flush) {
    set_has_flush();
    _impl_.value_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.flush)
}
inline ::tendermint::abci::ResponseFlush* Response::_internal_mutable_flush() {
  if (value_case() != kFlush) {
    clear_value();
    set_has_flush();
    _impl_.value_.flush_ = CreateMaybeMessage< ::tendermint::abci::ResponseFlush >(GetArenaForAllocation());
  }
  return _impl_.value_.flush_;
}
inline ::tendermint::abci::ResponseFlush* Response::mutable_flush() {
  ::tendermint::abci::ResponseFlush* _msg = _internal_mutable_flush();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.flush)
  return _msg;
}

// .tendermint.abci.ResponseInfo info = 4 [json_name = "info"];
inline bool Response::has_info() const {
  return value_case() == kInfo;
}
inline bool Response::_internal_has_info() const {
  return value_case() == kInfo;
}
inline void Response::set_has_info() {
  _impl_._oneof_case_[0] = kInfo;
}
inline void Response::clear_info() {
  if (value_case() == kInfo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.info_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseInfo* Response::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.info)
  if (value_case() == kInfo) {
    clear_has_value();
    ::tendermint::abci::ResponseInfo* temp = _impl_.value_.info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseInfo& Response::_internal_info() const {
  return value_case() == kInfo
      ? *_impl_.value_.info_
      : reinterpret_cast<::tendermint::abci::ResponseInfo&>(::tendermint::abci::_ResponseInfo_default_instance_);
}
inline const ::tendermint::abci::ResponseInfo& Response::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.info)
  return _internal_info();
}
inline ::tendermint::abci::ResponseInfo* Response::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.info)
  if (value_case() == kInfo) {
    clear_has_value();
    ::tendermint::abci::ResponseInfo* temp = _impl_.value_.info_;
    _impl_.value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_info(::tendermint::abci::ResponseInfo* info) {
  clear_value();
  if (info) {
    set_has_info();
    _impl_.value_.info_ = info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.info)
}
inline ::tendermint::abci::ResponseInfo* Response::_internal_mutable_info() {
  if (value_case() != kInfo) {
    clear_value();
    set_has_info();
    _impl_.value_.info_ = CreateMaybeMessage< ::tendermint::abci::ResponseInfo >(GetArenaForAllocation());
  }
  return _impl_.value_.info_;
}
inline ::tendermint::abci::ResponseInfo* Response::mutable_info() {
  ::tendermint::abci::ResponseInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.info)
  return _msg;
}

// .tendermint.abci.ResponseInitChain init_chain = 6 [json_name = "initChain"];
inline bool Response::has_init_chain() const {
  return value_case() == kInitChain;
}
inline bool Response::_internal_has_init_chain() const {
  return value_case() == kInitChain;
}
inline void Response::set_has_init_chain() {
  _impl_._oneof_case_[0] = kInitChain;
}
inline void Response::clear_init_chain() {
  if (value_case() == kInitChain) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.init_chain_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseInitChain* Response::release_init_chain() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.init_chain)
  if (value_case() == kInitChain) {
    clear_has_value();
    ::tendermint::abci::ResponseInitChain* temp = _impl_.value_.init_chain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseInitChain& Response::_internal_init_chain() const {
  return value_case() == kInitChain
      ? *_impl_.value_.init_chain_
      : reinterpret_cast<::tendermint::abci::ResponseInitChain&>(::tendermint::abci::_ResponseInitChain_default_instance_);
}
inline const ::tendermint::abci::ResponseInitChain& Response::init_chain() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.init_chain)
  return _internal_init_chain();
}
inline ::tendermint::abci::ResponseInitChain* Response::unsafe_arena_release_init_chain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.init_chain)
  if (value_case() == kInitChain) {
    clear_has_value();
    ::tendermint::abci::ResponseInitChain* temp = _impl_.value_.init_chain_;
    _impl_.value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_init_chain(::tendermint::abci::ResponseInitChain* init_chain) {
  clear_value();
  if (init_chain) {
    set_has_init_chain();
    _impl_.value_.init_chain_ = init_chain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.init_chain)
}
inline ::tendermint::abci::ResponseInitChain* Response::_internal_mutable_init_chain() {
  if (value_case() != kInitChain) {
    clear_value();
    set_has_init_chain();
    _impl_.value_.init_chain_ = CreateMaybeMessage< ::tendermint::abci::ResponseInitChain >(GetArenaForAllocation());
  }
  return _impl_.value_.init_chain_;
}
inline ::tendermint::abci::ResponseInitChain* Response::mutable_init_chain() {
  ::tendermint::abci::ResponseInitChain* _msg = _internal_mutable_init_chain();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.init_chain)
  return _msg;
}

// .tendermint.abci.ResponseQuery query = 7 [json_name = "query"];
inline bool Response::has_query() const {
  return value_case() == kQuery;
}
inline bool Response::_internal_has_query() const {
  return value_case() == kQuery;
}
inline void Response::set_has_query() {
  _impl_._oneof_case_[0] = kQuery;
}
inline void Response::clear_query() {
  if (value_case() == kQuery) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.query_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.query)
  if (value_case() == kQuery) {
    clear_has_value();
    ::tendermint::abci::ResponseQuery* temp = _impl_.value_.query_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseQuery& Response::_internal_query() const {
  return value_case() == kQuery
      ? *_impl_.value_.query_
      : reinterpret_cast<::tendermint::abci::ResponseQuery&>(::tendermint::abci::_ResponseQuery_default_instance_);
}
inline const ::tendermint::abci::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.query)
  return _internal_query();
}
inline ::tendermint::abci::ResponseQuery* Response::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.query)
  if (value_case() == kQuery) {
    clear_has_value();
    ::tendermint::abci::ResponseQuery* temp = _impl_.value_.query_;
    _impl_.value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_query(::tendermint::abci::ResponseQuery* query) {
  clear_value();
  if (query) {
    set_has_query();
    _impl_.value_.query_ = query;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.query)
}
inline ::tendermint::abci::ResponseQuery* Response::_internal_mutable_query() {
  if (value_case() != kQuery) {
    clear_value();
    set_has_query();
    _impl_.value_.query_ = CreateMaybeMessage< ::tendermint::abci::ResponseQuery >(GetArenaForAllocation());
  }
  return _impl_.value_.query_;
}
inline ::tendermint::abci::ResponseQuery* Response::mutable_query() {
  ::tendermint::abci::ResponseQuery* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.query)
  return _msg;
}

// .tendermint.abci.ResponseBeginBlock begin_block = 8 [json_name = "beginBlock"];
inline bool Response::has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline bool Response::_internal_has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline void Response::set_has_begin_block() {
  _impl_._oneof_case_[0] = kBeginBlock;
}
inline void Response::clear_begin_block() {
  if (value_case() == kBeginBlock) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.begin_block_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseBeginBlock* Response::release_begin_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.begin_block)
  if (value_case() == kBeginBlock) {
    clear_has_value();
    ::tendermint::abci::ResponseBeginBlock* temp = _impl_.value_.begin_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseBeginBlock& Response::_internal_begin_block() const {
  return value_case() == kBeginBlock
      ? *_impl_.value_.begin_block_
      : reinterpret_cast<::tendermint::abci::ResponseBeginBlock&>(::tendermint::abci::_ResponseBeginBlock_default_instance_);
}
inline const ::tendermint::abci::ResponseBeginBlock& Response::begin_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.begin_block)
  return _internal_begin_block();
}
inline ::tendermint::abci::ResponseBeginBlock* Response::unsafe_arena_release_begin_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.begin_block)
  if (value_case() == kBeginBlock) {
    clear_has_value();
    ::tendermint::abci::ResponseBeginBlock* temp = _impl_.value_.begin_block_;
    _impl_.value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_begin_block(::tendermint::abci::ResponseBeginBlock* begin_block) {
  clear_value();
  if (begin_block) {
    set_has_begin_block();
    _impl_.value_.begin_block_ = begin_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.begin_block)
}
inline ::tendermint::abci::ResponseBeginBlock* Response::_internal_mutable_begin_block() {
  if (value_case() != kBeginBlock) {
    clear_value();
    set_has_begin_block();
    _impl_.value_.begin_block_ = CreateMaybeMessage< ::tendermint::abci::ResponseBeginBlock >(GetArenaForAllocation());
  }
  return _impl_.value_.begin_block_;
}
inline ::tendermint::abci::ResponseBeginBlock* Response::mutable_begin_block() {
  ::tendermint::abci::ResponseBeginBlock* _msg = _internal_mutable_begin_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.begin_block)
  return _msg;
}

// .tendermint.abci.ResponseCheckTx check_tx = 9 [json_name = "checkTx"];
inline bool Response::has_check_tx() const {
  return value_case() == kCheckTx;
}
inline bool Response::_internal_has_check_tx() const {
  return value_case() == kCheckTx;
}
inline void Response::set_has_check_tx() {
  _impl_._oneof_case_[0] = kCheckTx;
}
inline void Response::clear_check_tx() {
  if (value_case() == kCheckTx) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.check_tx_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseCheckTx* Response::release_check_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.check_tx)
  if (value_case() == kCheckTx) {
    clear_has_value();
    ::tendermint::abci::ResponseCheckTx* temp = _impl_.value_.check_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseCheckTx& Response::_internal_check_tx() const {
  return value_case() == kCheckTx
      ? *_impl_.value_.check_tx_
      : reinterpret_cast<::tendermint::abci::ResponseCheckTx&>(::tendermint::abci::_ResponseCheckTx_default_instance_);
}
inline const ::tendermint::abci::ResponseCheckTx& Response::check_tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.check_tx)
  return _internal_check_tx();
}
inline ::tendermint::abci::ResponseCheckTx* Response::unsafe_arena_release_check_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.check_tx)
  if (value_case() == kCheckTx) {
    clear_has_value();
    ::tendermint::abci::ResponseCheckTx* temp = _impl_.value_.check_tx_;
    _impl_.value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_check_tx(::tendermint::abci::ResponseCheckTx* check_tx) {
  clear_value();
  if (check_tx) {
    set_has_check_tx();
    _impl_.value_.check_tx_ = check_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.check_tx)
}
inline ::tendermint::abci::ResponseCheckTx* Response::_internal_mutable_check_tx() {
  if (value_case() != kCheckTx) {
    clear_value();
    set_has_check_tx();
    _impl_.value_.check_tx_ = CreateMaybeMessage< ::tendermint::abci::ResponseCheckTx >(GetArenaForAllocation());
  }
  return _impl_.value_.check_tx_;
}
inline ::tendermint::abci::ResponseCheckTx* Response::mutable_check_tx() {
  ::tendermint::abci::ResponseCheckTx* _msg = _internal_mutable_check_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.check_tx)
  return _msg;
}

// .tendermint.abci.ResponseDeliverTx deliver_tx = 10 [json_name = "deliverTx"];
inline bool Response::has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline bool Response::_internal_has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline void Response::set_has_deliver_tx() {
  _impl_._oneof_case_[0] = kDeliverTx;
}
inline void Response::clear_deliver_tx() {
  if (value_case() == kDeliverTx) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.deliver_tx_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseDeliverTx* Response::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.deliver_tx)
  if (value_case() == kDeliverTx) {
    clear_has_value();
    ::tendermint::abci::ResponseDeliverTx* temp = _impl_.value_.deliver_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseDeliverTx& Response::_internal_deliver_tx() const {
  return value_case() == kDeliverTx
      ? *_impl_.value_.deliver_tx_
      : reinterpret_cast<::tendermint::abci::ResponseDeliverTx&>(::tendermint::abci::_ResponseDeliverTx_default_instance_);
}
inline const ::tendermint::abci::ResponseDeliverTx& Response::deliver_tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.deliver_tx)
  return _internal_deliver_tx();
}
inline ::tendermint::abci::ResponseDeliverTx* Response::unsafe_arena_release_deliver_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.deliver_tx)
  if (value_case() == kDeliverTx) {
    clear_has_value();
    ::tendermint::abci::ResponseDeliverTx* temp = _impl_.value_.deliver_tx_;
    _impl_.value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_deliver_tx(::tendermint::abci::ResponseDeliverTx* deliver_tx) {
  clear_value();
  if (deliver_tx) {
    set_has_deliver_tx();
    _impl_.value_.deliver_tx_ = deliver_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.deliver_tx)
}
inline ::tendermint::abci::ResponseDeliverTx* Response::_internal_mutable_deliver_tx() {
  if (value_case() != kDeliverTx) {
    clear_value();
    set_has_deliver_tx();
    _impl_.value_.deliver_tx_ = CreateMaybeMessage< ::tendermint::abci::ResponseDeliverTx >(GetArenaForAllocation());
  }
  return _impl_.value_.deliver_tx_;
}
inline ::tendermint::abci::ResponseDeliverTx* Response::mutable_deliver_tx() {
  ::tendermint::abci::ResponseDeliverTx* _msg = _internal_mutable_deliver_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.deliver_tx)
  return _msg;
}

// .tendermint.abci.ResponseEndBlock end_block = 11 [json_name = "endBlock"];
inline bool Response::has_end_block() const {
  return value_case() == kEndBlock;
}
inline bool Response::_internal_has_end_block() const {
  return value_case() == kEndBlock;
}
inline void Response::set_has_end_block() {
  _impl_._oneof_case_[0] = kEndBlock;
}
inline void Response::clear_end_block() {
  if (value_case() == kEndBlock) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.end_block_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseEndBlock* Response::release_end_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.end_block)
  if (value_case() == kEndBlock) {
    clear_has_value();
    ::tendermint::abci::ResponseEndBlock* temp = _impl_.value_.end_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseEndBlock& Response::_internal_end_block() const {
  return value_case() == kEndBlock
      ? *_impl_.value_.end_block_
      : reinterpret_cast<::tendermint::abci::ResponseEndBlock&>(::tendermint::abci::_ResponseEndBlock_default_instance_);
}
inline const ::tendermint::abci::ResponseEndBlock& Response::end_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.end_block)
  return _internal_end_block();
}
inline ::tendermint::abci::ResponseEndBlock* Response::unsafe_arena_release_end_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.end_block)
  if (value_case() == kEndBlock) {
    clear_has_value();
    ::tendermint::abci::ResponseEndBlock* temp = _impl_.value_.end_block_;
    _impl_.value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_end_block(::tendermint::abci::ResponseEndBlock* end_block) {
  clear_value();
  if (end_block) {
    set_has_end_block();
    _impl_.value_.end_block_ = end_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.end_block)
}
inline ::tendermint::abci::ResponseEndBlock* Response::_internal_mutable_end_block() {
  if (value_case() != kEndBlock) {
    clear_value();
    set_has_end_block();
    _impl_.value_.end_block_ = CreateMaybeMessage< ::tendermint::abci::ResponseEndBlock >(GetArenaForAllocation());
  }
  return _impl_.value_.end_block_;
}
inline ::tendermint::abci::ResponseEndBlock* Response::mutable_end_block() {
  ::tendermint::abci::ResponseEndBlock* _msg = _internal_mutable_end_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.end_block)
  return _msg;
}

// .tendermint.abci.ResponseCommit commit = 12 [json_name = "commit"];
inline bool Response::has_commit() const {
  return value_case() == kCommit;
}
inline bool Response::_internal_has_commit() const {
  return value_case() == kCommit;
}
inline void Response::set_has_commit() {
  _impl_._oneof_case_[0] = kCommit;
}
inline void Response::clear_commit() {
  if (value_case() == kCommit) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.commit_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseCommit* Response::release_commit() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.commit)
  if (value_case() == kCommit) {
    clear_has_value();
    ::tendermint::abci::ResponseCommit* temp = _impl_.value_.commit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseCommit& Response::_internal_commit() const {
  return value_case() == kCommit
      ? *_impl_.value_.commit_
      : reinterpret_cast<::tendermint::abci::ResponseCommit&>(::tendermint::abci::_ResponseCommit_default_instance_);
}
inline const ::tendermint::abci::ResponseCommit& Response::commit() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.commit)
  return _internal_commit();
}
inline ::tendermint::abci::ResponseCommit* Response::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.commit)
  if (value_case() == kCommit) {
    clear_has_value();
    ::tendermint::abci::ResponseCommit* temp = _impl_.value_.commit_;
    _impl_.value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_commit(::tendermint::abci::ResponseCommit* commit) {
  clear_value();
  if (commit) {
    set_has_commit();
    _impl_.value_.commit_ = commit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.commit)
}
inline ::tendermint::abci::ResponseCommit* Response::_internal_mutable_commit() {
  if (value_case() != kCommit) {
    clear_value();
    set_has_commit();
    _impl_.value_.commit_ = CreateMaybeMessage< ::tendermint::abci::ResponseCommit >(GetArenaForAllocation());
  }
  return _impl_.value_.commit_;
}
inline ::tendermint::abci::ResponseCommit* Response::mutable_commit() {
  ::tendermint::abci::ResponseCommit* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.commit)
  return _msg;
}

// .tendermint.abci.ResponseListSnapshots list_snapshots = 13 [json_name = "listSnapshots"];
inline bool Response::has_list_snapshots() const {
  return value_case() == kListSnapshots;
}
inline bool Response::_internal_has_list_snapshots() const {
  return value_case() == kListSnapshots;
}
inline void Response::set_has_list_snapshots() {
  _impl_._oneof_case_[0] = kListSnapshots;
}
inline void Response::clear_list_snapshots() {
  if (value_case() == kListSnapshots) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.list_snapshots_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseListSnapshots* Response::release_list_snapshots() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.list_snapshots)
  if (value_case() == kListSnapshots) {
    clear_has_value();
    ::tendermint::abci::ResponseListSnapshots* temp = _impl_.value_.list_snapshots_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.list_snapshots_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseListSnapshots& Response::_internal_list_snapshots() const {
  return value_case() == kListSnapshots
      ? *_impl_.value_.list_snapshots_
      : reinterpret_cast<::tendermint::abci::ResponseListSnapshots&>(::tendermint::abci::_ResponseListSnapshots_default_instance_);
}
inline const ::tendermint::abci::ResponseListSnapshots& Response::list_snapshots() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.list_snapshots)
  return _internal_list_snapshots();
}
inline ::tendermint::abci::ResponseListSnapshots* Response::unsafe_arena_release_list_snapshots() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.list_snapshots)
  if (value_case() == kListSnapshots) {
    clear_has_value();
    ::tendermint::abci::ResponseListSnapshots* temp = _impl_.value_.list_snapshots_;
    _impl_.value_.list_snapshots_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_list_snapshots(::tendermint::abci::ResponseListSnapshots* list_snapshots) {
  clear_value();
  if (list_snapshots) {
    set_has_list_snapshots();
    _impl_.value_.list_snapshots_ = list_snapshots;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.list_snapshots)
}
inline ::tendermint::abci::ResponseListSnapshots* Response::_internal_mutable_list_snapshots() {
  if (value_case() != kListSnapshots) {
    clear_value();
    set_has_list_snapshots();
    _impl_.value_.list_snapshots_ = CreateMaybeMessage< ::tendermint::abci::ResponseListSnapshots >(GetArenaForAllocation());
  }
  return _impl_.value_.list_snapshots_;
}
inline ::tendermint::abci::ResponseListSnapshots* Response::mutable_list_snapshots() {
  ::tendermint::abci::ResponseListSnapshots* _msg = _internal_mutable_list_snapshots();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.list_snapshots)
  return _msg;
}

// .tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14 [json_name = "offerSnapshot"];
inline bool Response::has_offer_snapshot() const {
  return value_case() == kOfferSnapshot;
}
inline bool Response::_internal_has_offer_snapshot() const {
  return value_case() == kOfferSnapshot;
}
inline void Response::set_has_offer_snapshot() {
  _impl_._oneof_case_[0] = kOfferSnapshot;
}
inline void Response::clear_offer_snapshot() {
  if (value_case() == kOfferSnapshot) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.offer_snapshot_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseOfferSnapshot* Response::release_offer_snapshot() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.offer_snapshot)
  if (value_case() == kOfferSnapshot) {
    clear_has_value();
    ::tendermint::abci::ResponseOfferSnapshot* temp = _impl_.value_.offer_snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.offer_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseOfferSnapshot& Response::_internal_offer_snapshot() const {
  return value_case() == kOfferSnapshot
      ? *_impl_.value_.offer_snapshot_
      : reinterpret_cast<::tendermint::abci::ResponseOfferSnapshot&>(::tendermint::abci::_ResponseOfferSnapshot_default_instance_);
}
inline const ::tendermint::abci::ResponseOfferSnapshot& Response::offer_snapshot() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.offer_snapshot)
  return _internal_offer_snapshot();
}
inline ::tendermint::abci::ResponseOfferSnapshot* Response::unsafe_arena_release_offer_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.offer_snapshot)
  if (value_case() == kOfferSnapshot) {
    clear_has_value();
    ::tendermint::abci::ResponseOfferSnapshot* temp = _impl_.value_.offer_snapshot_;
    _impl_.value_.offer_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_offer_snapshot(::tendermint::abci::ResponseOfferSnapshot* offer_snapshot) {
  clear_value();
  if (offer_snapshot) {
    set_has_offer_snapshot();
    _impl_.value_.offer_snapshot_ = offer_snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.offer_snapshot)
}
inline ::tendermint::abci::ResponseOfferSnapshot* Response::_internal_mutable_offer_snapshot() {
  if (value_case() != kOfferSnapshot) {
    clear_value();
    set_has_offer_snapshot();
    _impl_.value_.offer_snapshot_ = CreateMaybeMessage< ::tendermint::abci::ResponseOfferSnapshot >(GetArenaForAllocation());
  }
  return _impl_.value_.offer_snapshot_;
}
inline ::tendermint::abci::ResponseOfferSnapshot* Response::mutable_offer_snapshot() {
  ::tendermint::abci::ResponseOfferSnapshot* _msg = _internal_mutable_offer_snapshot();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.offer_snapshot)
  return _msg;
}

// .tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15 [json_name = "loadSnapshotChunk"];
inline bool Response::has_load_snapshot_chunk() const {
  return value_case() == kLoadSnapshotChunk;
}
inline bool Response::_internal_has_load_snapshot_chunk() const {
  return value_case() == kLoadSnapshotChunk;
}
inline void Response::set_has_load_snapshot_chunk() {
  _impl_._oneof_case_[0] = kLoadSnapshotChunk;
}
inline void Response::clear_load_snapshot_chunk() {
  if (value_case() == kLoadSnapshotChunk) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.load_snapshot_chunk_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseLoadSnapshotChunk* Response::release_load_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.load_snapshot_chunk)
  if (value_case() == kLoadSnapshotChunk) {
    clear_has_value();
    ::tendermint::abci::ResponseLoadSnapshotChunk* temp = _impl_.value_.load_snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.load_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseLoadSnapshotChunk& Response::_internal_load_snapshot_chunk() const {
  return value_case() == kLoadSnapshotChunk
      ? *_impl_.value_.load_snapshot_chunk_
      : reinterpret_cast<::tendermint::abci::ResponseLoadSnapshotChunk&>(::tendermint::abci::_ResponseLoadSnapshotChunk_default_instance_);
}
inline const ::tendermint::abci::ResponseLoadSnapshotChunk& Response::load_snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.load_snapshot_chunk)
  return _internal_load_snapshot_chunk();
}
inline ::tendermint::abci::ResponseLoadSnapshotChunk* Response::unsafe_arena_release_load_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.load_snapshot_chunk)
  if (value_case() == kLoadSnapshotChunk) {
    clear_has_value();
    ::tendermint::abci::ResponseLoadSnapshotChunk* temp = _impl_.value_.load_snapshot_chunk_;
    _impl_.value_.load_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_load_snapshot_chunk(::tendermint::abci::ResponseLoadSnapshotChunk* load_snapshot_chunk) {
  clear_value();
  if (load_snapshot_chunk) {
    set_has_load_snapshot_chunk();
    _impl_.value_.load_snapshot_chunk_ = load_snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.load_snapshot_chunk)
}
inline ::tendermint::abci::ResponseLoadSnapshotChunk* Response::_internal_mutable_load_snapshot_chunk() {
  if (value_case() != kLoadSnapshotChunk) {
    clear_value();
    set_has_load_snapshot_chunk();
    _impl_.value_.load_snapshot_chunk_ = CreateMaybeMessage< ::tendermint::abci::ResponseLoadSnapshotChunk >(GetArenaForAllocation());
  }
  return _impl_.value_.load_snapshot_chunk_;
}
inline ::tendermint::abci::ResponseLoadSnapshotChunk* Response::mutable_load_snapshot_chunk() {
  ::tendermint::abci::ResponseLoadSnapshotChunk* _msg = _internal_mutable_load_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.load_snapshot_chunk)
  return _msg;
}

// .tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16 [json_name = "applySnapshotChunk"];
inline bool Response::has_apply_snapshot_chunk() const {
  return value_case() == kApplySnapshotChunk;
}
inline bool Response::_internal_has_apply_snapshot_chunk() const {
  return value_case() == kApplySnapshotChunk;
}
inline void Response::set_has_apply_snapshot_chunk() {
  _impl_._oneof_case_[0] = kApplySnapshotChunk;
}
inline void Response::clear_apply_snapshot_chunk() {
  if (value_case() == kApplySnapshotChunk) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.apply_snapshot_chunk_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseApplySnapshotChunk* Response::release_apply_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.apply_snapshot_chunk)
  if (value_case() == kApplySnapshotChunk) {
    clear_has_value();
    ::tendermint::abci::ResponseApplySnapshotChunk* temp = _impl_.value_.apply_snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.apply_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseApplySnapshotChunk& Response::_internal_apply_snapshot_chunk() const {
  return value_case() == kApplySnapshotChunk
      ? *_impl_.value_.apply_snapshot_chunk_
      : reinterpret_cast<::tendermint::abci::ResponseApplySnapshotChunk&>(::tendermint::abci::_ResponseApplySnapshotChunk_default_instance_);
}
inline const ::tendermint::abci::ResponseApplySnapshotChunk& Response::apply_snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.apply_snapshot_chunk)
  return _internal_apply_snapshot_chunk();
}
inline ::tendermint::abci::ResponseApplySnapshotChunk* Response::unsafe_arena_release_apply_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.apply_snapshot_chunk)
  if (value_case() == kApplySnapshotChunk) {
    clear_has_value();
    ::tendermint::abci::ResponseApplySnapshotChunk* temp = _impl_.value_.apply_snapshot_chunk_;
    _impl_.value_.apply_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_apply_snapshot_chunk(::tendermint::abci::ResponseApplySnapshotChunk* apply_snapshot_chunk) {
  clear_value();
  if (apply_snapshot_chunk) {
    set_has_apply_snapshot_chunk();
    _impl_.value_.apply_snapshot_chunk_ = apply_snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.apply_snapshot_chunk)
}
inline ::tendermint::abci::ResponseApplySnapshotChunk* Response::_internal_mutable_apply_snapshot_chunk() {
  if (value_case() != kApplySnapshotChunk) {
    clear_value();
    set_has_apply_snapshot_chunk();
    _impl_.value_.apply_snapshot_chunk_ = CreateMaybeMessage< ::tendermint::abci::ResponseApplySnapshotChunk >(GetArenaForAllocation());
  }
  return _impl_.value_.apply_snapshot_chunk_;
}
inline ::tendermint::abci::ResponseApplySnapshotChunk* Response::mutable_apply_snapshot_chunk() {
  ::tendermint::abci::ResponseApplySnapshotChunk* _msg = _internal_mutable_apply_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.apply_snapshot_chunk)
  return _msg;
}

// .tendermint.abci.ResponsePrepareProposal prepare_proposal = 17 [json_name = "prepareProposal"];
inline bool Response::has_prepare_proposal() const {
  return value_case() == kPrepareProposal;
}
inline bool Response::_internal_has_prepare_proposal() const {
  return value_case() == kPrepareProposal;
}
inline void Response::set_has_prepare_proposal() {
  _impl_._oneof_case_[0] = kPrepareProposal;
}
inline void Response::clear_prepare_proposal() {
  if (value_case() == kPrepareProposal) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.prepare_proposal_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponsePrepareProposal* Response::release_prepare_proposal() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.prepare_proposal)
  if (value_case() == kPrepareProposal) {
    clear_has_value();
    ::tendermint::abci::ResponsePrepareProposal* temp = _impl_.value_.prepare_proposal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.prepare_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponsePrepareProposal& Response::_internal_prepare_proposal() const {
  return value_case() == kPrepareProposal
      ? *_impl_.value_.prepare_proposal_
      : reinterpret_cast<::tendermint::abci::ResponsePrepareProposal&>(::tendermint::abci::_ResponsePrepareProposal_default_instance_);
}
inline const ::tendermint::abci::ResponsePrepareProposal& Response::prepare_proposal() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.prepare_proposal)
  return _internal_prepare_proposal();
}
inline ::tendermint::abci::ResponsePrepareProposal* Response::unsafe_arena_release_prepare_proposal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.prepare_proposal)
  if (value_case() == kPrepareProposal) {
    clear_has_value();
    ::tendermint::abci::ResponsePrepareProposal* temp = _impl_.value_.prepare_proposal_;
    _impl_.value_.prepare_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_prepare_proposal(::tendermint::abci::ResponsePrepareProposal* prepare_proposal) {
  clear_value();
  if (prepare_proposal) {
    set_has_prepare_proposal();
    _impl_.value_.prepare_proposal_ = prepare_proposal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.prepare_proposal)
}
inline ::tendermint::abci::ResponsePrepareProposal* Response::_internal_mutable_prepare_proposal() {
  if (value_case() != kPrepareProposal) {
    clear_value();
    set_has_prepare_proposal();
    _impl_.value_.prepare_proposal_ = CreateMaybeMessage< ::tendermint::abci::ResponsePrepareProposal >(GetArenaForAllocation());
  }
  return _impl_.value_.prepare_proposal_;
}
inline ::tendermint::abci::ResponsePrepareProposal* Response::mutable_prepare_proposal() {
  ::tendermint::abci::ResponsePrepareProposal* _msg = _internal_mutable_prepare_proposal();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.prepare_proposal)
  return _msg;
}

// .tendermint.abci.ResponseProcessProposal process_proposal = 18 [json_name = "processProposal"];
inline bool Response::has_process_proposal() const {
  return value_case() == kProcessProposal;
}
inline bool Response::_internal_has_process_proposal() const {
  return value_case() == kProcessProposal;
}
inline void Response::set_has_process_proposal() {
  _impl_._oneof_case_[0] = kProcessProposal;
}
inline void Response::clear_process_proposal() {
  if (value_case() == kProcessProposal) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.process_proposal_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseProcessProposal* Response::release_process_proposal() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.process_proposal)
  if (value_case() == kProcessProposal) {
    clear_has_value();
    ::tendermint::abci::ResponseProcessProposal* temp = _impl_.value_.process_proposal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.process_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseProcessProposal& Response::_internal_process_proposal() const {
  return value_case() == kProcessProposal
      ? *_impl_.value_.process_proposal_
      : reinterpret_cast<::tendermint::abci::ResponseProcessProposal&>(::tendermint::abci::_ResponseProcessProposal_default_instance_);
}
inline const ::tendermint::abci::ResponseProcessProposal& Response::process_proposal() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.process_proposal)
  return _internal_process_proposal();
}
inline ::tendermint::abci::ResponseProcessProposal* Response::unsafe_arena_release_process_proposal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.process_proposal)
  if (value_case() == kProcessProposal) {
    clear_has_value();
    ::tendermint::abci::ResponseProcessProposal* temp = _impl_.value_.process_proposal_;
    _impl_.value_.process_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_process_proposal(::tendermint::abci::ResponseProcessProposal* process_proposal) {
  clear_value();
  if (process_proposal) {
    set_has_process_proposal();
    _impl_.value_.process_proposal_ = process_proposal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.process_proposal)
}
inline ::tendermint::abci::ResponseProcessProposal* Response::_internal_mutable_process_proposal() {
  if (value_case() != kProcessProposal) {
    clear_value();
    set_has_process_proposal();
    _impl_.value_.process_proposal_ = CreateMaybeMessage< ::tendermint::abci::ResponseProcessProposal >(GetArenaForAllocation());
  }
  return _impl_.value_.process_proposal_;
}
inline ::tendermint::abci::ResponseProcessProposal* Response::mutable_process_proposal() {
  ::tendermint::abci::ResponseProcessProposal* _msg = _internal_mutable_process_proposal();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.process_proposal)
  return _msg;
}

inline bool Response::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Response::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Response::ValueCase Response::value_case() const {
  return Response::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseException

// string error = 1 [json_name = "error"];
inline void ResponseException::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& ResponseException::error() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseException.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseException::set_error(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseException.error)
}
inline std::string* ResponseException::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseException.error)
  return _s;
}
inline const std::string& ResponseException::_internal_error() const {
  return _impl_.error_.Get();
}
inline void ResponseException::_internal_set_error(const std::string& value) {
  ;


  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseException::_internal_mutable_error() {
  ;
  return _impl_.error_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseException::release_error() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseException.error)
  return _impl_.error_.Release();
}
inline void ResponseException::set_allocated_error(std::string* value) {
  _impl_.error_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseException.error)
}

// -------------------------------------------------------------------

// ResponseEcho

// string message = 1 [json_name = "message"];
inline void ResponseEcho::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ResponseEcho::message() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseEcho.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseEcho::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseEcho.message)
}
inline std::string* ResponseEcho::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseEcho.message)
  return _s;
}
inline const std::string& ResponseEcho::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ResponseEcho::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseEcho::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseEcho::release_message() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseEcho.message)
  return _impl_.message_.Release();
}
inline void ResponseEcho::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseEcho.message)
}

// -------------------------------------------------------------------

// ResponseFlush

// -------------------------------------------------------------------

// ResponseInfo

// string data = 1 [json_name = "data"];
inline void ResponseInfo::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ResponseInfo::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseInfo::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.data)
}
inline std::string* ResponseInfo::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInfo.data)
  return _s;
}
inline const std::string& ResponseInfo::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ResponseInfo::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInfo.data)
  return _impl_.data_.Release();
}
inline void ResponseInfo::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInfo.data)
}

// string version = 2 [json_name = "version"];
inline void ResponseInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ResponseInfo::version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseInfo::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.version)
}
inline std::string* ResponseInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInfo.version)
  return _s;
}
inline const std::string& ResponseInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ResponseInfo::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_version() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInfo.version)
  return _impl_.version_.Release();
}
inline void ResponseInfo::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInfo.version)
}

// uint64 app_version = 3 [json_name = "appVersion"];
inline void ResponseInfo::clear_app_version() {
  _impl_.app_version_ = ::uint64_t{0u};
}
inline ::uint64_t ResponseInfo::app_version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.app_version)
  return _internal_app_version();
}
inline void ResponseInfo::set_app_version(::uint64_t value) {
  _internal_set_app_version(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.app_version)
}
inline ::uint64_t ResponseInfo::_internal_app_version() const {
  return _impl_.app_version_;
}
inline void ResponseInfo::_internal_set_app_version(::uint64_t value) {
  ;
  _impl_.app_version_ = value;
}

// int64 last_block_height = 4 [json_name = "lastBlockHeight"];
inline void ResponseInfo::clear_last_block_height() {
  _impl_.last_block_height_ = ::int64_t{0};
}
inline ::int64_t ResponseInfo::last_block_height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.last_block_height)
  return _internal_last_block_height();
}
inline void ResponseInfo::set_last_block_height(::int64_t value) {
  _internal_set_last_block_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.last_block_height)
}
inline ::int64_t ResponseInfo::_internal_last_block_height() const {
  return _impl_.last_block_height_;
}
inline void ResponseInfo::_internal_set_last_block_height(::int64_t value) {
  ;
  _impl_.last_block_height_ = value;
}

// bytes last_block_app_hash = 5 [json_name = "lastBlockAppHash"];
inline void ResponseInfo::clear_last_block_app_hash() {
  _impl_.last_block_app_hash_.ClearToEmpty();
}
inline const std::string& ResponseInfo::last_block_app_hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.last_block_app_hash)
  return _internal_last_block_app_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseInfo::set_last_block_app_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.last_block_app_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.last_block_app_hash)
}
inline std::string* ResponseInfo::mutable_last_block_app_hash() {
  std::string* _s = _internal_mutable_last_block_app_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInfo.last_block_app_hash)
  return _s;
}
inline const std::string& ResponseInfo::_internal_last_block_app_hash() const {
  return _impl_.last_block_app_hash_.Get();
}
inline void ResponseInfo::_internal_set_last_block_app_hash(const std::string& value) {
  ;


  _impl_.last_block_app_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_last_block_app_hash() {
  ;
  return _impl_.last_block_app_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_last_block_app_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInfo.last_block_app_hash)
  return _impl_.last_block_app_hash_.Release();
}
inline void ResponseInfo::set_allocated_last_block_app_hash(std::string* value) {
  _impl_.last_block_app_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.last_block_app_hash_.IsDefault()) {
          _impl_.last_block_app_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInfo.last_block_app_hash)
}

// -------------------------------------------------------------------

// ResponseInitChain

// .tendermint.types.ConsensusParams consensus_params = 1 [json_name = "consensusParams"];
inline bool ResponseInitChain::has_consensus_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consensus_params_ != nullptr);
  return value;
}
inline const ::tendermint::types::ConsensusParams& ResponseInitChain::_internal_consensus_params() const {
  const ::tendermint::types::ConsensusParams* p = _impl_.consensus_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::ConsensusParams&>(
      ::tendermint::types::_ConsensusParams_default_instance_);
}
inline const ::tendermint::types::ConsensusParams& ResponseInitChain::consensus_params() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInitChain.consensus_params)
  return _internal_consensus_params();
}
inline void ResponseInitChain::unsafe_arena_set_allocated_consensus_params(
    ::tendermint::types::ConsensusParams* consensus_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_params_);
  }
  _impl_.consensus_params_ = consensus_params;
  if (consensus_params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ResponseInitChain.consensus_params)
}
inline ::tendermint::types::ConsensusParams* ResponseInitChain::release_consensus_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::ConsensusParams* temp = _impl_.consensus_params_;
  _impl_.consensus_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::ConsensusParams* ResponseInitChain::unsafe_arena_release_consensus_params() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInitChain.consensus_params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::ConsensusParams* temp = _impl_.consensus_params_;
  _impl_.consensus_params_ = nullptr;
  return temp;
}
inline ::tendermint::types::ConsensusParams* ResponseInitChain::_internal_mutable_consensus_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.consensus_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::ConsensusParams>(GetArenaForAllocation());
    _impl_.consensus_params_ = p;
  }
  return _impl_.consensus_params_;
}
inline ::tendermint::types::ConsensusParams* ResponseInitChain::mutable_consensus_params() {
  ::tendermint::types::ConsensusParams* _msg = _internal_mutable_consensus_params();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInitChain.consensus_params)
  return _msg;
}
inline void ResponseInitChain::set_allocated_consensus_params(::tendermint::types::ConsensusParams* consensus_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_params_);
  }
  if (consensus_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consensus_params));
    if (message_arena != submessage_arena) {
      consensus_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consensus_params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.consensus_params_ = consensus_params;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInitChain.consensus_params)
}

// repeated .tendermint.abci.ValidatorUpdate validators = 2 [json_name = "validators", (.gogoproto.nullable) = false];
inline int ResponseInitChain::_internal_validators_size() const {
  return _impl_.validators_.size();
}
inline int ResponseInitChain::validators_size() const {
  return _internal_validators_size();
}
inline void ResponseInitChain::clear_validators() {
  _internal_mutable_validators()->Clear();
}
inline ::tendermint::abci::ValidatorUpdate* ResponseInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInitChain.validators)
  return _internal_mutable_validators()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
ResponseInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseInitChain.validators)
  return _internal_mutable_validators();
}
inline const ::tendermint::abci::ValidatorUpdate& ResponseInitChain::_internal_validators(int index) const {
  return _internal_validators().Get(index);
}
inline const ::tendermint::abci::ValidatorUpdate& ResponseInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInitChain.validators)
  return _internal_validators(index);
}
inline ::tendermint::abci::ValidatorUpdate* ResponseInitChain::_internal_add_validators() {
  return _internal_mutable_validators()->Add();
}
inline ::tendermint::abci::ValidatorUpdate* ResponseInitChain::add_validators() {
  ::tendermint::abci::ValidatorUpdate* _add = _internal_add_validators();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseInitChain.validators)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
ResponseInitChain::validators() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseInitChain.validators)
  return _internal_validators();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>&
ResponseInitChain::_internal_validators() const {
  return _impl_.validators_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>*
ResponseInitChain::_internal_mutable_validators() {
  return &_impl_.validators_;
}

// bytes app_hash = 3 [json_name = "appHash"];
inline void ResponseInitChain::clear_app_hash() {
  _impl_.app_hash_.ClearToEmpty();
}
inline const std::string& ResponseInitChain::app_hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInitChain.app_hash)
  return _internal_app_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseInitChain::set_app_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.app_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInitChain.app_hash)
}
inline std::string* ResponseInitChain::mutable_app_hash() {
  std::string* _s = _internal_mutable_app_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInitChain.app_hash)
  return _s;
}
inline const std::string& ResponseInitChain::_internal_app_hash() const {
  return _impl_.app_hash_.Get();
}
inline void ResponseInitChain::_internal_set_app_hash(const std::string& value) {
  ;


  _impl_.app_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseInitChain::_internal_mutable_app_hash() {
  ;
  return _impl_.app_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseInitChain::release_app_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInitChain.app_hash)
  return _impl_.app_hash_.Release();
}
inline void ResponseInitChain::set_allocated_app_hash(std::string* value) {
  _impl_.app_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_hash_.IsDefault()) {
          _impl_.app_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInitChain.app_hash)
}

// -------------------------------------------------------------------

// ResponseQuery

// uint32 code = 1 [json_name = "code"];
inline void ResponseQuery::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t ResponseQuery::code() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.code)
  return _internal_code();
}
inline void ResponseQuery::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.code)
}
inline ::uint32_t ResponseQuery::_internal_code() const {
  return _impl_.code_;
}
inline void ResponseQuery::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// string log = 3 [json_name = "log"];
inline void ResponseQuery::clear_log() {
  _impl_.log_.ClearToEmpty();
}
inline const std::string& ResponseQuery::log() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.log)
  return _internal_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseQuery::set_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.log)
}
inline std::string* ResponseQuery::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.log)
  return _s;
}
inline const std::string& ResponseQuery::_internal_log() const {
  return _impl_.log_.Get();
}
inline void ResponseQuery::_internal_set_log(const std::string& value) {
  ;


  _impl_.log_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_log() {
  ;
  return _impl_.log_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_log() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.log)
  return _impl_.log_.Release();
}
inline void ResponseQuery::set_allocated_log(std::string* value) {
  _impl_.log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.log_.IsDefault()) {
          _impl_.log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.log)
}

// string info = 4 [json_name = "info"];
inline void ResponseQuery::clear_info() {
  _impl_.info_.ClearToEmpty();
}
inline const std::string& ResponseQuery::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.info)
  return _internal_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseQuery::set_info(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.info_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.info)
}
inline std::string* ResponseQuery::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.info)
  return _s;
}
inline const std::string& ResponseQuery::_internal_info() const {
  return _impl_.info_.Get();
}
inline void ResponseQuery::_internal_set_info(const std::string& value) {
  ;


  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_info() {
  ;
  return _impl_.info_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.info)
  return _impl_.info_.Release();
}
inline void ResponseQuery::set_allocated_info(std::string* value) {
  _impl_.info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.info_.IsDefault()) {
          _impl_.info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.info)
}

// int64 index = 5 [json_name = "index"];
inline void ResponseQuery::clear_index() {
  _impl_.index_ = ::int64_t{0};
}
inline ::int64_t ResponseQuery::index() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.index)
  return _internal_index();
}
inline void ResponseQuery::set_index(::int64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.index)
}
inline ::int64_t ResponseQuery::_internal_index() const {
  return _impl_.index_;
}
inline void ResponseQuery::_internal_set_index(::int64_t value) {
  ;
  _impl_.index_ = value;
}

// bytes key = 6 [json_name = "key"];
inline void ResponseQuery::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ResponseQuery::key() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseQuery::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.key)
}
inline std::string* ResponseQuery::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.key)
  return _s;
}
inline const std::string& ResponseQuery::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ResponseQuery::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_key() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.key)
  return _impl_.key_.Release();
}
inline void ResponseQuery::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.key)
}

// bytes value = 7 [json_name = "value"];
inline void ResponseQuery::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ResponseQuery::value() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseQuery::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.value)
}
inline std::string* ResponseQuery::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.value)
  return _s;
}
inline const std::string& ResponseQuery::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ResponseQuery::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_value() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.value)
  return _impl_.value_.Release();
}
inline void ResponseQuery::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.value)
}

// .tendermint.crypto.ProofOps proof_ops = 8 [json_name = "proofOps"];
inline bool ResponseQuery::has_proof_ops() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_ops_ != nullptr);
  return value;
}
inline const ::tendermint::crypto::ProofOps& ResponseQuery::_internal_proof_ops() const {
  const ::tendermint::crypto::ProofOps* p = _impl_.proof_ops_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::crypto::ProofOps&>(
      ::tendermint::crypto::_ProofOps_default_instance_);
}
inline const ::tendermint::crypto::ProofOps& ResponseQuery::proof_ops() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.proof_ops)
  return _internal_proof_ops();
}
inline void ResponseQuery::unsafe_arena_set_allocated_proof_ops(
    ::tendermint::crypto::ProofOps* proof_ops) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_ops_);
  }
  _impl_.proof_ops_ = proof_ops;
  if (proof_ops) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ResponseQuery.proof_ops)
}
inline ::tendermint::crypto::ProofOps* ResponseQuery::release_proof_ops() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::crypto::ProofOps* temp = _impl_.proof_ops_;
  _impl_.proof_ops_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::crypto::ProofOps* ResponseQuery::unsafe_arena_release_proof_ops() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.proof_ops)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::crypto::ProofOps* temp = _impl_.proof_ops_;
  _impl_.proof_ops_ = nullptr;
  return temp;
}
inline ::tendermint::crypto::ProofOps* ResponseQuery::_internal_mutable_proof_ops() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proof_ops_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::crypto::ProofOps>(GetArenaForAllocation());
    _impl_.proof_ops_ = p;
  }
  return _impl_.proof_ops_;
}
inline ::tendermint::crypto::ProofOps* ResponseQuery::mutable_proof_ops() {
  ::tendermint::crypto::ProofOps* _msg = _internal_mutable_proof_ops();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.proof_ops)
  return _msg;
}
inline void ResponseQuery::set_allocated_proof_ops(::tendermint::crypto::ProofOps* proof_ops) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_ops_);
  }
  if (proof_ops) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_ops));
    if (message_arena != submessage_arena) {
      proof_ops = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_ops, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.proof_ops_ = proof_ops;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.proof_ops)
}

// int64 height = 9 [json_name = "height"];
inline void ResponseQuery::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t ResponseQuery::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.height)
  return _internal_height();
}
inline void ResponseQuery::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.height)
}
inline ::int64_t ResponseQuery::_internal_height() const {
  return _impl_.height_;
}
inline void ResponseQuery::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// string codespace = 10 [json_name = "codespace"];
inline void ResponseQuery::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& ResponseQuery::codespace() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseQuery::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.codespace)
}
inline std::string* ResponseQuery::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.codespace)
  return _s;
}
inline const std::string& ResponseQuery::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void ResponseQuery::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_codespace() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.codespace)
  return _impl_.codespace_.Release();
}
inline void ResponseQuery::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.codespace)
}

// -------------------------------------------------------------------

// ResponseBeginBlock

// repeated .tendermint.abci.Event events = 1 [json_name = "events", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
inline int ResponseBeginBlock::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int ResponseBeginBlock::events_size() const {
  return _internal_events_size();
}
inline void ResponseBeginBlock::clear_events() {
  _internal_mutable_events()->Clear();
}
inline ::tendermint::abci::Event* ResponseBeginBlock::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseBeginBlock.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
ResponseBeginBlock::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseBeginBlock.events)
  return _internal_mutable_events();
}
inline const ::tendermint::abci::Event& ResponseBeginBlock::_internal_events(int index) const {
  return _internal_events().Get(index);
}
inline const ::tendermint::abci::Event& ResponseBeginBlock::events(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseBeginBlock.events)
  return _internal_events(index);
}
inline ::tendermint::abci::Event* ResponseBeginBlock::_internal_add_events() {
  return _internal_mutable_events()->Add();
}
inline ::tendermint::abci::Event* ResponseBeginBlock::add_events() {
  ::tendermint::abci::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseBeginBlock.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
ResponseBeginBlock::events() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseBeginBlock.events)
  return _internal_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>&
ResponseBeginBlock::_internal_events() const {
  return _impl_.events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>*
ResponseBeginBlock::_internal_mutable_events() {
  return &_impl_.events_;
}

// -------------------------------------------------------------------

// ResponseCheckTx

// uint32 code = 1 [json_name = "code"];
inline void ResponseCheckTx::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t ResponseCheckTx::code() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.code)
  return _internal_code();
}
inline void ResponseCheckTx::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.code)
}
inline ::uint32_t ResponseCheckTx::_internal_code() const {
  return _impl_.code_;
}
inline void ResponseCheckTx::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// bytes data = 2 [json_name = "data"];
inline void ResponseCheckTx::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseCheckTx::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.data)
}
inline std::string* ResponseCheckTx::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.data)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ResponseCheckTx::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.data)
  return _impl_.data_.Release();
}
inline void ResponseCheckTx::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.data)
}

// string log = 3 [json_name = "log"];
inline void ResponseCheckTx::clear_log() {
  _impl_.log_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::log() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.log)
  return _internal_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseCheckTx::set_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.log)
}
inline std::string* ResponseCheckTx::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.log)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_log() const {
  return _impl_.log_.Get();
}
inline void ResponseCheckTx::_internal_set_log(const std::string& value) {
  ;


  _impl_.log_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_log() {
  ;
  return _impl_.log_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_log() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.log)
  return _impl_.log_.Release();
}
inline void ResponseCheckTx::set_allocated_log(std::string* value) {
  _impl_.log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.log_.IsDefault()) {
          _impl_.log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.log)
}

// string info = 4 [json_name = "info"];
inline void ResponseCheckTx::clear_info() {
  _impl_.info_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.info)
  return _internal_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseCheckTx::set_info(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.info_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.info)
}
inline std::string* ResponseCheckTx::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.info)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_info() const {
  return _impl_.info_.Get();
}
inline void ResponseCheckTx::_internal_set_info(const std::string& value) {
  ;


  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_info() {
  ;
  return _impl_.info_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.info)
  return _impl_.info_.Release();
}
inline void ResponseCheckTx::set_allocated_info(std::string* value) {
  _impl_.info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.info_.IsDefault()) {
          _impl_.info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.info)
}

// int64 gas_wanted = 5 [json_name = "gas_wanted"];
inline void ResponseCheckTx::clear_gas_wanted() {
  _impl_.gas_wanted_ = ::int64_t{0};
}
inline ::int64_t ResponseCheckTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.gas_wanted)
  return _internal_gas_wanted();
}
inline void ResponseCheckTx::set_gas_wanted(::int64_t value) {
  _internal_set_gas_wanted(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.gas_wanted)
}
inline ::int64_t ResponseCheckTx::_internal_gas_wanted() const {
  return _impl_.gas_wanted_;
}
inline void ResponseCheckTx::_internal_set_gas_wanted(::int64_t value) {
  ;
  _impl_.gas_wanted_ = value;
}

// int64 gas_used = 6 [json_name = "gas_used"];
inline void ResponseCheckTx::clear_gas_used() {
  _impl_.gas_used_ = ::int64_t{0};
}
inline ::int64_t ResponseCheckTx::gas_used() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.gas_used)
  return _internal_gas_used();
}
inline void ResponseCheckTx::set_gas_used(::int64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.gas_used)
}
inline ::int64_t ResponseCheckTx::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline void ResponseCheckTx::_internal_set_gas_used(::int64_t value) {
  ;
  _impl_.gas_used_ = value;
}

// repeated .tendermint.abci.Event events = 7 [json_name = "events", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
inline int ResponseCheckTx::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int ResponseCheckTx::events_size() const {
  return _internal_events_size();
}
inline void ResponseCheckTx::clear_events() {
  _internal_mutable_events()->Clear();
}
inline ::tendermint::abci::Event* ResponseCheckTx::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
ResponseCheckTx::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseCheckTx.events)
  return _internal_mutable_events();
}
inline const ::tendermint::abci::Event& ResponseCheckTx::_internal_events(int index) const {
  return _internal_events().Get(index);
}
inline const ::tendermint::abci::Event& ResponseCheckTx::events(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.events)
  return _internal_events(index);
}
inline ::tendermint::abci::Event* ResponseCheckTx::_internal_add_events() {
  return _internal_mutable_events()->Add();
}
inline ::tendermint::abci::Event* ResponseCheckTx::add_events() {
  ::tendermint::abci::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseCheckTx.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
ResponseCheckTx::events() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseCheckTx.events)
  return _internal_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>&
ResponseCheckTx::_internal_events() const {
  return _impl_.events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>*
ResponseCheckTx::_internal_mutable_events() {
  return &_impl_.events_;
}

// string codespace = 8 [json_name = "codespace"];
inline void ResponseCheckTx::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::codespace() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseCheckTx::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.codespace)
}
inline std::string* ResponseCheckTx::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.codespace)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void ResponseCheckTx::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_codespace() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.codespace)
  return _impl_.codespace_.Release();
}
inline void ResponseCheckTx::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.codespace)
}

// string sender = 9 [json_name = "sender"];
inline void ResponseCheckTx::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::sender() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseCheckTx::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.sender)
}
inline std::string* ResponseCheckTx::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.sender)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void ResponseCheckTx::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_sender() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.sender)
  return _impl_.sender_.Release();
}
inline void ResponseCheckTx::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.sender)
}

// int64 priority = 10 [json_name = "priority"];
inline void ResponseCheckTx::clear_priority() {
  _impl_.priority_ = ::int64_t{0};
}
inline ::int64_t ResponseCheckTx::priority() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.priority)
  return _internal_priority();
}
inline void ResponseCheckTx::set_priority(::int64_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.priority)
}
inline ::int64_t ResponseCheckTx::_internal_priority() const {
  return _impl_.priority_;
}
inline void ResponseCheckTx::_internal_set_priority(::int64_t value) {
  ;
  _impl_.priority_ = value;
}

// string mempool_error = 11 [json_name = "mempoolError"];
inline void ResponseCheckTx::clear_mempool_error() {
  _impl_.mempool_error_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::mempool_error() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.mempool_error)
  return _internal_mempool_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseCheckTx::set_mempool_error(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mempool_error_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.mempool_error)
}
inline std::string* ResponseCheckTx::mutable_mempool_error() {
  std::string* _s = _internal_mutable_mempool_error();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.mempool_error)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_mempool_error() const {
  return _impl_.mempool_error_.Get();
}
inline void ResponseCheckTx::_internal_set_mempool_error(const std::string& value) {
  ;


  _impl_.mempool_error_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_mempool_error() {
  ;
  return _impl_.mempool_error_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_mempool_error() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.mempool_error)
  return _impl_.mempool_error_.Release();
}
inline void ResponseCheckTx::set_allocated_mempool_error(std::string* value) {
  _impl_.mempool_error_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mempool_error_.IsDefault()) {
          _impl_.mempool_error_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.mempool_error)
}

// -------------------------------------------------------------------

// ResponseDeliverTx

// uint32 code = 1 [json_name = "code"];
inline void ResponseDeliverTx::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t ResponseDeliverTx::code() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.code)
  return _internal_code();
}
inline void ResponseDeliverTx::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.code)
}
inline ::uint32_t ResponseDeliverTx::_internal_code() const {
  return _impl_.code_;
}
inline void ResponseDeliverTx::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// bytes data = 2 [json_name = "data"];
inline void ResponseDeliverTx::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ResponseDeliverTx::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseDeliverTx::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.data)
}
inline std::string* ResponseDeliverTx::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.data)
  return _s;
}
inline const std::string& ResponseDeliverTx::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ResponseDeliverTx::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseDeliverTx.data)
  return _impl_.data_.Release();
}
inline void ResponseDeliverTx::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseDeliverTx.data)
}

// string log = 3 [json_name = "log"];
inline void ResponseDeliverTx::clear_log() {
  _impl_.log_.ClearToEmpty();
}
inline const std::string& ResponseDeliverTx::log() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.log)
  return _internal_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseDeliverTx::set_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.log)
}
inline std::string* ResponseDeliverTx::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.log)
  return _s;
}
inline const std::string& ResponseDeliverTx::_internal_log() const {
  return _impl_.log_.Get();
}
inline void ResponseDeliverTx::_internal_set_log(const std::string& value) {
  ;


  _impl_.log_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::_internal_mutable_log() {
  ;
  return _impl_.log_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::release_log() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseDeliverTx.log)
  return _impl_.log_.Release();
}
inline void ResponseDeliverTx::set_allocated_log(std::string* value) {
  _impl_.log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.log_.IsDefault()) {
          _impl_.log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseDeliverTx.log)
}

// string info = 4 [json_name = "info"];
inline void ResponseDeliverTx::clear_info() {
  _impl_.info_.ClearToEmpty();
}
inline const std::string& ResponseDeliverTx::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.info)
  return _internal_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseDeliverTx::set_info(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.info_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.info)
}
inline std::string* ResponseDeliverTx::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.info)
  return _s;
}
inline const std::string& ResponseDeliverTx::_internal_info() const {
  return _impl_.info_.Get();
}
inline void ResponseDeliverTx::_internal_set_info(const std::string& value) {
  ;


  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::_internal_mutable_info() {
  ;
  return _impl_.info_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseDeliverTx.info)
  return _impl_.info_.Release();
}
inline void ResponseDeliverTx::set_allocated_info(std::string* value) {
  _impl_.info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.info_.IsDefault()) {
          _impl_.info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseDeliverTx.info)
}

// int64 gas_wanted = 5 [json_name = "gas_wanted"];
inline void ResponseDeliverTx::clear_gas_wanted() {
  _impl_.gas_wanted_ = ::int64_t{0};
}
inline ::int64_t ResponseDeliverTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.gas_wanted)
  return _internal_gas_wanted();
}
inline void ResponseDeliverTx::set_gas_wanted(::int64_t value) {
  _internal_set_gas_wanted(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.gas_wanted)
}
inline ::int64_t ResponseDeliverTx::_internal_gas_wanted() const {
  return _impl_.gas_wanted_;
}
inline void ResponseDeliverTx::_internal_set_gas_wanted(::int64_t value) {
  ;
  _impl_.gas_wanted_ = value;
}

// int64 gas_used = 6 [json_name = "gas_used"];
inline void ResponseDeliverTx::clear_gas_used() {
  _impl_.gas_used_ = ::int64_t{0};
}
inline ::int64_t ResponseDeliverTx::gas_used() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.gas_used)
  return _internal_gas_used();
}
inline void ResponseDeliverTx::set_gas_used(::int64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.gas_used)
}
inline ::int64_t ResponseDeliverTx::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline void ResponseDeliverTx::_internal_set_gas_used(::int64_t value) {
  ;
  _impl_.gas_used_ = value;
}

// repeated .tendermint.abci.Event events = 7 [json_name = "events", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
inline int ResponseDeliverTx::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int ResponseDeliverTx::events_size() const {
  return _internal_events_size();
}
inline void ResponseDeliverTx::clear_events() {
  _internal_mutable_events()->Clear();
}
inline ::tendermint::abci::Event* ResponseDeliverTx::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
ResponseDeliverTx::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseDeliverTx.events)
  return _internal_mutable_events();
}
inline const ::tendermint::abci::Event& ResponseDeliverTx::_internal_events(int index) const {
  return _internal_events().Get(index);
}
inline const ::tendermint::abci::Event& ResponseDeliverTx::events(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.events)
  return _internal_events(index);
}
inline ::tendermint::abci::Event* ResponseDeliverTx::_internal_add_events() {
  return _internal_mutable_events()->Add();
}
inline ::tendermint::abci::Event* ResponseDeliverTx::add_events() {
  ::tendermint::abci::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseDeliverTx.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
ResponseDeliverTx::events() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseDeliverTx.events)
  return _internal_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>&
ResponseDeliverTx::_internal_events() const {
  return _impl_.events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>*
ResponseDeliverTx::_internal_mutable_events() {
  return &_impl_.events_;
}

// string codespace = 8 [json_name = "codespace"];
inline void ResponseDeliverTx::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& ResponseDeliverTx::codespace() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseDeliverTx::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.codespace)
}
inline std::string* ResponseDeliverTx::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.codespace)
  return _s;
}
inline const std::string& ResponseDeliverTx::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void ResponseDeliverTx::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::release_codespace() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseDeliverTx.codespace)
  return _impl_.codespace_.Release();
}
inline void ResponseDeliverTx::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseDeliverTx.codespace)
}

// -------------------------------------------------------------------

// ResponseEndBlock

// repeated .tendermint.abci.ValidatorUpdate validator_updates = 1 [json_name = "validatorUpdates", (.gogoproto.nullable) = false];
inline int ResponseEndBlock::_internal_validator_updates_size() const {
  return _impl_.validator_updates_.size();
}
inline int ResponseEndBlock::validator_updates_size() const {
  return _internal_validator_updates_size();
}
inline void ResponseEndBlock::clear_validator_updates() {
  _internal_mutable_validator_updates()->Clear();
}
inline ::tendermint::abci::ValidatorUpdate* ResponseEndBlock::mutable_validator_updates(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseEndBlock.validator_updates)
  return _internal_mutable_validator_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
ResponseEndBlock::mutable_validator_updates() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseEndBlock.validator_updates)
  return _internal_mutable_validator_updates();
}
inline const ::tendermint::abci::ValidatorUpdate& ResponseEndBlock::_internal_validator_updates(int index) const {
  return _internal_validator_updates().Get(index);
}
inline const ::tendermint::abci::ValidatorUpdate& ResponseEndBlock::validator_updates(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseEndBlock.validator_updates)
  return _internal_validator_updates(index);
}
inline ::tendermint::abci::ValidatorUpdate* ResponseEndBlock::_internal_add_validator_updates() {
  return _internal_mutable_validator_updates()->Add();
}
inline ::tendermint::abci::ValidatorUpdate* ResponseEndBlock::add_validator_updates() {
  ::tendermint::abci::ValidatorUpdate* _add = _internal_add_validator_updates();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseEndBlock.validator_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
ResponseEndBlock::validator_updates() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseEndBlock.validator_updates)
  return _internal_validator_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>&
ResponseEndBlock::_internal_validator_updates() const {
  return _impl_.validator_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>*
ResponseEndBlock::_internal_mutable_validator_updates() {
  return &_impl_.validator_updates_;
}

// .tendermint.types.ConsensusParams consensus_param_updates = 2 [json_name = "consensusParamUpdates"];
inline bool ResponseEndBlock::has_consensus_param_updates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consensus_param_updates_ != nullptr);
  return value;
}
inline const ::tendermint::types::ConsensusParams& ResponseEndBlock::_internal_consensus_param_updates() const {
  const ::tendermint::types::ConsensusParams* p = _impl_.consensus_param_updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::ConsensusParams&>(
      ::tendermint::types::_ConsensusParams_default_instance_);
}
inline const ::tendermint::types::ConsensusParams& ResponseEndBlock::consensus_param_updates() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseEndBlock.consensus_param_updates)
  return _internal_consensus_param_updates();
}
inline void ResponseEndBlock::unsafe_arena_set_allocated_consensus_param_updates(
    ::tendermint::types::ConsensusParams* consensus_param_updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_param_updates_);
  }
  _impl_.consensus_param_updates_ = consensus_param_updates;
  if (consensus_param_updates) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ResponseEndBlock.consensus_param_updates)
}
inline ::tendermint::types::ConsensusParams* ResponseEndBlock::release_consensus_param_updates() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::ConsensusParams* temp = _impl_.consensus_param_updates_;
  _impl_.consensus_param_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::ConsensusParams* ResponseEndBlock::unsafe_arena_release_consensus_param_updates() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseEndBlock.consensus_param_updates)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::ConsensusParams* temp = _impl_.consensus_param_updates_;
  _impl_.consensus_param_updates_ = nullptr;
  return temp;
}
inline ::tendermint::types::ConsensusParams* ResponseEndBlock::_internal_mutable_consensus_param_updates() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.consensus_param_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::ConsensusParams>(GetArenaForAllocation());
    _impl_.consensus_param_updates_ = p;
  }
  return _impl_.consensus_param_updates_;
}
inline ::tendermint::types::ConsensusParams* ResponseEndBlock::mutable_consensus_param_updates() {
  ::tendermint::types::ConsensusParams* _msg = _internal_mutable_consensus_param_updates();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseEndBlock.consensus_param_updates)
  return _msg;
}
inline void ResponseEndBlock::set_allocated_consensus_param_updates(::tendermint::types::ConsensusParams* consensus_param_updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_param_updates_);
  }
  if (consensus_param_updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consensus_param_updates));
    if (message_arena != submessage_arena) {
      consensus_param_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consensus_param_updates, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.consensus_param_updates_ = consensus_param_updates;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseEndBlock.consensus_param_updates)
}

// repeated .tendermint.abci.Event events = 3 [json_name = "events", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
inline int ResponseEndBlock::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int ResponseEndBlock::events_size() const {
  return _internal_events_size();
}
inline void ResponseEndBlock::clear_events() {
  _internal_mutable_events()->Clear();
}
inline ::tendermint::abci::Event* ResponseEndBlock::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseEndBlock.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
ResponseEndBlock::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseEndBlock.events)
  return _internal_mutable_events();
}
inline const ::tendermint::abci::Event& ResponseEndBlock::_internal_events(int index) const {
  return _internal_events().Get(index);
}
inline const ::tendermint::abci::Event& ResponseEndBlock::events(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseEndBlock.events)
  return _internal_events(index);
}
inline ::tendermint::abci::Event* ResponseEndBlock::_internal_add_events() {
  return _internal_mutable_events()->Add();
}
inline ::tendermint::abci::Event* ResponseEndBlock::add_events() {
  ::tendermint::abci::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseEndBlock.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
ResponseEndBlock::events() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseEndBlock.events)
  return _internal_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>&
ResponseEndBlock::_internal_events() const {
  return _impl_.events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Event>*
ResponseEndBlock::_internal_mutable_events() {
  return &_impl_.events_;
}

// -------------------------------------------------------------------

// ResponseCommit

// bytes data = 2 [json_name = "data"];
inline void ResponseCommit::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ResponseCommit::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCommit.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseCommit::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCommit.data)
}
inline std::string* ResponseCommit::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCommit.data)
  return _s;
}
inline const std::string& ResponseCommit::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ResponseCommit::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseCommit::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseCommit::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCommit.data)
  return _impl_.data_.Release();
}
inline void ResponseCommit::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCommit.data)
}

// int64 retain_height = 3 [json_name = "retainHeight"];
inline void ResponseCommit::clear_retain_height() {
  _impl_.retain_height_ = ::int64_t{0};
}
inline ::int64_t ResponseCommit::retain_height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCommit.retain_height)
  return _internal_retain_height();
}
inline void ResponseCommit::set_retain_height(::int64_t value) {
  _internal_set_retain_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCommit.retain_height)
}
inline ::int64_t ResponseCommit::_internal_retain_height() const {
  return _impl_.retain_height_;
}
inline void ResponseCommit::_internal_set_retain_height(::int64_t value) {
  ;
  _impl_.retain_height_ = value;
}

// -------------------------------------------------------------------

// ResponseListSnapshots

// repeated .tendermint.abci.Snapshot snapshots = 1 [json_name = "snapshots"];
inline int ResponseListSnapshots::_internal_snapshots_size() const {
  return _impl_.snapshots_.size();
}
inline int ResponseListSnapshots::snapshots_size() const {
  return _internal_snapshots_size();
}
inline void ResponseListSnapshots::clear_snapshots() {
  _internal_mutable_snapshots()->Clear();
}
inline ::tendermint::abci::Snapshot* ResponseListSnapshots::mutable_snapshots(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseListSnapshots.snapshots)
  return _internal_mutable_snapshots()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot >*
ResponseListSnapshots::mutable_snapshots() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseListSnapshots.snapshots)
  return _internal_mutable_snapshots();
}
inline const ::tendermint::abci::Snapshot& ResponseListSnapshots::_internal_snapshots(int index) const {
  return _internal_snapshots().Get(index);
}
inline const ::tendermint::abci::Snapshot& ResponseListSnapshots::snapshots(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseListSnapshots.snapshots)
  return _internal_snapshots(index);
}
inline ::tendermint::abci::Snapshot* ResponseListSnapshots::_internal_add_snapshots() {
  return _internal_mutable_snapshots()->Add();
}
inline ::tendermint::abci::Snapshot* ResponseListSnapshots::add_snapshots() {
  ::tendermint::abci::Snapshot* _add = _internal_add_snapshots();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseListSnapshots.snapshots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot >&
ResponseListSnapshots::snapshots() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseListSnapshots.snapshots)
  return _internal_snapshots();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Snapshot>&
ResponseListSnapshots::_internal_snapshots() const {
  return _impl_.snapshots_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::Snapshot>*
ResponseListSnapshots::_internal_mutable_snapshots() {
  return &_impl_.snapshots_;
}

// -------------------------------------------------------------------

// ResponseOfferSnapshot

// .tendermint.abci.ResponseOfferSnapshot.Result result = 1 [json_name = "result"];
inline void ResponseOfferSnapshot::clear_result() {
  _impl_.result_ = 0;
}
inline ::tendermint::abci::ResponseOfferSnapshot_Result ResponseOfferSnapshot::result() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseOfferSnapshot.result)
  return _internal_result();
}
inline void ResponseOfferSnapshot::set_result(::tendermint::abci::ResponseOfferSnapshot_Result value) {
   _internal_set_result(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseOfferSnapshot.result)
}
inline ::tendermint::abci::ResponseOfferSnapshot_Result ResponseOfferSnapshot::_internal_result() const {
  return static_cast<::tendermint::abci::ResponseOfferSnapshot_Result>(_impl_.result_);
}
inline void ResponseOfferSnapshot::_internal_set_result(::tendermint::abci::ResponseOfferSnapshot_Result value) {
  ;
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// ResponseLoadSnapshotChunk

// bytes chunk = 1 [json_name = "chunk"];
inline void ResponseLoadSnapshotChunk::clear_chunk() {
  _impl_.chunk_.ClearToEmpty();
}
inline const std::string& ResponseLoadSnapshotChunk::chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
  return _internal_chunk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseLoadSnapshotChunk::set_chunk(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.chunk_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
}
inline std::string* ResponseLoadSnapshotChunk::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
  return _s;
}
inline const std::string& ResponseLoadSnapshotChunk::_internal_chunk() const {
  return _impl_.chunk_.Get();
}
inline void ResponseLoadSnapshotChunk::_internal_set_chunk(const std::string& value) {
  ;


  _impl_.chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseLoadSnapshotChunk::_internal_mutable_chunk() {
  ;
  return _impl_.chunk_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseLoadSnapshotChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
  return _impl_.chunk_.Release();
}
inline void ResponseLoadSnapshotChunk::set_allocated_chunk(std::string* value) {
  _impl_.chunk_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chunk_.IsDefault()) {
          _impl_.chunk_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
}

// -------------------------------------------------------------------

// ResponseApplySnapshotChunk

// .tendermint.abci.ResponseApplySnapshotChunk.Result result = 1 [json_name = "result"];
inline void ResponseApplySnapshotChunk::clear_result() {
  _impl_.result_ = 0;
}
inline ::tendermint::abci::ResponseApplySnapshotChunk_Result ResponseApplySnapshotChunk::result() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseApplySnapshotChunk.result)
  return _internal_result();
}
inline void ResponseApplySnapshotChunk::set_result(::tendermint::abci::ResponseApplySnapshotChunk_Result value) {
   _internal_set_result(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseApplySnapshotChunk.result)
}
inline ::tendermint::abci::ResponseApplySnapshotChunk_Result ResponseApplySnapshotChunk::_internal_result() const {
  return static_cast<::tendermint::abci::ResponseApplySnapshotChunk_Result>(_impl_.result_);
}
inline void ResponseApplySnapshotChunk::_internal_set_result(::tendermint::abci::ResponseApplySnapshotChunk_Result value) {
  ;
  _impl_.result_ = value;
}

// repeated uint32 refetch_chunks = 2 [json_name = "refetchChunks"];
inline int ResponseApplySnapshotChunk::_internal_refetch_chunks_size() const {
  return _impl_.refetch_chunks_.size();
}
inline int ResponseApplySnapshotChunk::refetch_chunks_size() const {
  return _internal_refetch_chunks_size();
}
inline void ResponseApplySnapshotChunk::clear_refetch_chunks() {
  _internal_mutable_refetch_chunks()->Clear();
}
inline ::uint32_t ResponseApplySnapshotChunk::refetch_chunks(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
  return _internal_refetch_chunks(index);
}
inline void ResponseApplySnapshotChunk::set_refetch_chunks(int index, ::uint32_t value) {
  _internal_mutable_refetch_chunks()->Set(index, value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
}
inline void ResponseApplySnapshotChunk::add_refetch_chunks(::uint32_t value) {
  _internal_add_refetch_chunks(value);
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& ResponseApplySnapshotChunk::refetch_chunks() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
  return _internal_refetch_chunks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* ResponseApplySnapshotChunk::mutable_refetch_chunks() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
  return _internal_mutable_refetch_chunks();
}

inline ::uint32_t ResponseApplySnapshotChunk::_internal_refetch_chunks(int index) const {
  return _internal_refetch_chunks().Get(index);
}
inline void ResponseApplySnapshotChunk::_internal_add_refetch_chunks(::uint32_t value) {
  _internal_mutable_refetch_chunks()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& ResponseApplySnapshotChunk::_internal_refetch_chunks() const {
  return _impl_.refetch_chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* ResponseApplySnapshotChunk::_internal_mutable_refetch_chunks() {
  return &_impl_.refetch_chunks_;
}

// repeated string reject_senders = 3 [json_name = "rejectSenders"];
inline int ResponseApplySnapshotChunk::_internal_reject_senders_size() const {
  return _impl_.reject_senders_.size();
}
inline int ResponseApplySnapshotChunk::reject_senders_size() const {
  return _internal_reject_senders_size();
}
inline void ResponseApplySnapshotChunk::clear_reject_senders() {
  _internal_mutable_reject_senders()->Clear();
}
inline std::string* ResponseApplySnapshotChunk::add_reject_senders() {
  std::string* _s = _internal_add_reject_senders();
  // @@protoc_insertion_point(field_add_mutable:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return _s;
}
inline const std::string& ResponseApplySnapshotChunk::reject_senders(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return _internal_reject_senders(index);
}
inline std::string* ResponseApplySnapshotChunk::mutable_reject_senders(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return _internal_mutable_reject_senders()->Mutable(index);
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, const std::string& value) {
  _internal_mutable_reject_senders()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, std::string&& value) {
  _internal_mutable_reject_senders()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_reject_senders()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_reject_senders()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, absl::string_view value) {
  _internal_mutable_reject_senders()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::add_reject_senders(const std::string& value) {
  _internal_mutable_reject_senders()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::add_reject_senders(std::string&& value) {
  _internal_mutable_reject_senders()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::add_reject_senders(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_reject_senders()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::add_reject_senders(const char* value, std::size_t size) {
  _internal_mutable_reject_senders()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::add_reject_senders(absl::string_view value) {
  _internal_mutable_reject_senders()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponseApplySnapshotChunk::reject_senders() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return _internal_reject_senders();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ResponseApplySnapshotChunk::mutable_reject_senders() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return _internal_mutable_reject_senders();
}
inline const std::string& ResponseApplySnapshotChunk::_internal_reject_senders(int index) const {
  return _internal_reject_senders().Get(index);
}
inline std::string* ResponseApplySnapshotChunk::_internal_add_reject_senders() {
  return _internal_mutable_reject_senders()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponseApplySnapshotChunk::_internal_reject_senders() const {
  return _impl_.reject_senders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResponseApplySnapshotChunk::_internal_mutable_reject_senders() {
  return &_impl_.reject_senders_;
}

// -------------------------------------------------------------------

// ResponsePrepareProposal

// repeated bytes txs = 1 [json_name = "txs"];
inline int ResponsePrepareProposal::_internal_txs_size() const {
  return _impl_.txs_.size();
}
inline int ResponsePrepareProposal::txs_size() const {
  return _internal_txs_size();
}
inline void ResponsePrepareProposal::clear_txs() {
  _internal_mutable_txs()->Clear();
}
inline std::string* ResponsePrepareProposal::add_txs() {
  std::string* _s = _internal_add_txs();
  // @@protoc_insertion_point(field_add_mutable:tendermint.abci.ResponsePrepareProposal.txs)
  return _s;
}
inline const std::string& ResponsePrepareProposal::txs(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponsePrepareProposal.txs)
  return _internal_txs(index);
}
inline std::string* ResponsePrepareProposal::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponsePrepareProposal.txs)
  return _internal_mutable_txs()->Mutable(index);
}
inline void ResponsePrepareProposal::set_txs(int index, const std::string& value) {
  _internal_mutable_txs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::set_txs(int index, std::string&& value) {
  _internal_mutable_txs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::set_txs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_txs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::set_txs(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_txs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::set_txs(int index, absl::string_view value) {
  _internal_mutable_txs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::add_txs(const std::string& value) {
  _internal_mutable_txs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::add_txs(std::string&& value) {
  _internal_mutable_txs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::add_txs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_txs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::add_txs(const void* value, std::size_t size) {
  _internal_mutable_txs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tendermint.abci.ResponsePrepareProposal.txs)
}
inline void ResponsePrepareProposal::add_txs(absl::string_view value) {
  _internal_mutable_txs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:tendermint.abci.ResponsePrepareProposal.txs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponsePrepareProposal::txs() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponsePrepareProposal.txs)
  return _internal_txs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ResponsePrepareProposal::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponsePrepareProposal.txs)
  return _internal_mutable_txs();
}
inline const std::string& ResponsePrepareProposal::_internal_txs(int index) const {
  return _internal_txs().Get(index);
}
inline std::string* ResponsePrepareProposal::_internal_add_txs() {
  return _internal_mutable_txs()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponsePrepareProposal::_internal_txs() const {
  return _impl_.txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResponsePrepareProposal::_internal_mutable_txs() {
  return &_impl_.txs_;
}

// -------------------------------------------------------------------

// ResponseProcessProposal

// .tendermint.abci.ResponseProcessProposal.ProposalStatus status = 1 [json_name = "status"];
inline void ResponseProcessProposal::clear_status() {
  _impl_.status_ = 0;
}
inline ::tendermint::abci::ResponseProcessProposal_ProposalStatus ResponseProcessProposal::status() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseProcessProposal.status)
  return _internal_status();
}
inline void ResponseProcessProposal::set_status(::tendermint::abci::ResponseProcessProposal_ProposalStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseProcessProposal.status)
}
inline ::tendermint::abci::ResponseProcessProposal_ProposalStatus ResponseProcessProposal::_internal_status() const {
  return static_cast<::tendermint::abci::ResponseProcessProposal_ProposalStatus>(_impl_.status_);
}
inline void ResponseProcessProposal::_internal_set_status(::tendermint::abci::ResponseProcessProposal_ProposalStatus value) {
  ;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// CommitInfo

// int32 round = 1 [json_name = "round"];
inline void CommitInfo::clear_round() {
  _impl_.round_ = 0;
}
inline ::int32_t CommitInfo::round() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.CommitInfo.round)
  return _internal_round();
}
inline void CommitInfo::set_round(::int32_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.CommitInfo.round)
}
inline ::int32_t CommitInfo::_internal_round() const {
  return _impl_.round_;
}
inline void CommitInfo::_internal_set_round(::int32_t value) {
  ;
  _impl_.round_ = value;
}

// repeated .tendermint.abci.VoteInfo votes = 2 [json_name = "votes", (.gogoproto.nullable) = false];
inline int CommitInfo::_internal_votes_size() const {
  return _impl_.votes_.size();
}
inline int CommitInfo::votes_size() const {
  return _internal_votes_size();
}
inline void CommitInfo::clear_votes() {
  _internal_mutable_votes()->Clear();
}
inline ::tendermint::abci::VoteInfo* CommitInfo::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.CommitInfo.votes)
  return _internal_mutable_votes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo >*
CommitInfo::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.CommitInfo.votes)
  return _internal_mutable_votes();
}
inline const ::tendermint::abci::VoteInfo& CommitInfo::_internal_votes(int index) const {
  return _internal_votes().Get(index);
}
inline const ::tendermint::abci::VoteInfo& CommitInfo::votes(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.CommitInfo.votes)
  return _internal_votes(index);
}
inline ::tendermint::abci::VoteInfo* CommitInfo::_internal_add_votes() {
  return _internal_mutable_votes()->Add();
}
inline ::tendermint::abci::VoteInfo* CommitInfo::add_votes() {
  ::tendermint::abci::VoteInfo* _add = _internal_add_votes();
  // @@protoc_insertion_point(field_add:tendermint.abci.CommitInfo.votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo >&
CommitInfo::votes() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.CommitInfo.votes)
  return _internal_votes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::VoteInfo>&
CommitInfo::_internal_votes() const {
  return _impl_.votes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::VoteInfo>*
CommitInfo::_internal_mutable_votes() {
  return &_impl_.votes_;
}

// -------------------------------------------------------------------

// ExtendedCommitInfo

// int32 round = 1 [json_name = "round"];
inline void ExtendedCommitInfo::clear_round() {
  _impl_.round_ = 0;
}
inline ::int32_t ExtendedCommitInfo::round() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ExtendedCommitInfo.round)
  return _internal_round();
}
inline void ExtendedCommitInfo::set_round(::int32_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ExtendedCommitInfo.round)
}
inline ::int32_t ExtendedCommitInfo::_internal_round() const {
  return _impl_.round_;
}
inline void ExtendedCommitInfo::_internal_set_round(::int32_t value) {
  ;
  _impl_.round_ = value;
}

// repeated .tendermint.abci.ExtendedVoteInfo votes = 2 [json_name = "votes", (.gogoproto.nullable) = false];
inline int ExtendedCommitInfo::_internal_votes_size() const {
  return _impl_.votes_.size();
}
inline int ExtendedCommitInfo::votes_size() const {
  return _internal_votes_size();
}
inline void ExtendedCommitInfo::clear_votes() {
  _internal_mutable_votes()->Clear();
}
inline ::tendermint::abci::ExtendedVoteInfo* ExtendedCommitInfo::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ExtendedCommitInfo.votes)
  return _internal_mutable_votes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ExtendedVoteInfo >*
ExtendedCommitInfo::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ExtendedCommitInfo.votes)
  return _internal_mutable_votes();
}
inline const ::tendermint::abci::ExtendedVoteInfo& ExtendedCommitInfo::_internal_votes(int index) const {
  return _internal_votes().Get(index);
}
inline const ::tendermint::abci::ExtendedVoteInfo& ExtendedCommitInfo::votes(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ExtendedCommitInfo.votes)
  return _internal_votes(index);
}
inline ::tendermint::abci::ExtendedVoteInfo* ExtendedCommitInfo::_internal_add_votes() {
  return _internal_mutable_votes()->Add();
}
inline ::tendermint::abci::ExtendedVoteInfo* ExtendedCommitInfo::add_votes() {
  ::tendermint::abci::ExtendedVoteInfo* _add = _internal_add_votes();
  // @@protoc_insertion_point(field_add:tendermint.abci.ExtendedCommitInfo.votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ExtendedVoteInfo >&
ExtendedCommitInfo::votes() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ExtendedCommitInfo.votes)
  return _internal_votes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ExtendedVoteInfo>&
ExtendedCommitInfo::_internal_votes() const {
  return _impl_.votes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ExtendedVoteInfo>*
ExtendedCommitInfo::_internal_mutable_votes() {
  return &_impl_.votes_;
}

// -------------------------------------------------------------------

// Event

// string type = 1 [json_name = "type"];
inline void Event::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Event::type() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Event.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Event::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.Event.type)
}
inline std::string* Event::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Event.type)
  return _s;
}
inline const std::string& Event::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Event::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* Event::release_type() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Event.type)
  return _impl_.type_.Release();
}
inline void Event::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Event.type)
}

// repeated .tendermint.abci.EventAttribute attributes = 2 [json_name = "attributes", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "attributes,omitempty"];
inline int Event::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int Event::attributes_size() const {
  return _internal_attributes_size();
}
inline void Event::clear_attributes() {
  _internal_mutable_attributes()->Clear();
}
inline ::tendermint::abci::EventAttribute* Event::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Event.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute >*
Event::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.Event.attributes)
  return _internal_mutable_attributes();
}
inline const ::tendermint::abci::EventAttribute& Event::_internal_attributes(int index) const {
  return _internal_attributes().Get(index);
}
inline const ::tendermint::abci::EventAttribute& Event::attributes(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Event.attributes)
  return _internal_attributes(index);
}
inline ::tendermint::abci::EventAttribute* Event::_internal_add_attributes() {
  return _internal_mutable_attributes()->Add();
}
inline ::tendermint::abci::EventAttribute* Event::add_attributes() {
  ::tendermint::abci::EventAttribute* _add = _internal_add_attributes();
  // @@protoc_insertion_point(field_add:tendermint.abci.Event.attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute >&
Event::attributes() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.Event.attributes)
  return _internal_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::EventAttribute>&
Event::_internal_attributes() const {
  return _impl_.attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::EventAttribute>*
Event::_internal_mutable_attributes() {
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// EventAttribute

// string key = 1 [json_name = "key"];
inline void EventAttribute::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& EventAttribute::key() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.EventAttribute.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAttribute::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.EventAttribute.key)
}
inline std::string* EventAttribute::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.EventAttribute.key)
  return _s;
}
inline const std::string& EventAttribute::_internal_key() const {
  return _impl_.key_.Get();
}
inline void EventAttribute::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAttribute::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAttribute::release_key() {
  // @@protoc_insertion_point(field_release:tendermint.abci.EventAttribute.key)
  return _impl_.key_.Release();
}
inline void EventAttribute::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.EventAttribute.key)
}

// string value = 2 [json_name = "value"];
inline void EventAttribute::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& EventAttribute::value() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.EventAttribute.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAttribute::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.EventAttribute.value)
}
inline std::string* EventAttribute::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.EventAttribute.value)
  return _s;
}
inline const std::string& EventAttribute::_internal_value() const {
  return _impl_.value_.Get();
}
inline void EventAttribute::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAttribute::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAttribute::release_value() {
  // @@protoc_insertion_point(field_release:tendermint.abci.EventAttribute.value)
  return _impl_.value_.Release();
}
inline void EventAttribute::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.EventAttribute.value)
}

// bool index = 3 [json_name = "index"];
inline void EventAttribute::clear_index() {
  _impl_.index_ = false;
}
inline bool EventAttribute::index() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.EventAttribute.index)
  return _internal_index();
}
inline void EventAttribute::set_index(bool value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.EventAttribute.index)
}
inline bool EventAttribute::_internal_index() const {
  return _impl_.index_;
}
inline void EventAttribute::_internal_set_index(bool value) {
  ;
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// TxResult

// int64 height = 1 [json_name = "height"];
inline void TxResult::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t TxResult::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.TxResult.height)
  return _internal_height();
}
inline void TxResult::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.TxResult.height)
}
inline ::int64_t TxResult::_internal_height() const {
  return _impl_.height_;
}
inline void TxResult::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// uint32 index = 2 [json_name = "index"];
inline void TxResult::clear_index() {
  _impl_.index_ = 0u;
}
inline ::uint32_t TxResult::index() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.TxResult.index)
  return _internal_index();
}
inline void TxResult::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.TxResult.index)
}
inline ::uint32_t TxResult::_internal_index() const {
  return _impl_.index_;
}
inline void TxResult::_internal_set_index(::uint32_t value) {
  ;
  _impl_.index_ = value;
}

// bytes tx = 3 [json_name = "tx"];
inline void TxResult::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& TxResult::tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.TxResult.tx)
  return _internal_tx();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxResult::set_tx(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.TxResult.tx)
}
inline std::string* TxResult::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.TxResult.tx)
  return _s;
}
inline const std::string& TxResult::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void TxResult::_internal_set_tx(const std::string& value) {
  ;


  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* TxResult::_internal_mutable_tx() {
  ;
  return _impl_.tx_.Mutable( GetArenaForAllocation());
}
inline std::string* TxResult::release_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.TxResult.tx)
  return _impl_.tx_.Release();
}
inline void TxResult::set_allocated_tx(std::string* value) {
  _impl_.tx_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_.IsDefault()) {
          _impl_.tx_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.TxResult.tx)
}

// .tendermint.abci.ResponseDeliverTx result = 4 [json_name = "result", (.gogoproto.nullable) = false];
inline bool TxResult::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void TxResult::clear_result() {
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tendermint::abci::ResponseDeliverTx& TxResult::_internal_result() const {
  const ::tendermint::abci::ResponseDeliverTx* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::ResponseDeliverTx&>(
      ::tendermint::abci::_ResponseDeliverTx_default_instance_);
}
inline const ::tendermint::abci::ResponseDeliverTx& TxResult::result() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.TxResult.result)
  return _internal_result();
}
inline void TxResult::unsafe_arena_set_allocated_result(
    ::tendermint::abci::ResponseDeliverTx* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.TxResult.result)
}
inline ::tendermint::abci::ResponseDeliverTx* TxResult::release_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::ResponseDeliverTx* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::ResponseDeliverTx* TxResult::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:tendermint.abci.TxResult.result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::ResponseDeliverTx* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::tendermint::abci::ResponseDeliverTx* TxResult::_internal_mutable_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::ResponseDeliverTx>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::tendermint::abci::ResponseDeliverTx* TxResult::mutable_result() {
  ::tendermint::abci::ResponseDeliverTx* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.TxResult.result)
  return _msg;
}
inline void TxResult::set_allocated_result(::tendermint::abci::ResponseDeliverTx* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.TxResult.result)
}

// -------------------------------------------------------------------

// Validator

// bytes address = 1 [json_name = "address"];
inline void Validator::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Validator::address() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Validator.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.Validator.address)
}
inline std::string* Validator::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Validator.address)
  return _s;
}
inline const std::string& Validator::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Validator::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_address() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Validator.address)
  return _impl_.address_.Release();
}
inline void Validator::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Validator.address)
}

// int64 power = 3 [json_name = "power"];
inline void Validator::clear_power() {
  _impl_.power_ = ::int64_t{0};
}
inline ::int64_t Validator::power() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Validator.power)
  return _internal_power();
}
inline void Validator::set_power(::int64_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Validator.power)
}
inline ::int64_t Validator::_internal_power() const {
  return _impl_.power_;
}
inline void Validator::_internal_set_power(::int64_t value) {
  ;
  _impl_.power_ = value;
}

// -------------------------------------------------------------------

// ValidatorUpdate

// .tendermint.crypto.PublicKey pub_key = 1 [json_name = "pubKey", (.gogoproto.nullable) = false];
inline bool ValidatorUpdate::has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pub_key_ != nullptr);
  return value;
}
inline const ::tendermint::crypto::PublicKey& ValidatorUpdate::_internal_pub_key() const {
  const ::tendermint::crypto::PublicKey* p = _impl_.pub_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::crypto::PublicKey&>(
      ::tendermint::crypto::_PublicKey_default_instance_);
}
inline const ::tendermint::crypto::PublicKey& ValidatorUpdate::pub_key() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ValidatorUpdate.pub_key)
  return _internal_pub_key();
}
inline void ValidatorUpdate::unsafe_arena_set_allocated_pub_key(
    ::tendermint::crypto::PublicKey* pub_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pub_key_);
  }
  _impl_.pub_key_ = pub_key;
  if (pub_key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ValidatorUpdate.pub_key)
}
inline ::tendermint::crypto::PublicKey* ValidatorUpdate::release_pub_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::crypto::PublicKey* temp = _impl_.pub_key_;
  _impl_.pub_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::crypto::PublicKey* ValidatorUpdate::unsafe_arena_release_pub_key() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ValidatorUpdate.pub_key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::crypto::PublicKey* temp = _impl_.pub_key_;
  _impl_.pub_key_ = nullptr;
  return temp;
}
inline ::tendermint::crypto::PublicKey* ValidatorUpdate::_internal_mutable_pub_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::crypto::PublicKey>(GetArenaForAllocation());
    _impl_.pub_key_ = p;
  }
  return _impl_.pub_key_;
}
inline ::tendermint::crypto::PublicKey* ValidatorUpdate::mutable_pub_key() {
  ::tendermint::crypto::PublicKey* _msg = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ValidatorUpdate.pub_key)
  return _msg;
}
inline void ValidatorUpdate::set_allocated_pub_key(::tendermint::crypto::PublicKey* pub_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pub_key_);
  }
  if (pub_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pub_key));
    if (message_arena != submessage_arena) {
      pub_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pub_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pub_key_ = pub_key;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ValidatorUpdate.pub_key)
}

// int64 power = 2 [json_name = "power"];
inline void ValidatorUpdate::clear_power() {
  _impl_.power_ = ::int64_t{0};
}
inline ::int64_t ValidatorUpdate::power() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ValidatorUpdate.power)
  return _internal_power();
}
inline void ValidatorUpdate::set_power(::int64_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ValidatorUpdate.power)
}
inline ::int64_t ValidatorUpdate::_internal_power() const {
  return _impl_.power_;
}
inline void ValidatorUpdate::_internal_set_power(::int64_t value) {
  ;
  _impl_.power_ = value;
}

// -------------------------------------------------------------------

// VoteInfo

// .tendermint.abci.Validator validator = 1 [json_name = "validator", (.gogoproto.nullable) = false];
inline bool VoteInfo::has_validator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.validator_ != nullptr);
  return value;
}
inline void VoteInfo::clear_validator() {
  if (_impl_.validator_ != nullptr) _impl_.validator_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tendermint::abci::Validator& VoteInfo::_internal_validator() const {
  const ::tendermint::abci::Validator* p = _impl_.validator_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::Validator&>(
      ::tendermint::abci::_Validator_default_instance_);
}
inline const ::tendermint::abci::Validator& VoteInfo::validator() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.VoteInfo.validator)
  return _internal_validator();
}
inline void VoteInfo::unsafe_arena_set_allocated_validator(
    ::tendermint::abci::Validator* validator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.validator_);
  }
  _impl_.validator_ = validator;
  if (validator) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.VoteInfo.validator)
}
inline ::tendermint::abci::Validator* VoteInfo::release_validator() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::Validator* temp = _impl_.validator_;
  _impl_.validator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::Validator* VoteInfo::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_release:tendermint.abci.VoteInfo.validator)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::Validator* temp = _impl_.validator_;
  _impl_.validator_ = nullptr;
  return temp;
}
inline ::tendermint::abci::Validator* VoteInfo::_internal_mutable_validator() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::Validator>(GetArenaForAllocation());
    _impl_.validator_ = p;
  }
  return _impl_.validator_;
}
inline ::tendermint::abci::Validator* VoteInfo::mutable_validator() {
  ::tendermint::abci::Validator* _msg = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.VoteInfo.validator)
  return _msg;
}
inline void VoteInfo::set_allocated_validator(::tendermint::abci::Validator* validator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.validator_;
  }
  if (validator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(validator);
    if (message_arena != submessage_arena) {
      validator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.VoteInfo.validator)
}

// bool signed_last_block = 2 [json_name = "signedLastBlock"];
inline void VoteInfo::clear_signed_last_block() {
  _impl_.signed_last_block_ = false;
}
inline bool VoteInfo::signed_last_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.VoteInfo.signed_last_block)
  return _internal_signed_last_block();
}
inline void VoteInfo::set_signed_last_block(bool value) {
  _internal_set_signed_last_block(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.VoteInfo.signed_last_block)
}
inline bool VoteInfo::_internal_signed_last_block() const {
  return _impl_.signed_last_block_;
}
inline void VoteInfo::_internal_set_signed_last_block(bool value) {
  ;
  _impl_.signed_last_block_ = value;
}

// -------------------------------------------------------------------

// ExtendedVoteInfo

// .tendermint.abci.Validator validator = 1 [json_name = "validator", (.gogoproto.nullable) = false];
inline bool ExtendedVoteInfo::has_validator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.validator_ != nullptr);
  return value;
}
inline void ExtendedVoteInfo::clear_validator() {
  if (_impl_.validator_ != nullptr) _impl_.validator_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tendermint::abci::Validator& ExtendedVoteInfo::_internal_validator() const {
  const ::tendermint::abci::Validator* p = _impl_.validator_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::Validator&>(
      ::tendermint::abci::_Validator_default_instance_);
}
inline const ::tendermint::abci::Validator& ExtendedVoteInfo::validator() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ExtendedVoteInfo.validator)
  return _internal_validator();
}
inline void ExtendedVoteInfo::unsafe_arena_set_allocated_validator(
    ::tendermint::abci::Validator* validator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.validator_);
  }
  _impl_.validator_ = validator;
  if (validator) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ExtendedVoteInfo.validator)
}
inline ::tendermint::abci::Validator* ExtendedVoteInfo::release_validator() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::Validator* temp = _impl_.validator_;
  _impl_.validator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::Validator* ExtendedVoteInfo::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ExtendedVoteInfo.validator)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::Validator* temp = _impl_.validator_;
  _impl_.validator_ = nullptr;
  return temp;
}
inline ::tendermint::abci::Validator* ExtendedVoteInfo::_internal_mutable_validator() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::Validator>(GetArenaForAllocation());
    _impl_.validator_ = p;
  }
  return _impl_.validator_;
}
inline ::tendermint::abci::Validator* ExtendedVoteInfo::mutable_validator() {
  ::tendermint::abci::Validator* _msg = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ExtendedVoteInfo.validator)
  return _msg;
}
inline void ExtendedVoteInfo::set_allocated_validator(::tendermint::abci::Validator* validator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.validator_;
  }
  if (validator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(validator);
    if (message_arena != submessage_arena) {
      validator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ExtendedVoteInfo.validator)
}

// bool signed_last_block = 2 [json_name = "signedLastBlock"];
inline void ExtendedVoteInfo::clear_signed_last_block() {
  _impl_.signed_last_block_ = false;
}
inline bool ExtendedVoteInfo::signed_last_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ExtendedVoteInfo.signed_last_block)
  return _internal_signed_last_block();
}
inline void ExtendedVoteInfo::set_signed_last_block(bool value) {
  _internal_set_signed_last_block(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ExtendedVoteInfo.signed_last_block)
}
inline bool ExtendedVoteInfo::_internal_signed_last_block() const {
  return _impl_.signed_last_block_;
}
inline void ExtendedVoteInfo::_internal_set_signed_last_block(bool value) {
  ;
  _impl_.signed_last_block_ = value;
}

// bytes vote_extension = 3 [json_name = "voteExtension"];
inline void ExtendedVoteInfo::clear_vote_extension() {
  _impl_.vote_extension_.ClearToEmpty();
}
inline const std::string& ExtendedVoteInfo::vote_extension() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ExtendedVoteInfo.vote_extension)
  return _internal_vote_extension();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExtendedVoteInfo::set_vote_extension(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.vote_extension_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ExtendedVoteInfo.vote_extension)
}
inline std::string* ExtendedVoteInfo::mutable_vote_extension() {
  std::string* _s = _internal_mutable_vote_extension();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ExtendedVoteInfo.vote_extension)
  return _s;
}
inline const std::string& ExtendedVoteInfo::_internal_vote_extension() const {
  return _impl_.vote_extension_.Get();
}
inline void ExtendedVoteInfo::_internal_set_vote_extension(const std::string& value) {
  ;


  _impl_.vote_extension_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedVoteInfo::_internal_mutable_vote_extension() {
  ;
  return _impl_.vote_extension_.Mutable( GetArenaForAllocation());
}
inline std::string* ExtendedVoteInfo::release_vote_extension() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ExtendedVoteInfo.vote_extension)
  return _impl_.vote_extension_.Release();
}
inline void ExtendedVoteInfo::set_allocated_vote_extension(std::string* value) {
  _impl_.vote_extension_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vote_extension_.IsDefault()) {
          _impl_.vote_extension_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ExtendedVoteInfo.vote_extension)
}

// -------------------------------------------------------------------

// Misbehavior

// .tendermint.abci.MisbehaviorType type = 1 [json_name = "type"];
inline void Misbehavior::clear_type() {
  _impl_.type_ = 0;
}
inline ::tendermint::abci::MisbehaviorType Misbehavior::type() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Misbehavior.type)
  return _internal_type();
}
inline void Misbehavior::set_type(::tendermint::abci::MisbehaviorType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Misbehavior.type)
}
inline ::tendermint::abci::MisbehaviorType Misbehavior::_internal_type() const {
  return static_cast<::tendermint::abci::MisbehaviorType>(_impl_.type_);
}
inline void Misbehavior::_internal_set_type(::tendermint::abci::MisbehaviorType value) {
  ;
  _impl_.type_ = value;
}

// .tendermint.abci.Validator validator = 2 [json_name = "validator", (.gogoproto.nullable) = false];
inline bool Misbehavior::has_validator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.validator_ != nullptr);
  return value;
}
inline void Misbehavior::clear_validator() {
  if (_impl_.validator_ != nullptr) _impl_.validator_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tendermint::abci::Validator& Misbehavior::_internal_validator() const {
  const ::tendermint::abci::Validator* p = _impl_.validator_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::Validator&>(
      ::tendermint::abci::_Validator_default_instance_);
}
inline const ::tendermint::abci::Validator& Misbehavior::validator() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Misbehavior.validator)
  return _internal_validator();
}
inline void Misbehavior::unsafe_arena_set_allocated_validator(
    ::tendermint::abci::Validator* validator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.validator_);
  }
  _impl_.validator_ = validator;
  if (validator) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Misbehavior.validator)
}
inline ::tendermint::abci::Validator* Misbehavior::release_validator() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::Validator* temp = _impl_.validator_;
  _impl_.validator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::Validator* Misbehavior::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Misbehavior.validator)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::abci::Validator* temp = _impl_.validator_;
  _impl_.validator_ = nullptr;
  return temp;
}
inline ::tendermint::abci::Validator* Misbehavior::_internal_mutable_validator() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::Validator>(GetArenaForAllocation());
    _impl_.validator_ = p;
  }
  return _impl_.validator_;
}
inline ::tendermint::abci::Validator* Misbehavior::mutable_validator() {
  ::tendermint::abci::Validator* _msg = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Misbehavior.validator)
  return _msg;
}
inline void Misbehavior::set_allocated_validator(::tendermint::abci::Validator* validator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.validator_;
  }
  if (validator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(validator);
    if (message_arena != submessage_arena) {
      validator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Misbehavior.validator)
}

// int64 height = 3 [json_name = "height"];
inline void Misbehavior::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t Misbehavior::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Misbehavior.height)
  return _internal_height();
}
inline void Misbehavior::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Misbehavior.height)
}
inline ::int64_t Misbehavior::_internal_height() const {
  return _impl_.height_;
}
inline void Misbehavior::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// .google.protobuf.Timestamp time = 4 [json_name = "time", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Misbehavior::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Misbehavior::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Misbehavior::time() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Misbehavior.time)
  return _internal_time();
}
inline void Misbehavior::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Misbehavior.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Misbehavior::release_time() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Misbehavior::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Misbehavior.time)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Misbehavior::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Misbehavior::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Misbehavior.time)
  return _msg;
}
inline void Misbehavior::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Misbehavior.time)
}

// int64 total_voting_power = 5 [json_name = "totalVotingPower"];
inline void Misbehavior::clear_total_voting_power() {
  _impl_.total_voting_power_ = ::int64_t{0};
}
inline ::int64_t Misbehavior::total_voting_power() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Misbehavior.total_voting_power)
  return _internal_total_voting_power();
}
inline void Misbehavior::set_total_voting_power(::int64_t value) {
  _internal_set_total_voting_power(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Misbehavior.total_voting_power)
}
inline ::int64_t Misbehavior::_internal_total_voting_power() const {
  return _impl_.total_voting_power_;
}
inline void Misbehavior::_internal_set_total_voting_power(::int64_t value) {
  ;
  _impl_.total_voting_power_ = value;
}

// -------------------------------------------------------------------

// Snapshot

// uint64 height = 1 [json_name = "height"];
inline void Snapshot::clear_height() {
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t Snapshot::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.height)
  return _internal_height();
}
inline void Snapshot::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.height)
}
inline ::uint64_t Snapshot::_internal_height() const {
  return _impl_.height_;
}
inline void Snapshot::_internal_set_height(::uint64_t value) {
  ;
  _impl_.height_ = value;
}

// uint32 format = 2 [json_name = "format"];
inline void Snapshot::clear_format() {
  _impl_.format_ = 0u;
}
inline ::uint32_t Snapshot::format() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.format)
  return _internal_format();
}
inline void Snapshot::set_format(::uint32_t value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.format)
}
inline ::uint32_t Snapshot::_internal_format() const {
  return _impl_.format_;
}
inline void Snapshot::_internal_set_format(::uint32_t value) {
  ;
  _impl_.format_ = value;
}

// uint32 chunks = 3 [json_name = "chunks"];
inline void Snapshot::clear_chunks() {
  _impl_.chunks_ = 0u;
}
inline ::uint32_t Snapshot::chunks() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.chunks)
  return _internal_chunks();
}
inline void Snapshot::set_chunks(::uint32_t value) {
  _internal_set_chunks(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.chunks)
}
inline ::uint32_t Snapshot::_internal_chunks() const {
  return _impl_.chunks_;
}
inline void Snapshot::_internal_set_chunks(::uint32_t value) {
  ;
  _impl_.chunks_ = value;
}

// bytes hash = 4 [json_name = "hash"];
inline void Snapshot::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& Snapshot::hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Snapshot::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.hash)
}
inline std::string* Snapshot::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Snapshot.hash)
  return _s;
}
inline const std::string& Snapshot::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void Snapshot::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Snapshot::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* Snapshot::release_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Snapshot.hash)
  return _impl_.hash_.Release();
}
inline void Snapshot::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Snapshot.hash)
}

// bytes metadata = 5 [json_name = "metadata"];
inline void Snapshot::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& Snapshot::metadata() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Snapshot::set_metadata(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.metadata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.metadata)
}
inline std::string* Snapshot::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Snapshot.metadata)
  return _s;
}
inline const std::string& Snapshot::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void Snapshot::_internal_set_metadata(const std::string& value) {
  ;


  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* Snapshot::_internal_mutable_metadata() {
  ;
  return _impl_.metadata_.Mutable( GetArenaForAllocation());
}
inline std::string* Snapshot::release_metadata() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Snapshot.metadata)
  return _impl_.metadata_.Release();
}
inline void Snapshot::set_allocated_metadata(std::string* value) {
  _impl_.metadata_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_.IsDefault()) {
          _impl_.metadata_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Snapshot.metadata)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace abci
}  // namespace tendermint


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::tendermint::abci::ResponseOfferSnapshot_Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tendermint::abci::ResponseOfferSnapshot_Result>() {
  return ::tendermint::abci::ResponseOfferSnapshot_Result_descriptor();
}
template <>
struct is_proto_enum<::tendermint::abci::ResponseApplySnapshotChunk_Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tendermint::abci::ResponseApplySnapshotChunk_Result>() {
  return ::tendermint::abci::ResponseApplySnapshotChunk_Result_descriptor();
}
template <>
struct is_proto_enum<::tendermint::abci::ResponseProcessProposal_ProposalStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tendermint::abci::ResponseProcessProposal_ProposalStatus>() {
  return ::tendermint::abci::ResponseProcessProposal_ProposalStatus_descriptor();
}
template <>
struct is_proto_enum<::tendermint::abci::CheckTxType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tendermint::abci::CheckTxType>() {
  return ::tendermint::abci::CheckTxType_descriptor();
}
template <>
struct is_proto_enum<::tendermint::abci::MisbehaviorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tendermint::abci::MisbehaviorType>() {
  return ::tendermint::abci::MisbehaviorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tendermint_2fabci_2ftypes_2eproto_2epb_2eh
